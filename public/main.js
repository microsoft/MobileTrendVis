/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

var u;

var globals = {
  width: 0,
  height: 0,
  svg_dim: u,
  inner_padding: u,
  chart_dim: u,
  padding: 0,
  main_svg: u,
  defs: u,
  userID: u,
  chart_g: u,

  chart_instance: u,
  year_indicator: u,
  all_data: u,  
  hideAddressBar: u,
  shuffle: u,
  consent_complete: u,
  introduction_complete: u,
  experiment_complete: u,
  test_override: u,  
  last_pause: u,
  resumptions: u,
  trial_index: u,
  max_trials: u,
  ordering: u,
  participant: u,
  trials: u,
  trial_response: u,
  condition: u,
  lines: u,
  facets: u,
  animation: u,
  num_selected: u,
  outer_progress_circle: u,
  inner_progress_circle: u,
  param_x: 'Life Expectancy',
  param_y: 'GDP Per Capita',
  param_r: 'Population',
  param_yearMin: 1975,
  param_yearMax: 2000,
  log_message: u
};

test_override = false;
consent_complete = false;
introduction_complete = false;
experiment_complete = false;
resumptions = [];
trial_index = -1;
max_trials = 0;
condition = 'multiples';
ordering = 0;
participant = -1;
userID = -1;
tps = 0;
trial_response = [];
num_selected = 0;
log_message = '';

shuffle = function (array) {
  var currentIndex = array.length, temporaryValue, randomIndex;

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
};

hideAddressBar = function () {
  
  setTimeout(function(){
    // Hide the address bar!
		window.scrollTo(0, 1);
  }, 10);  
  

  var touchstartHandler = function(e) {
    if (e.touches.length != 1) return;
    lastTouchY = e.touches[0].clientY;
  };
  
  var touchmoveHandler = function(e) {
    var touchY = e.touches[0].clientY;
    var touchYDelta = touchY - lastTouchY;
    lastTouchY = touchY;

    e.preventDefault();
    return;
  };

  document.addEventListener('touchstart', touchstartHandler, {passive: false });
  document.addEventListener('touchmove', touchmoveHandler, {passive: false });

};

module.exports = globals;



/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

// https://d3js.org Version 4.9.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var version = "4.9.1";

var ascending = function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};

var bisector = function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
};

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

var pairs = function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
};

function pair(a, b) {
  return [a, b];
}

var cross = function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
};

var descending = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var number = function(x) {
  return x === null ? NaN : +x;
};

var variance = function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
};

var deviation = function(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
};

var extent = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
};

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

var constant = function(x) {
  return function() {
    return x;
  };
};

var identity = function(x) {
  return x;
};

var sequence = function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
};

var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

var ticks = function(start, stop, count) {
  var reverse = stop < start,
      i = -1,
      n,
      ticks,
      step;

  if (reverse) n = start, start = stop, stop = n;

  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
};

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

var sturges = function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
};

var histogram = function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = sequence(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
};

var threshold = function(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
};

var freedmanDiaconis = function(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (threshold(values, 0.75) - threshold(values, 0.25)) * Math.pow(values.length, -1 / 3)));
};

var scott = function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
};

var max = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
};

var mean = function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
};

var median = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return threshold(numbers.sort(ascending), 0.5);
};

var merge = function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
};

var min = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
};

var permute = function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
};

var scan = function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
};

var shuffle = function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
};

var sum = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
};

var transpose = function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
};

function length(d) {
  return d.length;
}

var zip = function() {
  return transpose(arguments);
};

var slice$1 = Array.prototype.slice;

var identity$1 = function(x) {
  return x;
};

var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$1) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = range[0] + 0.5,
        range1 = range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : identity$1)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "#000"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "#000")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "#000")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = slice$1.call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice$1.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : slice$1.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}

var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

var namespace = function(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
};

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

var creator = function(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
};

var nextId = 0;

function local$1() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local$1.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames$1(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

var selection_on = function(typename, value, capture) {
  var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
};

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

var sourceEvent = function() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
};

var point = function(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
};

var mouse = function(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
};

function none() {}

var selector = function(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
};

var selection_select = function(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
};

function empty$1() {
  return [];
}

var selectorAll = function(selector) {
  return selector == null ? empty$1 : function() {
    return this.querySelectorAll(selector);
  };
};

var selection_selectAll = function(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
};

var selection_filter = function(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
};

var sparse = function(update) {
  return new Array(update.length);
};

var selection_enter = function() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
};

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

var constant$1 = function(x) {
  return function() {
    return x;
  };
};

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

var selection_data = function(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant$1(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
};

var selection_exit = function() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
};

var selection_merge = function(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
};

var selection_order = function() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
};

var selection_sort = function(compare) {
  if (!compare) compare = ascending$1;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
};

function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

var selection_call = function() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
};

var selection_nodes = function() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
};

var selection_node = function() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
};

var selection_size = function() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
};

var selection_empty = function() {
  return !this.node();
};

var selection_each = function(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
};

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

var selection_attr = function(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
};

var defaultView = function(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
};

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

var selection_style = function(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
};

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

var selection_property = function(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
};

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

var selection_classed = function(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
};

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

var selection_text = function(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
};

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

var selection_html = function(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
};

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

var selection_raise = function() {
  return this.each(raise);
};

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

var selection_lower = function() {
  return this.each(lower);
};

var selection_append = function(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
};

function constantNull() {
  return null;
}

var selection_insert = function(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
};

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

var selection_remove = function() {
  return this.each(remove);
};

var selection_datum = function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
};

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

var selection_dispatch = function(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
};

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

var select = function(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
};

var selectAll = function(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
};

var touch = function(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
};

var touches = function(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
};

function nopropagation() {
  exports.event.stopImmediatePropagation();
}

var noevent = function() {
  exports.event.preventDefault();
  exports.event.stopImmediatePropagation();
};

var dragDisable = function(view) {
  var root = view.document.documentElement,
      selection$$1 = select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection$$1.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
};

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection$$1 = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection$$1.on("click.drag", noevent, true);
    setTimeout(function() { selection$$1.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection$$1.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

var constant$2 = function(x) {
  return function() {
    return x;
  };
};

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter$1() {
  return !exports.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: exports.event.x, y: exports.event.y} : d;
}

var drag = function() {
  var filter = defaultFilter$1,
      container = defaultContainer,
      subject = defaultSubject,
      gestures = {},
      listeners = dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection$$1) {
    selection$$1
        .on("mousedown.drag", mousedowned)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
    if (!gesture) return;
    select(exports.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    dragDisable(exports.event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = exports.event.clientX;
    mousedowny = exports.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();
    if (!mousemoving) {
      var dx = exports.event.clientX - mousedownx, dy = exports.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    select(exports.event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(exports.event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches$$1 = exports.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches$$1.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches$$1[i].identifier, c, touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches$$1 = exports.event.changedTouches,
        n = touches$$1.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches$$1[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches$$1 = exports.event.changedTouches,
        n = touches$$1.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches$$1[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((exports.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
};

var define = function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
};

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex3 = /^#([0-9a-f]{3})$/;
var reHex6 = /^#([0-9a-f]{6})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

var Kn = 18;
var Xn = 0.950470;
var Yn = 1;
var Zn = 1.088830;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Rgb(
      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861;
var B = +1.78277;
var C = -0.29227;
var D = -0.90649;
var E = +1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

var basis$1 = function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var basisClosed = function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var constant$3 = function(x) {
  return function() {
    return x;
  };
};

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$3(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$3(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$3(isNaN(a) ? b : a);
}

var interpolateRgb = ((function rgbGamma(y) {
  var color$$1 = gamma(y);

  function rgb$$1(start, end) {
    var r = color$$1((start = rgb(start)).r, (end = rgb(end)).r),
        g = color$$1(start.g, end.g),
        b = color$$1(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$$1.gamma = rgbGamma;

  return rgb$$1;
}))(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color$$1;
    for (i = 0; i < n; ++i) {
      color$$1 = rgb(colors[i]);
      r[i] = color$$1.r || 0;
      g[i] = color$$1.g || 0;
      b[i] = color$$1.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color$$1.opacity = 1;
    return function(t) {
      color$$1.r = r(t);
      color$$1.g = g(t);
      color$$1.b = b(t);
      return color$$1 + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

var array$1 = function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(nb),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = interpolateValue(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
};

var date = function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
};

var reinterpolate = function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
};

var object = function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = interpolateValue(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
};

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

var interpolateString = function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: reinterpolate(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
};

var interpolateValue = function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$3(b)
      : (t === "number" ? reinterpolate
      : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
      : b instanceof color ? interpolateRgb
      : b instanceof Date ? date
      : Array.isArray(b) ? array$1
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : reinterpolate)(a, b);
};

var interpolateRound = function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
};

var degrees = 180 / Math.PI;

var identity$2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

var decompose = function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
};

var cssNode;
var cssRoot;
var cssView;
var svgNode;

function parseCss(value) {
  if (value === "none") return identity$2;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity$2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$2;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: reinterpolate(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: reinterpolate(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: reinterpolate(xa, xb)}, {i: i - 2, x: reinterpolate(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2;
var rho2 = 2;
var rho4 = 4;
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
var interpolateZoom = function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
};

function hsl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = hsl(start)).h, (end = hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$2 = hsl$1(hue);
var hslLong = hsl$1(nogamma);

function lab$1(start, end) {
  var l = nogamma((start = lab(start)).l, (end = lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = hcl(start)).h, (end = hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$2 = hcl$1(hue);
var hclLong = hcl$1(nogamma);

function cubehelix$1(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix$$1(start, end) {
      var h = hue$$1((start = cubehelix(start)).h, (end = cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$$1.gamma = cubehelixGamma;

    return cubehelix$$1;
  })(1);
}

var cubehelix$2 = cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

var quantize = function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
};

var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1000;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof requestAnimationFrame === "function" ? requestAnimationFrame : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, delay);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clockNow, interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

var timeout$1 = function(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
};

var interval$1 = function(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
};

var emptyOn = dispatch("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

var schedule = function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
};

function init(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id]) || schedule.state > CREATED) throw new Error("too late");
  return schedule;
}

function set$1(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id]) || schedule.state > STARTING) throw new Error("too late");
  return schedule;
}

function get$1(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("too late");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout$1(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout$1(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

var interrupt = function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
};

var selection_interrupt = function(name) {
  return this.each(function() {
    interrupt(this, name);
  });
};

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set$1(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set$1(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

var transition_tween = function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get$1(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
};

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set$1(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get$1(node, id).value[name];
  };
}

var interpolate$$1 = function(a, b) {
  var c;
  return (typeof b === "number" ? reinterpolate
      : b instanceof color ? interpolateRgb
      : (c = color(b)) ? (b = c, interpolateRgb)
      : interpolateString)(a, b);
};

function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrConstantNS$1(fullname, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrFunction$1(name, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS$1(fullname, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

var transition_attr = function(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$$1;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
      : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + ""));
};

function attrTweenNS(fullname, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

var transition_attrTween = function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
};

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

var transition_delay = function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get$1(this.node(), id).delay;
};

function durationFunction(id, value) {
  return function() {
    set$1(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set$1(this, id).duration = value;
  };
}

var transition_duration = function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get$1(this.node(), id).duration;
};

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set$1(this, id).ease = value;
  };
}

var transition_ease = function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get$1(this.node(), id).ease;
};

var transition_filter = function(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
};

var transition_merge = function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
};

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set$1;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

var transition_on = function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get$1(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
};

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

var transition_remove = function() {
  return this.on("end.remove", removeFunction(this._id));
};

var transition_select = function(select$$1) {
  var name = this._name,
      id = this._id;

  if (typeof select$$1 !== "function") select$$1 = selector(select$$1);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select$$1.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
};

var transition_selectAll = function(select$$1) {
  var name = this._name,
      id = this._id;

  if (typeof select$$1 !== "function") select$$1 = selectorAll(select$$1);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select$$1.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
};

var Selection$1 = selection.prototype.constructor;

var transition_selection = function() {
  return new Selection$1(this._groups, this._parents);
};

function styleRemove$1(name, interpolate$$2) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = styleValue(this, name),
        value1 = (this.style.removeProperty(name), styleValue(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$2(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant$1(name, interpolate$$2, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = styleValue(this, name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$2(value00 = value0, value1);
  };
}

function styleFunction$1(name, interpolate$$2, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = styleValue(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), styleValue(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$2(value00 = value0, value10 = value1);
  };
}

var transition_style = function(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$$1;
  return value == null ? this
          .styleTween(name, styleRemove$1(name, i))
          .on("end.style." + name, styleRemoveEnd(name))
      : this.styleTween(name, typeof value === "function"
          ? styleFunction$1(name, i, tweenValue(this, "style." + name, value))
          : styleConstant$1(name, i, value + ""), priority);
};

function styleTween(name, value, priority) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

var transition_styleTween = function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
};

function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

var transition_text = function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction$1(tweenValue(this, "text", value))
      : textConstant$1(value == null ? "" : value + ""));
};

var transition_transition = function() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get$1(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
};

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease
};

function linear$1(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

var pi = Math.PI;
var halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}

var selection_transition = function(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
};

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

var root$1 = [null];

var active = function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root$1, name, +i);
      }
    }
  }

  return null;
};

var constant$4 = function(x) {
  return function() {
    return x;
  };
};

var BrushEvent = function(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
};

function nopropagation$1() {
  exports.event.stopImmediatePropagation();
}

var noevent$1 = function() {
  exports.event.preventDefault();
  exports.event.stopImmediatePropagation();
};

var MODE_DRAG = {name: "drag"};
var MODE_SPACE = {name: "space"};
var MODE_HANDLE = {name: "handle"};
var MODE_CENTER = {name: "center"};

var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function(xy) { return xy; },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !exports.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name “__brush” rather than auto-generated.
function local$$1(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush$1(X);
}

function brushY() {
  return brush$1(Y);
}

var brush = function() {
  return brush$1(XY);
};

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = dispatch(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local$$1(this).extent;
          select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
        .on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function(group, selection$$1) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection$$1 === "function" ? selection$$1.apply(this, arguments) : selection$$1, state.extent),
                i = interpolateValue(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && empty(selection1) ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 && selection1 ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection$$1 === "function" ? selection$$1.apply(that, args) : selection$$1, state.extent),
                emit = emitter(that, args).beforestart();

            interrupt(that);
            state.selection = selection1 == null || empty(selection1) ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  function redraw() {
    var group = select(this),
        selection$$1 = local$$1(this).selection;

    if (selection$$1) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection$$1[0][0])
          .attr("y", selection$$1[0][1])
          .attr("width", selection$$1[1][0] - selection$$1[0][0])
          .attr("height", selection$$1[1][1] - selection$$1[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection$$1[1][0] - handleSize / 2 : selection$$1[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection$$1[1][1] - handleSize / 2 : selection$$1[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection$$1[1][0] - selection$$1[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection$$1[1][1] - selection$$1[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (exports.event.touches) { if (exports.event.changedTouches.length < exports.event.touches.length) return noevent$1(); }
    else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = exports.event.target.__data__.type,
        mode = (exports.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (exports.event.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local$$1(that),
        extent = state.extent,
        selection$$1 = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && exports.event.shiftKey,
        lockX,
        lockY,
        point0 = mouse(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection$$1 = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection$$1[0][0];
      n0 = selection$$1[0][1];
      e0 = selection$$1[1][0];
      s0 = selection$$1[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (exports.event.touches) {
      group
          .on("touchmove.brush", moved, true)
          .on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = select(exports.event.view)
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);

      dragDisable(exports.event.view);
    }

    nopropagation$1();
    interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = mouse(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent$1();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection$$1 = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection$$1[0][0], e1 = selection$$1[1][0];
      if (lockY) n1 = selection$$1[0][1], s1 = selection$$1[1][1];

      if (selection$$1[0][0] !== w1
          || selection$$1[0][1] !== n1
          || selection$$1[1][0] !== e1
          || selection$$1[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation$1();
      if (exports.event.touches) {
        if (exports.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        yesdrag(exports.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection$$1 = state.selection; // May be set by brush.move (on start)!
      if (empty(selection$$1)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (exports.event.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent$1();
    }

    function keyupped() {
      switch (exports.event.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (exports.event.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent$1();
    }
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$4(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

var cos = Math.cos;
var sin = Math.sin;
var pi$1 = Math.PI;
var halfPi$1 = pi$1 / 2;
var tau$1 = pi$1 * 2;
var max$1 = Math.max;

function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

var chord = function() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = sequence(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(sequence(n));
      k += x;
    }

    // Sort groups…
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups…
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = max$1(0, tau$1 - padAngle * n) / k;
    dx = k ? padAngle : tau$1 / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
};

var slice$2 = Array.prototype.slice;

var constant$5 = function(x) {
  return function() {
    return x;
  };
};

var pi$2 = Math.PI;
var tau$2 = 2 * pi$2;
var epsilon$1 = 1e-6;
var tauEpsilon = tau$2 - epsilon$1;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon$1)) {}

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon$1) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau$2 + tau$2;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon$1) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

var ribbon = function() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice$2.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi$1,
        sa1 = endAngle.apply(this, argv) - halfPi$1,
        sx0 = sr * cos(sa0),
        sy0 = sr * sin(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi$1,
        ta1 = endAngle.apply(this, argv) - halfPi$1;

    if (!context) context = buffer = path();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$5(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$5(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
};

var prefix = "$";

function Map() {}

Map.prototype = map$1.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map$1(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

var nest = function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) return rollup != null
        ? rollup(array) : (sortValues != null
        ? array.sort(sortValues)
        : array);

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map$1(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();
    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
};

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map$1();
}

function setMap(map, key, value) {
  map.set(key, value);
}

function Set() {}

var proto = map$1.prototype;

Set.prototype = set$2.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set$2(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};

var values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};

var entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

var dsv = function(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      delimiterCode = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns;
    return rows;
  }

  function parseRows(text, f) {
    var EOL = {}, // sentinel value for end-of-line
        EOF = {}, // sentinel value for end-of-file
        rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // the current line number
        t, // the current token
        eol; // is the current token followed by EOL?

    function token() {
      if (I >= N) return EOF; // special case: end of file
      if (eol) return eol = false, EOL; // special case: end of line

      // special case: quotes
      var j = I, c;
      if (text.charCodeAt(j) === 34) {
        var i = j;
        while (i++ < N) {
          if (text.charCodeAt(i) === 34) {
            if (text.charCodeAt(i + 1) !== 34) break;
            ++i;
          }
        }
        I = i + 2;
        c = text.charCodeAt(i + 1);
        if (c === 13) {
          eol = true;
          if (text.charCodeAt(i + 2) === 10) ++I;
        } else if (c === 10) {
          eol = true;
        }
        return text.slice(j + 1, i).replace(/""/g, "\"");
      }

      // common case: find next delimiter or newline
      while (I < N) {
        var k = 1;
        c = text.charCodeAt(I++);
        if (c === 10) eol = true; // \n
        else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \r|\r\n
        else if (c !== delimiterCode) continue;
        return text.slice(j, I - k);
      }

      // special case: last token before EOF
      return text.slice(j);
    }

    while ((t = token()) !== EOF) {
      var a = [];
      while (t !== EOL && t !== EOF) {
        a.push(t);
        t = token();
      }
      if (f && (a = f(a, n++)) == null) continue;
      rows.push(a);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? ""
        : reFormat.test(text += "") ? "\"" + text.replace(/\"/g, "\"\"") + "\""
        : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
};

var csv = dsv(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

var tsv = dsv("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

var center$1 = function(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
};

var constant$6 = function(x) {
  return function() {
    return x;
  };
};

var jiggle = function() {
  return (Math.random() - 0.5) * 1e-6;
};

var tree_add = function(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
};

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, inherit the existing extent.
  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

var tree_cover = function(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
      case 0: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
        break;
      }
      case 1: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
        break;
      }
      case 2: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
        break;
      }
      case 3: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
        break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  // If the quadtree covers the point already, just return.
  else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
};

var tree_data = function() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
};

var tree_extent = function(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
};

var Quad = function(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
};

var tree_find = function(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
};

var tree_remove = function(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
};

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

var tree_root = function() {
  return this._root;
};

var tree_size = function() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
};

var tree_visit = function(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
};

var tree_visitAfter = function(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
};

function defaultX(d) {
  return d[0];
}

var tree_x = function(_) {
  return arguments.length ? (this._x = _, this) : this._x;
};

function defaultY(d) {
  return d[1];
}

var tree_y = function(_) {
  return arguments.length ? (this._y = _, this) : this._y;
};

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

var collide = function(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant$6(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : radius;
  };

  return force;
};

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

var link = function(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant$6(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = map$1(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant$6(+_), initializeDistance(), force) : distance;
  };

  return force;
};

function x$1(d) {
  return d.x;
}

function y$1(d) {
  return d.y;
}

var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));

var simulation = function(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = map$1(),
      stepper = timer(step),
      event = dispatch("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick() {
    var i, n = nodes.length, node;

    alpha += (alphaTarget - alpha) * alphaDecay;

    forces.each(function(force) {
      force(alpha);
    });

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (node.fx == null) node.x += node.vx *= velocityDecay;
      else node.x = node.fx, node.vx = 0;
      if (node.fy == null) node.y += node.vy *= velocityDecay;
      else node.y = node.fy, node.vy = 0;
    }
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
};

var manyBody = function() {
  var nodes,
      node,
      alpha,
      strength = constant$6(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = quadtree(nodes, x$1, y$1).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, x$$1, y$$1, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x$$1 = y$$1 = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = q.value)) {
          strength += c, x$$1 += c * q.x, y$$1 += c * q.y;
        }
      }
      quad.x = x$$1 / strength;
      quad.y = y$$1 / strength;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x$$1 = quad.x - node.x,
        y$$1 = quad.y - node.y,
        w = x2 - x1,
        l = x$$1 * x$$1 + y$$1 * y$$1;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;
        if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x$$1 * quad.value * alpha / l;
        node.vy += y$$1 * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x$$1 === 0) x$$1 = jiggle(), l += x$$1 * x$$1;
      if (y$$1 === 0) y$$1 = jiggle(), l += y$$1 * y$$1;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x$$1 * w;
      node.vy += y$$1 * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
};

var x$2 = function(x) {
  var strength = constant$6(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant$6(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : x;
  };

  return force;
};

var y$2 = function(y) {
  var strength = constant$6(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant$6(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$6(+_), initialize(), force) : y;
  };

  return force;
};

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
var formatDecimal = function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
};

var exponent$1 = function(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
};

var formatGroup = function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
};

var formatNumerals = function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
};

var formatDefault = function(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
};

var prefixExponent;

var formatPrefixAuto = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
};

var formatRounded = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
};

var formatTypes = {
  "": formatDefault,
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!formatTypes[type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};

var identity$3 = function(x) {
  return x;
};

var prefixes = ["y","z","a","f","p","n","\xB5","m","","k","M","G","T","P","E","Z","Y"];

var formatLocale = function(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity$3,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity$3,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
};

var locale$1;



defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale$1 = formatLocale(definition);
  exports.format = locale$1.format;
  exports.formatPrefix = locale$1.formatPrefix;
  return locale$1;
}

var precisionFixed = function(step) {
  return Math.max(0, -exponent$1(Math.abs(step)));
};

var precisionPrefix = function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$1(value) / 3))) * 3 - exponent$1(Math.abs(step)));
};

var precisionRound = function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent$1(max) - exponent$1(step)) + 1;
};

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

var adder = function() {
  return new Adder;
};

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add$1(temp, y, this.t);
    add$1(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add$1(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}

var epsilon$2 = 1e-6;
var epsilon2$1 = 1e-12;
var pi$3 = Math.PI;
var halfPi$2 = pi$3 / 2;
var quarterPi = pi$3 / 4;
var tau$3 = pi$3 * 2;

var degrees$1 = 180 / pi$3;
var radians = pi$3 / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos$1 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;

var log = Math.log;
var pow = Math.pow;
var sin$1 = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi$3 : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);
}

function haversin(x) {
  return (x = sin$1(x / 2)) * x;
}

function noop$1() {}

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

var geoStream = function(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
};

var areaRingSum = adder();

var areaSum = adder();
var lambda00;
var phi00;
var lambda0;
var cosPhi0;
var sinPhi0;

var areaStream = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau$3 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop$1;
  },
  sphere: function() {
    areaSum.add(tau$3);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians, phi *= radians;
  lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);
}

function areaPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  phi = phi / 2 + quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = cos$1(phi),
      sinPhi = sin$1(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * cos$1(adLambda),
      v = k * sdLambda * sin$1(adLambda);
  areaRingSum.add(atan2(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

var area = function(object) {
  areaSum.reset();
  geoStream(object, areaStream);
  return areaSum * 2;
};

function spherical(cartesian) {
  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

var lambda0$1;
var phi0;
var lambda1;
var phi1;
var lambda2;
var lambda00$1;
var phi00$1;
var p0;
var deltaSum = adder();
var ranges;
var range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon$2) phi1 = 90;
    else if (deltaSum < -epsilon$2) phi0 = -90;
    range[0] = lambda0$1, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians, phi * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2,
        sign$$1 = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * degrees$1 * sign$$1,
        phii,
        antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
      phii = inflection[1] * degrees$1;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
      phii = -inflection[1] * degrees$1;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1) lambda0$1 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0$1, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi;
  }
  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon$2) lambda0$1 = -(lambda1 = 180);
  range[0] = lambda0$1, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

var bounds = function(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0$1 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0$1, phi0], [lambda1, phi1]];
};

var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda00$2;
var phi00$2;
var x0;
var y0;
var z0; // previous point

var centroidStream = {
  sphere: noop$1,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi);
  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi);
  x0 = cosPhi * cos$1(lambda);
  y0 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi),
      x = cosPhi * cos$1(lambda),
      y = cosPhi * sin$1(lambda),
      z = sin$1(phi),
      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00$2, phi00$2);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00$2 = lambda, phi00$2 = phi;
  lambda *= radians, phi *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos$1(phi);
  x0 = cosPhi * cos$1(lambda);
  y0 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos$1(phi),
      x = cosPhi * cos$1(lambda),
      y = cosPhi * sin$1(lambda),
      z = sin$1(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = sqrt(cx * cx + cy * cy + cz * cz),
      w = asin(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

var centroid = function(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  geoStream(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < epsilon2$1) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < epsilon$2) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < epsilon2$1) return [NaN, NaN];
  }

  return [atan2(y, x) * degrees$1, asin(z / sqrt(m)) * degrees$1];
};

var constant$7 = function(x) {
  return function() {
    return x;
  };
};

var compose = function(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
};

function rotationIdentity(lambda, phi) {
  return [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau$3) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi$3 ? lambda - tau$3 : lambda < -pi$3 ? lambda + tau$3 : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos$1(deltaPhi),
      sinDeltaPhi = sin$1(deltaPhi),
      cosDeltaGamma = cos$1(deltaGamma),
      sinDeltaGamma = sin$1(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = cos$1(phi),
        x = cos$1(lambda) * cosPhi,
        y = sin$1(lambda) * cosPhi,
        z = sin$1(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = cos$1(phi),
        x = cos$1(lambda) * cosPhi,
        y = sin$1(lambda) * cosPhi,
        z = sin$1(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

var rotation = function(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
  };

  return forward;
};

// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos$1(radius),
      sinRadius = sin$1(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau$3;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$3;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = cartesian(point), point[0] -= cosRadius;
  cartesianNormalizeInPlace(point);
  var radius = acos(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + tau$3 - epsilon$2) % tau$3;
}

var circle = function() {
  var center = constant$7([0, 0]),
      radius = constant$7(90),
      precision = constant$7(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= degrees$1, x[1] *= degrees$1;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * radians,
        p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : constant$7([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant$7(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant$7(+_), circle) : precision;
  };

  return circle;
};

var clipBuffer = function() {
  var lines = [],
      line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop$1,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
};

var clipLine = function(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
};

var pointEqual = function(a, b) {
  return abs(a[0] - b[0]) < epsilon$2 && abs(a[1] - b[1]) < epsilon$2;
};

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
var clipPolygon = function(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link$1(subject);
  link$1(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
};

function link$1(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}

var clipMax = 1e9;
var clipMin = -clipMax;

// TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipExtent(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return abs(p[0] - x0) < epsilon$2 ? direction > 0 ? 0 : 3
        : abs(p[0] - x1) < epsilon$2 ? direction > 0 ? 2 : 1
        : abs(p[1] - y0) < epsilon$2 ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = clipBuffer(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = merge(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          clipPolygon(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (clipLine(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

var extent$1 = function() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
};

var sum$1 = adder();

var polygonContains = function(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [sin$1(lambda), -cos$1(lambda), 0],
      angle = 0,
      winding = 0;

  sum$1.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + quarterPi,
        sinPhi0 = sin$1(phi0),
        cosPhi0 = cos$1(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + quarterPi,
          sinPhi1 = sin$1(phi1),
          cosPhi1 = cos$1(phi1),
          delta = lambda1 - lambda0,
          sign$$1 = delta >= 0 ? 1 : -1,
          absDelta = sign$$1 * delta,
          antimeridian = absDelta > pi$3,
          k = sinPhi0 * sinPhi1;

      sum$1.add(atan2(k * sign$$1 * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
      angle += antimeridian ? delta + sign$$1 * tau$3 : delta;

      // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -epsilon$2 || angle < epsilon$2 && sum$1 < -epsilon$2) ^ (winding & 1);
};

var lengthSum = adder();
var lambda0$2;
var sinPhi0$1;
var cosPhi0$1;

var lengthStream = {
  sphere: noop$1,
  point: noop$1,
  lineStart: lengthLineStart,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop$1;
}

function lengthPointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var sinPhi = sin$1(phi),
      cosPhi = cos$1(phi),
      delta = abs(lambda - lambda0$2),
      cosDelta = cos$1(delta),
      sinDelta = sin$1(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x * x + y * y), z));
  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
}

var length$1 = function(object) {
  lengthSum.reset();
  geoStream(object, lengthStream);
  return +lengthSum;
};

var coordinates = [null, null];
var object$1 = {type: "LineString", coordinates: coordinates};

var distance = function(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return length$1(object$1);
};

var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = distance(coordinates[0], coordinates[1]),
      ao = distance(coordinates[0], point),
      ob = distance(point, coordinates[1]);
  return ao + ob <= ab + epsilon$2;
}

function containsPolygon(coordinates, point) {
  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * radians, point[1] * radians];
}

var contains = function(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
};

function graticuleX(y0, y1, dy) {
  var y = sequence(y0, y1 - epsilon$2, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = sequence(x0, x1 - epsilon$2, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return sequence(ceil(X0 / DX) * DX, X1, DX).map(X)
        .concat(sequence(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(sequence(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon$2; }).map(x))
        .concat(sequence(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon$2; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]])
      .extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
}

function graticule10() {
  return graticule()();
}

var interpolate$1 = function(a, b) {
  var x0 = a[0] * radians,
      y0 = a[1] * radians,
      x1 = b[0] * radians,
      y1 = b[1] * radians,
      cy0 = cos$1(y0),
      sy0 = sin$1(y0),
      cy1 = cos$1(y1),
      sy1 = sin$1(y1),
      kx0 = cy0 * cos$1(x0),
      ky0 = cy0 * sin$1(x0),
      kx1 = cy1 * cos$1(x1),
      ky1 = cy1 * sin$1(x1),
      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
      k = sin$1(d);

  var interpolate = d ? function(t) {
    var B = sin$1(t *= d) / k,
        A = sin$1(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      atan2(y, x) * degrees$1,
      atan2(z, sqrt(x * x + y * y)) * degrees$1
    ];
  } : function() {
    return [x0 * degrees$1, y0 * degrees$1];
  };

  interpolate.distance = d;

  return interpolate;
};

var identity$4 = function(x) {
  return x;
};

var areaSum$1 = adder();
var areaRingSum$1 = adder();
var x00;
var y00;
var x0$1;
var y0$1;

var areaStream$1 = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$1;
    areaSum$1.add(abs(areaRingSum$1));
    areaRingSum$1.reset();
  },
  result: function() {
    var area = areaSum$1 / 2;
    areaSum$1.reset();
    return area;
  }
};

function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}

function areaPointFirst$1(x, y) {
  areaStream$1.point = areaPoint$1;
  x00 = x0$1 = x, y00 = y0$1 = y;
}

function areaPoint$1(x, y) {
  areaRingSum$1.add(y0$1 * x - x0$1 * y);
  x0$1 = x, y0$1 = y;
}

function areaRingEnd$1() {
  areaPoint$1(x00, y00);
}

var x0$2 = Infinity;
var y0$2 = x0$2;
var x1 = -x0$2;
var y1 = x1;

var boundsStream$1 = {
  point: boundsPoint$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1,
  result: function() {
    var bounds = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds;
  }
};

function boundsPoint$1(x, y) {
  if (x < x0$2) x0$2 = x;
  if (x > x1) x1 = x;
  if (y < y0$2) y0$2 = y;
  if (y > y1) y1 = y;
}

// TODO Enforce positive area for exterior, negative area for interior?

var X0$1 = 0;
var Y0$1 = 0;
var Z0$1 = 0;
var X1$1 = 0;
var Y1$1 = 0;
var Z1$1 = 0;
var X2$1 = 0;
var Y2$1 = 0;
var Z2$1 = 0;
var x00$1;
var y00$1;
var x0$3;
var y0$3;

var centroidStream$1 = {
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.point = centroidPoint$1;
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  },
  result: function() {
    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
        : [NaN, NaN];
    X0$1 = Y0$1 = Z0$1 =
    X1$1 = Y1$1 = Z1$1 =
    X2$1 = Y2$1 = Z2$1 = 0;
    return centroid;
  }
};

function centroidPoint$1(x, y) {
  X0$1 += x;
  Y0$1 += y;
  ++Z0$1;
}

function centroidLineStart$1() {
  centroidStream$1.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream$1.point = centroidPointLine;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}

function centroidRingStart$1() {
  centroidStream$1.point = centroidPointFirstRing;
}

function centroidRingEnd$1() {
  centroidPointRing(x00$1, y00$1);
}

function centroidPointFirstRing(x, y) {
  centroidStream$1.point = centroidPointRing;
  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0$3,
      dy = y - y0$3,
      z = sqrt(dx * dx + dy * dy);

  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;

  z = y0$3 * x - x0$3 * y;
  X2$1 += z * (x0$3 + x);
  Y2$1 += z * (y0$3 + y);
  Z2$1 += z * 3;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau$3);
        break;
      }
    }
  },
  result: noop$1
};

var lengthSum$1 = adder();
var lengthRing;
var x00$2;
var y00$2;
var x0$4;
var y0$4;

var lengthStream$1 = {
  point: noop$1,
  lineStart: function() {
    lengthStream$1.point = lengthPointFirst$1;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint$1(x00$2, y00$2);
    lengthStream$1.point = noop$1;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum$1;
    lengthSum$1.reset();
    return length;
  }
};

function lengthPointFirst$1(x, y) {
  lengthStream$1.point = lengthPoint$1;
  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
}

function lengthPoint$1(x, y) {
  x0$4 -= x, y0$4 -= y;
  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
  x0$4 = x, y0$4 = y;
}

function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle$1(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle$1(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle$1(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}

var index$1 = function(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    geoStream(object, projectionStream(areaStream$1));
    return areaStream$1.result();
  };

  path.measure = function(object) {
    geoStream(object, projectionStream(lengthStream$1));
    return lengthStream$1.result();
  };

  path.bounds = function(object) {
    geoStream(object, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };

  path.centroid = function(object) {
    geoStream(object, projectionStream(centroidStream$1));
    return centroidStream$1.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$4) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
};

var clip = function(pointVisible, clipLine, interpolate, start) {
  return function(rotate, sink) {
    var line = clipLine(sink),
        rotatedStart = rotate.invert(start[0], start[1]),
        ringBuffer = clipBuffer(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains(polygon, rotatedStart);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipPolygon(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      var point = rotate(lambda, phi);
      if (pointVisible(lambda = point[0], phi = point[1])) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      var point = rotate(lambda, phi);
      line.point(point[0], point[1]);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      var point = rotate(lambda, phi);
      ringSink.point(point[0], point[1]);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
};

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$2 : halfPi$2 - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$2 : halfPi$2 - b[1]);
}

var clipAntimeridian = clip(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi$3, -halfPi$2]
);

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi$3 : -pi$3,
          delta = abs(lambda1 - lambda0);
      if (abs(delta - pi$3) < epsilon$2) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi$3) { // line crosses antimeridian
        if (abs(lambda0 - sign0) < epsilon$2) lambda0 -= sign0 * epsilon$2; // handle degeneracies
        if (abs(lambda1 - sign1) < epsilon$2) lambda1 -= sign1 * epsilon$2;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon$2
      ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
          - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi$2;
    stream.point(-pi$3, phi);
    stream.point(0, phi);
    stream.point(pi$3, phi);
    stream.point(pi$3, 0);
    stream.point(pi$3, -phi);
    stream.point(0, -phi);
    stream.point(-pi$3, -phi);
    stream.point(-pi$3, 0);
    stream.point(-pi$3, phi);
  } else if (abs(from[0] - to[0]) > epsilon$2) {
    var lambda = from[0] < to[0] ? pi$3 : -pi$3;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

var clipCircle = function(radius, delta) {
  var cr = cos$1(radius),
      smallRadius = cr > 0,
      notHemisphere = abs(cr) > epsilon$2; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return cos$1(lambda) * cos$1(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? pi$3 : -pi$3), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        // Handle degeneracies.
        // TODO ignore if not clipping polygons.
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
            point1[0] += epsilon$2;
            point1[1] += epsilon$2;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = cartesian(a),
        pb = cartesian(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
    var n1 = [1, 0, 0], // normal
        n2 = cartesianCross(pa, pb),
        n2n2 = cartesianDot(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = cartesianCross(n1, n2),
        A = cartesianScale(n1, c1),
        B = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = cartesianDot(A, u),
        uu = cartesianDot(u, u),
        t2 = w * w - uu * (cartesianDot(A, A) - 1);

    if (t2 < 0) return;

    var t = sqrt(t2),
        q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = abs(delta - pi$3) < epsilon$2,
        meridian = polar || delta < epsilon$2;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$2 ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > pi$3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi$3 - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$3, radius - pi$3]);
};

var transform = function(methods) {
  return {
    stream: transformer(methods)
  };
};

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};

function fitExtent(projection, extent, object) {
  var w = extent[1][0] - extent[0][0],
      h = extent[1][1] - extent[0][1],
      clip = projection.clipExtent && projection.clipExtent();

  projection
      .scale(150)
      .translate([0, 0]);

  if (clip != null) projection.clipExtent(null);

  geoStream(object, projection.stream(boundsStream$1));

  var b = boundsStream$1.result(),
      k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
      x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
      y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;

  if (clip != null) projection.clipExtent(clip);

  return projection
      .scale(k * 150)
      .translate([x, y]);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

var maxDepth = 16;
var cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

var resample = function(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
};

function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample$1(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = sqrt(a * a + b * b + c * c),
          phi2 = asin(c /= m),
          lambda2 = abs(abs(c) - 1) < epsilon$2 || abs(lambda0 - lambda1) < epsilon$2 ? (lambda0 + lambda1) / 2 : atan2(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      dx, dy, lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
      theta = null, preclip = clipAntimeridian, // clip angle
      x0 = null, y0, x1, y1, postclip = identity$4, // clip extent
      delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision
      cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * radians, point[1] * radians);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * degrees$1, point[1] * degrees$1];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return fitSize(projection, size, object);
  };

  function recenter() {
    projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = pi$3 / 3,
      m = projectionMutator(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];
  };

  return p;
}

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos$1(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };

  return forward;
}

function conicEqualAreaRaw(y0, y1) {
  var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (abs(n) < epsilon$2) return cylindricalEqualAreaRaw(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

  function project(x, y) {
    var r = sqrt(c - 2 * n * sin$1(y)) / n;
    return [r * sin$1(x *= n), r0 - r * cos$1(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y;
    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

var conicEqualArea = function() {
  return conicProjection(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
};

var albers = function() {
  return conicEqualArea()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
};

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
var albersUsa = function() {
  var cache,
      cacheStream,
      lower48 = albers(), lower48Point,
      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + epsilon$2, y + 0.120 * k + epsilon$2], [x - 0.214 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + epsilon$2, y + 0.166 * k + epsilon$2], [x - 0.115 * k - epsilon$2, y + 0.234 * k - epsilon$2]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return fitExtent(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
};

function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = cos$1(x),
        cy = cos$1(y),
        k = scale(cx * cy);
    return [
      k * cy * sin$1(x),
      k * sin$1(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = sqrt(x * x + y * y),
        c = angle(z),
        sc = sin$1(c),
        cc = cos$1(c);
    return [
      atan2(x * sc, z * cc),
      asin(z && y * sc / z)
    ];
  }
}

var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

var azimuthalEqualArea = function() {
  return projection(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
};

var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin$1(c);
});

azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

var azimuthalEquidistant = function() {
  return projection(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
};

function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi$2 + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi$2];
};

var mercator = function() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / tau$3);
};

function mercatorProjection(project) {
  var m = projection(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = pi$3 * scale(),
        t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

function tany(y) {
  return tan((halfPi$2 + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = cos$1(y0),
      n = y0 === y1 ? sin$1(y0) : log(cy0 / cos$1(y1)) / log(tany(y1) / tany(y0)),
      f = cy0 * pow(tany(y0), n) / n;

  if (!n) return mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -halfPi$2 + epsilon$2) y = -halfPi$2 + epsilon$2; }
    else { if (y > halfPi$2 - epsilon$2) y = halfPi$2 - epsilon$2; }
    var r = f / pow(tany(y), n);
    return [r * sin$1(n * x), f - r * cos$1(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi$2];
  };

  return project;
}

var conicConformal = function() {
  return conicProjection(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
};

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

var equirectangular = function() {
  return projection(equirectangularRaw)
      .scale(152.63);
};

function conicEquidistantRaw(y0, y1) {
  var cy0 = cos$1(y0),
      n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (abs(n) < epsilon$2) return equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * sin$1(nx), g - gy * cos$1(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y;
    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
  };

  return project;
}

var conicEquidistant = function() {
  return conicProjection(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
};

function gnomonicRaw(x, y) {
  var cy = cos$1(y), k = cos$1(x) * cy;
  return [cy * sin$1(x) / k, sin$1(y) / k];
}

gnomonicRaw.invert = azimuthalInvert(atan);

var gnomonic = function() {
  return projection(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
};

function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity$4 : transformer({
    point: function(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

var identity$5 = function() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity$4, // scale, translate and reflect
      x0 = null, y0, x1, y1, clip = identity$4, // clip extent
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));
    },
    clipExtent: function(_) {
      return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$4) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function(_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object) {
      return fitExtent(projection, extent, object);
    },
    fitSize: function(size, object) {
      return fitSize(projection, size, object);
    }
  };
};

function orthographicRaw(x, y) {
  return [cos$1(y) * sin$1(x), sin$1(y)];
}

orthographicRaw.invert = azimuthalInvert(asin);

var orthographic = function() {
  return projection(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + epsilon$2);
};

function stereographicRaw(x, y) {
  var cy = cos$1(y), k = 1 + cos$1(x) * cy;
  return [cy * sin$1(x) / k, sin$1(y) / k];
}

stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

var stereographic = function() {
  return projection(stereographicRaw)
      .scale(250)
      .clipAngle(142);
};

function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi$2 + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi$2];
};

var transverseMercator = function() {
  var m = mercatorProjection(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
};

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

var cluster = function() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
};

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

var node_count = function() {
  return this.eachAfter(count);
};

var node_each = function(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
};

var node_eachBefore = function(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
};

var node_eachAfter = function(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
};

var node_sum = function(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
};

var node_sort = function(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
};

var node_path = function(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
};

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

var node_ancestors = function() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
};

var node_descendants = function() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
};

var node_leaves = function() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
};

var node_links = function() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
};

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

function Node$2(value) {
  this._ = value;
  this.next = null;
}

var shuffle$1 = function(array) {
  var i,
      n = (array = array.slice()).length,
      head = null,
      node = head;

  while (n) {
    var next = new Node$2(array[n - 1]);
    if (node) node = node.next = next;
    else node = head = next;
    array[i] = array[--n];
  }

  return {
    head: head,
    tail: node
  };
};

var enclose = function(circles) {
  return encloseN(shuffle$1(circles), []);
};

function encloses(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r - b.r;
  return dr * dr + 1e-6 > dx * dx + dy * dy;
}

// Returns the smallest circle that contains circles L and intersects circles B.
function encloseN(L, B) {
  var circle,
      l0 = null,
      l1 = L.head,
      l2,
      p1;

  switch (B.length) {
    case 1: circle = enclose1(B[0]); break;
    case 2: circle = enclose2(B[0], B[1]); break;
    case 3: circle = enclose3(B[0], B[1], B[2]); break;
  }

  while (l1) {
    p1 = l1._, l2 = l1.next;
    if (!circle || !encloses(circle, p1)) {

      // Temporarily truncate L before l1.
      if (l0) L.tail = l0, l0.next = null;
      else L.head = L.tail = null;

      B.push(p1);
      circle = encloseN(L, B); // Note: reorders L!
      B.pop();

      // Move l1 to the front of L and reconnect the truncated list L.
      if (L.head) l1.next = L.head, L.head = l1;
      else l1.next = null, L.head = L.tail = l1;
      l0 = L.tail, l0.next = l2;

    } else {
      l0 = l1;
    }
    l1 = l2;
  }

  L.tail = l0;
  return circle;
}

function enclose1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function enclose2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function enclose3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = 2 * (x1 - x2),
      b2 = 2 * (y1 - y2),
      c2 = 2 * (r2 - r1),
      d2 = x1 * x1 + y1 * y1 - r1 * r1 - x2 * x2 - y2 * y2 + r2 * r2,
      a3 = 2 * (x1 - x3),
      b3 = 2 * (y1 - y3),
      c3 = 2 * (r3 - r1),
      d3 = x1 * x1 + y1 * y1 - r1 * r1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / ab - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / ab - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (xa * xb + ya * yb + r1),
      C = xa * xa + ya * ya - r1 * r1,
      r = (-B - Math.sqrt(B * B - 4 * A * C)) / (2 * A);
  return {
    x: xa + xb * r + x1,
    y: ya + yb * r + y1,
    r: r
  };
}

function place(a, b, c) {
  var ax = a.x,
      ay = a.y,
      da = b.r + c.r,
      db = a.r + c.r,
      dx = b.x - ax,
      dy = b.y - ay,
      dc = dx * dx + dy * dy;
  if (dc) {
    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
    c.x = ax + x * dx + y * dy;
    c.y = ay + x * dy - y * dx;
  } else {
    c.x = ax + db;
    c.y = ay;
  }
}

function intersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function distance2(node, x, y) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab - x,
      dy = (a.y * b.r + b.y * a.r) / ab - y;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the weighted centroid.
  var aa = a.r * a.r,
      ba = b.r * b.r,
      ca = c.r * c.r,
      oa = aa + ba + ca,
      ox = aa * a.x + ba * b.x + ca * c.x,
      oy = aa * a.y + ba * b.y + ca * c.y,
      cx, cy, i, j, k, sj, sk;

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Update the weighted centroid.
    oa += ca = c._.r * c._.r;
    ox += ca * c._.x;
    oy += ca * c._.y;

    // Compute the new closest circle pair to the centroid.
    aa = distance2(a, cx = ox / oa, cy = oy / oa);
    while ((c = c.next) !== b) {
      if ((ca = distance2(c, cx, cy)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

var siblings = function(circles) {
  packEnclose(circles);
  return circles;
};

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

var constant$8 = function(x) {
  return function() {
    return x;
  };
};

function defaultRadius$1(d) {
  return Math.sqrt(d.value);
}

var index$2 = function() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius$1))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant$8(+x), pack) : padding;
  };

  return pack;
};

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

var roundNode = function(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
};

var treemapDice = function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
};

var partition = function() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
};

var keyPrefix$1 = "$";
var preroot = {depth: -1};
var ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

var stratify = function() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix$1 + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix$1 + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
};

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
var tree = function() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.’s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
};

var treemapSlice = function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
};

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = ((function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
}))(phi);

var index$3 = function() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$8(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$8(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$8(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$8(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$8(+x), treemap) : paddingLeft;
  };

  return treemap;
};

var binary = function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
};

var sliceDice = function(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
};

var resquarify = ((function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
}))(phi);

var area$1 = function(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
};

var centroid$1 = function(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
};

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
var cross$1 = function(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
};

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

var hull = function(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
};

var contains$1 = function(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
};

var length$2 = function(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
};

var slice$3 = [].slice;

var noabort = {};

function Queue(size) {
  this._size = size;
  this._call =
  this._error = null;
  this._tasks = [];
  this._data = [];
  this._waiting =
  this._active =
  this._ended =
  this._start = 0; // inside a synchronous task callback?
}

Queue.prototype = queue.prototype = {
  constructor: Queue,
  defer: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("defer after await");
    if (this._error != null) return this;
    var t = slice$3.call(arguments, 1);
    t.push(callback);
    ++this._waiting, this._tasks.push(t);
    poke$1(this);
    return this;
  },
  abort: function() {
    if (this._error == null) abort(this, new Error("abort"));
    return this;
  },
  await: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = function(error, results) { callback.apply(null, [error].concat(results)); };
    maybeNotify(this);
    return this;
  },
  awaitAll: function(callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = callback;
    maybeNotify(this);
    return this;
  }
};

function poke$1(q) {
  if (!q._start) {
    try { start$1(q); } // let the current task complete
    catch (e) {
      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously
      else if (!q._data) throw e; // await callback errored synchronously
    }
  }
}

function start$1(q) {
  while (q._start = q._waiting && q._active < q._size) {
    var i = q._ended + q._active,
        t = q._tasks[i],
        j = t.length - 1,
        c = t[j];
    t[j] = end(q, i);
    --q._waiting, ++q._active;
    t = c.apply(null, t);
    if (!q._tasks[i]) continue; // task finished synchronously
    q._tasks[i] = t || noabort;
  }
}

function end(q, i) {
  return function(e, r) {
    if (!q._tasks[i]) return; // ignore multiple callbacks
    --q._active, ++q._ended;
    q._tasks[i] = null;
    if (q._error != null) return; // ignore secondary errors
    if (e != null) {
      abort(q, e);
    } else {
      q._data[i] = r;
      if (q._waiting) poke$1(q);
      else maybeNotify(q);
    }
  };
}

function abort(q, e) {
  var i = q._tasks.length, t;
  q._error = e; // ignore active callbacks
  q._data = undefined; // allow gc
  q._waiting = NaN; // prevent starting

  while (--i >= 0) {
    if (t = q._tasks[i]) {
      q._tasks[i] = null;
      if (t.abort) {
        try { t.abort(); }
        catch (e) { /* ignore */ }
      }
    }
  }

  q._active = NaN; // allow notification
  maybeNotify(q);
}

function maybeNotify(q) {
  if (!q._active && q._call) {
    var d = q._data;
    q._data = undefined; // allow gc
    q._call(q._error, d);
  }
}

function queue(concurrency) {
  if (concurrency == null) concurrency = Infinity;
  else if (!((concurrency = +concurrency) >= 1)) throw new Error("invalid concurrency");
  return new Queue(concurrency);
}

var defaultSource$1 = function() {
  return Math.random();
};

var uniform = ((function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;
    else max -= min;
    return function() {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;

  return randomUniform;
}))(defaultSource$1);

var normal = ((function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
}))(defaultSource$1);

var logNormal = ((function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;

  return randomLogNormal;
}))(defaultSource$1);

var irwinHall = ((function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();
      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;

  return randomIrwinHall;
}))(defaultSource$1);

var bates = ((function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;

  return randomBates;
}))(defaultSource$1);

var exponential$1 = ((function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;

  return randomExponential;
}))(defaultSource$1);

var request = function(url, callback) {
  var request,
      event = dispatch("beforesend", "progress", "load", "error"),
      mimeType,
      headers = map$1(),
      xhr = new XMLHttpRequest,
      user = null,
      password = null,
      response,
      responseType,
      timeout = 0;

  // If IE does not support CORS, use XDomainRequest.
  if (typeof XDomainRequest !== "undefined"
      && !("withCredentials" in xhr)
      && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest;

  "onload" in xhr
      ? xhr.onload = xhr.onerror = xhr.ontimeout = respond
      : xhr.onreadystatechange = function(o) { xhr.readyState > 3 && respond(o); };

  function respond(o) {
    var status = xhr.status, result;
    if (!status && hasResponse(xhr)
        || status >= 200 && status < 300
        || status === 304) {
      if (response) {
        try {
          result = response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }
      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function(e) {
    event.call("progress", request, e);
  };

  request = {
    header: function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);
      else headers.set(name, value + "");
      return request;
    },

    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return request;
    },

    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return request;
    },

    timeout: function(value) {
      if (!arguments.length) return timeout;
      timeout = +value;
      return request;
    },

    user: function(value) {
      return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
    },

    password: function(value) {
      return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
    },

    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function(value) {
      response = value;
      return request;
    },

    // Alias for send("GET", …).
    get: function(data, callback) {
      return request.send("GET", data, callback);
    },

    // Alias for send("POST", …).
    post: function(data, callback) {
      return request.send("POST", data, callback);
    },

    // If callback is non-null, it will be used for error and load events.
    send: function(method, data, callback) {
      xhr.open(method, url, true, user, password);
      if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function(value, name) { xhr.setRequestHeader(name, value); });
      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
      if (responseType != null) xhr.responseType = responseType;
      if (timeout > 0) xhr.timeout = timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function(xhr) { callback(null, xhr); });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },

    abort: function() {
      xhr.abort();
      return request;
    },

    on: function() {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
};

function fixCallback(callback) {
  return function(error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text"
      ? xhr.response // null on error
      : xhr.responseText; // "" on error
}

var type$1 = function(defaultMimeType, response) {
  return function(url, callback) {
    var r = request(url).mimeType(defaultMimeType).response(response);
    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }
    return r;
  };
};

var html = type$1("text/html", function(xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
});

var json = type$1("application/json", function(xhr) {
  return JSON.parse(xhr.responseText);
});

var text = type$1("text/plain", function(xhr) {
  return xhr.responseText;
});

var xml = type$1("application/xml", function(xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
});

var dsv$1 = function(defaultMimeType, parse) {
  return function(url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = request(url).mimeType(defaultMimeType);
    r.row = function(_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };
    r.row(row);
    return callback ? r.get(callback) : r;
  };
};

function responseOf(parse, row) {
  return function(request$$1) {
    return parse(request$$1.responseText, row);
  };
}

var csv$1 = dsv$1("text/csv", csvParse);

var tsv$1 = dsv$1("text/tab-separated-values", tsvParse);

var array$2 = Array.prototype;

var map$3 = array$2.map;
var slice$4 = array$2.slice;

var implicit = {name: "implicit"};

function ordinal(range) {
  var index = map$1(),
      domain = [],
      unknown = implicit;

  range = range == null ? [] : slice$4.call(range);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = map$1();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = slice$4.call(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range$$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range$$1[1] < range$$1[0],
        start = range$$1[reverse - 0],
        stop = range$$1[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = sequence(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range$$1)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point$1() {
  return pointish(band().paddingInner(1));
}

var constant$9 = function(x) {
  return function() {
    return x;
  };
};

var number$1 = function(x) {
  return +x;
};

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant$9(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range$$1, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range$$1[0], r1 = range$$1[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range$$1, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range$$1.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range$$1 = range$$1.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);
  }

  return function(x) {
    var i = bisectRight(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range$$1 = unit,
      interpolate$$1 = interpolateValue,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$3.call(_, number$1), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice$4.call(_), rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = slice$4.call(_), interpolate$$1 = interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
  };

  return rescale();
}

var tickFormat = function(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
      return exports.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return exports.format(specifier);
};

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return tickFormat(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear$2() {
  var scale = continuous(deinterpolateLinear, reinterpolate);

  scale.copy = function() {
    return copy(scale, linear$2());
  };

  return linearish(scale);
}

function identity$6() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map$3.call(_, number$1), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity$6().domain(domain);
  };

  return linearish(scale);
}

var nice = function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
};

function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant$9(b);
}

function reinterpolate$1(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log$1() {
  var scale = continuous(deinterpolate, reinterpolate$1).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = exports.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log$1().base(base));
  };

  return scale;
}

function raise$1(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow$1() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise$1(b, exponent) - (a = raise$1(a, exponent)))
        ? function(x) { return (raise$1(x, exponent) - a) / b; }
        : constant$9(b);
  }

  function reinterpolate(a, b) {
    b = raise$1(b, exponent) - (a = raise$1(a, exponent));
    return function(t) { return raise$1(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow$1().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt$1() {
  return pow$1().exponent(0.5);
}

function quantile$$1() {
  var domain = [],
      range$$1 = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range$$1.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range$$1[bisectRight(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice$4.call(_), rescale()) : range$$1.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile$$1()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

function quantize$1() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range$$1 = [0, 1];

  function scale(x) {
    if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range$$1 = slice$4.call(_)).length - 1, rescale()) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize$1()
        .domain([x0, x1])
        .range(range$$1);
  };

  return linearish(scale);
}

function threshold$1() {
  var domain = [0.5],
      range$$1 = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range$$1[bisectRight(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice$4.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice$4.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold$1()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

var t0$1 = new Date;
var t1$1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0$1.setTime(+start), t1$1.setTime(+end);
      floori(t0$1), floori(t1$1);
      return Math.floor(count(t0$1, t1$1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var milliseconds = millisecond.range;

var durationSecond$1 = 1e3;
var durationMinute$1 = 6e4;
var durationHour$1 = 36e5;
var durationDay$1 = 864e5;
var durationWeek$1 = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond$1) * durationSecond$1);
}, function(date, step) {
  date.setTime(+date + step * durationSecond$1);
}, function(start, end) {
  return (end - start) / durationSecond$1;
}, function(date) {
  return date.getUTCSeconds();
});

var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute$1) * durationMinute$1);
}, function(date, step) {
  date.setTime(+date + step * durationMinute$1);
}, function(start, end) {
  return (end - start) / durationMinute$1;
}, function(date) {
  return date.getMinutes();
});

var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute$1 % durationHour$1;
  if (offset < 0) offset += durationHour$1;
  date.setTime(Math.floor((+date - offset) / durationHour$1) * durationHour$1 + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour$1);
}, function(start, end) {
  return (end - start) / durationHour$1;
}, function(date) {
  return date.getHours();
});

var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
}, function(date) {
  return date.getDate() - 1;
});

var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute$1);
}, function(start, end) {
  return (end - start) / durationMinute$1;
}, function(date) {
  return date.getUTCMinutes();
});

var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour$1);
}, function(start, end) {
  return (end - start) / durationHour$1;
}, function(date) {
  return date.getUTCHours();
});

var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay$1;
}, function(date) {
  return date.getUTCDate() - 1;
});

var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek$1;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var utcYears = utcYear.range;

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale$1(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "S": formatSeconds,
    "U": formatWeekNumberSunday,
    "w": formatWeekdayNumber,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "S": formatUTCSeconds,
    "U": formatUTCWeekNumberSunday,
    "w": formatUTCWeekdayNumber,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "S": parseSeconds,
    "U": parseWeekNumberSunday,
    "w": parseWeekdayNumber,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0);
      if (i != string.length) return null;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "W" in d ? 1 : 0;
        var day$$1 = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$$1 + 5) % 7 : d.w + d.U * 7 - (day$$1 + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"};
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + day.count(year(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(year(d), d), p, 2);
}

function formatWeekdayNumber(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(monday.count(year(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d), d), p, 2);
}

function formatUTCWeekdayNumber(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

var locale$2;





defaultLocale$1({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale$1(definition) {
  locale$2 = formatLocale$1(definition);
  exports.timeFormat = locale$2.format;
  exports.timeParse = locale$2.parse;
  exports.utcFormat = locale$2.utcFormat;
  exports.utcParse = locale$2.utcParse;
  return locale$2;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

function date$1(t) {
  return new Date(t);
}

function number$2(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format) {
  var scale = continuous(deinterpolateLinear, reinterpolate),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  var tickIntervals = [
    [second$$1,  1,      durationSecond],
    [second$$1,  5,  5 * durationSecond],
    [second$$1, 15, 15 * durationSecond],
    [second$$1, 30, 30 * durationSecond],
    [minute$$1,  1,      durationMinute],
    [minute$$1,  5,  5 * durationMinute],
    [minute$$1, 15, 15 * durationMinute],
    [minute$$1, 30, 30 * durationMinute],
    [  hour$$1,  1,      durationHour  ],
    [  hour$$1,  3,  3 * durationHour  ],
    [  hour$$1,  6,  6 * durationHour  ],
    [  hour$$1, 12, 12 * durationHour  ],
    [   day$$1,  1,      durationDay   ],
    [   day$$1,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month$$1,  1,      durationMonth ],
    [ month$$1,  3,  3 * durationMonth ],
    [  year$$1,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second$$1(date) < date ? formatMillisecond
        : minute$$1(date) < date ? formatSecond
        : hour$$1(date) < date ? formatMinute
        : day$$1(date) < date ? formatHour
        : month$$1(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year$$1(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = tickStep(start / durationYear, stop / durationYear, interval);
        interval = year$$1;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = tickStep(start, stop, interval);
        interval = millisecond$$1;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map$3.call(_, number$2)) : domain().map(date$1);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year$$1, month$$1, week, day$$1, hour$$1, minute$$1, second$$1, millisecond$$1, format));
  };

  return scale;
}

var time = function() {
  return calendar(year, month, sunday, day, hour, minute, second, millisecond, exports.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
};

var utcTime = function() {
  return calendar(utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, millisecond, exports.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
};

var colors = function(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
};

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

var cubehelix$3 = cubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));

var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));

var rainbow = cubehelix();

var rainbow$1 = function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
};

function ramp(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

var constant$10 = function(x) {
  return function constant() {
    return x;
  };
};

var abs$1 = Math.abs;
var atan2$1 = Math.atan2;
var cos$2 = Math.cos;
var max$2 = Math.max;
var min$1 = Math.min;
var sin$2 = Math.sin;
var sqrt$2 = Math.sqrt;

var epsilon$3 = 1e-12;
var pi$4 = Math.PI;
var halfPi$3 = pi$4 / 2;
var tau$4 = 2 * pi$4;

function acos$1(x) {
  return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
}

function asin$1(x) {
  return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt$2(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt$2(max$2(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

var arc = function() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant$10(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi$3,
        a1 = endAngle.apply(this, arguments) - halfPi$3,
        da = abs$1(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon$3)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau$4 - epsilon$3) {
      context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$3) {
        context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon$3) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$2(r0 * r0 + r1 * r1)),
          rc = min$1(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
      if (rp > epsilon$3) {
        var p0 = asin$1(rp / r0 * sin$2(ap)),
            p1 = asin$1(rp / r1 * sin$2(ap));
        if ((da0 -= p0 * 2) > epsilon$3) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$3) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos$2(a01),
          y01 = r1 * sin$2(a01),
          x10 = r0 * cos$2(a10),
          y10 = r0 * sin$2(a10);

      // Apply rounded corners?
      if (rc > epsilon$3) {
        var x11 = r1 * cos$2(a11),
            y11 = r1 * sin$2(a11),
            x00 = r0 * cos$2(a00),
            y00 = r0 * sin$2(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi$4) {
          var oc = da0 > epsilon$3 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$2(ax * ax + ay * ay) * sqrt$2(bx * bx + by * by))) / 2),
              lc = sqrt$2(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min$1(rc, (r0 - lc) / (kc - 1));
          rc1 = min$1(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon$3)) context.moveTo(x01, y01);

      // Does the sector’s outer ring have rounded corners?
      else if (rc1 > epsilon$3) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and it’s a circular sector?
      // Or perhaps it’s an annular sector collapsed due to padding?
      if (!(r0 > epsilon$3) || !(da0 > epsilon$3)) context.lineTo(x10, y10);

      // Does the sector’s inner ring (or point) have rounded corners?
      else if (rc0 > epsilon$3) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$4 / 2;
    return [cos$2(a) * r, sin$2(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$10(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$10(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$10(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$10(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$10(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$10(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$10(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
};

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

var curveLinear = function(context) {
  return new Linear(context);
};

function x$3(p) {
  return p[0];
}

function y$3(p) {
  return p[1];
}

var line = function() {
  var x$$1 = x$3,
      y$$1 = y$3,
      defined = constant$10(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$10(+_), line) : x$$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$10(+_), line) : y$$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$10(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
};

var area$2 = function() {
  var x0 = x$3,
      x1 = null,
      y0 = constant$10(0),
      y1 = y$3,
      defined = constant$10(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$10(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$10(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$10(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$10(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$10(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$10(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$10(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
};

var descending$1 = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var identity$7 = function(d) {
  return d;
};

var pie = function() {
  var value = identity$7,
      sortValues = descending$1,
      sort = null,
      startAngle = constant$10(0),
      endAngle = constant$10(tau$4),
      padAngle = constant$10(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau$4, Math.max(-tau$4, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$10(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$10(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$10(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$10(+_), pie) : padAngle;
  };

  return pie;
};

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function radialLine(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

var radialLine$1 = function() {
  return radialLine(line().curve(curveRadialLinear));
};

var radialArea = function() {
  var a = area$2().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return radialLine(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return radialLine(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return radialLine(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return radialLine(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
};

var slice$5 = Array.prototype.slice;

var radialPoint = function(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
};

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link$2(curve) {
  var source = linkSource,
      target = linkTarget,
      x$$1 = x$3,
      y$$1 = y$3,
      context = null;

  function link() {
    var buffer, argv = slice$5.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = path();
    curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$10(+_), link) : x$$1;
  };

  link.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$10(+_), link) : y$$1;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = radialPoint(x0, y0),
      p1 = radialPoint(x0, y0 = (y0 + y1) / 2),
      p2 = radialPoint(x1, y0),
      p3 = radialPoint(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link$2(curveHorizontal);
}

function linkVertical() {
  return link$2(curveVertical);
}

function linkRadial() {
  var l = link$2(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi$4);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau$4);
  }
};

var cross$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3);
var tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810;
var kr = Math.sin(pi$4 / 10) / Math.sin(7 * pi$4 / 10);
var kx = Math.sin(tau$4 / 10) * kr;
var ky = -Math.cos(tau$4 / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau$4 * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5;
var s = Math.sqrt(3) / 2;
var k = 1 / Math.sqrt(12);
var a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle$2,
  cross$2,
  diamond,
  square,
  star,
  triangle,
  wye
];

var symbol = function() {
  var type = constant$10(circle$2),
      size = constant$10(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$10(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$10(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
};

var noop$2 = function() {};

function point$2(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point$2(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point$2(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basis$2 = function(context) {
  return new Basis(context);
};

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point$2(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisClosed$1 = function(context) {
  return new BasisClosed(context);
};

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisOpen = function(context) {
  return new BasisOpen(context);
};

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
}))(0.85);

function point$3(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$3(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
}))(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
}))(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
}))(0);

function point$4(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon$3) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon$3) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$4(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}))(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$4(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}))(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$4(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}))(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

var linearClosed = function(context) {
  return new LinearClosed(context);
};

function sign$1(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$1(s0) + sign$1(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$5(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$5(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$5(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$5(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

var natural = function(context) {
  return new Natural(context);
};

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

var step = function(context) {
  return new Step(context, 0.5);
};

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

var none$1 = function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
};

var none$2 = function(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
};

function stackValue(d, key) {
  return d[key];
}

var stack = function() {
  var keys = constant$10([]),
      order = none$2,
      offset = none$1,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant$10(slice$5.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$10(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$2 : typeof _ === "function" ? _ : constant$10(slice$5.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
  };

  return stack;
};

var expand = function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none$1(series, order);
};

var diverging = function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
};

var silhouette = function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none$1(series, order);
};

var wiggle = function(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none$1(series, order);
};

var ascending$2 = function(series) {
  var sums = series.map(sum$2);
  return none$2(series).sort(function(a, b) { return sums[a] - sums[b]; });
};

function sum$2(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

var descending$2 = function(series) {
  return ascending$2(series).reverse();
};

var insideOut = function(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum$2),
      order = none$2(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
};

var reverse = function(series) {
  return none$2(series).reverse();
};

var constant$11 = function(x) {
  return function() {
    return x;
  };
};

function x$4(d) {
  return d[0];
}

function y$4(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// Liang–Barsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$4
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon$4)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon$4 || Math.abs(endY - startY) > epsilon$4) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon$4 && y1 - endY > epsilon$4 ? [x0, Math.abs(startX - x0) < epsilon$4 ? startY : y1]
              : Math.abs(endY - y1) < epsilon$4 && x1 - endX > epsilon$4 ? [Math.abs(startY - y1) < epsilon$4 ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon$4 && endY - y0 > epsilon$4 ? [x1, Math.abs(startX - x1) < epsilon$4 ? startY : y0]
              : Math.abs(endY - y0) < epsilon$4 && endX - x0 > epsilon$4 ? [Math.abs(startY - y0) < epsilon$4 ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2$2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon$4
      && Math.abs(y - lArc.circle.cy) < epsilon$4) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon$4
      && Math.abs(y - rArc.circle.cy) < epsilon$4) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon$4) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon$4) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon$4) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon$4) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon$4 = 1e-6;
var epsilon2$2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree;
  circles = new RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

var voronoi = function() {
  var x$$1 = x$4,
      y$$1 = y$4,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x$$1(d, i, data) / epsilon$4) * epsilon$4, Math.round(y$$1(d, i, data) / epsilon$4) * epsilon$4];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant$11(+_), voronoi) : x$$1;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant$11(+_), voronoi) : y$$1;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
};

var constant$12 = function(x) {
  return function() {
    return x;
  };
};

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity$8 = new Transform(1, 0, 0);

transform$1.prototype = Transform.prototype;

function transform$1(node) {
  return node.__zoom || identity$8;
}

function nopropagation$2() {
  exports.event.stopImmediatePropagation();
}

var noevent$2 = function() {
  exports.event.preventDefault();
  exports.event.stopImmediatePropagation();
};

// Ignore right-click, since that should open the context menu.
function defaultFilter$2() {
  return !exports.event.button;
}

function defaultExtent$1() {
  var e = this, w, h;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }
  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || identity$8;
}

var zoom = function() {
  var filter = defaultFilter$2,
      extent = defaultExtent$1,
      k0 = 0,
      k1 = Infinity,
      x0 = -k1,
      x1 = k1,
      y0 = x0,
      y1 = x1,
      duration = 250,
      interpolate$$1 = interpolateZoom,
      gestures = [],
      listeners = dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection$$1) {
    selection$$1
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
        .property("__zoom", defaultTransform);
  }

  zoom.transform = function(collection, transform) {
    var selection$$1 = collection.selection ? collection.selection() : collection;
    selection$$1.property("__zoom", defaultTransform);
    if (collection !== selection$$1) {
      schedule(collection, transform);
    } else {
      selection$$1.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection$$1, k) {
    zoom.scaleTo(selection$$1, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function(selection$$1, k) {
    zoom.transform(selection$$1, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e);
    });
  };

  zoom.translateBy = function(selection$$1, x, y) {
    zoom.transform(selection$$1, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments));
    });
  };

  function scale(transform, k) {
    k = Math.max(k0, Math.min(k1, k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function constrain(transform, extent) {
    var dx0 = transform.invertX(extent[0][0]) - x0,
        dx1 = transform.invertX(extent[1][0]) - x1,
        dy0 = transform.invertY(extent[0][1]) - y0,
        dy1 = transform.invertY(extent[1][1]) - y1;
    return transform.translate(
      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
    );
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition$$1, transform, center) {
    transition$$1
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = center || centroid(e),
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate$$1(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }
    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(k0, Math.min(k1, t.k * Math.pow(2, -exports.event.deltaY * (exports.event.deltaMode ? 120 : 1) / 500))),
        p = mouse(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      interrupt(this);
      g.start();
    }

    noevent$2();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = select(exports.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = mouse(this),
        x0 = exports.event.clientX,
        y0 = exports.event.clientY;

    dragDisable(exports.event.view);
    nopropagation$2();
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();

    function mousemoved() {
      noevent$2();
      if (!g.moved) {
        var dx = exports.event.clientX - x0, dy = exports.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(exports.event.view, g.moved);
      noevent$2();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (exports.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments));

    noevent$2();
    if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);
    else select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches$$1 = exports.event.changedTouches,
        started,
        n = touches$$1.length, i, t, p;

    nopropagation$2();
    for (i = 0; i < n; ++i) {
      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;
      else if (!g.touch1) g.touch1 = p;
    }

    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);
      if (!g.touch1) {
        g.end();
        p = select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches$$1 = exports.event.changedTouches,
        n = touches$$1.length, i, t, p, l;

    noevent$2();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    for (i = 0; i < n; ++i) {
      t = touches$$1[i], p = touch(this, touches$$1, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches$$1 = exports.event.changedTouches,
        n = touches$$1.length, i, t;

    nopropagation$2();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches$$1[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else g.end();
  }

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$12(!!_), zoom) : filter;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$12([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (k0 = +_[0], k1 = +_[1], zoom) : [k0, k1];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], zoom) : [[x0, y0], [x1, y1]];
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate$$1 = _, zoom) : interpolate$$1;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
    
  return zoom;
};

exports.version = version;
exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = threshold;
exports.range = sequence;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;
exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;
exports.brush = brush;
exports.brushX = brushX;
exports.brushY = brushY;
exports.brushSelection = brushSelection;
exports.chord = chord;
exports.ribbon = ribbon;
exports.nest = nest;
exports.set = set$2;
exports.map = map$1;
exports.keys = keys;
exports.values = values;
exports.entries = entries;
exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.cubehelix = cubehelix;
exports.dispatch = dispatch;
exports.drag = drag;
exports.dragDisable = dragDisable;
exports.dragEnable = yesdrag;
exports.dsvFormat = dsv;
exports.csvParse = csvParse;
exports.csvParseRows = csvParseRows;
exports.csvFormat = csvFormat;
exports.csvFormatRows = csvFormatRows;
exports.tsvParse = tsvParse;
exports.tsvParseRows = tsvParseRows;
exports.tsvFormat = tsvFormat;
exports.tsvFormatRows = tsvFormatRows;
exports.easeLinear = linear$1;
exports.easeQuad = quadInOut;
exports.easeQuadIn = quadIn;
exports.easeQuadOut = quadOut;
exports.easeQuadInOut = quadInOut;
exports.easeCubic = cubicInOut;
exports.easeCubicIn = cubicIn;
exports.easeCubicOut = cubicOut;
exports.easeCubicInOut = cubicInOut;
exports.easePoly = polyInOut;
exports.easePolyIn = polyIn;
exports.easePolyOut = polyOut;
exports.easePolyInOut = polyInOut;
exports.easeSin = sinInOut;
exports.easeSinIn = sinIn;
exports.easeSinOut = sinOut;
exports.easeSinInOut = sinInOut;
exports.easeExp = expInOut;
exports.easeExpIn = expIn;
exports.easeExpOut = expOut;
exports.easeExpInOut = expInOut;
exports.easeCircle = circleInOut;
exports.easeCircleIn = circleIn;
exports.easeCircleOut = circleOut;
exports.easeCircleInOut = circleInOut;
exports.easeBounce = bounceOut;
exports.easeBounceIn = bounceIn;
exports.easeBounceOut = bounceOut;
exports.easeBounceInOut = bounceInOut;
exports.easeBack = backInOut;
exports.easeBackIn = backIn;
exports.easeBackOut = backOut;
exports.easeBackInOut = backInOut;
exports.easeElastic = elasticOut;
exports.easeElasticIn = elasticIn;
exports.easeElasticOut = elasticOut;
exports.easeElasticInOut = elasticInOut;
exports.forceCenter = center$1;
exports.forceCollide = collide;
exports.forceLink = link;
exports.forceManyBody = manyBody;
exports.forceSimulation = simulation;
exports.forceX = x$2;
exports.forceY = y$2;
exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;
exports.geoArea = area;
exports.geoBounds = bounds;
exports.geoCentroid = centroid;
exports.geoCircle = circle;
exports.geoClipExtent = extent$1;
exports.geoContains = contains;
exports.geoDistance = distance;
exports.geoGraticule = graticule;
exports.geoGraticule10 = graticule10;
exports.geoInterpolate = interpolate$1;
exports.geoLength = length$1;
exports.geoPath = index$1;
exports.geoAlbers = albers;
exports.geoAlbersUsa = albersUsa;
exports.geoAzimuthalEqualArea = azimuthalEqualArea;
exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
exports.geoAzimuthalEquidistant = azimuthalEquidistant;
exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
exports.geoConicConformal = conicConformal;
exports.geoConicConformalRaw = conicConformalRaw;
exports.geoConicEqualArea = conicEqualArea;
exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
exports.geoConicEquidistant = conicEquidistant;
exports.geoConicEquidistantRaw = conicEquidistantRaw;
exports.geoEquirectangular = equirectangular;
exports.geoEquirectangularRaw = equirectangularRaw;
exports.geoGnomonic = gnomonic;
exports.geoGnomonicRaw = gnomonicRaw;
exports.geoIdentity = identity$5;
exports.geoProjection = projection;
exports.geoProjectionMutator = projectionMutator;
exports.geoMercator = mercator;
exports.geoMercatorRaw = mercatorRaw;
exports.geoOrthographic = orthographic;
exports.geoOrthographicRaw = orthographicRaw;
exports.geoStereographic = stereographic;
exports.geoStereographicRaw = stereographicRaw;
exports.geoTransverseMercator = transverseMercator;
exports.geoTransverseMercatorRaw = transverseMercatorRaw;
exports.geoRotation = rotation;
exports.geoStream = geoStream;
exports.geoTransform = transform;
exports.cluster = cluster;
exports.hierarchy = hierarchy;
exports.pack = index$2;
exports.packSiblings = siblings;
exports.packEnclose = enclose;
exports.partition = partition;
exports.stratify = stratify;
exports.tree = tree;
exports.treemap = index$3;
exports.treemapBinary = binary;
exports.treemapDice = treemapDice;
exports.treemapSlice = treemapSlice;
exports.treemapSliceDice = sliceDice;
exports.treemapSquarify = squarify;
exports.treemapResquarify = resquarify;
exports.interpolate = interpolateValue;
exports.interpolateArray = array$1;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateNumber = reinterpolate;
exports.interpolateObject = object;
exports.interpolateRound = interpolateRound;
exports.interpolateString = interpolateString;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = interpolateZoom;
exports.interpolateRgb = interpolateRgb;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$2;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab$1;
exports.interpolateHcl = hcl$2;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$2;
exports.interpolateCubehelixLong = cubehelixLong;
exports.quantize = quantize;
exports.path = path;
exports.polygonArea = area$1;
exports.polygonCentroid = centroid$1;
exports.polygonHull = hull;
exports.polygonContains = contains$1;
exports.polygonLength = length$2;
exports.quadtree = quadtree;
exports.queue = queue;
exports.randomUniform = uniform;
exports.randomNormal = normal;
exports.randomLogNormal = logNormal;
exports.randomBates = bates;
exports.randomIrwinHall = irwinHall;
exports.randomExponential = exponential$1;
exports.request = request;
exports.html = html;
exports.json = json;
exports.text = text;
exports.xml = xml;
exports.csv = csv$1;
exports.tsv = tsv$1;
exports.scaleBand = band;
exports.scalePoint = point$1;
exports.scaleIdentity = identity$6;
exports.scaleLinear = linear$2;
exports.scaleLog = log$1;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow$1;
exports.scaleSqrt = sqrt$1;
exports.scaleQuantile = quantile$$1;
exports.scaleQuantize = quantize$1;
exports.scaleThreshold = threshold$1;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.schemeCategory10 = category10;
exports.schemeCategory20b = category20b;
exports.schemeCategory20c = category20c;
exports.schemeCategory20 = category20;
exports.interpolateCubehelixDefault = cubehelix$3;
exports.interpolateRainbow = rainbow$1;
exports.interpolateWarm = warm;
exports.interpolateCool = cool;
exports.interpolateViridis = viridis;
exports.interpolateMagma = magma;
exports.interpolateInferno = inferno;
exports.interpolatePlasma = plasma;
exports.scaleSequential = sequential;
exports.creator = creator;
exports.local = local$1;
exports.matcher = matcher$1;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;
exports.customEvent = customEvent;
exports.arc = arc;
exports.area = area$2;
exports.line = line;
exports.pie = pie;
exports.radialArea = radialArea;
exports.radialLine = radialLine$1;
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;
exports.symbol = symbol;
exports.symbols = symbols;
exports.symbolCircle = circle$2;
exports.symbolCross = cross$2;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.curveBasisClosed = basisClosed$1;
exports.curveBasisOpen = basisOpen;
exports.curveBasis = basis$2;
exports.curveBundle = bundle;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCardinal = cardinal;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveCatmullRom = catmullRom;
exports.curveLinearClosed = linearClosed;
exports.curveLinear = curveLinear;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.stack = stack;
exports.stackOffsetExpand = expand;
exports.stackOffsetDiverging = diverging;
exports.stackOffsetNone = none$1;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAscending = ascending$2;
exports.stackOrderDescending = descending$2;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$2;
exports.stackOrderReverse = reverse;
exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;
exports.timeFormatDefaultLocale = defaultLocale$1;
exports.timeFormatLocale = formatLocale$1;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;
exports.now = now;
exports.timer = timer;
exports.timerFlush = timerFlush;
exports.timeout = timeout$1;
exports.interval = interval$1;
exports.transition = transition;
exports.active = active;
exports.interrupt = interrupt;
exports.voronoi = voronoi;
exports.zoom = zoom;
exports.zoomTransform = transform$1;
exports.zoomIdentity = identity$8;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),
/* 2 */
/***/ (function(module, exports) {

var studyData = [
  {
    "name": "Australia",
    "region": "OC",
    "code": "AUS",
    "Population": [[1975,12925179],[1976,13104717],[1977,13274487],[1978,13445160],[1979,13624504],[1980,13815623],[1981,14016589],[1982,14224073],[1983,14432572],[1984,14638327],[1985,14840224],[1986,15040448],[1987,15242390],[1988,15450858],[1989,15669117],[1990,15898038],[1991,16135897],[1992,16380120],[1993,16626941],[1994,16873335],[1995,17119108],[1996,17364316],[1997,17606545],[1998,17842944],[1999,18071758],[2000,18291108]],
    "Arable Area": [[1974,0],[1975,41283],[1976,40787],[1977,40387],[1978,42287],[1979,42387],[1980,42233],[1981,41241],[1982,42670],[1983,44087],[1984,44186],[1985,43171],[1986,46531],[1987,44975],[1988,47239],[1989,47310],[1990,46975],[1991,47106],[1992,47223],[1993,47877],[1994,48081],[1995,45874],[1996,47378],[1997,46486],[1998,52100],[1999,46348],[2000,52221]],
    "Energy Consumption": [[1975,57974],[1976,60888],[1977,64772],[1978,69743],[1979,73933],[1980,76596],[1981,82607],[1982,86295],[1983,91232],[1984,96135],[1985,101480],[1986,105329],[1987,106287],[1988,112947],[1989,120996],[1990,126211],[1991,131523],[1992,139017],[1993,147788],[1994,155077],[1995,156851],[1996,159761],[1997,163747],[1998,167513],[1999,173384],[2000,177672]],
    "GDP Per Capita": [[1975,3798],[1976,4325],[1977,4852],[1978,5379],[1979,5906],[1980,6433],[1981,6860],[1982,7577],[1983,8377],[1984,9259],[1985,10429],[1986,10490],[1987,11351],[1988,12327],[1989,13064],[1990,13388],[1991,14334],[1992,15252],[1993,16215],[1994,16703],[1995,17004],[1996,17714],[1997,18595],[1998,19624],[1999,20753],[2000,21602]],
    "Life Expectancy (Women)": [[1975,73.76],[1976,74.12],[1977,74.48],[1978,74.84],[1979,75.2],[1980,75.56],[1981,75.92],[1982,76.28],[1983,76.64],[1984,77],[1985,77.34],[1986,77.68],[1987,78.02],[1988,78.36],[1989,78.7],[1990,78.84],[1991,78.98],[1992,79.12],[1993,79.26],[1994,79.4],[1995,79.64],[1996,79.88],[1997,80.12],[1998,80.36],[1999,80.6],[2000,80.83]],
    "Life Expectancy (Men)": [[1975,67.04],[1976,67.38],[1977,67.72],[1978,68.06],[1979,68.4],[1980,68.74],[1981,69.08],[1982,69.42],[1983,69.75],[1984,70.1],[1985,70.46],[1986,70.82],[1987,71.18],[1988,71.54],[1989,71.9],[1990,72.12],[1991,72.34],[1992,72.56],[1993,72.78],[1994,73],[1995,73.34],[1996,73.68],[1997,74.02],[1998,74.36],[1999,74.7],[2000,75.04]],
    "Life Expectancy": [[1975,70.26],[1976,70.62],[1977,70.98],[1978,71.34],[1979,71.7],[1980,72.06],[1981,72.42],[1982,72.78],[1983,73.14],[1984,73.5],[1985,73.84],[1986,74.18],[1987,74.52],[1988,74.86],[1989,75.2],[1990,75.38],[1991,75.56],[1992,75.74],[1993,75.92],[1994,76.1],[1995,76.39],[1996,76.69],[1997,77],[1998,77.3],[1999,77.6],[2000,77.89]],
    "Infant Mortality": [[1975,19.33],[1976,18.65],[1977,17.95],[1978,17.29],[1979,16.6],[1980,15.9],[1981,15.24],[1982,14.55],[1983,13.85],[1984,13.19],[1985,12.5],[1986,12],[1987,11.5],[1988,11],[1989,10.5],[1990,10],[1991,9.72],[1992,9.44],[1993,9.16],[1994,8.87],[1995,8.6],[1996,8.2],[1997,7.8],[1998,7.39],[1999,7],[2000,6.6]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,2.03],[1989,4.19],[1990,6.16],[1991,8.2],[1992,10.3],[1993,13.1],[1994,15],[1995,16],[1996,18.4],[1997,20.8],[1998,24],[1999,27.6],[2000,28.9]],
    "Indexed Population": [[1975,0.010545315378442414],[1976,0.010691795735303607],[1977,0.010830306636529669],[1978,0.010969554271830108],[1979,0.011115876349167017],[1980,0.011271805340928951],[1981,0.011435768242359102],[1982,0.011605049009455692],[1983,0.011775157888496353],[1984,0.011943028009729599],[1985,0.01210775048970155],[1986,0.012271108012745004],[1987,0.012435867207039599],[1988,0.012605950793991325],[1989,0.012784022601676423],[1990,0.0129707932562065],[1991,0.013164856191087397],[1992,0.01336411134706391],[1993,0.013565486143267701],[1994,0.0137665125613433],[1995,0.013967032321766418],[1996,0.014167091113471903],[1997,0.014364719417018395],[1998,0.014557591176097971],[1999,0.014744274532127542],[2000,0.014923236458168282]],
    "Indexed Energy Consumption": [[1975,0.015716243380290852],[1976,0.0165062032452332],[1977,0.017559121610173513],[1978,0.018906716149853814],[1979,0.020042588433350186],[1980,0.020764504397777595],[1981,0.022394033824053656],[1982,0.02339381830652015],[1983,0.02473219574413867],[1984,0.0260613560796954],[1985,0.027510338742055333],[1986,0.02855376891369675],[1987,0.02881347431884938],[1988,0.030618941958010678],[1989,0.03280095532551958],[1990,0.03421469612705504],[1991,0.0356547327785903],[1992,0.037686290509502424],[1993,0.04006403175020569],[1994,0.04204001577751],[1995,0.04252093163214546],[1996,0.043309807132139354],[1997,0.044390376803265026],[1998,0.0454113064022262],[1999,0.04700288305530668],[2000,0.04816532228003996]],
    "Indexed GDP": [[1975,0.13058726447531288],[1976,0.1487071929583276],[1977,0.16682712144134232],[1978,0.18494704992435704],[1979,0.20306697840737176],[1980,0.22118690689038648],[1981,0.23586851877320864],[1982,0.26052124879658917],[1983,0.28802778159812953],[1984,0.3183537340118278],[1985,0.3585820382340806],[1986,0.36067941136019804],[1987,0.39028331728785587],[1988,0.4238412873057351],[1989,0.44918168064915415],[1990,0.460321826433778],[1991,0.4928483014715995],[1992,0.5244120478613671],[1993,0.5575230367212213],[1994,0.5743020217301609],[1995,0.5846513546967405],[1996,0.6090634025581075],[1997,0.6393549718058039],[1998,0.6747352496217852],[1999,0.713553844037959],[2000,0.7427451519735937]]
  },
  {
    "name": "China",
    "region": "AS",
    "code": "CHN",
    "Population": [[1975,851410624],[1976,871825538],[1977,891587287],[1978,910328330],[1979,927807624],[1980,943877441],[1981,958635696],[1982,972412497],[1983,985695522],[1984,998877093],[1985,1011976337],[1986,1024987016],[1987,1038240611],[1988,1052132282],[1989,1066906060],[1990,1082759055],[1991,1099532095],[1992,1116665305],[1993,1133368548],[1994,1149068978],[1995,1163550191],[1996,1176963429],[1997,1189550675],[1998,1201711768],[1999,1213731655],[2000,1225679701]],
    "Arable Area": [[1975,102165],[1976,101781],[1977,101388],[1978,102029],[1979,100637],[1980,100590],[1981,100532],[1982,100316],[1983,100423],[1984,100219],[1985,100908],[1986,101199],[1987,114902],[1988,115900],[1989,125896],[1990,126996],[1991,128794],[1992,129703],[1993,131002],[1994,131397],[1995,131391],[1996,131783],[1997,132782],[1998,133479],[1999,134700],[2000,135079]],
    "Energy Consumption": [[1975,138400],[1976,152400],[1977,166800],[1978,168800],[1979,195800],[1980,203100],[1981,223400],[1982,256550],[1983,282202],[1984,300928],[1985,309507],[1986,328010],[1987,351870],[1988,377760],[1989,411770],[1990,450700],[1991,498520],[1992,546680],[1993,586530],[1994,623040],[1995,680400],[1996,759420],[1997,843842],[1998,926037],[1999,1002340],[2000,1077722]],
    "GDP Per Capita": [[1975,206],[1976,211],[1977,216],[1978,221],[1979,226],[1980,231],[1981,261],[1982,308],[1983,355],[1984,412],[1985,468],[1986,532],[1987,603],[1988,711],[1989,823],[1990,904],[1991,1021],[1992,1157],[1993,1229],[1994,1303],[1995,1454],[1996,1680],[1997,1944],[1998,2217],[1999,2518],[2000,2789]],
    "Life Expectancy (Women)": [[1975,61.98],[1976,62.46],[1977,62.94],[1978,63.42],[1979,63.9],[1980,64.38],[1981,64.86],[1982,65.34],[1983,65.82],[1984,66.3],[1985,66.42],[1986,66.54],[1987,66.66],[1988,66.78],[1989,66.9],[1990,67.28],[1991,67.66],[1992,68.04],[1993,68.42],[1994,68.8],[1995,69.1],[1996,69.39],[1997,69.7],[1998,70],[1999,70.3],[2000,70.6]],
    "Life Expectancy (Men)": [[1975,60.9],[1976,61.3],[1977,61.7],[1978,62.1],[1979,62.5],[1980,62.9],[1981,63.3],[1982,63.7],[1983,64.1],[1984,64.5],[1985,64.46],[1986,64.42],[1987,64.38],[1988,64.34],[1989,64.3],[1990,64.64],[1991,64.98],[1992,65.32],[1993,65.66],[1994,66],[1995,66.28],[1996,66.56],[1997,66.84],[1998,67.12],[1999,67.4],[2000,67.68]],
    "Life Expectancy": [[1975,61.52],[1976,61.94],[1977,62.36],[1978,62.78],[1979,63.2],[1980,63.62],[1981,64.04],[1982,64.46],[1983,64.88],[1984,65.3],[1985,65.34],[1986,65.38],[1987,65.42],[1988,65.46],[1989,65.5],[1990,65.86],[1991,66.22],[1992,66.58],[1993,66.94],[1994,67.3],[1995,67.58],[1996,67.86],[1997,68.14],[1998,68.42],[1999,68.7],[2000,68.98]],
    "Infant Mortality": [[1975,67.16],[1976,65.65],[1977,64.1],[1978,62.64],[1979,61.1],[1980,59.55],[1981,58.09],[1982,56.55],[1983,55],[1984,53.54],[1985,52],[1986,49.16],[1987,46.32],[1988,43.48],[1989,40.64],[1990,37.8],[1991,36.51],[1992,35.23],[1993,33.96],[1994,32.68],[1995,31.4],[1996,31.09],[1997,30.79],[1998,30.5],[1999,30.2],[2000,29.9]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0],[1991,0],[1992,0],[1993,0],[1994,0],[1995,0.1],[1996,0.1],[1997,0.1],[1998,0.2],[1999,0.2],[2000,0.4]],
    "Indexed Population": [[1975,0.6946436522570753],[1976,0.7112996464644885],[1977,0.7274227404374709],[1978,0.7427130670902741],[1979,0.7569739657457214],[1980,0.7700849089936915],[1981,0.7821257831208873],[1982,0.7933659146077349],[1983,0.8042031871750808],[1984,0.8149576860782163],[1985,0.8256450165360126],[1986,0.8362600891274775],[1987,0.8470733505278146],[1988,0.8584072014422632],[1989,0.8704607403790233],[1990,0.8833947842300115],[1991,0.897079468724921],[1992,0.9110580064995301],[1993,0.9246857454482719],[1994,0.9374953155073913],[1995,0.9493101583151698],[1996,0.9602536682623906],[1997,0.9705232729476361],[1998,0.980445190549827],[1999,0.9902519018710583],[2000,1]],
    "Indexed Energy Consumption": [[1975,0.03751902721620475],[1976,0.041314304535763034],[1977,0.04521801835016584],[1978,0.045760200824388454],[1979,0.053079664226393715],[1980,0.05505863025730625],[1981,0.06056178237066576],[1982,0.06954845688090555],[1983,0.07650248929528478],[1984,0.08157894380143109],[1985,0.08390463552460899],[1986,0.08892063668487948],[1987,0.09538887360235523],[1988,0.10240742573116696],[1989,0.11162723870532247],[1990,0.1221808205660656],[1991,0.13514440352472826],[1992,0.14820015750400875],[1993,0.1590031433028943],[1994,0.16890068436982808],[1995,0.1844504777305326],[1996,0.205872107287068],[1997,0.22875817170647866],[1998,0.2510405159408425],[1999,0.2717255906061464],[2000,0.29216099024207093]],
    "Indexed GDP": [[1975,0.007082932196396644],[1976,0.007254848026406272],[1977,0.0074267638564158986],[1978,0.007598679686425526],[1979,0.007770595516435153],[1980,0.00794251134644478],[1981,0.008974006326502545],[1982,0.01059001512859304],[1983,0.012206023930683537],[1984,0.014165864392793288],[1985,0.016091321688901115],[1986,0.018291844313024344],[1987,0.02073304909916105],[1988,0.024446431027369],[1989,0.028297345619584652],[1990,0.031082382065740613],[1991,0.035105212487965894],[1992,0.039781323064227755],[1993,0.04225691101636639],[1994,0.04480126530050887],[1995,0.04999312336679961],[1996,0.05776371888323477],[1997,0.0668408747077431],[1998,0.07622747902626874],[1999,0.08657681199284831],[2000,0.0958946499793701]]
  },
  {
    "name": "Denmark",
    "region": "EU",
    "code": "DNK",
    "Population": [[1975,4959189],[1976,4987826],[1977,5014364],[1978,5038466],[1979,5059864],[1980,5078660],[1981,5094844],[1982,5107958],[1983,5117433],[1984,5123029],[1985,5124597],[1986,5122764],[1987,5119055],[1988,5115502],[1989,5113678],[1990,5114105],[1991,5116737],[1992,5121853],[1993,5129576],[1994,5139947],[1995,5153137],[1996,5169106],[1997,5187348],[1998,5207139],[1999,5227861],[2000,5249337]],
    "Arable Area": [[1975,2662],[1976,2666],[1977,2668],[1978,2655],[1979,2660],[1980,2667],[1981,2648],[1982,2653],[1983,2656],[1984,2653],[1985,2651],[1986,2644],[1987,2610],[1988,2627],[1989,2614],[1990,2604],[1991,2588],[1992,2570],[1993,2555],[1994,2571],[1995,2558],[1996,2548],[1997,2542],[1998,2374],[1999,2328],[2000,2331]],
    "Energy Consumption": [[1975,16664],[1976,18306],[1977,18896],[1978,18673],[1979,19587],[1980,21758],[1981,23065],[1982,24475],[1983,25596],[1984,25916],[1985,25328],[1986,25806],[1987,26474],[1988,27552],[1989,29599],[1990,30970],[1991,32050],[1992,32452],[1993,32614],[1994,33336],[1995,34386],[1996,34641],[1997,36035],[1998,36475],[1999,37260],[2000,39462]],
    "GDP Per Capita": [[1975,3535],[1976,4355],[1977,5175],[1978,5995],[1979,6815],[1980,7635],[1981,8156],[1982,8850],[1983,9953],[1984,10874],[1985,11753],[1986,12918],[1987,13645],[1988,14738],[1989,15743],[1990,16672],[1991,17052],[1992,17860],[1993,18615],[1994,19546],[1995,20416],[1996,20828],[1997,21069],[1998,22592],[1999,23487],[2000,24394]],
    "Life Expectancy (Women)": [[1975,75.68],[1976,75.86],[1977,76.04],[1978,76.22],[1979,76.4],[1980,76.58],[1981,76.76],[1982,76.94],[1983,77.12],[1984,77.3],[1985,77.36],[1986,77.42],[1987,77.47],[1988,77.53],[1989,77.6],[1990,77.66],[1991,77.72],[1992,77.78],[1993,77.84],[1994,77.9],[1995,77.88],[1996,77.86],[1997,77.84],[1998,77.82],[1999,77.8],[2000,77.78]],
    "Life Expectancy (Men)": [[1975,70.58],[1976,70.66],[1977,70.74],[1978,70.82],[1979,70.9],[1980,70.98],[1981,71.06],[1982,71.14],[1983,71.22],[1984,71.3],[1985,71.36],[1986,71.42],[1987,71.47],[1988,71.53],[1989,71.6],[1990,71.69],[1991,71.8],[1992,71.89],[1993,72],[1994,72.1],[1995,72.17],[1996,72.25],[1997,72.34],[1998,72.42],[1999,72.5],[2000,72.58]],
    "Life Expectancy": [[1975,73.11],[1976,73.24],[1977,73.35],[1978,73.47],[1979,73.6],[1980,73.72],[1981,73.84],[1982,73.96],[1983,74.08],[1984,74.2],[1985,74.28],[1986,74.36],[1987,74.44],[1988,74.52],[1989,74.6],[1990,74.66],[1991,74.72],[1992,74.78],[1993,74.84],[1994,74.9],[1995,74.96],[1996,75.02],[1997,75.08],[1998,75.14],[1999,75.2],[2000,75.26]],
    "Infant Mortality": [[1975,13.86],[1976,13.4],[1977,12.92],[1978,12.47],[1979,12],[1980,11.52],[1981,11.07],[1982,10.6],[1983,10.12],[1984,9.67],[1985,9.2],[1986,8.95],[1987,8.71],[1988,8.48],[1989,8.24],[1990,8],[1991,8],[1992,8],[1993,8],[1994,8],[1995,8],[1996,7.7],[1997,7.4],[1998,7.1],[1999,6.8],[2000,6.5]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0.95],[1991,3.38],[1992,5.8],[1993,7.8],[1994,11.5],[1995,13.4],[1996,15.5],[1997,17.9],[1998,19.2],[1999,26.8],[2000,30.5]],
    "Indexed Population": [[1975,0.004046072555459577],[1976,0.004069436734516011],[1977,0.0040910883943895875],[1978,0.004110752585597402],[1979,0.004128210653951264],[1980,0.004143545818582501],[1981,0.004156749920752746],[1982,0.004167449290244874],[1983,0.004175179694845905],[1984,0.004179745324835073],[1985,0.004181024615010737],[1986,0.004179529118268395],[1987,0.004176503042208741],[1988,0.004173604242467584],[1989,0.004172116088589771],[1990,0.004172464466717965],[1991,0.0041746118466556865],[1992,0.004178785857203325],[1993,0.004185086850842771],[1994,0.004193548278401325],[1995,0.0042043096543050275],[1996,0.004217338343600422],[1997,0.004232221514126226],[1998,0.0042483684732248],[1999,0.004265275010865176],[2000,0.004282796717378287]],
    "Indexed Energy Consumption": [[1975,0.004517464375222803],[1976,0.004962596186559568],[1977,0.005122540016455238],[1978,0.005062086670579417],[1979,0.005309864061299151],[1980,0.0058984031370677955],[1981,0.006252719383972273],[1982,0.006634958028299214],[1983,0.006938851305100988],[1984,0.0070256005009766065],[1985,0.006866198853555158],[1986,0.006995780464894363],[1987,0.007176869411284715],[1988,0.007469105764890703],[1989,0.008024029527257547],[1990,0.008395695613337147],[1991,0.008688474149417357],[1992,0.008797452826736102],[1993,0.008841369607148134],[1994,0.009037097480342496],[1995,0.009321743279309368],[1996,0.009390871544772752],[1997,0.009768772729305911],[1998,0.009888052873634886],[1999,0.010100859494767262],[2000,0.010697802398886357]],
    "Indexed GDP": [[1975,0.12154449181680649],[1976,0.14973868793838538],[1977,0.17793288405996424],[1978,0.2061270801815431],[1979,0.234321276303122],[1980,0.26251547242470086],[1981,0.280429101911704],[1982,0.3042910191170403],[1983,0.3422156512171641],[1984,0.3738825471049374],[1985,0.4041053500206299],[1986,0.44416173841287304],[1987,0.46915830009627285],[1988,0.5067391005363774],[1989,0.5412941823683125],[1990,0.5732361435841012],[1991,0.5863017466648329],[1992,0.6140833447943886],[1993,0.6400426351258424],[1994,0.672053362673635],[1995,0.7019667170953101],[1996,0.7161325814881034],[1997,0.7244189244945675],[1998,0.7767844863154999],[1999,0.8075574198872232],[2000,0.8387429514509696]]
  },
  {
    "name": "Gambia",
    "region": "AF",
    "code": "GMB",
    "Population": [[1975,497455],[1976,514510],[1977,532494],[1978,551036],[1979,569883],[1980,589013],[1981,608563],[1982,628627],[1983,649352],[1984,670884],[1985,693208],[1986,716401],[1987,740807],[1988,766861],[1989,794870],[1990,824989],[1991,857122],[1992,891000],[1993,926218],[1994,962473],[1995,999635],[1996,1037763],[1997,1076967],[1998,1117431],[1999,1159255],[2000,1202420]],
    "Arable Area": [[1975,133],[1976,138],[1977,143],[1978,170],[1979,164],[1980,163],[1981,170],[1982,177],[1983,166],[1984,159],[1985,181],[1986,202],[1987,183],[1988,169],[1989,169],[1990,177],[1991,184],[1992,199],[1993,181],[1994,187],[1995,196],[1996,162],[1997,161],[1998,180],[1999,185],[2000,190]],
    "Energy Consumption": [[1975,13],[1976,16],[1977,18],[1978,26],[1979,27],[1980,28],[1981,31],[1982,39],[1983,41],[1984,45],[1985,45],[1986,44],[1987,45],[1988,47],[1989,48],[1990,53],[1991,58],[1992,65],[1993,61],[1994,70],[1995,70],[1996,71],[1997,73],[1998,73],[1999,74],[2000,76]],
    "GDP Per Capita": [[1975,400],[1976,452],[1977,504],[1978,556],[1979,608],[1980,660],[1981,701],[1982,785],[1983,820],[1984,924],[1985,1010],[1986,1043],[1987,1206],[1988,1164],[1989,1197],[1990,1398],[1991,1168],[1992,1222],[1993,1401],[1994,1484],[1995,1469],[1996,1456],[1997,1478],[1998,1463],[1999,1452],[2000,1467]],
    "Life Expectancy (Women)": [[1975,35.83],[1976,36.58],[1977,37.31],[1978,38.05],[1979,38.8],[1980,39.54],[1981,40.28],[1982,41.01],[1983,41.76],[1984,42.5],[1985,43.28],[1986,44.06],[1987,44.83],[1988,45.62],[1989,46.4],[1990,47.18],[1991,47.96],[1992,48.73],[1993,49.51],[1994,50.3],[1995,51],[1996,51.69],[1997,52.4],[1998,53.09],[1999,53.8],[2000,54.5]],
    "Life Expectancy (Men)": [[1975,35.07],[1976,35.75],[1977,36.44],[1978,37.12],[1979,37.8],[1980,38.48],[1981,39.16],[1982,39.84],[1983,40.52],[1984,41.2],[1985,41.92],[1986,42.64],[1987,43.36],[1988,44.08],[1989,44.8],[1990,45.5],[1991,46.19],[1992,46.9],[1993,47.59],[1994,48.3],[1995,48.96],[1996,49.62],[1997,50.28],[1998,50.94],[1999,51.6],[2000,52.26]],
    "Life Expectancy": [[1975,35.5],[1976,36.19],[1977,36.9],[1978,37.59],[1979,38.3],[1980,39],[1981,39.69],[1982,40.4],[1983,41.09],[1984,41.8],[1985,42.55],[1986,43.32],[1987,44.08],[1988,44.84],[1989,45.6],[1990,46.34],[1991,47.08],[1992,47.82],[1993,48.55],[1994,49.3],[1995,49.96],[1996,50.62],[1997,51.28],[1998,51.94],[1999,52.6],[2000,53.26]],
    "Infant Mortality": [[1975,184.14],[1976,179.1],[1977,173.96],[1978,169.13],[1979,164],[1980,158.86],[1981,154.03],[1982,148.9],[1983,143.76],[1984,138.93],[1985,133.8],[1986,129.1],[1987,124.4],[1988,119.7],[1989,115],[1990,110.3],[1991,107.62],[1992,104.94],[1993,102.26],[1994,99.58],[1995,96.9],[1996,95.48],[1997,94.06],[1998,92.64],[1999,91.22],[2000,89.8]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0],[1991,0],[1992,0],[1993,0],[1994,0],[1995,0],[1996,0],[1997,0],[1998,0],[1999,0.1],[2000,0.2]],
    "Indexed Population": [[1975,0.0004058605193462366],[1976,0.00041977524762809137],[1977,0.00043444792270407354],[1978,0.0004495758553808341],[1979,0.0004649526295777334],[1980,0.0004805602960703679],[1981,0.0004965106295743409],[1982,0.0005128803222302855],[1983,0.00052978930749217],[1984,0.0005473567029401264],[1985,0.000565570270466607],[1986,0.0005844928323570237],[1987,0.0006044050492111397],[1988,0.0006256618261478412],[1989,0.00064851363643494],[1990,0.0006730869405170969],[1991,0.0006993034145060056],[1992,0.0007269435883396424],[1993,0.0007556770331142165],[1994,0.0007852565390572623],[1995,0.000815576042570032],[1996,0.0008466836802088803],[1997,0.0008786691980958246],[1998,0.0009116827170167845],[1999,0.000945805824355412],[2000,0.0009810230185088135]],
    "Indexed Energy Consumption": [[1975,0.0000035241860824469778],[1976,0.000004337459793780896],[1977,0.000004879642268003508],[1978,0.0000070483721648939556],[1979,0.000007319463402005262],[1980,0.000007590554639116568],[1981,0.000008403828350450486],[1982,0.000010572558247340933],[1983,0.000011114740721563546],[1984,0.00001219910567000877],[1985,0.00001219910567000877],[1986,0.000011928014432897463],[1987,0.00001219910567000877],[1988,0.000012741288144231381],[1989,0.000013012379381342688],[1990,0.000014367835566899218],[1991,0.000015723291752455747],[1992,0.00001762093041223489],[1993,0.000016536565463789666],[1994,0.00001897638659779142],[1995,0.00001897638659779142],[1996,0.000019247477834902726],[1997,0.000019789660309125337],[1998,0.000019789660309125337],[1999,0.000020060751546236642],[2000,0.000020602934020459256]],
    "Indexed GDP": [[1975,0.013753266400770183],[1976,0.015541191032870307],[1977,0.017329115664970432],[1978,0.019117040297070554],[1979,0.02090496492917068],[1980,0.0226928895612708],[1981,0.024102599367349747],[1982,0.026990785311511483],[1983,0.028194196121578877],[1984,0.03177004538577912],[1985,0.03472699766194471],[1986,0.035861642140008254],[1987,0.0414660981983221],[1988,0.04002200522624123],[1989,0.04115664970430477],[1990,0.04806766607069179],[1991,0.04015953789024893],[1992,0.04201622885435291],[1993,0.04817081556869757],[1994,0.05102461834685738],[1995,0.050508870856828494],[1996,0.050061889698803465],[1997,0.050818319350845825],[1998,0.05030257186081694],[1999,0.049924357034795766],[2000,0.05044010452482465]]
  },
  {
    "name": "Hungary",
    "region": "EU",
    "code": "HUN",
    "Population": [[1975,10375077],[1976,10412747],[1977,10450803],[1978,10490380],[1979,10531820],[1980,10575974],[1981,10621216],[1982,10662416],[1983,10692745],[1984,10707472],[1985,10705147],[1986,10687680],[1987,10657974],[1988,10620517],[1989,10579093],[1990,10533787],[1991,10484994],[1992,10437192],[1993,10395900],[1994,10364840],[1995,10346394],[1996,10339149],[1997,10338252],[1998,10336581],[1999,10328967],[2000,10313830]],
    "Arable Area": [[1975,5578],[1976,5565],[1977,5555],[1978,5503],[1979,5495],[1980,5471],[1981,5422],[1982,5388],[1983,5354],[1984,5333],[1985,5317],[1986,5299],[1987,5292],[1988,5289],[1989,5293],[1990,5289],[1991,5289],[1992,5287],[1993,5287],[1994,5288],[1995,5287],[1996,4972],[1997,4973],[1998,4974],[1999,5031],[2000,5036]],
    "Energy Consumption": [[1975,19340],[1976,20713],[1977,22305],[1978,23644],[1979,24596],[1980,26166],[1981,27845],[1982,30095],[1983,30645],[1984,31262],[1985,32203],[1986,33516],[1987,34866],[1988,36572],[1989,37604],[1990,38579],[1991,40362],[1992,40525],[1993,40672],[1994,39538],[1995,37342],[1996,35155],[1997,35388],[1998,35548],[1999,36422],[2000,37288]],
    "GDP Per Capita": [[1975,2102],[1976,2366],[1977,2630],[1978,2894],[1979,3158],[1980,3422],[1981,3911],[1982,4170],[1983,4868],[1984,5274],[1985,6056],[1986,6696],[1987,6945],[1988,7467],[1989,7708],[1990,8032],[1991,8606],[1992,8922],[1993,9463],[1994,9470],[1995,8605],[1996,8477],[1997,8604],[1998,9086],[1999,9462],[2000,9844]],
    "Life Expectancy (Women)": [[1975,71.89],[1976,72],[1977,72.1],[1978,72.2],[1979,72.3],[1980,72.39],[1981,72.5],[1982,72.6],[1983,72.7],[1984,72.8],[1985,72.84],[1986,72.88],[1987,72.92],[1988,72.96],[1989,73],[1990,73.12],[1991,73.24],[1992,73.36],[1993,73.47],[1994,73.6],[1995,73.66],[1996,73.72],[1997,73.78],[1998,73.84],[1999,73.9],[2000,73.96]],
    "Life Expectancy (Men)": [[1975,66.66],[1976,66.62],[1977,66.58],[1978,66.54],[1979,66.5],[1980,66.46],[1981,66.42],[1982,66.38],[1983,66.34],[1984,66.3],[1985,66.1],[1986,65.89],[1987,65.7],[1988,65.5],[1989,65.3],[1990,65.34],[1991,65.38],[1992,65.42],[1993,65.46],[1994,65.5],[1995,65.36],[1996,65.22],[1997,65.08],[1998,64.94],[1999,64.8],[2000,64.66]],
    "Life Expectancy": [[1975,69.21],[1976,69.24],[1977,69.25],[1978,69.28],[1979,69.3],[1980,69.32],[1981,69.34],[1982,69.36],[1983,69.38],[1984,69.4],[1985,69.34],[1986,69.28],[1987,69.22],[1988,69.16],[1989,69.1],[1990,69.17],[1991,69.25],[1992,69.34],[1993,69.42],[1994,69.5],[1995,69.5],[1996,69.5],[1997,69.5],[1998,69.5],[1999,69.5],[2000,69.5]],
    "Infant Mortality": [[1975,39.03],[1976,37.8],[1977,36.54],[1978,35.35],[1979,34.1],[1980,32.84],[1981,31.65],[1982,30.4],[1983,29.14],[1984,27.95],[1985,26.7],[1986,25.43],[1987,24.18],[1988,22.91],[1989,21.65],[1990,20.4],[1991,19.74],[1992,19.08],[1993,18.42],[1994,17.76],[1995,17.1],[1996,16.34],[1997,15.58],[1998,14.82],[1999,14.06],[2000,13.3]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0.12],[1991,0.42],[1992,0.8],[1993,0.9],[1994,1],[1995,1.2],[1996,1.9],[1997,2.7],[1998,3.4],[1999,3.9],[2000,4.4]],
    "Indexed Population": [[1975,0.008464753876184167],[1976,0.008495487843605888],[1977,0.008526536738328507],[1978,0.008558826577156474],[1979,0.008592636388941878],[1980,0.008628660482319597],[1981,0.008665572246431451],[1982,0.008699186248496091],[1983,0.008723930886083916],[1984,0.008735946260074352],[1985,0.008734049353404442],[1986,0.00871979848510194],[1987,0.008695562136914267],[1988,0.008665001950619724],[1989,0.008631205192815704],[1990,0.008594241212778313],[1991,0.008554432280672975],[1992,0.008515431879539629],[1993,0.00848174281708203],[1994,0.008456401775719708],[1995,0.008441352166931253],[1996,0.008435441160985662],[1997,0.008434709322154304],[1998,0.008433345996973478],[1999,0.008427133933582213],[2000,0.008414784051318803]],
    "Indexed Energy Consumption": [[1975,0.0052429045257326575],[1976,0.005615112794286481],[1977,0.00604669004376768],[1978,0.006409681210259719],[1979,0.0066677600679896825],[1980,0.007093373310254432],[1981,0.007548535497364316],[1982,0.008158490780864754],[1983,0.008307590961275972],[1984,0.008474854254573647],[1985,0.008729951108695387],[1986,0.009085893903022531],[1987,0.009451867073122795],[1988,0.009914348723634683],[1989,0.010194114880333551],[1990,0.010458428836517073],[1991,0.010941784512286532],[1992,0.010985972383935675],[1993,0.011025822795791037],[1994,0.010718405332906817],[1995,0.01012308897621039],[1996,0.009530212440647962],[1997,0.009593376698894896],[1998,0.009636751296832705],[1999,0.009873685038067986],[2000,0.010108450049406378]],
    "Indexed GDP": [[1975,0.07227341493604732],[1976,0.08135057076055563],[1977,0.09042772658506396],[1978,0.09950488240957227],[1979,0.1085820382340806],[1980,0.11765919405858892],[1981,0.13447256223353046],[1982,0.14337780222802915],[1983,0.1673772520973731],[1984,0.18133681749415487],[1985,0.20822445330766057],[1986,0.23022967954889287],[1987,0.2387910878833723],[1988,0.2567391005363774],[1989,0.2650254435428414],[1990,0.27616558932746527],[1991,0.29590152661257046],[1992,0.3067666070691789],[1993,0.3253678998762206],[1994,0.32560858203823406],[1995,0.29586714344656856],[1996,0.2914660981983221],[1997,0.29583276028056665],[1998,0.3124054462934947],[1999,0.32533351671021865],[2000,0.3384678861229542]]
  },
  {
    "name": "India",
    "region": "AS",
    "code": "IND",
    "Population": [[1975,561427382],[1976,573901785],[1977,586762819],[1978,600044316],[1979,613767233],[1980,627941825],[1981,642552661],[1982,657562064],[1983,672916902],[1984,688575418],[1985,704519770],[1986,720749252],[1987,737259342],[1988,754050696],[1989,771120552],[1990,788442870],[1991,805998670],[1992,823799168],[1993,841864119],[1994,860195242],[1995,878789217],[1996,897599210],[1997,916529257],[1998,935455492],[1999,954281733],[2000,972968477]],
    "Arable Area": [[1975,164440],[1976,165260],[1977,166530],[1978,167230],[1979,168010],[1980,168189],[1981,168260],[1982,168635],[1983,168423],[1984,168255],[1985,168391],[1986,168675],[1987,168520],[1988,169078],[1989,169015],[1990,169250],[1991,169770],[1992,169310],[1993,169485],[1994,169438],[1995,169340],[1996,169270],[1997,169737],[1998,169790],[1999,169750],[2000,169530]],
    "Energy Consumption": [[1975,66383],[1976,70508],[1977,72785],[1978,76665],[1979,85908],[1980,95591],[1981,98903],[1982,110086],[1983,112786],[1984,119223],[1985,131036],[1986,140227],[1987,150909],[1988,169100],[1989,183299],[1990,201382],[1991,219838],[1992,242508],[1993,269961],[1994,290815],[1995,317084],[1996,333919],[1997,357781],[1998,386980],[1999,419565],[2000,438372]],
    "GDP Per Capita": [[1975,344],[1976,366],[1977,388],[1978,410],[1979,432],[1980,454],[1981,506],[1982,560],[1983,560],[1984,636],[1985,726],[1986,784],[1987,855],[1988,905],[1989,965],[1990,1013],[1991,1064],[1992,1188],[1993,1287],[1994,1388],[1995,1424],[1996,1505],[1997,1583],[1998,1704],[1999,1836],[2000,1971]],
    "Life Expectancy (Women)": [[1975,46.88],[1976,47.66],[1977,48.44],[1978,49.22],[1979,50],[1980,50.78],[1981,51.56],[1982,52.33],[1983,53.12],[1984,53.9],[1985,54.44],[1986,54.98],[1987,55.52],[1988,56.06],[1989,56.6],[1990,57.04],[1991,57.48],[1992,57.92],[1993,58.36],[1994,58.8],[1995,59.19],[1996,59.59],[1997,60],[1998,60.4],[1999,60.8],[2000,61.19]],
    "Life Expectancy (Men)": [[1975,48.83],[1976,49.48],[1977,50.12],[1978,50.76],[1979,51.4],[1980,52.04],[1981,52.68],[1982,53.32],[1983,53.96],[1984,54.6],[1985,55.04],[1986,55.48],[1987,55.92],[1988,56.36],[1989,56.8],[1990,57.14],[1991,57.48],[1992,57.82],[1993,58.16],[1994,58.5],[1995,58.78],[1996,59.06],[1997,59.33],[1998,59.62],[1999,59.9],[2000,60.18]],
    "Life Expectancy": [[1975,47.72],[1976,48.44],[1977,49.16],[1978,49.88],[1979,50.6],[1980,51.32],[1981,52.04],[1982,52.76],[1983,53.48],[1984,54.2],[1985,54.68],[1986,55.16],[1987,55.64],[1988,56.12],[1989,56.6],[1990,56.98],[1991,57.36],[1992,57.74],[1993,58.12],[1994,58.5],[1995,58.84],[1996,59.18],[1997,59.52],[1998,59.86],[1999,60.2],[2000,60.54]],
    "Infant Mortality": [[1975,125.07],[1976,123],[1977,120.89],[1978,118.9],[1979,116.8],[1980,114.69],[1981,112.7],[1982,110.6],[1983,108.49],[1984,106.5],[1985,104.4],[1986,102.46],[1987,100.52],[1988,98.58],[1989,96.64],[1990,94.7],[1991,92.9],[1992,91.1],[1993,89.3],[1994,87.5],[1995,85.7],[1996,84],[1997,82.3],[1998,80.6],[1999,78.9],[2000,77.2]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0],[1991,0],[1992,0],[1993,0],[1994,0],[1995,0],[1996,0],[1997,0.1],[1998,0.1],[1999,0.1],[2000,0.2]],
    "Indexed Population": [[1975,0.45805391207992274],[1976,0.46823145111383385],[1977,0.4787244322650327],[1978,0.4895604581771564],[1979,0.5007566271181968],[1980,0.5123213058743477],[1981,0.5242419046964375],[1982,0.5364876839059277],[1983,0.5490152944941363],[1984,0.5617906680172718],[1985,0.574799247654343],[1986,0.5880404573984211],[1987,0.6015106078680176],[1988,0.6152102342763691],[1989,0.6291370831799392],[1990,0.6432699092240249],[1991,0.6575932271232091],[1992,0.6721161877184421],[1993,0.6868549085973644],[1994,0.7018107922471011],[1995,0.7169811299665148],[1996,0.732327711120346],[1997,0.7477722411917467],[1998,0.7632136611520827],[1999,0.7785734986240096],[2000,0.7938195241433634]],
    "Indexed Energy Consumption": [[1975,0.017995849593159825],[1976,0.019114100946243964],[1977,0.019731375693146407],[1978,0.020783209693138273],[1979,0.023288905997758076],[1980,0.02591388244670685],[1981,0.0268117366240195],[1982,0.029843349928635233],[1983,0.030575296268835758],[1984,0.032320310562121236],[1985,0.03552271134611709],[1986,0.038014310906407105],[1987,0.04091010750123008],[1988,0.04584152819552184],[1989,0.04969075267126528],[1990,0.05459289551194903],[1991,0.05959615538407529],[1992,0.0657417937293886],[1993,0.07318406146180528],[1994,0.07883739812052445],[1995,0.08595869382820134],[1996,0.09052251480497019],[1997,0.09699129390492017],[1998,0.10490688693733319],[1999,0.1137403948986051],[2000,0.11883880779495744]],
    "Indexed GDP": [[1975,0.011827809104662357],[1976,0.012584238756704717],[1977,0.013340668408747078],[1978,0.014097098060789438],[1979,0.014853527712831797],[1980,0.015609957364874158],[1981,0.01739788199697428],[1982,0.019254572961078256],[1983,0.019254572961078256],[1984,0.02186769357722459],[1985,0.024962178517397883],[1986,0.02695640214550956],[1987,0.029397606931646267],[1988,0.03111676523174254],[1989,0.03317975519185807],[1990,0.03483014715995049],[1991,0.03658368862604869],[1992,0.04084720121028744],[1993,0.044251134644478066],[1994,0.04772383441067254],[1995,0.048961628386741854],[1996,0.05174666483289781],[1997,0.054428551781047996],[1998,0.05858891486728098],[1999,0.06312749277953514],[2000,0.06776922018979507]]
  },
  {
    "name": "Iceland",
    "region": "EU",
    "code": "ISL",
    "Population": [[1975,206821],[1976,209722],[1977,212673],[1978,215485],[1979,218031],[1980,220260],[1981,222238],[1982,224096],[1983,226025],[1984,228160],[1985,230543],[1986,233131],[1987,235861],[1988,238641],[1989,241398],[1990,244123],[1991,246836],[1992,249524],[1993,252178],[1994,254793],[1995,257360],[1996,259882],[1997,262386],[1998,264908],[1999,267478],[2000,270096]],
    "Arable Area": [[1975,7],[1976,7],[1977,8],[1978,8],[1979,8],[1980,8],[1981,8],[1982,8],[1983,8],[1984,8],[1985,8],[1986,8],[1987,8],[1988,7],[1989,7],[1990,7],[1991,7],[1992,7],[1993,7],[1994,7],[1995,7],[1996,6],[1997,6],[1998,6],[1999,6],[2000,6]],
    "Energy Consumption": [[1975,1621],[1976,1795],[1977,2390],[1978,2374],[1979,2330],[1980,2426],[1981,2607],[1982,2679],[1983,2959],[1984,3155],[1985,3329],[1986,3758],[1987,3960],[1988,4125],[1989,4044],[1990,4114],[1991,4210],[1992,4482],[1993,4541],[1994,4510],[1995,4494],[1996,4546],[1997,4727],[1998,4780],[1999,4981],[2000,5123]],
    "GDP Per Capita": [[1975,3324],[1976,3999],[1977,4674],[1978,5349],[1979,6024],[1980,6699],[1981,7651],[1982,8635],[1983,9728],[1984,11135],[1985,12619],[1986,13582],[1987,13750],[1988,14823],[1989,15565],[1990,16649],[1991,18157],[1992,18516],[1993,19270],[1994,20062],[1995,20377],[1996,19839],[1997,20283],[1998,21514],[1999,21745],[2000,23024]],
    "Life Expectancy (Women)": [[1975,75.88],[1976,76.26],[1977,76.64],[1978,77.02],[1979,77.4],[1980,77.78],[1981,78.16],[1982,78.54],[1983,78.92],[1984,79.3],[1985,79.39],[1986,79.5],[1987,79.6],[1988,79.7],[1989,79.8],[1990,79.89],[1991,80],[1992,80.1],[1993,80.2],[1994,80.3],[1995,80.39],[1996,80.5],[1997,80.6],[1998,80.7],[1999,80.8],[2000,80.89]],
    "Life Expectancy (Men)": [[1975,69.8],[1976,70.2],[1977,70.6],[1978,71],[1979,71.4],[1980,71.8],[1981,72.2],[1982,72.6],[1983,73],[1984,73.4],[1985,73.5],[1986,73.6],[1987,73.7],[1988,73.8],[1989,73.9],[1990,74.18],[1991,74.46],[1992,74.74],[1993,75.02],[1994,75.3],[1995,75.5],[1996,75.7],[1997,75.89],[1998,76.1],[1999,76.3],[2000,76.5]],
    "Life Expectancy": [[1975,72.7],[1976,73.1],[1977,73.5],[1978,73.89],[1979,74.3],[1980,74.7],[1981,75.1],[1982,75.5],[1983,75.89],[1984,76.3],[1985,76.39],[1986,76.5],[1987,76.6],[1988,76.7],[1989,76.8],[1990,77],[1991,77.2],[1992,77.39],[1993,77.6],[1994,77.8],[1995,77.96],[1996,78.11],[1997,78.28],[1998,78.44],[1999,78.6],[2000,78.75]],
    "Infant Mortality": [[1975,13.63],[1976,13.14],[1977,12.65],[1978,12.19],[1979,11.7],[1980,11.2],[1981,10.74],[1982,10.25],[1983,9.75],[1984,9.29],[1985,8.8],[1986,8.32],[1987,7.84],[1988,7.36],[1989,6.88],[1990,6.4],[1991,6.32],[1992,6.24],[1993,6.16],[1994,6.08],[1995,6],[1996,5.78],[1997,5.56],[1998,5.34],[1999,5.12],[2000,4.9]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0],[1991,0],[1992,0],[1993,0.57],[1994,3.9],[1995,7.7],[1996,11.4],[1997,13.2],[1998,16.9],[1999,20.5],[2000,26]],
    "Indexed Population": [[1975,0.00016873984274297775],[1976,0.00017110669274272332],[1977,0.0001735143364342949],[1978,0.00017580857366259018],[1979,0.00017788578845037101],[1980,0.00017970437123197492],[1981,0.00018131816968061217],[1982,0.000182834063268867],[1983,0.0001844078838995148],[1984,0.00018614977454048577],[1985,0.00018809400189291378],[1986,0.00019020548338182847],[1987,0.00019243281895552907],[1988,0.00019470094822105567],[1989,0.00019695031238834232],[1990,0.0001991735685928603],[1991,0.00020138703431134004],[1992,0.00020358010318390678],[1993,0.00020574543234603182],[1994,0.00020787894242853256],[1995,0.00020997329056688033],[1996,0.00021203092438258468],[1997,0.00021407387246923166],[1998,0.000216131506284936],[1999,0.00021822830204479334],[2000,0.00022036425974880365]],
    "Indexed Energy Consumption": [[1975,0.00043943889535742704],[1976,0.0004866087706147943],[1977,0.0006479080566960213],[1978,0.0006435705969022404],[1979,0.000631642582469343],[1980,0.0006576673412320283],[1981,0.0007067348551491748],[1982,0.0007262534242211887],[1983,0.0008021589706123545],[1984,0.0008552928530861704],[1985,0.0009024627283435376],[1986,0.0010187608690642878],[1987,0.0010735212989607717],[1988,0.0011182513530841372],[1989,0.0010962929628781214],[1990,0.001115269349475913],[1991,0.0011412941082385982],[1992,0.0012150309247328734],[1993,0.0012310253077224406],[1994,0.0012226214793719901],[1995,0.001218284019578209],[1996,0.0012323807639079971],[1997,0.0012814482778251435],[1998,0.0012958161133920427],[1999,0.0013503054520514152],[2000,0.0013888004077212206]],
    "Indexed GDP": [[1975,0.11428964379040021],[1976,0.1374982808416999],[1977,0.1607069178929996],[1978,0.18391555494429926],[1979,0.20712419199559895],[1980,0.23033282904689864],[1981,0.2630656030807317],[1982,0.29689863842662634],[1983,0.33447943886673087],[1984,0.38285655343144],[1985,0.4338811717782973],[1986,0.4669921606381516],[1987,0.47276853252647505],[1988,0.509661669646541],[1989,0.5351739788199698],[1990,0.572445330766057],[1991,0.6242951450969605],[1992,0.6366387016916518],[1993,0.6625636088571035],[1994,0.6897950763306285],[1995,0.700625773621235],[1996,0.6821276303121991],[1997,0.697393756017054],[1998,0.7397194333654243],[1999,0.7476619447118691],[2000,0.7916380140283318]]
  },
  {
    "name": "Israel",
    "region": "AS",
    "code": "ISR",
    "Population": [[1975,2981178],[1976,3072749],[1977,3169216],[1978,3265615],[1979,3358251],[1980,3446529],[1981,3531387],[1982,3612531],[1983,3689964],[1984,3763901],[1985,3834951],[1986,3903752],[1987,3970806],[1988,4036715],[1989,4102601],[1990,4167117],[1991,4232020],[1992,4305161],[1993,4396831],[1994,4513700],[1995,4659310],[1996,4829690],[1997,5014633],[1998,5199614],[1999,5373900],[2000,5534067]],
    "Arable Area": [[1975,411],[1976,411],[1977,421],[1978,427],[1979,422],[1980,412],[1981,413],[1982,413],[1983,413],[1984,413],[1985,418],[1986,420],[1987,407],[1988,419],[1989,420],[1990,428],[1991,428],[1992,428],[1993,427],[1994,431],[1995,433],[1996,432],[1997,432],[1998,434],[1999,428],[2000,419]],
    "Energy Consumption": [[1975,7606],[1976,8438],[1977,8663],[1978,9086],[1979,9626],[1980,10255],[1981,10973],[1982,11711],[1983,12251],[1984,12363],[1985,12931],[1986,13625],[1987,14384],[1988,14710],[1989,15131],[1990,15630],[1991,17074],[1992,18991],[1993,20087],[1994,20507],[1995,21154],[1996,24070],[1997,25370],[1998,27581],[1999,29474],[2000,31531]],
    "GDP Per Capita": [[1975,4456],[1976,4716],[1977,4976],[1978,5236],[1979,5496],[1980,5756],[1981,5918],[1982,6534],[1983,7405],[1984,8380],[1985,9350],[1986,9971],[1987,10551],[1988,11045],[1989,11518],[1990,12099],[1991,13067],[1992,13471],[1993,13873],[1994,14891],[1995,15548],[1996,16253],[1997,17020],[1998,18091],[1999,19510],[2000,20122]],
    "Life Expectancy (Women)": [[1975,72.1],[1976,72.39],[1977,72.7],[1978,73],[1979,73.3],[1980,73.6],[1981,73.89],[1982,74.2],[1983,74.5],[1984,74.8],[1985,75.08],[1986,75.36],[1987,75.64],[1988,75.92],[1989,76.2],[1990,76.44],[1991,76.68],[1992,76.92],[1993,77.16],[1994,77.4],[1995,77.7],[1996,78],[1997,78.3],[1998,78.6],[1999,78.9],[2000,79.2]],
    "Life Expectancy (Men)": [[1975,69.05],[1976,69.32],[1977,69.57],[1978,69.83],[1979,70.1],[1980,70.36],[1981,70.62],[1982,70.88],[1983,71.14],[1984,71.4],[1985,71.68],[1986,71.96],[1987,72.24],[1988,72.52],[1989,72.8],[1990,73],[1991,73.2],[1992,73.39],[1993,73.6],[1994,73.8],[1995,74.08],[1996,74.36],[1997,74.64],[1998,74.92],[1999,75.2],[2000,75.48]],
    "Life Expectancy": [[1975,70.39],[1976,70.69],[1977,71],[1978,71.3],[1979,71.6],[1980,71.89],[1981,72.19],[1982,72.5],[1983,72.8],[1984,73.1],[1985,73.38],[1986,73.66],[1987,73.94],[1988,74.22],[1989,74.5],[1990,74.72],[1991,74.94],[1992,75.16],[1993,75.38],[1994,75.6],[1995,75.86],[1996,76.12],[1997,76.38],[1998,76.64],[1999,76.9],[2000,77.16]],
    "Infant Mortality": [[1975,24.56],[1976,23.9],[1977,23.22],[1978,22.58],[1979,21.9],[1980,21.22],[1981,20.58],[1982,19.9],[1983,19.22],[1984,18.58],[1985,17.9],[1986,17.16],[1987,16.41],[1988,15.68],[1989,14.94],[1990,14.2],[1991,13.47],[1992,12.76],[1993,12.04],[1994,11.32],[1995,10.6],[1996,10.24],[1997,9.88],[1998,9.52],[1999,9.16],[2000,8.8]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0.23],[1988,1.09],[1989,1.96],[1990,2.8],[1991,3.62],[1992,4.4],[1993,5.4],[1994,6.3],[1995,7],[1996,7.7],[1997,8.3],[1998,9.8],[1999,13.3],[2000,15.6]],
    "Indexed Population": [[1975,0.0024322651322100995],[1976,0.0025069755152941054],[1977,0.002585680416681715],[1978,0.0026643298386484415],[1979,0.0027399091273683416],[1980,0.002811932837908686],[1981,0.002881166259928131],[1982,0.0029473695265187392],[1983,0.0030105450853020205],[1984,0.0030708683491528265],[1985,0.003128836185237598],[1986,0.0031849691210640357],[1987,0.003239676725298072],[1988,0.0032934501539892925],[1989,0.003347204817582273],[1990,0.0033998417340192206],[1991,0.0034527943936309017],[1992,0.0035124682219078375],[1993,0.003587259376501659],[1994,0.0036826097359019573],[1995,0.0038014091252376874],[1996,0.003940417709504027],[1997,0.004091307864451612],[1998,0.004242229022604985],[1999,0.0043844244100767725],[2000,0.004515100474850729]],
    "Indexed Energy Consumption": [[1975,0.0020619199494685933],[1976,0.0022874678587452],[1977,0.0023484633870952437],[1978,0.0024631349803933265],[1979,0.0026095242484334316],[1980,0.002780040636576443],[1981,0.0029746841448223607],[1982,0.0031747494778105044],[1983,0.00332113874585061],[1984,0.003351500964407076],[1985,0.0035054807870862977],[1986,0.003693618105641544],[1987,0.0038993763546090253],[1988,0.003987752097907311],[1989,0.004101881508731171],[1990,0.004237156036049712],[1991,0.004628611782438438],[1992,0.005148293683980812],[1993,0.0054454096798548035],[1994,0.005559267999441552],[1995,0.005734664029852567],[1996,0.006525166077269135],[1997,0.006877584685513833],[1998,0.007476967410766931],[1999,0.007990143122618632],[2000,0.00854777779735659]],
    "Indexed GDP": [[1975,0.15321138770457984],[1976,0.16215101086508046],[1977,0.17109063402558108],[1978,0.1800302571860817],[1979,0.18896988034658233],[1980,0.19790950350708295],[1981,0.20347957639939485],[1982,0.22465960665658094],[1983,0.254607344244258],[1984,0.28813093109613536],[1985,0.321482602118003],[1986,0.3428345482051987],[1987,0.3627767844863155],[1988,0.3797620684912667],[1989,0.39602530601017744],[1990,0.4160019254572961],[1991,0.44928483014716],[1992,0.46317562921193783],[1993,0.4769976619447119],[1994,0.5119997249346719],[1995,0.534589464997937],[1996,0.5588295970292945],[1997,0.5852014853527713],[1998,0.6220258561408335],[1999,0.6708155686975656],[2000,0.6918580662907441]]
  },
  {
    "name": "Liberia",
    "region": "AF",
    "code": "LBR",
    "Population": [[1975,1427168],[1976,1469158],[1977,1512670],[1978,1557914],[1979,1605036],[1980,1653089],[1981,1701806],[1982,1752706],[1983,1807890],[1984,1868259],[1985,1935410],[1986,2007231],[1987,2076455],[1988,2133303],[1989,2171122],[1990,2189305],[1991,2191352],[1992,2180175],[1993,2160323],[1994,2136718],[1995,2106120],[1996,2071562],[1997,2051573],[1998,2070347],[1999,2143442],[2000,2281842]],
    "Arable Area": [[1975,571],[1976,571],[1977,571],[1978,571],[1979,571],[1980,571],[1981,576],[1982,576],[1983,576],[1984,576],[1985,576],[1986,580],[1987,585],[1988,586],[1989,588],[1990,597],[1991,603],[1992,613],[1993,615],[1994,615],[1995,605],[1996,605],[1997,585],[1998,585],[1999,585],[2000,585]],
    "Energy Consumption": [[1975,650],[1976,846],[1977,834],[1978,860],[1979,853],[1980,883],[1981,893],[1982,841],[1983,900],[1984,890],[1985,837],[1986,841],[1987,829],[1988,862],[1989,862],[1990,849],[1991,825],[1992,834],[1993,818],[1994,565],[1995,450],[1996,460],[1997,480],[1998,480],[1999,486],[2000,488]],
    "GDP Per Capita": [[1975,383],[1976,385],[1977,419],[1978,446],[1979,498],[1980,495],[1981,549],[1982,549],[1983,527],[1984,506],[1985,491],[1986,480],[1987,507],[1988,546],[1989,571],[1990,284],[1991,262],[1992,171],[1993,124],[1994,102],[1995,101],[1996,113],[1997,177],[1998,200],[1999,225],[2000,224]],
    "Life Expectancy (Women)": [[1975,42.46],[1976,42.72],[1977,42.98],[1978,43.24],[1979,43.5],[1980,43.76],[1981,44.01],[1982,44.28],[1983,44.54],[1984,44.8],[1985,45.04],[1986,45.28],[1987,45.51],[1988,45.76],[1989,46],[1990,46.24],[1991,46.48],[1992,46.72],[1993,46.96],[1994,47.2],[1995,46.16],[1996,45.12],[1997,44.08],[1998,43.04],[1999,42],[2000,40.96]],
    "Life Expectancy (Men)": [[1975,41],[1976,41.19],[1977,41.4],[1978,41.59],[1979,41.8],[1980,42],[1981,42.19],[1982,42.4],[1983,42.59],[1984,42.8],[1985,42.98],[1986,43.16],[1987,43.34],[1988,43.52],[1989,43.7],[1990,43.94],[1991,44.18],[1992,44.42],[1993,44.66],[1994,44.9],[1995,43.83],[1996,42.78],[1997,41.72],[1998,40.66],[1999,39.6],[2000,38.54]],
    "Life Expectancy": [[1975,41.64],[1976,41.88],[1977,42.12],[1978,42.36],[1979,42.6],[1980,42.84],[1981,43.08],[1982,43.32],[1983,43.55],[1984,43.8],[1985,44.01],[1986,44.23],[1987,44.46],[1988,44.68],[1989,44.9],[1990,45.12],[1991,45.33],[1992,45.56],[1993,45.78],[1994,46],[1995,44.96],[1996,43.92],[1997,42.87],[1998,41.83],[1999,40.8],[2000,39.76]],
    "Infant Mortality": [[1975,170.03],[1976,168.8],[1977,167.54],[1978,166.35],[1979,165.1],[1980,163.84],[1981,162.65],[1982,161.39],[1983,160.14],[1984,158.95],[1985,157.7],[1986,156.17],[1987,154.66],[1988,153.14],[1989,151.62],[1990,150.1],[1991,147.78],[1992,145.46],[1993,143.14],[1994,140.82],[1995,138.5],[1996,146.62],[1997,154.74],[1998,162.85],[1999,170.98],[2000,179.1]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0],[1991,0],[1992,0],[1993,0],[1994,0],[1995,0],[1996,0],[1997,0],[1998,0],[1999,0],[2000,0]],
    "Indexed Population": [[1975,0.0011643890315190919],[1976,0.0011986475739145818],[1977,0.0012341478762892557],[1978,0.001271061272148783],[1979,0.0013095068790732955],[1980,0.0013487120645396084],[1981,0.001388458990233371],[1982,0.0014299869685122574],[1983,0.001475010150306797],[1984,0.0015242636379436947],[1985,0.0015790503819398736],[1986,0.0016376472567526024],[1987,0.001694125307211888],[1988,0.0017405061030703974],[1989,0.001771361635693761],[1990,0.0017861966696632108],[1991,0.001787866763406568],[1992,0.0017787477415357798],[1993,0.0017625510141331777],[1994,0.0017432923122221145],[1995,0.0017183282045722646],[1996,0.001690133236529794],[1997,0.0016738247344115884],[1998,0.0016891419498184215],[1999,0.0017487782478988775],[2000,0.0018616951868732955]],
    "Indexed Energy Consumption": [[1975,0.0001762093041223489],[1976,0.00022934318659616486],[1977,0.0002260900917508292],[1978,0.00023313846391572317],[1979,0.00023124082525594403],[1980,0.0002393735623692832],[1981,0.00024208447474039624],[1982,0.00022798773041060835],[1983,0.0002439821134001754],[1984,0.00024127120102906234],[1985,0.00022690336546216312],[1986,0.00022798773041060835],[1987,0.00022473463556527267],[1988,0.00023368064638994577],[1989,0.00023368064638994577],[1990,0.0002301564603074988],[1991,0.00022365027061682744],[1992,0.0002260900917508292],[1993,0.0002217526319570483],[1994,0.00015316654896788788],[1995,0.0001219910567000877],[1996,0.00012470196907120076],[1997,0.00013012379381342688],[1998,0.00013012379381342688],[1999,0.00013175034123609472],[2000,0.00013229252371031733]],
    "Indexed GDP": [[1975,0.013168752578737451],[1976,0.0132375189107413],[1977,0.014406546554806766],[1978,0.015334892036858753],[1979,0.017122816668958877],[1980,0.0170196671709531],[1981,0.018876358135057076],[1982,0.018876358135057076],[1983,0.018119928483014715],[1984,0.01739788199697428],[1985,0.0168821345069454],[1986,0.01650391968092422],[1987,0.017432265162976208],[1988,0.0187732086370513],[1989,0.019632787787099436],[1990,0.00976481914454683],[1991,0.00900838949250447],[1992,0.005879521386329253],[1993,0.004263512584238757],[1994,0.003507082932196397],[1995,0.0034726997661944712],[1996,0.0038852977582175766],[1997,0.006085820382340806],[1998,0.006876633200385091],[1999,0.007736212350433228],[2000,0.007701829184431302]]
  },
  {
    "name": "Norway",
    "region": "EU",
    "code": "NOR",
    "Population": [[1975,3906491],[1976,3934530],[1977,3961021],[1978,3985400],[1979,4007311],[1980,4026584],[1981,4043438],[1982,4058406],[1983,4072256],[1984,4085619],[1985,4098697],[1986,4111566],[1987,4124588],[1988,4138150],[1989,4152559],[1990,4167994],[1991,4184542],[1992,4202287],[1993,4221267],[1994,4241487],[1995,4263058],[1996,4285960],[1997,4309881],[1998,4334392],[1999,4359184],[2000,4384077]],
    "Arable Area": [[1975,806],[1976,795],[1977,790],[1978,793],[1979,792],[1980,795],[1981,800],[1982,806],[1983,830],[1984,817],[1985,828],[1986,841],[1987,849],[1988,855],[1989,858],[1990,869],[1991,869],[1992,874],[1993,882],[1994,864],[1995,892],[1996,883],[1997,890],[1998,901],[1999,992],[2000,1000]],
    "Energy Consumption": [[1975,71642],[1976,73397],[1977,85318],[1978,78089],[1979,78744],[1980,82348],[1981,81257],[1982,85546],[1983,93707],[1984,91526],[1985,97122],[1986,95996],[1987,101946],[1988,107161],[1989,106822],[1990,99834],[1991,104426],[1992,104391],[1993,104611],[1994,106167],[1995,108648],[1996,109335],[1997,112721],[1998,106242],[1999,117805],[2000,114045]],
    "GDP Per Capita": [[1975,3102],[1976,3886],[1977,4670],[1978,5454],[1979,6238],[1980,7022],[1981,7794],[1982,8628],[1983,9769],[1984,11106],[1985,12275],[1986,13064],[1987,13963],[1988,15326],[1989,16488],[1990,17417],[1991,18125],[1992,18866],[1993,19779],[1994,20924],[1995,22409],[1996,23285],[1997,24366],[1998,25877],[1999,27277],[2000,29084]],
    "Life Expectancy (Women)": [[1975,76.8],[1976,77],[1977,77.19],[1978,77.39],[1979,77.6],[1980,77.8],[1981,78],[1982,78.19],[1983,78.39],[1984,78.6],[1985,78.78],[1986,78.96],[1987,79.14],[1988,79.32],[1989,79.5],[1990,79.56],[1991,79.62],[1992,79.67],[1993,79.74],[1994,79.8],[1995,79.89],[1996,80],[1997,80.1],[1998,80.2],[1999,80.3],[2000,80.39]],
    "Life Expectancy (Men)": [[1975,70.76],[1976,70.92],[1977,71.08],[1978,71.24],[1979,71.4],[1980,71.56],[1981,71.72],[1982,71.88],[1983,72.04],[1984,72.2],[1985,72.32],[1986,72.44],[1987,72.56],[1988,72.67],[1989,72.8],[1990,72.84],[1991,72.88],[1992,72.92],[1993,72.96],[1994,73],[1995,73.26],[1996,73.52],[1997,73.78],[1998,74.03],[1999,74.3],[2000,74.56]],
    "Life Expectancy": [[1975,73.68],[1976,73.86],[1977,74.04],[1978,74.22],[1979,74.4],[1980,74.58],[1981,74.76],[1982,74.94],[1983,75.12],[1984,75.3],[1985,75.44],[1986,75.58],[1987,75.72],[1988,75.86],[1989,76],[1990,76.06],[1991,76.12],[1992,76.17],[1993,76.24],[1994,76.3],[1995,76.52],[1996,76.74],[1997,76.96],[1998,77.18],[1999,77.4],[2000,77.62]],
    "Infant Mortality": [[1975,13.46],[1976,13.05],[1977,12.62],[1978,12.22],[1979,11.8],[1980,11.37],[1981,10.97],[1982,10.55],[1983,10.12],[1984,9.72],[1985,9.3],[1986,9.04],[1987,8.78],[1988,8.52],[1989,8.26],[1990,8],[1991,7.98],[1992,7.96],[1993,7.94],[1994,7.92],[1995,7.9],[1996,7.42],[1997,6.94],[1998,6.46],[1999,5.98],[2000,5.5]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0],[1991,1.97],[1992,4.79],[1993,7.81],[1994,11.06],[1995,14.5],[1996,16.2],[1997,18.9],[1998,22.9],[1999,27.3],[2000,31.7]],
    "Indexed Population": [[1975,0.0031872037995022647],[1976,0.0032100800860044593],[1977,0.0032316933998077202],[1978,0.00325158358806825],[1979,0.0032694601997002477],[1980,0.0032851845361515047],[1981,0.0032989352737922187],[1982,0.0033111472733772557],[1983,0.003322447126013063],[1984,0.0033333496480904843],[1985,0.0033440196461244974],[1986,0.0033545191265266783],[1987,0.0033651434356258463],[1988,0.0033762083165967353],[1989,0.003387964242707157],[1990,0.003400557255373849],[1991,0.003414058335620588],[1992,0.0034285360168496417],[1993,0.003444021302266798],[1994,0.00346051827124124],[1995,0.0034781174857688208],[1996,0.00349680262837281],[1997,0.0035163191464162137],[1998,0.0035363170300231643],[1999,0.003556544174178177],[2000,0.0035768537215906783]],
    "Indexed Energy Consumption": [[1975,0.019421518409128185],[1976,0.019897283530258526],[1977,0.023128962167862404],[1978,0.021169243614784772],[1979,0.02134680837509268],[1980,0.022323821193641825],[1981,0.02202806065395339],[1982,0.023190770969923783],[1983,0.025403146555989152],[1984,0.024811896567849392],[1985,0.026328923130724262],[1986,0.02602367439773693],[1987,0.0276366672585492],[1988,0.029050408060084663],[1989,0.028958508130703928],[1990,0.02706412256577012],[1991,0.02830897352658524],[1992,0.028299485333286346],[1993,0.02835912540545083],[1994,0.028780943370396023],[1995,0.029453520729669173],[1996,0.02963976040956464],[1997,0.030557675338423525],[1998,0.02880127521317937],[1999,0.0319359031878974],[2000,0.030916600136358892]],
    "Indexed GDP": [[1975,0.10665658093797277],[1976,0.13361298308348232],[1977,0.1605693852289919],[1978,0.18752578737450146],[1979,0.214482189520011],[1980,0.24143859166552056],[1981,0.267982395819007],[1982,0.29665795626461283],[1983,0.3358891486728098],[1984,0.3818594416173841],[1985,0.42205336267363497],[1986,0.44918168064915415],[1987,0.48009214688488516],[1988,0.5269564021455095],[1989,0.566909641039747],[1990,0.5988516022555357],[1991,0.623194883784899],[1992,0.6486728097923257],[1993,0.6800646403520836],[1994,0.7194333654242883],[1995,0.7704923669371476],[1996,0.8006120203548343],[1997,0.8377802228029156],[1998,0.8897331866318251],[1999,0.9378696190345207],[2000,1]]
  },
  {
    "name": "French Polynesia",
    "region": "OC",
    "code": "PYF",
    "Population": [[1975,114592],[1976,118304],[1977,122044],[1978,125865],[1979,129807],[1980,133869],[1981,138031],[1982,142295],[1983,146654],[1984,151101],[1985,155639],[1986,160253],[1987,164894],[1988,169500],[1989,174024],[1990,178446],[1991,182776],[1992,187026],[1993,191222],[1994,195386],[1995,199515],[1996,203605],[1997,207671],[1998,211730],[1999,215796],[2000,219871]],
    "Arable Area": [[1975,24],[1976,24],[1977,24],[1978,24],[1979,24],[1980,24],[1981,24],[1982,24],[1983,24],[1984,24],[1985,24],[1986,24],[1987,24],[1988,24],[1989,24],[1990,24],[1991,23],[1992,23],[1993,23],[1994,23],[1995,23],[1996,23],[1997,23],[1998,23],[1999,23],[2000,23]],
    "Energy Consumption": [[1975,102],[1976,109],[1977,119],[1978,129],[1979,141],[1980,153],[1981,196],[1982,215],[1983,235],[1984,255],[1985,280],[1986,290],[1987,187],[1988,203],[1989,220],[1990,225],[1991,225],[1992,256],[1993,271],[1994,291],[1995,302],[1996,317],[1997,323],[1998,335],[1999,349],[2000,335]],
    "GDP Per Capita": [[1975,3408],[1976,4073],[1977,4738],[1978,5403],[1979,6068],[1980,6733],[1981,7088],[1982,8087],[1983,8832],[1984,9396],[1985,10828],[1986,12269],[1987,13065],[1988,13900],[1989,14709],[1990,15896],[1991,17080],[1992,17679],[1993,18486],[1994,19205],[1995,20418],[1996,20653],[1997,20734],[1998,20931],[1999,21062],[2000,21131]],
    "Life Expectancy (Women)": [[1975,61.48],[1976,61.86],[1977,62.23],[1978,62.62],[1979,63],[1980,63.38],[1981,63.76],[1982,64.14],[1983,64.52],[1984,64.9],[1985,65.72],[1986,66.54],[1987,67.36],[1988,68.18],[1989,69],[1990,69.42],[1991,69.84],[1992,70.25],[1993,70.67],[1994,71.1],[1995,71.44],[1996,71.78],[1997,72.11],[1998,72.46],[1999,72.8],[2000,73.14]],
    "Life Expectancy (Men)": [[1975,58.33],[1976,58.58],[1977,58.81],[1978,59.05],[1979,59.3],[1980,59.54],[1981,59.78],[1982,60.01],[1983,60.26],[1984,60.5],[1985,61.2],[1986,61.9],[1987,62.6],[1988,63.3],[1989,64],[1990,64.36],[1991,64.72],[1992,65.08],[1993,65.44],[1994,65.8],[1995,66.22],[1996,66.64],[1997,67.06],[1998,67.48],[1999,67.9],[2000,68.32]],
    "Life Expectancy": [[1975,59.69],[1976,60],[1977,60.3],[1978,60.6],[1979,60.9],[1980,61.19],[1981,61.5],[1982,61.8],[1983,62.1],[1984,62.4],[1985,63.16],[1986,63.92],[1987,64.68],[1988,65.44],[1989,66.2],[1990,66.6],[1991,67],[1992,67.4],[1993,67.8],[1994,68.2],[1995,68.6],[1996,69],[1997,69.4],[1998,69.8],[1999,70.2],[2000,70.6]],
    "Infant Mortality": [[1975,69.33],[1976,68],[1977,66.64],[1978,65.36],[1979,64],[1980,62.64],[1981,61.36],[1982,60],[1983,58.64],[1984,57.36],[1985,56],[1986,50.8],[1987,45.6],[1988,40.4],[1989,35.2],[1990,30],[1991,27.56],[1992,25.12],[1993,22.68],[1994,20.24],[1995,17.8],[1996,16.5],[1997,15.2],[1998,13.9],[1999,12.6],[2000,11.3]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0],[1991,0],[1992,0],[1993,0],[1994,0],[1995,0],[1996,0],[1997,0],[1998,0],[1999,0],[2000,0]],
    "Indexed Population": [[1975,0.0000934926146745413],[1976,0.00009652113835570488],[1977,0.00009957250650429104],[1978,0.00010268996043363535],[1979,0.00010590613509719862],[1980,0.00010922021462114432],[1981,0.00011261588152874207],[1982,0.0001160947675676649],[1983,0.00011965116162105715],[1984,0.0001232793525720632],[1985,0.00012698178804219259],[1986,0.00013074622992389755],[1987,0.00013453270039918855],[1988,0.00013829061529020134],[1989,0.00014198162852661946],[1990,0.00014558942263171248],[1991,0.00014912215634384565],[1992,0.0001525896201490572],[1993,0.00015601302676709664],[1994,0.00015941032542236743],[1995,0.00016277906849335999],[1996,0.00016611599248472826],[1997,0.00016943333550402008],[1998,0.00017274496740645622],[1999,0.000176062310425748],[2000,0.00017938699630956848]],
    "Indexed Energy Consumption": [[1975,0.00002765130618535321],[1976,0.000029548944845132352],[1977,0.00003225985721624541],[1978,0.00003497076958735847],[1979,0.00003822386443269414],[1980,0.000041476959278029814],[1981,0.000053133882473815974],[1982,0.00005828461597893079],[1983,0.0000637064407211569],[1984,0.00006912826546338303],[1985,0.00007590554639116568],[1986,0.00007861645876227874],[1987,0.00005069406133981422],[1988,0.000055031521133595115],[1989,0.00005964007216448732],[1990,0.00006099552835004385],[1991,0.00006099552835004385],[1992,0.00006939935670049434],[1993,0.00007346572525716392],[1994,0.00007888754999939004],[1995,0.00008186955360761441],[1996,0.000085935922164284],[1997,0.00008756246958695184],[1998,0.0000908155644322875],[1999,0.00009461084175184579],[2000,0.0000908155644322875]],
    "Indexed GDP": [[1975,0.11717782973456196],[1976,0.1400426351258424],[1977,0.1629074405171228],[1978,0.18577224590840324],[1979,0.20863705129968368],[1980,0.2315018566909641],[1981,0.24370788062164764],[1982,0.2780566634575712],[1983,0.30367212212900563],[1984,0.3230642277540916],[1985,0.37230092146884886],[1986,0.4218470636776234],[1987,0.4492160638151561],[1988,0.47792600742676383],[1989,0.5057419887223216],[1990,0.5465548067666071],[1991,0.5872644753128868],[1992,0.6078599917480402],[1993,0.635607206711594],[1994,0.6603287030669784],[1995,0.702035483427314],[1996,0.7101155274377665],[1997,0.7129005638839224],[1998,0.7196740475863017],[1999,0.724178242332554],[2000,0.7265506807866868]]
  },
  {
    "name": "Rwanda",
    "region": "AF",
    "code": "RWA",
    "Population": [[1975,3898015],[1976,4020260],[1977,4144469],[1978,4273655],[1979,4410039],[1980,4554233],[1981,4705607],[1982,4863700],[1983,5027665],[1984,5196989],[1985,5363504],[1986,5526006],[1987,5698321],[1988,5899683],[1989,6139088],[1990,6440588],[1991,6789282],[1992,7109723],[1993,7299316],[1994,7293695],[1995,7047441],[1996,6606155],[1997,6107096],[1998,5742029],[1999,5643992],[2000,5869054]],
    "Arable Area": [[1975,748],[1976,808],[1977,805],[1978,884],[1979,912],[1980,939],[1981,965],[1982,980],[1983,997],[1984,1015],[1985,1060],[1986,1075],[1987,1090],[1988,1108],[1989,1119],[1990,1130],[1991,1142],[1992,1153],[1993,1155],[1994,1185],[1995,1187],[1996,1187],[1997,1130],[1998,940],[1999,940],[2000,1000]],
    "Energy Consumption": [[1975,87],[1976,124],[1977,126],[1978,135],[1979,143],[1980,150],[1981,153],[1982,169],[1983,193],[1984,166],[1985,162],[1986,155],[1987,165],[1988,176],[1989,184],[1990,234],[1991,246],[1992,213],[1993,161],[1994,180],[1995,176],[1996,185],[1997,168],[1998,171],[1999,175],[2000,175]],
    "GDP Per Capita": [[1975,39],[1976,118],[1977,197],[1978,276],[1979,355],[1980,434],[1981,455],[1982,515],[1983,602],[1984,690],[1985,769],[1986,807],[1987,869],[1988,837],[1989,874],[1990,902],[1991,883],[1992,913],[1993,924],[1994,939],[1995,985],[1996,1141],[1997,1166],[1998,629],[1999,875],[2000,978]],
    "Life Expectancy (Women)": [[1975,46.04],[1976,46.08],[1977,46.12],[1978,46.16],[1979,46.2],[1980,46.24],[1981,46.28],[1982,46.32],[1983,46.36],[1984,46.4],[1985,46.72],[1986,47.04],[1987,47.36],[1988,47.68],[1989,48],[1990,47.66],[1991,47.32],[1992,46.98],[1993,46.64],[1994,46.3],[1995,42.14],[1996,37.98],[1997,33.82],[1998,29.66],[1999,25.5],[2000,25.5]],
    "Life Expectancy (Men)": [[1975,42.83],[1976,42.87],[1977,42.92],[1978,42.96],[1979,43],[1980,43.04],[1981,43.08],[1982,43.12],[1983,43.16],[1984,43.2],[1985,43.46],[1986,43.72],[1987,43.98],[1988,44.24],[1989,44.5],[1990,43.98],[1991,43.46],[1992,42.94],[1993,42.42],[1994,41.9],[1995,37.9],[1996,33.9],[1997,29.9],[1998,25.9],[1999,21.9],[2000,21.9]],
    "Life Expectancy": [[1975,44.28],[1976,44.36],[1977,44.44],[1978,44.52],[1979,44.6],[1980,44.68],[1981,44.76],[1982,44.84],[1983,44.92],[1984,45],[1985,45.24],[1986,45.48],[1987,45.72],[1988,45.96],[1989,46.2],[1990,45.76],[1991,45.32],[1992,44.88],[1993,44.44],[1994,44],[1995,39.92],[1996,35.84],[1997,31.76],[1998,27.68],[1999,23.6],[2000,23.6]],
    "Infant Mortality": [[1975,135.8],[1976,135.45],[1977,135.09],[1978,134.75],[1979,134.4],[1980,134.04],[1981,133.7],[1982,133.35],[1983,132.99],[1984,132.65],[1985,132.3],[1986,130.7],[1987,129.1],[1988,127.5],[1989,125.9],[1990,124.3],[1991,122.86],[1992,121.42],[1993,119.97],[1994,118.53],[1995,117.1],[1996,120.5],[1997,123.89],[1998,127.3],[1999,130.7],[2000,130.7]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0],[1991,0],[1992,0],[1993,0],[1994,0],[1995,0],[1996,0],[1997,0],[1998,0],[1999,0],[2000,0]],
    "Indexed Population": [[1975,0.003180288452863918],[1976,0.00328002495000935],[1977,0.0033813638233697076],[1978,0.003486763300814427],[1979,0.00359803543813442],[1980,0.003715679550117637],[1981,0.0038391816362470703],[1982,0.003968165578684084],[1983,0.004101940332289145],[1984,0.004240087353784119],[1985,0.0043759425856723065],[1986,0.004508523715854538],[1987,0.004649111015994545],[1988,0.004813397003463958],[1989,0.005008721279296116],[1990,0.005254707241007004],[1991,0.005539197552558635],[1992,0.005800636980607057],[1993,0.005955320948894461],[1994,0.00595073492205938],[1995,0.005749822726320896],[1996,0.005389789024498171],[1997,0.004982619843518156],[1998,0.004684771229641177],[1999,0.00460478540633023],[2000,0.0047884076037251755]],
    "Indexed Energy Consumption": [[1975,0.00002358493762868362],[1976,0.00003361531340180194],[1977,0.00003415749587602455],[1978,0.00003659731701002631],[1979,0.00003876604690691676],[1980,0.0000406636855666959],[1981,0.000041476959278029814],[1982,0.00004581441907181071],[1983,0.000052320608762482054],[1984,0.000045001145360476794],[1985,0.00004391678041203157],[1986,0.00004201914175225243],[1987,0.00004473005412336549],[1988,0.000047712057731589854],[1989,0.0000498807876284803],[1990,0.0000634353494840456],[1991,0.00006668844432938128],[1992,0.000057742433504708175],[1993,0.000043645689174920263],[1994,0.00004879642268003508],[1995,0.000047712057731589854],[1996,0.00005015187886559161],[1997,0.000045543327834699404],[1998,0.000046356601546033324],[1999,0.00004744096649447855],[2000,0.00004744096649447855]],
    "Indexed GDP": [[1975,0.0013409434740750928],[1976,0.0040572135882272035],[1977,0.006773483702379315],[1978,0.009489753816531426],[1979,0.012206023930683537],[1980,0.014922294044835648],[1981,0.015644340530876082],[1982,0.01770733049099161],[1983,0.020698665933159124],[1984,0.023724384541328566],[1985,0.026440654655480678],[1986,0.027747214963553844],[1987,0.029878971255673223],[1988,0.02877870994361161],[1989,0.030050887085682848],[1990,0.031013615733736764],[1991,0.03036033557970018],[1992,0.031391830559757944],[1993,0.03177004538577912],[1994,0.032285792875808],[1995,0.03386741851189658],[1996,0.039231192408196947],[1997,0.040090771558245086],[1998,0.021627011415211114],[1999,0.030085270251684774],[2000,0.0336267363498831]]
  },
  {
    "name": "Saudi Arabia",
    "region": "AS",
    "code": "SAU",
    "Population": [[1975,5991369],[1976,6262068],[1977,6560072],[1978,6888909],[1979,7251401],[1980,7647380],[1981,8077168],[1982,8544235],[1983,9052716],[1984,9604374],[1985,10196888],[1986,10825137],[1987,11483869],[1988,12166340],[1989,12864760],[1990,13581997],[1991,14311016],[1992,15022596],[1993,15679120],[1994,16255743],[1995,16738406],[1996,17139601],[1997,17494146],[1998,17852219],[1999,18250583],[2000,18700473]],
    "Arable Area": [[1975,1467],[1976,1517],[1977,1570],[1978,1640],[1979,1684],[1980,1750],[1981,1804],[1982,1856],[1983,1909],[1984,1962],[1985,2013],[1986,2068],[1987,2270],[1988,2423],[1989,2625],[1990,2780],[1991,2980],[1992,3130],[1993,3290],[1994,3481],[1995,3672],[1996,3746],[1997,3785],[1998,3785],[1999,3785],[2000,3500]],
    "Energy Consumption": [[1975,1150],[1976,1350],[1977,1564],[1978,1670],[1979,2478],[1980,6389],[1981,7263],[1982,9713],[1983,15470],[1984,18909],[1985,25061],[1986,31014],[1987,30615],[1988,31778],[1989,33601],[1990,52863],[1991,57849],[1992,61306],[1993,66061],[1994,70115],[1995,74574],[1996,79628],[1997,87906],[1998,96880],[1999,99833],[2000,103353]],
    "GDP Per Capita": [[1975,3918],[1976,4988],[1977,6058],[1978,7128],[1979,8198],[1980,9268],[1981,9935],[1982,9967],[1983,10883],[1984,12184],[1985,13088],[1986,11141],[1987,9577],[1988,9203],[1989,8447],[1990,8441],[1991,7947],[1992,8501],[1993,8535],[1994,9506],[1995,10563],[1996,11128],[1997,11228],[1998,11479],[1999,11351],[2000,11691]],
    "Life Expectancy (Women)": [[1975,51.98],[1976,52.86],[1977,53.74],[1978,54.62],[1979,55.5],[1980,56.38],[1981,57.26],[1982,58.14],[1983,59.01],[1984,59.9],[1985,60.82],[1986,61.74],[1987,62.66],[1988,63.58],[1989,64.5],[1990,65.22],[1991,65.94],[1992,66.66],[1993,67.38],[1994,68.1],[1995,68.64],[1996,69.17],[1997,69.72],[1998,70.25],[1999,70.8],[2000,71.34]],
    "Life Expectancy (Men)": [[1975,48.23],[1976,49.27],[1977,50.32],[1978,51.36],[1979,52.4],[1980,53.44],[1981,54.48],[1982,55.52],[1983,56.56],[1984,57.6],[1985,58.46],[1986,59.32],[1987,60.18],[1988,61.04],[1989,61.9],[1990,62.51],[1991,63.14],[1992,63.76],[1993,64.38],[1994,65],[1995,65.48],[1996,65.96],[1997,66.44],[1998,66.92],[1999,67.4],[2000,67.88]],
    "Life Expectancy": [[1975,50.05],[1976,51.01],[1977,51.98],[1978,52.94],[1979,53.9],[1980,54.86],[1981,55.82],[1982,56.78],[1983,57.74],[1984,58.7],[1985,59.56],[1986,60.42],[1987,61.28],[1988,62.14],[1989,63],[1990,63.66],[1991,64.32],[1992,64.98],[1993,65.64],[1994,66.3],[1995,66.8],[1996,67.3],[1997,67.8],[1998,68.3],[1999,68.8],[2000,69.3]],
    "Infant Mortality": [[1975,123],[1976,118.5],[1977,113.91],[1978,109.59],[1979,105],[1980,100.41],[1981,96.09],[1982,91.5],[1983,86.91],[1984,82.59],[1985,78],[1986,73.68],[1987,69.36],[1988,65.03],[1989,60.72],[1990,56.4],[1991,53.62],[1992,50.83],[1993,48.06],[1994,45.28],[1995,42.5],[1996,40.42],[1997,38.34],[1998,36.26],[1999,34.18],[2000,32.1]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0.07],[1979,0.21],[1980,0.35],[1981,0.49],[1982,0.63],[1983,0.77],[1984,0.91],[1985,1.05],[1986,1.19],[1987,1.32],[1988,1.46],[1989,1.62],[1990,1.76],[1991,1.89],[1992,1.99],[1993,2.15],[1994,2.4],[1995,2.5],[1996,2.5],[1997,2.5],[1998,3],[1999,3.6],[2000,4]],
    "Indexed Population": [[1975,0.004888201212039164],[1976,0.005109057443711389],[1977,0.005352191110489803],[1978,0.005620480615269649],[1979,0.005916228354017589],[1980,0.006239297259929085],[1981,0.006589950044379498],[1982,0.006971017789581554],[1983,0.007385874133849264],[1984,0.007835957462756414],[1985,0.00831937413312844],[1986,0.00883194605504852],[1987,0.009369388259127252],[1988,0.009926198492211139],[1989,0.01049602109711369],[1990,0.011081195999998045],[1991,0.011675983528424283],[1992,0.012256543033015443],[1993,0.012792183787663136],[1994,0.013262635406899016],[1995,0.013656427520455445],[1996,0.01398375202429823],[1997,0.014273016013667343],[1998,0.014565158405931698],[1999,0.014890173170943296],[2000,0.01525722665125544]],
    "Indexed Energy Consumption": [[1975,0.0003117549226780019],[1976,0.0003659731701002631],[1977,0.0004239866948420826],[1978,0.000452722365975881],[1979,0.0006717640855618162],[1980,0.001732001913904134],[1981,0.0019689356551394156],[1982,0.002633109186062115],[1983,0.004193781438111904],[1984,0.005126064202537685],[1985,0.00679381749324644],[1986,0.008407623627770044],[1987,0.008299458224162634],[1988,0.008614737332923082],[1989,0.009108936658176994],[1990,0.014330696067414968],[1991,0.01568235697565194],[1992,0.016619519382345724],[1993,0.017908558214809984],[1994,0.01900756209005922],[1995,0.020216357916338534],[1996,0.021586453028699073],[1997,0.023830546289506465],[1998,0.026263319051343326],[1999,0.02706385147453301],[2000,0.02801809262916481]],
    "Indexed GDP": [[1975,0.13471324439554394],[1976,0.17150323201760417],[1977,0.2082932196396644],[1978,0.24508320726172467],[1979,0.28187319488378487],[1980,0.31866318250584513],[1981,0.34159675422912944],[1982,0.34269701554119103],[1983,0.3741919955989548],[1984,0.4189244945674598],[1985,0.4500068766332004],[1986,0.38306285242745153],[1987,0.3292875808004401],[1988,0.31642827671572],[1989,0.29043460321826436],[1990,0.29022830422225276],[1991,0.2732430202173016],[1992,0.2922912941823683],[1993,0.2934603218264338],[1994,0.3268463760143034],[1995,0.3631893824783386],[1996,0.3826158712694265],[1997,0.38605418786961904],[1998,0.39468436253610234],[1999,0.39028331728785587],[2000,0.40197359372851055]]
  },
  {
    "name": "Sweden",
    "region": "EU",
    "code": "SWE",
    "Population": [[1975,8084965],[1976,8117862],[1977,8144216],[1978,8168132],[1979,8192567],[1980,8218932],[1981,8246303],[1982,8272583],[1983,8294607],[1984,8310468],[1985,8319263],[1986,8322897],[1987,8325663],[1988,8333422],[1989,8350365],[1990,8377418],[1991,8413202],[1992,8456653],[1993,8505836],[1994,8558830],[1995,8616521],[1996,8678155],[1997,8738187],[1998,8789384],[1999,8826949],[2000,8848174]],
    "Arable Area": [[1975,3055],[1976,3035],[1977,3022],[1978,3023],[1979,3010],[1980,3007],[1981,2998],[1982,3004],[1983,2989],[1984,2983],[1985,2964],[1986,2954],[1987,2945],[1988,2937],[1989,2926],[1990,2912],[1991,2894],[1992,2876],[1993,2857],[1994,2849],[1995,2793],[1996,2771],[1997,2783],[1998,2783],[1999,2770],[2000,2815]],
    "Energy Consumption": [[1975,73571],[1976,78988],[1977,84889],[1978,84464],[1979,87870],[1980,92676],[1981,94822],[1982,98067],[1983,103067],[1984,97230],[1985,100656],[1986,103392],[1987,114324],[1988,124229],[1989,135757],[1990,133992],[1991,142556],[1992,143683],[1993,143286],[1994,145497],[1995,146698],[1996,144963],[1997,145723],[1998,143848],[1999,146734],[2000,146822]],
    "GDP Per Capita": [[1975,4745],[1976,5172],[1977,5599],[1978,6026],[1979,6453],[1980,6880],[1981,7197],[1982,7827],[1983,8778],[1984,9765],[1985,10705],[1986,11643],[1987,12350],[1988,13357],[1989,14049],[1990,14635],[1991,15432],[1992,16317],[1993,17318],[1994,18163],[1995,18616],[1996,18957],[1997,19013],[1998,19744],[1999,20802],[2000,21439]],
    "Life Expectancy (Women)": [[1975,76.86],[1976,77.02],[1977,77.18],[1978,77.34],[1979,77.5],[1980,77.66],[1981,77.82],[1982,77.98],[1983,78.14],[1984,78.3],[1985,78.53],[1986,78.78],[1987,79.02],[1988,79.26],[1989,79.5],[1990,79.62],[1991,79.74],[1992,79.86],[1993,79.97],[1994,80.1],[1995,80.25],[1996,80.42],[1997,80.58],[1998,80.74],[1999,80.9],[2000,81.06]],
    "Life Expectancy (Men)": [[1975,71.94],[1976,71.97],[1977,72.02],[1978,72.05],[1979,72.1],[1980,72.14],[1981,72.17],[1982,72.22],[1983,72.25],[1984,72.3],[1985,72.53],[1986,72.78],[1987,73.02],[1988,73.26],[1989,73.5],[1990,73.66],[1991,73.82],[1992,73.98],[1993,74.14],[1994,74.3],[1995,74.53],[1996,74.78],[1997,75.02],[1998,75.26],[1999,75.5],[2000,75.74]],
    "Life Expectancy": [[1975,74.3],[1976,74.4],[1977,74.5],[1978,74.6],[1979,74.7],[1980,74.8],[1981,74.9],[1982,75],[1983,75.1],[1984,75.2],[1985,75.42],[1986,75.64],[1987,75.86],[1988,76.08],[1989,76.3],[1990,76.5],[1991,76.7],[1992,76.89],[1993,77.1],[1994,77.3],[1995,77.5],[1996,77.7],[1997,77.89],[1998,78.1],[1999,78.3],[2000,78.5]],
    "Infant Mortality": [[1975,11.73],[1976,11.34],[1977,10.95],[1978,10.59],[1979,10.2],[1980,9.8],[1981,9.44],[1982,9.05],[1983,8.65],[1984,8.29],[1985,7.9],[1986,7.68],[1987,7.46],[1988,7.24],[1989,7.02],[1990,6.8],[1991,6.64],[1992,6.47],[1993,6.32],[1994,6.16],[1995,6],[1996,5.84],[1997,5.68],[1998,5.52],[1999,5.36],[2000,5.2]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0.05],[1990,2.16],[1991,4.1],[1992,5.9],[1993,8.2],[1994,10.5],[1995,12.7],[1996,13.8],[1997,14.9],[1998,18.1],[1999,24.9],[2000,29.4]],
    "Indexed Population": [[1975,0.006596311412682848],[1976,0.006623151214282858],[1977,0.006644652753370515],[1978,0.0066641651920447366],[1979,0.0066841010692401115],[1980,0.006705611582939971],[1981,0.006727942865719369],[1982,0.006749384030143125],[1983,0.006767352835518649],[1984,0.0067802934104396985],[1985,0.006787469020831895],[1986,0.00679043390635381],[1987,0.006792690613385626],[1988,0.006799020978483187],[1989,0.006812844328895351],[1990,0.006834916163794736],[1991,0.006864111393160782],[1992,0.006899561927231427],[1993,0.006939689050133009],[1994,0.006982925468225569],[1995,0.007029994045728265],[1996,0.007080279613768361],[1997,0.007129258151922351],[1998,0.007171028444730684],[1999,0.007201676745399572],[2000,0.007218993667579716]],
    "Indexed Energy Consumption": [[1975,0.019944453405515893],[1976,0.02141295463694784],[1977,0.023012664027141656],[1978,0.02289745025136935],[1979,0.023820787004970458],[1980,0.025123651490527393],[1981,0.025705413285368257],[1982,0.026585104349794445],[1983,0.027940560535350975],[1984,0.02635820098433228],[1985,0.027286959562675617],[1986,0.02802866518741215],[1987,0.030992234591512947],[1988,0.03367739329510043],[1989,0.03680253307651957],[1990,0.03632405704301811],[1991,0.03864568239763934],[1992,0.03895120222186378],[1993,0.03884357900073059],[1994,0.03944296172598369],[1995,0.03976854230175437],[1996,0.03929819900536625],[1997,0.039504228345570845],[1998,0.03899593227598715],[1999,0.03977830158629037],[2000,0.03980215761515617]],
    "Indexed GDP": [[1975,0.16314812267913628],[1976,0.17782973456195847],[1977,0.19251134644478063],[1978,0.20719295832760282],[1979,0.22187457021042498],[1980,0.23655618209324714],[1981,0.24745564571585751],[1982,0.26911704029707056],[1983,0.30181543116490167],[1984,0.3357516160088021],[1985,0.368071792050612],[1986,0.4003232017604181],[1987,0.4246321001237794],[1988,0.4592559482877183],[1989,0.48304909916105077],[1990,0.5031976344381791],[1991,0.5306010177417136],[1992,0.5610301196534176],[1993,0.595447668821345],[1994,0.624501444092972],[1995,0.6400770182918443],[1996,0.6518016778985009],[1997,0.6537271351946087],[1998,0.6788612295420162],[1999,0.7152386191720533],[2000,0.7371406959152799]]
  },
  {
    "name": "United States",
    "region": "NA",
    "code": "USA",
    "Population": [[1975,212124541],[1976,214124345],[1977,216123111],[1978,218133070],[1979,220165016],[1980,222226196],[1981,224323441],[1982,226465668],[1983,228661616],[1984,230917197],[1985,233239037],[1986,235626667],[1987,238069643],[1988,240552312],[1989,243063478],[1990,245598258],[1991,248160372],[1992,250757356],[1993,253400645],[1994,256097549],[1995,258849984],[1996,261652086],[1997,264493898],[1998,267361632],[1999,270244831],[2000,273138278]],
    "Arable Area": [[1975,189900],[1976,189300],[1977,188800],[1978,188218],[1979,188218],[1980,188218],[1981,188293],[1982,190624],[1983,190624],[1984,190624],[1985,190624],[1986,189799],[1987,189799],[1988,189799],[1989,189799],[1990,189799],[1991,187776],[1992,187776],[1993,187776],[1994,187776],[1995,187776],[1996,186180],[1997,184948],[1998,184139],[1999,184139],[2000,181306]],
    "Energy Consumption": [[1975,1721317],[1976,1861216],[1977,1979739],[1978,1981410],[1979,2009365],[1980,2132463],[1981,2228643],[1982,2305408],[1983,2348085],[1984,2381378],[1985,2392193],[1986,2333122],[1987,2402910],[1988,2518181],[1989,2609815],[1990,2635832],[1991,2765736],[1992,2910900],[1993,3121605],[1994,3181227],[1995,3276274],[1996,3299529],[1997,3417658],[1998,3496783],[1999,3595759],[2000,3688795]],
    "GDP Per Capita": [[1975,4346],[1976,5142],[1977,5938],[1978,6734],[1979,7530],[1980,8326],[1981,9141],[1982,10236],[1983,11352],[1984,12200],[1985,13504],[1986,13766],[1987,15023],[1988,16433],[1989,17533],[1990,18533],[1991,19394],[1992,20506],[1993,22070],[1994,23155],[1995,23640],[1996,24760],[1997,25791],[1998,27079],[1999,27780],[2000,28990]],
    "Life Expectancy (Women)": [[1975,73.96],[1976,74.32],[1977,74.68],[1978,75.04],[1979,75.4],[1980,75.76],[1981,76.12],[1982,76.48],[1983,76.84],[1984,77.2],[1985,77.34],[1986,77.48],[1987,77.62],[1988,77.76],[1989,77.9],[1990,78],[1991,78.1],[1992,78.2],[1993,78.3],[1994,78.4],[1995,78.5],[1996,78.6],[1997,78.7],[1998,78.8],[1999,78.9],[2000,79]],
    "Life Expectancy (Men)": [[1975,66.44],[1976,66.78],[1977,67.11],[1978,67.46],[1979,67.8],[1980,68.14],[1981,68.48],[1982,68.82],[1983,69.16],[1984,69.5],[1985,69.76],[1986,70.02],[1987,70.28],[1988,70.53],[1989,70.8],[1990,70.94],[1991,71.08],[1992,71.22],[1993,71.36],[1994,71.5],[1995,71.64],[1996,71.78],[1997,71.92],[1998,72.06],[1999,72.2],[2000,72.34]],
    "Life Expectancy": [[1975,70.06],[1976,70.42],[1977,70.78],[1978,71.14],[1979,71.5],[1980,71.86],[1981,72.22],[1982,72.58],[1983,72.94],[1984,73.3],[1985,73.46],[1986,73.61],[1987,73.78],[1988,73.94],[1989,74.1],[1990,74.22],[1991,74.34],[1992,74.46],[1993,74.58],[1994,74.7],[1995,74.82],[1996,74.94],[1997,75.06],[1998,75.17],[1999,75.3],[2000,75.42]],
    "Infant Mortality": [[1975,20.76],[1976,20.1],[1977,19.42],[1978,18.78],[1979,18.1],[1980,17.42],[1981,16.78],[1982,16.1],[1983,15.42],[1984,14.78],[1985,14.1],[1986,13.34],[1987,12.58],[1988,11.82],[1989,11.06],[1990,10.3],[1991,10],[1992,9.7],[1993,9.4],[1994,9.1],[1995,8.8],[1996,8.6],[1997,8.4],[1998,8.2],[1999,8],[2000,7.8]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0.9],[1986,2.4],[1987,5.2],[1988,8.1],[1989,10.6],[1990,12.9],[1991,15.6],[1992,18.4],[1993,20],[1994,21.8],[1995,23.4],[1996,25.3],[1997,27.2],[1998,29.7],[1999,32.4],[2000,35.9]],
    "Indexed Population": [[1975,0.1730668630857908],[1976,0.17469845084755956],[1977,0.176329191732286],[1978,0.17796906469286464],[1979,0.17962687627148685],[1980,0.18130853910584588],[1981,0.18301962643011904],[1982,0.18476741339130653],[1983,0.18655902991086576],[1984,0.1883992994349182],[1985,0.19029362794350463],[1986,0.19224163279179574],[1987,0.1942347929934429],[1988,0.1962603376752831],[1989,0.19830913231384256],[1990,0.20037719299717766],[1991,0.20246755477596018],[1992,0.2045863660754222],[1993,0.20674295641288426],[1994,0.20894328982609137],[1995,0.21118892952931428],[1996,0.21347509123837566],[1997,0.21579365129748526],[1998,0.21813336043818515],[1999,0.2204856870677668],[2000,0.22284637477242514]],
    "Indexed Energy Consumption": [[1975,0.4666339549907219],[1976,0.5045593479713565],[1977,0.5366898946674998],[1978,0.5371428881247128],[1979,0.5447212436581593],[1980,0.5780920327640869],[1981,0.6041655879494523],[1982,0.6249759067663018],[1983,0.636545267492501],[1984,0.6455707080496477],[1985,0.6485025597790064],[1986,0.6324889293116045],[1987,0.6514078445671283],[1988,0.6826568025601857],[1989,0.7074979769816431],[1990,0.7145509576975679],[1991,0.749766793763275],[1992,0.7891194821073007],[1993,0.8462397612228384],[1994,0.8624027629618887],[1995,0.888169171775607],[1996,0.8944733984946304],[1997,0.9264971352433519],[1998,0.9479472293797839],[1999,0.9747787556641125],[2000,1]],
    "Indexed GDP": [[1975,0.14942923944436803],[1976,0.1767982395819007],[1977,0.20416723971943337],[1978,0.23153623985696603],[1979,0.2589052399944987],[1980,0.28627424013203134],[1981,0.3142965204236006],[1982,0.35194608719570897],[1983,0.3903177004538578],[1984,0.4194746252234906],[1985,0.4643102736900014],[1986,0.47331866318250587],[1987,0.5165383028469261],[1988,0.565018566909641],[1989,0.6028400495117591],[1990,0.6372232155136845],[1991,0.6668271214413424],[1992,0.7050612020354834],[1993,0.7588364736624948],[1994,0.796142208774584],[1995,0.8128180442855178],[1996,0.8513271902076743],[1997,0.8867762343556594],[1998,0.9310617521661395],[1999,0.9551643515334892],[2000,0.996767982395819]]
  },
  {
    "name": "South Africa",
    "region": "AF",
    "code": "ZAF",
    "Population": [[1975,23105679],[1976,23735199],[1977,24383117],[1978,25039481],[1979,25697468],[1980,26352528],[1981,27007430],[1982,27671341],[1983,28357481],[1984,29074292],[1985,29829163],[1986,30616723],[1987,31417594],[1988,32204734],[1989,32960770],[1990,33672132],[1991,34349504],[1992,35028773],[1993,35760286],[1994,36577424],[1995,37492564],[1996,38486112],[1997,39520023],[1998,40539858],[1999,41504529],[2000,42401141]],
    "Arable Area": [[1975,13248],[1976,13284],[1977,13320],[1978,13356],[1979,13392],[1980,13430],[1981,13384],[1982,13344],[1983,13294],[1984,13254],[1985,13214],[1986,13169],[1987,13169],[1988,13169],[1989,13169],[1990,13300],[1991,13500],[1992,13700],[1993,14000],[1994,14300],[1995,14600],[1996,14900],[1997,15200],[1998,15500],[1999,15825],[2000,15800]],
    "Energy Consumption": [[1975,54823],[1976,59346],[1977,64495],[1978,70340],[1979,75139],[1980,80886],[1981,79253],[1982,84846],[1983,92529],[1984,99923],[1985,107029],[1986,111032],[1987,128457],[1988,122714],[1989,122250],[1990,144179],[1991,148170],[1992,157021],[1993,162604],[1994,165473],[1995,168325],[1996,168108],[1997,174855],[1998,182757],[1999,188688],[2000,198701]],
    "GDP Per Capita": [[1975,3082],[1976,3319],[1977,3556],[1978,3793],[1979,4030],[1980,4267],[1981,4447],[1982,4796],[1983,5267],[1984,5981],[1985,6741],[1986,6934],[1987,6885],[1988,7317],[1989,7298],[1990,7274],[1991,7376],[1992,7747],[1993,8057],[1994,8199],[1995,8132],[1996,7939],[1997,8033],[1998,8266],[1999,8522],[2000,8883]],
    "Life Expectancy (Women)": [[1975,54.84],[1976,55.28],[1977,55.72],[1978,56.16],[1979,56.6],[1980,57.04],[1981,57.48],[1982,57.92],[1983,58.36],[1984,58.8],[1985,59.37],[1986,59.96],[1987,60.54],[1988,61.12],[1989,61.7],[1990,62.3],[1991,62.9],[1992,63.5],[1993,64.1],[1994,64.7],[1995,64.92],[1996,65.14],[1997,65.36],[1998,65.58],[1999,65.8],[2000,66.02]],
    "Life Expectancy (Men)": [[1975,49.8],[1976,50.1],[1977,50.4],[1978,50.7],[1979,51],[1980,51.3],[1981,51.6],[1982,51.9],[1983,52.2],[1984,52.5],[1985,52.98],[1986,53.46],[1987,53.94],[1988,54.42],[1989,54.9],[1990,55.4],[1991,55.9],[1992,56.4],[1993,56.9],[1994,57.4],[1995,57.58],[1996,57.76],[1997,57.94],[1998,58.12],[1999,58.3],[2000,58.48]],
    "Life Expectancy": [[1975,52.26],[1976,52.62],[1977,52.98],[1978,53.34],[1979,53.7],[1980,54.06],[1981,54.42],[1982,54.78],[1983,55.14],[1984,55.5],[1985,56.04],[1986,56.58],[1987,57.12],[1988,57.66],[1989,58.2],[1990,58.72],[1991,59.24],[1992,59.76],[1993,60.28],[1994,60.8],[1995,61.01],[1996,61.23],[1997,61.46],[1998,61.68],[1999,61.9],[2000,62.12]],
    "Infant Mortality": [[1975,81.43],[1976,80.35],[1977,79.24],[1978,78.2],[1979,77.1],[1980,75.99],[1981,74.95],[1982,73.85],[1983,72.74],[1984,71.7],[1985,70.6],[1986,68.61],[1987,66.64],[1988,64.66],[1989,62.68],[1990,60.7],[1991,58.82],[1992,56.94],[1993,55.06],[1994,53.18],[1995,51.3],[1996,50.78],[1997,50.26],[1998,49.74],[1999,49.22],[2000,48.7]],
    "Number of Personal Computers": [[1975,0],[1976,0],[1977,0],[1978,0],[1979,0],[1980,0],[1981,0],[1982,0],[1983,0],[1984,0],[1985,0],[1986,0],[1987,0],[1988,0],[1989,0],[1990,0],[1991,0],[1992,0],[1993,0],[1994,0.38],[1995,0.9],[1996,1.2],[1997,1.5],[1998,2.3],[1999,2.8],[2000,3.5]],
    "Indexed Population": [[1975,0.018851318971137957],[1976,0.019364927868704255],[1977,0.019893547213114857],[1978,0.020429057427948708],[1979,0.02096589180601923],[1980,0.02150033812137026],[1981,0.022034655528655116],[1982,0.022576323143333188],[1983,0.023136126817523268],[1984,0.023720954158153264],[1985,0.024336833657001226],[1986,0.0249793832556912],[1987,0.025632792951019102],[1988,0.026274999882697738],[1989,0.02689182987456525],[1990,0.027472211518660045],[1991,0.028024861611051517],[1992,0.028579059416110865],[1993,0.029175881733885384],[1994,0.02984256324891196],[1995,0.030589202031665205],[1996,0.03139981185019234],[1997,0.03224335278438294],[1998,0.03307540947845068],[1999,0.033862459308200615],[2000,0.034593981580510816]],
    "Indexed Energy Consumption": [[1975,0.014862034892153129],[1976,0.016088180557607565],[1977,0.01748402933749368],[1978,0.019068557618409265],[1979,0.020369524465306422],[1980,0.021927485804985096],[1981,0.021484793814782334],[1982,0.02300100710394587],[1983,0.025083801078672033],[1984,0.02708824968587303],[1985,0.029014624016785968],[1986,0.030099802238942527],[1987,0.03482356704560703],[1988,0.033266690070876806],[1989,0.03314090373685716],[1990,0.03908566347547099],[1991,0.04016758860278221],[1992,0.04256701714245438],[1993,0.0440805195192468],[1994,0.04485828027851914],[1995,0.04563143248676058],[1996,0.04557260568830743],[1997,0.04740165826509741],[1998,0.04954382122075095],[1999,0.0511516633480581],[2000,0.053866099905253616]],
    "Indexed GDP": [[1975,0.10596891761793426],[1976,0.11411772796039059],[1977,0.12226653830284692],[1978,0.13041534864530327],[1979,0.1385641589877596],[1980,0.14671296933021594],[1981,0.1529019392105625],[1982,0.1649016641452345],[1983,0.1810961353321414],[1984,0.20564571585751615],[1985,0.2317769220189795],[1986,0.23841287305735112],[1987,0.23672809792325678],[1988,0.25158162563608855],[1989,0.250928345482052],[1990,0.2501031494980058],[1991,0.2536102324302022],[1992,0.2663663870169165],[1993,0.2770251684775134],[1994,0.28190757804978683],[1995,0.2796039059276578],[1996,0.2729679548892862],[1997,0.27619997249346717],[1998,0.28421125017191584],[1999,0.29301334066840873],[2000,0.3054256635951038]]
  }
];

module.exports = studyData;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var d3 = __webpack_require__(1);
var flubber = __webpack_require__(23);
var globals = __webpack_require__(0);

d3.chart = function () {  

  /**

  GLOBAL CHART VARIABLES

  **/

  var params = {};
      params.yearMin = globals.param_yearMin;
      params.yearMax = globals.param_yearMax;      
      params.x = globals.param_x;
      params.y = globals.param_y;
      params.radius = globals.param_r;
      params.color = 'region';
      params.facet = 'facet';
      params.key = 'code';
  
  var scale_pop = d3.scaleLinear(), 
      scale_x = d3.scaleLinear(), 
      scale_y = d3.scaleLinear(), 
      scale_scroll = d3.scaleLinear(),
      scale_reg = d3.scaleOrdinal(),
      scale_tmp = d3.scaleLinear(),
      animation = 'off',
      loop_count = 0,
      animation_duration = (params.yearMax - params.yearMin) * 500,
      current_year = params.yearMin,
      scroll_year = current_year,
      facets = globals.facets, //show facets?
      num_facets = 0,
      num_facet_cols = 0,
      facet_dim = 0,
      lines = globals.lines, //show lines?
      this_chart,
      thousand_format = d3.format(".2s"),
      caption_text = "";

  function chart (selection) {
    selection.each(function (data){

      this_chart = d3.select(this);
      this_chart.interrupt();

      /**

      DATA WRANGLING

      **/

      //sort data alphabetically by country code
      data.sort(function(x, y){
        return d3.ascending(x[params.key], y[params.key]);
      });

      //assign facet index
      data.forEach(function(d,i){
        d[params.facet] = i;
      });

      num_facets = d3.max(data, function(d){
        return d[params.facet] + 1;
      });

      num_facet_cols = Math.ceil(Math.sqrt(num_facets));

      facet_dim = chart_dim / num_facet_cols;      

      var countries = data.map(function(d){
        return {
          id: d.code,
          region: d.region,
          facet: d.facet,
          param_x: d[params.x].map(function(d) {
            return d[1];
          }),
          param_y: d[params.y].map(function(d) {
            return d[1];
          })
        };
      });

      countries.forEach(function(d){
        d.values = [];
        for(var i = 0; i < d.param_x.length; i++){
          if (d.param_x[i] != null && d.param_y[i] != null) {
            d.values.push({
              'param_x': d.param_x[i],
              'param_y': d.param_y[i]
            });
          }
        }
      }); 
      
      /**

      SCALES: initialize domains and ranges

      **/

      //region scale (color)

      scale_reg.range([
        "#fad139",
        "#54b2fc",
        "#f67afe",
        "#8bba32",
        "#c29aeb"]

      );

      //size scale

      if (facets == 'on') {
        scale_pop.range([1.75,7]); // r scale range      
      }
      else {
        scale_pop.range([7,28]); // r scale range      
      }
      
      var pop_max = d3.max(data, function(d){
        return d3.max(d[params.radius], function (dd) {
          return Math.sqrt(dd[1]);
        });
      });
      
      var pop_buffer = pop_max * 0.05;
      
      scale_pop.domain([0,pop_max + pop_buffer]);
      scale_pop.nice();

      //y scale

      if (facets == 'on') {
        scale_y.range([facet_dim, 0]); // y scale range
      }
      else {
        scale_y.range([chart_dim, 0]); // y scale range
      }
      
      var y_min = d3.min(data, function(d){
        return d3.min(d[params.y], function (dd){
          return dd[1];
        });
      });
      
      var y_max = d3.max(data, function(d){
        return d3.max(d[params.y], function (dd) {
          return dd[1];
        });
      });
      
      var y_buffer = (y_max - y_min) * 0.05;
      
      scale_y.domain([d3.max([0,y_min - y_buffer]),y_max + y_buffer]);
      scale_y.nice();

      
      //x scale
      
      if (facets == 'on') {
        scale_x.range([0, facet_dim]); // x scale range
      }
      else {
        scale_x.range([0, chart_dim]); // x scale range
      }
      
      var x_min = d3.min(data, function(d){
        return d3.min(d[params.x], function (dd){
          return dd[1];
        });
      });
      
      var x_max = d3.max(data, function(d){
        return d3.max(d[params.x], function (dd) {
          return dd[1];
        });
      });
      
      var x_buffer = (x_max - x_min) * 0.05;
      
      scale_x.domain([d3.max([0,x_min - x_buffer]),x_max + x_buffer]);
      scale_x.nice();

      // time scale

      scale_tmp.range([-5,5]);
      scale_tmp.domain([-0.5,0.5]);
      scale_tmp.clamp(true);
      scale_tmp.nice();
      scale_tmp.tickFormat(d3.format("d"));

      //SCROLL RING SCALE

      scale_scroll.range([-(4/12),(4/12)]);
      scale_scroll.domain([-10,10]);
      scale_scroll.clamp(true);

      /** 
       
      DEFS: add as required 
      
      **/
     
      /** 
      
        GUIDES / AXES

      **/

      year_indicator = this_chart.selectAll('.year_indicator')
      .data([null]);

      year_indicator.enter()
      .append("text")
      .attr("class", "year_indicator");

      year_indicator.transition().duration(250)
      .attr('id', facets == 'on' ? "faceted_year_indicator" : (current_year == params.yearMin) ? "central_year_indicator_min" : "central_year_indicator")
      .attr('text-anchor', facets == 'on' ? "middle" : "middle")
      .attr('alignment-baseline',facets == 'on' ?  'baseline' : 'middle')
      .attr('dy',facets == 'on' ?  '-0.2em' : '0em')
      .attr('transform', function () {
        return facets == 'on' ? 'translate(' + (chart_dim / 2) + ',' + (0 - 0.5 * inner_padding) + ')' : 'translate(' + (chart_dim / 2) + ',' + (chart_dim / 2) + ')';
      })
      .text(facets == 'on' ? (params.yearMin + ' ― ' + params.yearMax) : Math.round(current_year));

      year_indicator.exit()
      .remove();

      var x_indicator = this_chart.selectAll('.x_indicator')
      .data([null]);

      var x_indicator_enter = x_indicator.enter()
      .append("g")
      .attr("class", "x_indicator");

      x_indicator_enter.append('line');

      x_indicator.select('line').attr('x1', 0)
      .attr('x2', chart_dim)
      .attr('y1', chart_dim)
      .attr('y2', chart_dim)
      .style("stroke", facets == 'on' ? 'none' : '#ccc');

      x_indicator_enter.append("text")
      .attr('class','indicator_text');

      x_indicator.select('text').attr('text-anchor', "middle")
      .attr('alignment-baseline','hanging')
      .attr('dy','0.2em')
      .text('← ' + params.x + ' →')
      .attr('transform', function () {
        return 'translate(' + (chart_dim / 2) + ',' + (chart_dim + inner_padding * 0.5) + ')';
      });

      x_indicator.exit()
      .remove();

      var y_indicator = this_chart.selectAll('.y_indicator')
      .data([null]);

      var y_indicator_enter = y_indicator.enter()
      .append("g")
      .attr("class", "y_indicator");

      y_indicator_enter.append('line');

      y_indicator.select('line')
      .attr('x1', 0)
      .attr('x2', 0)
      .attr('y1', 0)
      .attr('y2', chart_dim)
      .style("stroke", facets == 'on' ? 'none' : '#ccc');

      y_indicator_enter.append("text")
      .attr('class','indicator_text');

      y_indicator.select('text')
      .attr('text-anchor', "middle")
      .attr('alignment-baseline','baseline')
      .attr('dy','-0.6em')
      .text('← ' + params.y + ' →')
      .attr('transform', function () {
        return 'translate(' + (0 - inner_padding * 0.5) + ',' + (chart_dim / 2) + ')rotate(-90)';
      });

      y_indicator.exit()
      .remove();

      
      /**
        
        HELPER FUNCTIONS
        
      **/

      var bisect = d3.bisector(function(d){
        return d[0];
      });

      function interpolateData(year) {
        return data.map(function (d){
          var tmp = {};
            tmp[params.key] = d[params.key];
            tmp[params.facet] = d[params.facet];
            tmp[params.color] = d[params.color];
            tmp[params.x] = (interpolateValues(d[params.x], year) != null) ? interpolateValues(d[params.x], year) : x_min;
            tmp[params.radius] = (interpolateValues(d[params.radius], year) != null) ? interpolateValues(d[params.radius], year) : 0;
            tmp[params.y] = (interpolateValues(d[params.y], year) != null) ? interpolateValues(d[params.y], year) : y_min;
            return tmp;
        });
      }

      // Finds (and possibly interpolates) the value for the specified year.
      function interpolateValues(values, year) {
        var i = bisect.left(values, year, 0, values.length - 1),
                a = values[i];
        if (i > 0) {
            var b = values[i - 1],
                    t = (year - a[0]) / (b[0] - a[0]);
            return a[1] * (1 - t) + b[1] * t;
        }
        return a[1];
      }      

      function order(a, b) {
        return b[params.radius] - a[params.radius];
      }

      // Positions the marks based on data.
      function position(mark) {        

        var mark_transition;
        
        if (animation == 'off'){
          mark_transition = mark.transition()
          .delay(function(d,i){
            return i * 10;
          })
          .duration(500);
        }
        else if (animation == 'on'){
          mark_transition = mark.transition()         
          .delay(function(d,i){
            return i * (50 / data.length);
          })
          .duration(50);
        }
        else {
          mark_transition = mark;
        }

        mark_transition.select('circle')
        .attr("cx", function (d) {         
          return (d[params.x] != null) ? scale_x(d[params.x]) : - facet_dim;
        })        
        .style("stroke", function(d){
          if (facets == 'on') {
            return '#999';
          }                   
          else {
            return '#fff';
          }
        })
        .style("opacity", function(d){            
          if (facets == 'on') {
            d3.select('#line_'+ d[params.key]).select('path').style('opacity',1);
            d3.select('#text_mark_' + d[params.key]).attr("class", 'text_mark');
            
            return 1;              
          }
          else {             
            
            d3.select('#line_'+ d[params.key]).select('path').style('opacity',0.5);
            d3.select('#text_mark_' + d[params.key]).attr("class", 'text_mark');
            
            return 0.5;
          }            
        })
        .attr("cy", function (d) {
          return d[params.y] != null ? scale_y(d[params.y]) : - facet_dim;
        })
        .attr("r", function (d) {
          return (d[params.y] != null && d[params.x] != null) ? scale_pop(Math.sqrt(d[params.radius])) : 0;
        })
        .attr('transform', function (d) {
          if (facets == 'on') {
            return 'translate(' + (facet_dim * (d[params.facet] % num_facet_cols)) + ',' + (facet_dim * Math.floor(d[params.facet] / num_facet_cols)) + ')';
          }
          else {
            return 'translate(0,0)';
          }
        }); 
        
        mark_transition.select('text')
        .attr("x", function (d) {         
          return facets == 'on' ? 0 : ((d[params.x] != null) ? scale_x(d[params.x]) : - facet_dim);
        })
        .attr("dy", facets == "on" ? '-1em' : '0em')        
        
        .attr("y", function (d) {
          return facets == 'on' ? 0 : (d[params.y] != null ? scale_y(d[params.y]) : - facet_dim);
        })
        .attr('transform', function (d) {
          if (facets == 'on') {
            return 'translate(' + (facet_dim * (d[params.facet] % num_facet_cols) + facet_dim * 0.5) + ',' + (facet_dim * Math.floor(d[params.facet] / num_facet_cols) + facet_dim) + ')';
          }
          else {
            return 'translate(0,0)';
          }
        });        
      }      

      function tweenYear() {
        var year = d3.interpolateNumber(params.yearMin,params.yearMax);
        var counter = 0;
        return function (t) {
          now = new Date();
          if (counter != Math.floor((t * animation_duration) / 100)) {
            displayYear(year(t));
          } 
          counter = Math.floor((t * animation_duration) / 100);
        };
      }

      function tweenCurrentYear() {
        var year = d3.interpolateNumber(current_year,params.yearMax);
        var counter = 0;
        return function (t) {
          now = new Date();
          if (counter != Math.floor((t * animation_duration) / 100)) {
            displayYear(year(t));
          } 
          counter = Math.floor((t * animation_duration) / 100);
        };
      }

      function displayYear(year) {        
       
        var progress =  ((year + 1) - params.yearMin) / ((params.yearMax + 1) - params.yearMin);
        if (globals.outer_progress_circle != undefined) {
          d3.select('#outer_progress_value').attr('d', globals.outer_progress_circle.endAngle((Math.PI * 2) * (loop_count + progress)));
        }
        
        current_year = year;
        circle_marks.data(interpolateData(year), function(d){
          return d[params.key];
        })
        .call(position)
        .sort(order);               
        
        d3.select('.year_indicator').text(facets == 'on' ? (params.yearMin + ' ― ' + params.yearMax) : Math.round(current_year));
        
      }

      var line = d3.line()
      .curve(d3.curveBasis)
      .x(function(d) { 
        return scale_x(d.param_x); 
      })
      .y(function(d) { 
        return scale_y(d.param_y); 
      });      

      function repeat() {
        if (animation == 'on') {            

          animation_duration = (params.yearMax - params.yearMin) * 500;
          this_chart.transition()
          .duration(animation_duration)
          .tween('year',tweenYear)
          .ease(d3.easeLinear)
          .on('end',function(){
            if (globals.trial_index > -1 && globals.num_selected == globals.trials[globals.trial_index].num_responses){
              d3.select('#progress_indicator').style('display','none');
              d3.select('#done_btn').attr('class','img_btn_enabled')
              .style('display',null)
              .attr('disabled',null)
              .attr('src', 'assets/done.svg');
            }
            else {
              d3.select('#submit_btn').attr('class','menu_btn_enabled')
              .attr('disabled',null);
            }
            loop_count++;
            if (!introduction_complete && globals.num_selected == 3) {              
              d3.select('#progress_indicator').style('display','none');
              d3.select('#done_btn').attr('class','img_btn_enabled')
              .style('display',null)
              .attr('disabled',null)
              .attr('src', 'assets/done.svg');
            }
            else {
              if (introduction_complete && loop_count > 0 && globals.num_selected == globals.trials[globals.trial_index].num_responses){
                d3.select('#done_btn').attr('class','img_btn_enabled')
                .attr('src', 'assets/done.svg');
              }
            }
            repeat();
          });
        }
        else {
          displayYear(current_year);
        }         
      }

      /**

      DATA ELEMENT ENTER

      **/

      // CIRCLES

      var circle_marks = this_chart.selectAll(".mark")
      .data(interpolateData(params.yearMin), function(d) {
        return d[params.key];
      });      

      // FACETS

      var facet_bounds = this_chart.selectAll(".facet")
      .data(data, function(d) {
        return d[params.key];
      });

      var facet_bound_enter = facet_bounds.enter()
      .append("g")
      .attr("class","facet")
      .attr("id", function (d) {
        return "facet_" + d[params.key];
      });
  
      facet_bound_enter.append('rect')
      .attr("class","facet_rect")      
      .attr("id", function (d) {
        return "facet_" + d[params.key];
      })
      .style("fill", facets == 'on' ? 'transparent' : 'none')
      .attr('width', facet_dim)
      .attr('height', facet_dim)
      .style("stroke-dasharray", '0.1em')
      .style("stroke", facets == 'on' ? '#666' : 'none')
      .attr('transform', function (d) {
        return 'translate(' + (facet_dim * (d[params.facet] % num_facet_cols)) + ',' + (facet_dim * Math.floor(d[params.facet] / num_facet_cols)) + ')';
      })
      .attr('rx', 5);             

      // LINES
            
      var line_marks = this_chart.selectAll(".line")
      .data(countries, function(d) {
        return d.id;
      });

      var line_mark_enter = line_marks.enter()
      .append("g")
      .attr("class","line")
      .attr("id", function (d) {
        return "line_" + d.id;
      });
  
      line_mark_enter.append('path')
      .attr("class","path_line")      
      .style("stroke", function (d) {
        return lines == 'on' ? scale_reg(d[params.color]) : 'transparent';
      })
      .style('fill','none')
      .attr("d", function(d) { 
        var tmp = d.values;           
        return line(tmp); 
      })
      .style("opacity", function(){
        if (facets == 'on') {
          return 1;
        }
        else {
          return 0.5;
        }
      })
      .attr('transform', function (d) {
        if (facets == 'on') {
          return 'translate(' + (facet_dim * (d[params.facet] % num_facet_cols)) + ',' + (facet_dim * Math.floor(d[params.facet] / num_facet_cols)) + ')';
        }
        else {
          return 'translate(0,0)';
        }
      });   
      
      //CIRCLE ENTER
      
      var circle_mark_enter = circle_marks.enter()
      .append("g")
      .attr("class","mark")
      .attr("id", function (d) {
        return "mark_" + d[params.key];
      });

      circle_mark_enter.append('circle')
      .attr("class", function (d) {
        return "circle_mark_" + d[params.key];
      })   
      .style("opacity", function(d){
        if (facets == 'on') {
          return 1;
        }
        else {
          return 0.5;
        }
      })
      .style("stroke", function(d){
        if (facets == 'on') {
          return '#999';
        }             
        else {
          return '#fff';
        }
      })
      .style("fill", function (d) {       
        return scale_reg(d[params.color]);
      });

      circle_mark_enter.append('text')
      .attr("class", 'text_mark')
      .attr('text-anchor', "middle")
      .attr('alignment-baseline','middle')
      .attr('id', function(d){
        return "text_mark_" + d[params.key];
      })
      .style('display',null)
      .text(function(d){
        return d[params.key];
      });

      circle_marks.call(position)
      .sort(order);  
      
      /**

      DATA ELEMENT UPDATE 

      **/

      repeat();    
      
      var facet_bound_update = facet_bounds.transition()
      .delay(function(d,i){
        return i * 10;
      })
      .duration(500);
      
      facet_bound_update.selectAll('rect.facet_rect')      
      .style("stroke", function(d){
        return facets == 'on' ? '#999' : 'none';              
      })
      .style("fill", facets == 'on' ? 'transparent' : 'none')
      .attr('transform', function (d) {
        return 'translate(' + (facet_dim * (d[params.facet] % num_facet_cols)) + ',' + (facet_dim * Math.floor(d[params.facet] / num_facet_cols)) + ')';
      });

      var line_mark_update = line_marks.transition()
      .delay(function(d,i){
        return i * 10;
      })
      .duration(500);

      line_mark_update.selectAll('path.path_line')
      .style("stroke", function (d) {
        return lines == 'on' ? scale_reg(d[params.color]) : 'transparent';
      })
      .attr("d", function(d) { 
        var tmp = d.values;   
        // for (var i = 0; i < tmp.length; i++) {
        //   if (tmp[i].param_x == null || tmp[i].param_y == null){
        //     tmp.splice(i,1);
        //   }
        // }
        // console.log(tmp);
        return line(tmp); 
      })
      .attr('transform', function (d) {
        if (facets == 'on') {
          return 'translate(' + (facet_dim * (d[params.facet] % num_facet_cols)) + ',' + (facet_dim * Math.floor(d[params.facet] / num_facet_cols)) + ')';
        }
        else {
          return 'translate(0,0)';
        }
      }); 
      
      /**

      DATA ELEMENT EXIT

      **/

      circle_marks.exit()      
      .remove();

      line_marks.exit()
      .remove();

      facet_bounds.exit()
      .remove();
    
    });
  }    

  /**

  GETTER / SETTER FUNCTIONS

  **/  

  //getter / setter for showing lines
  chart.lines = function (x) {
    if (!arguments.length) {
      return lines;
    }
    lines = x;
    return chart;
  };

  //getter / setter for animation
  chart.animation = function (x) {
    if (!arguments.length) {
      return animation;
    }
    animation = x;
    return chart;
  };

  //getter / setter for facets
  chart.facets = function (x) {
    if (!arguments.length) {
      return facets;
    }
    facets = x;
    return chart;
  };

  //getter / setter for current_year
  chart.current_year = function (x) {
    if (!arguments.length) {
      return current_year;
    }
    current_year = x;
    return chart;
  };
  
  //getter / setter for scale_pop
  chart.scale_pop = function (x) {
    if (!arguments.length) {
      return scale_pop;
    }
    scale_pop = x;
    return chart;
  };

  //getter / setter for scale_x
  chart.scale_x = function (x) {
    if (!arguments.length) {
      return scale_x;
    }
    scale_x = x;
    return chart;
  };

  //getter / setter for scale_y
  chart.scale_y = function (x) {
    if (!arguments.length) {
      return scale_y;
    }
    scale_y = x;
    return chart;
  };

  //getter / setter for scale_reg
  chart.scale_reg = function (x) {
    if (!arguments.length) {
      return scale_reg;
    }
    scale_reg = x;
    return chart;
  };

  //getter / setter for scale_tmp
  chart.scale_tmp = function (x) {
    if (!arguments.length) {
      return scale_tmp;
    }
    scale_tmp = x;
    return chart;
  };

  //getter / setter for scale_scroll
  chart.scale_scroll = function (x) {
    if (!arguments.length) {
      return scale_scroll;
    }
    scale_scroll = x;
    return chart;
  };

  //getter / setter for params
  chart.params = function (x) {
    if (!arguments.length) {
      return params;
    }
    params = x;
    return chart;
  };

  //getter / setter for this_chart
  chart.this_chart = function (x) {
    if (!arguments.length) {
      return this_chart;
    }
    this_chart = x;
    return chart;
  };
  
  //getter / setter for loop_count
  chart.loop_count = function (x) {
    if (!arguments.length) {
      return loop_count;
    }
    loop_count = x;
    return chart;
  };

  //getter / setter for caption_text
  chart.caption_text = function (x) {
    if (!arguments.length) {
      return caption_text;
    }
    caption_text = x;
    return chart;
  };
 
  return chart;

};

module.exports = d3.chart;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var d3 = __webpack_require__(1);
var nationData = __webpack_require__(2);
var globals = __webpack_require__(0); 

function countrySelector () {

  var checkExist;    
  globals.num_selected = 0;
  
  function getDims() {
    height = window.innerHeight;
    width = window.innerWidth;
    svg_dim = d3.min([height,width]) - 2;
    inner_padding = svg_dim * 0.1;
    chart_dim = svg_dim * 0.8;   
  }
  
  function redraw() {
  
    getDims();  

    d3.select('#selector_div').selectAll(".country_btn_enabled")
    .data(all_data, function(d) {
      return d.code;
    })
    .enter()
    .append('input')
    .attr('type','button')
    .attr('class', 'country_btn_enabled')
    .attr('id',function(d){
      return d.code + '_bttn';
    })
    .attr('value',function(d){
      return d.code;
    })
    .attr('title',function(d){
      return d.code;
    })
    .style('background',function(d){
      var scale_reg = chart_instance.scale_reg();
      var color_param = chart_instance.params().color;
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(scale_reg(d[color_param]));
      var rgb_result = result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
      return 'rgba(' + rgb_result.r + ',' + rgb_result.g + ',' + rgb_result.b + ',0.5)';
    })
    .style('height', function(){
      if (height < width) {
        return ((height / 8) - 4) + 'px';
      }
      else {
        var num_rows = all_data.length / 8;
        var menubar_height = (width / 7);
        var remaining_height = height - svg_dim - menubar_height - 10; 
        return (remaining_height / num_rows - 4) + 'px';
      }
    })
    .style('width', function(){
      if (height < width) {
        var num_cols = all_data.length / 8;
        var menubar_width = (height / 7);
        var remaining_width = width - svg_dim - menubar_width; 
        return (remaining_width / num_cols - 4) + 'px';
      }
      else {        
        return ((width / 8) - 4) + 'px';
      } 
    })
    .style('margin', '2px')
    .on('touchstart', function(d){
      d3.event.preventDefault(); 
      if (d3.select(this).style('border') == '5px solid gold') {
        globals.num_selected--;
        var unselected = globals.trial_response.indexOf(!introduction_complete ? d.code : d.name);
        globals.trial_response.splice(unselected,1);
        d3.select(this).style('border', '1px solid #ccc');

        if (introduction_complete && (globals.trial_index != -1 && globals.num_selected == globals.trials[globals.trial_index].num_responses && (chart_instance.loop_count() > 0 || chart_instance.lines() == 'on'))) {
          d3.select('#progress_indicator').style('display','none');
          d3.select('#done_btn').attr('class','img_btn_enabled')
          .style('display',null)
          .attr('disabled',null)
          .attr('src', 'assets/done.svg');

        }
        else {
          d3.select('#progress_indicator').style('display',null);
          d3.select('#outer_progress_indicator')
            .attr('display', globals.condition == 'multiples' ? 'none' : null);
          d3.select('#done_btn').attr('class','img_btn_disabled')
          .style('display','none')
          .attr('disabled',true)
          .attr('src', 'assets/na.svg');
        }
        
      }
      else {
        if ((!introduction_complete && globals.num_selected < 3) || (introduction_complete && globals.num_selected != globals.trials[globals.trial_index].num_responses)) {
          globals.num_selected++;
          globals.trial_response.push(!introduction_complete ? d.code : d.name);
          d3.select(this).style('border', '5px solid gold');    
          
          if (introduction_complete && (globals.trial_index != -1 && globals.num_selected == globals.trials[globals.trial_index].num_responses && (chart_instance.loop_count() > 0 || chart_instance.lines() == 'on'))) {
            d3.select('#progress_indicator').style('display','none');
            d3.select('#done_btn').attr('class','img_btn_enabled')
            .style('display',null)
            .attr('disabled',null)
            .attr('src', 'assets/done.svg');

          }
          else {
            d3.select('#progress_indicator').style('display',null);
            d3.select('#outer_progress_indicator')
            .attr('display', globals.condition == 'multiples' ? 'none' : null);
            d3.select('#done_btn').attr('class','img_btn_disabled')
            .style('display','none')
            .attr('disabled',true)
            .attr('src', 'assets/na.svg');
          }          
        }        
      }
      if (globals.outer_progress_circle != undefined) {
        if (!introduction_complete) {
          d3.select('#inner_progress_value').attr('d', globals.inner_progress_circle.endAngle((Math.PI * 2) * (globals.num_selected / 3)));
        }
        else {
          d3.select('#inner_progress_value').attr('d', globals.inner_progress_circle.endAngle((Math.PI * 2) * (globals.num_selected / globals.trials[globals.trial_index].num_responses)));
        }
      }
      if (!introduction_complete && globals.num_selected == 3) {        
        if (globals.condition == 'multiples' || chart_instance.loop_count() >= 1) {
          d3.select('#progress_indicator').style('display','none');
          d3.select('#done_btn').attr('class','img_btn_enabled')
          .style('display',null)
          .attr('disabled',null)
          .attr('src', 'assets/done.svg');
        } 
      }
    });    
    
  } 
  
  function loadData () {     

    checkExist = setInterval(function() {
      if (all_data != undefined) {        
        
        redraw();    
        
        hideAddressBar();

        clearInterval(checkExist);
      }
    }, 100); // check every 100ms  

  } 
    
  /** INIT **/

  getDims();
  
  d3.select('body').append('div')
  .attr('id','selector_div')
  .style('height', function(){
    if (height < width) {
      return (height) + 'px';
    }
    else {
      var menubar_height = (width / 7);
      var remaining_height = height - svg_dim - menubar_height - 10; 
      return (remaining_height) + 'px';
    }
  })
  .style('width', function(){
    if (height < width) {
      var menubar_width = (height / 7);
      var remaining_width = width - svg_dim - menubar_width; 
      return (remaining_width) + 'px';
    }
    else {        
      return (width) + 'px';
    }      
  })
  .style('bottom','0px')
  .style('float', (height < width) ? 'right' : 'unset')
  .style('left', (height < width) ? (svg_dim) + 'px' : 'unset')
  .style('position', 'absolute')
  .attr('tabindex',0);
  
  all_data = nationData;     
  loadData();

}

module.exports = countrySelector;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var d3 = __webpack_require__(1);
// var io = require('socket.io-client');
var preLoader = __webpack_require__(6);
var globals = __webpack_require__(0);
var initTasks = __webpack_require__(7);
var sandbox = __webpack_require__(9);
var consent = __webpack_require__(10);
var introduction = __webpack_require__(11);
var questionnaire = __webpack_require__(12);
var trial = __webpack_require__(21);
var countrySelector = __webpack_require__(4);
var menu = __webpack_require__(22);    
globals.userID = '1218_' + new Date().valueOf(); // CHANGE FOR PRODUCTION

if (window.location.href.indexOf('localhost') == -1) {
  var socket = io.connect({
    transports: ['websocket'],
    reconnect: true
  });
}
else {
  var socket = io.connect({
    transports: ['websocket'],
    reconnect: true
  });
}

socket.on('new_connection', function(msg) {
  console.log('new_connection', msg);
});

socket.on('new_participant', function(msg) {
  console.log('new_participant', msg);
  if (msg.user_id == globals.userID) {
    globals.participant = msg.participant;
    globals.condition = msg.condition;
    globals.ordering = msg.ordering;
    initTasks();
    loadMenu();
  }
});

socket.on('departure', function(msg) {
  console.log('departure: ', msg);
});

socket.on('completion', function(msg) {
  console.log('completion: ', msg);
});


function setCookie (c_name, value, exdays)
{
  var exdate = new Date();
  exdate.setDate(exdate.getDate() + exdays);
  var c_value = escape(value) + ((exdays==null) ? "" : "; expires="+exdate.toUTCString());
  document.cookie = c_name + "=" + c_value;
}

function getCookie (c_name)
{
   var i,x,y,ARRcookies=document.cookie.split(";");
   for (i=0;i<ARRcookies.length;i++)
    {
       x=ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));
          y=ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);
          x=x.replace(/^\s+|\s+$/g,"");
          if (x==c_name)
          {
              return unescape(y);
          }
    }
 }


/* jshint ignore:end */

window.addEventListener('load', function() { 

  imagesArray = [
    "assets/battery.svg",
    "assets/brightness.svg",
    "assets/done.svg",
    "assets/fullscreen.png",
    "assets/grid.svg",
    "assets/holdingphone.svg",
    "assets/line.svg",
    "assets/na.svg",
    "assets/next_gold.svg",
    "assets/next.svg",
    "assets/nonav.svg",
    "assets/play.svg",
    "assets/portrait.svg",
    "assets/prev_gold.svg",
    "assets/prev_grey.svg",
    "assets/prev.svg",
    "assets/wifi.svg"
  ];

  new preLoader(imagesArray, {
    onProgress: function(img, imageEl, index){
        // fires every time an image is done or errors.
        // imageEl will be falsy if error
        // console.log('just ' +  (!imageEl ? 'failed: ' : 'loaded: ') + img);
        // imageContainer.appendChild(imageEl);
        // can access any propery of this
        // console.log(this.completed.length + this.errors.length + ' / ' + this.queue.length + ' done');
    },
    onComplete: function(loaded, errors){
        // fires when whole list is done. cache is primed.
        // console.log('assets loaded:', loaded);
        // imageContainer.style.display = 'block';
        if (errors){
            console.log('the following failed', errors);
        }
    }
  });
  
  resumptions = [];
  globals.last_pause = new Date().valueOf();
  

  
  hideAddressBar();   

  globals.last_pause = new Date().valueOf();

  resumptions.push({
    'resumption_time': new Date().valueOf() + 1,
    'pause_time': globals.last_pause,
    'pause_duration': 1
  }); //app resumed

    
  d3.select('body').append('input')
  .attr('id','landscape_btn')
  .attr('type','button')
  .style('color','#111')
  .style('background','#ef5350')
  .style('border-color','#fff')
  .attr('value','Hold your phone in portrait mode.')
  .attr('title','Hold your phone in portrait mode.')
  .on('touchstart', function() {  
    d3.select('#landscape_btn').remove();
  }); 
  
});  

window.onfocus = function(e) {
  var r_time = new Date().valueOf();
  if (resumptions.length == 0 || globals.last_pause > resumptions[resumptions.length - 1].resumption_time && window.innerHeight > window.innerWidth) {
    resumptions.push({
      'resumption_time': r_time,
      'pause_time': globals.last_pause,
      'pause_type':'focus',
      'pause_duration': r_time - globals.last_pause
    }); //app resumed
  }
  
  globals.log_message = { 
    "TimeStamp": new Date().valueOf(),
    "user_id": globals.userID, 
    "Event": "InFocus",
    "Focus": true ,
    'resumption_time': r_time,
    'pause_time': globals.last_pause,
    'pause_type': 'focus',
    'pause_duration': r_time - globals.last_pause
  };
  
  console.log("InFocus", globals.log_message);

};

window.onblur = function(e) {
  if (resumptions.length == 0 || resumptions[resumptions.length - 1].resumption_time > globals.last_pause) {
    globals.last_pause = new Date().valueOf(); //app paused
  }

  globals.log_message = { 
    "TimeStamp": new Date().valueOf(),
    "Event": "FocusLoss",
    "user_id": globals.userID, 
    "Focus": false 
  };
  
  console.log("FocusLoss", globals.log_message);


};

window.onbeforeunload = function() { 
  socket.emit('unload', {
    userID: globals.userID,
    userAgent: navigator.userAgent
  });
  return "Your work will be lost."; 
};

window.onresize = function(e) {
  
  d3.select('#landscape_btn').remove();

  if (document.getElementById('landscape_btn')) {
    document.getElementById('landscape_btn').remove();
  }
  hideAddressBar();

  if (window.innerHeight < window.innerWidth) {
    if (resumptions[resumptions.length - 1].resumption_time > globals.last_pause) {
      globals.last_pause = new Date().valueOf(); //app paused
    }

    globals.log_message = { 
      "TimeStamp": new Date().valueOf(),
      "user_id": globals.userID, 
      "Event": "Resized",
      "Width": window.innerWidth, 
      "Height": window.innerHeight,
      "Mode": 'landscape' 
    };
    
    console.log("Resized", globals.log_message);


    d3.select('body').append('input')
    .attr('id','landscape_btn')
    .attr('type','button')
    .style('color','#111')
    .style('background','#ef5350')
    .style('border-color','#fff')
    .attr('value','Hold your phone in portrait mode.')
    .attr('title','Hold your phone in portrait mode.')
    .on('touchstart', function() {  
      d3.select('#landscape_btn').remove();
    });        
    
  }
  else {
    d3.select('#landscape_btn').remove();
    if (document.getElementById('landscape_btn')) {
      document.getElementById('landscape_btn').remove();
    }
    var r_time = new Date().valueOf();
    if (globals.last_pause > resumptions[resumptions.length - 1].resumption_time) {
      resumptions.push({
        'resumption_time': r_time,
        'pause_time': globals.last_pause,
        'pause_type': 'orientation',
        'pause_duration': r_time - globals.last_pause
      }); //app resumed
    }

    globals.log_message = { 
      "TimeStamp": new Date().valueOf(),
      "user_id": globals.userID, 
      "Event": "Resized",
      "Width": window.innerWidth, 
      "Height": window.innerHeight,
      "Orientation": 'portrait',
      'resumption_time': r_time,
      'pause_time': globals.last_pause,
      'pause_type': 'orientation',
      'pause_duration': r_time - globals.last_pause
    };
    
    console.log("Resized", globals.log_message);


  }  
};

d3.select("body")
.on("keydown", function () {    
  
  switch(d3.event.keyCode) {    

    case 27: // test override on 'Esc' and load menu
      test_override = true;
      consent_complete = true;
      introduction_complete = true;

      globals.trial_index = -1;

      globals.animation = 'off';
      globals.lines = 'off';
      globals.facets = 'off';

      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "Event": "Escape",
        "user_id": globals.userID
      };
      
      console.log("Escape", globals.log_message);


      if (document.getElementById('selector_div') != undefined) {      
        document.getElementById('selector_div').remove();                    
      } 
     
      if (document.getElementsByTagName('div')[0] != undefined) {        
               
        document.getElementsByTagName('div')[0].remove();   
        
        globals.log_message = { 
          "TimeStamp": new Date().valueOf(),
          "Event": "TestOverride_Load_Menu",
          "user_id": globals.userID
        };
        
        console.log("TestOverride_Load_Menu", globals.log_message);


        loadMenu();
        hideAddressBar();
      }           
    break;    

    default:      
    break;
  }    

});

loadSandbox = function () {

  globals.trial_index = 0;
  test_override = true;    

  globals.log_message = { 
    "TimeStamp": new Date().valueOf(),
    "Event": "SandBox_Open",
    "user_id": globals.userID
  };
  
  console.log("SandBox_Open", globals.log_message);


  setTimeout(function(){
    // Hide the address bar!
		sandbox();  
  }, 100);
  hideAddressBar(); 
};

loadMenu = function () {
  
  menu(); 

  d3.select('#consent_btn')
  .on('touchstart', function() {    
    if (test_override || !consent_complete) {
      document.getElementById('menu_div').remove();
      
      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "user_id": globals.userID,
        "Event": "ConsentStart",
        "ordering": globals.ordering,
        "condition": globals.condition,
        "Width": window.innerWidth, 
        "Height": window.innerHeight,
        "Scene": 0
      };
      
      console.log("ConsentStart", globals.log_message);

      
      consent(0);
      hideAddressBar();
    }  
  });

  d3.select('#introduction_btn')
  .on('touchstart', function() {      
    if (test_override || (!introduction_complete && consent_complete)) {
      document.getElementById('menu_div').remove();
      
      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "user_id": globals.userID,
        "Event": "IntroStart",
        "Scene": 0
      };
      
      console.log("IntroStart", globals.log_message);

      
      introduction(0);
      hideAddressBar();
    }
  });

  d3.select('#trial_btn')
  .on('touchstart', function() {

    if (test_override || introduction_complete) {
      globals.trial_index = -1;  
      test_override = false;  
      
      switch (globals.condition) {
  
        case 'stepper':
  
          globals.animation = 'off';
          globals.lines = 'off';
          globals.facets = 'off';
          break;
  
        case 'animation':
  
          globals.animation = 'on';
          globals.lines = 'off';
          globals.facets = 'off';
          break;
  
        case 'multiples':
  
          globals.animation = 'off';
          globals.lines = 'on';
          globals.facets = 'on';
          break;
  
        default:
  
          globals.animation = 'off';
          globals.lines = 'off';
          globals.facets = 'off';
          break;
      }   

      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "Event": "Experiment_Start",
        "condition": globals.condition,
        "ordering": globals.ordering,
        "user_id": globals.userID,
        "Width": window.innerWidth, 
        "Height": window.innerHeight
      };
      
      console.log("Experiment_Start", globals.log_message);

  
      document.getElementById('menu_div').remove();   
      trial();  
      countrySelector();
      hideAddressBar();   
    }
  });

  d3.select('#questionnaire_btn')
  .on('touchstart', function() {    
    if (test_override || experiment_complete) {
      document.getElementById('menu_div').remove();

      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "user_id": globals.userID,
        "Event": "SurveyStart",
        "condition": globals.condition,
        "ordering": globals.ordering,
        "Width": window.innerWidth, 
        "Height": window.innerHeight,
        "Scene": 0
      };
      
      console.log("SurveyStart", globals.log_message);


      socket.emit('questionnaire', globals.userID);
      questionnaire(0);
      hideAddressBar();
    }  
  });

  d3.select('#secret_sandbox')
  .on('touchstart', function() {  
    document.getElementById('menu_div').remove(); 
    globals.trial_index = 0;
    test_override = true;    

    globals.log_message = { 
      "TimeStamp": new Date().valueOf(),
      "Event": "SandBox_Open",
      "user_id": globals.userID
    };
    
    console.log("SandBox_Open", globals.log_message);


    sandbox();
    hideAddressBar();   
  });
};

 if (getCookie('visited')) {
  // alert('You have already participated in this study.'); //COMMENT FOR TESTING

  globals.log_message = { 
    "TimeStamp": new Date().valueOf(),
    "Event": "RepeatParticipant",
    "userAgent": navigator.userAgent,
    "user_id": globals.userID
  };
  
  console.log("RepeatParticipant", globals.log_message);


  socket.emit('userID', {
    userID: globals.userID,
    userAgent: navigator.userAgent
  }); //COMMENT FOR PRODUCTION
 }
 else {
  setCookie('visited',1,365);

   globals.log_message = { 
    "TimeStamp": new Date().valueOf(),
    "Event": "NewParticipant",
    "userAgent": navigator.userAgent,
    "user_id": globals.userID
  };
  
  console.log("NewParticipant", globals.log_message);


  socket.emit('userID', {
    userID: globals.userID,
    userAgent: navigator.userAgent
  });  
 }

d3.select('body').append('svg')
.style('display','none')
.attr('xmlns','http://www.w3.org/2000/svg')
.attr('version','1.1')
.attr('height','0')
.append('filter')
.attr('id','myblurfilter')
.attr('width','110%')
.attr('height','110%')
.append('feGaussianBlur')
.attr('stdDeviation','30')
.attr('result','blur');

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;;(function(){
	'use strict';

	// can we support addEventListener
	var hasNative = 'addEventListener' in (new Image());

	/**
	 * @constructor
	 * @param {Array} images - string of images to load
	 * @param {Object=} options - overrides to defaults
	 */
	var PreLoader = function(images, options){
		this.options = {
			pipeline: false,
			auto: true,
			prefetch: false,
			/* onProgress: function(){}, */
			/* onError: function(){}, */
			onComplete: function(){}
		};

		options && typeof options == 'object' && this.setOptions(options);

		this.addQueue(images);
		this.queue.length && this.options.auto && this.processQueue();
	};

	/**
	 * naive shallow copy/reference from options into proto options
	 * @param {Object} options
	 * @returns {PreLoader}
	 */
	PreLoader.prototype.setOptions = function(options){
		// shallow copy
		var o = this.options,
			key;

		for (key in options) options.hasOwnProperty(key) && (o[key] = options[key]);

		return this;
	};

	/**
	 * stores a local array, dereferenced from original
	 * @param images
	 * @returns {PreLoader}
	 */
	PreLoader.prototype.addQueue = function(images){
		this.queue = images.slice();

		return this;
	};

	/**
	 * reset the arrays
	 * @returns {PreLoader}
	 */
	PreLoader.prototype.reset = function(){
		this.completed = [];
		this.errors = [];

		return this;
	};

	/**
	 * Subscribe to events for an imag object and a source
	 * @param {Object} image
	 * @param {String} src
	 * @param {Number} index
	 * @returns {PreLoader}
	 * @private
	 */
	PreLoader.prototype._addEvents = function(image, src, index){
		var self = this,
			o = this.options,
			cleanup = function(){
				if (hasNative){
					this.removeEventListener('error', abort);
					this.removeEventListener('abort', abort);
					this.removeEventListener('load', load);
				}
				else {
					this.onerror = this.onabort = this.onload = null;
				}
			},
			abort = function(){
				cleanup.call(this);

				self.errors.push(src);
				o.onError && o.onError.call(self, src);
				_checkProgress.call(self, src);
				o.pipeline && self._loadNext(index);
			},
			load = function(){
				cleanup.call(this);

				// store progress. this === image
				self.completed.push(src); // this.src may differ
				_checkProgress.call(self, src, this);
				o.pipeline && self._loadNext(index);
			};

		if (hasNative){
			image.addEventListener('error', abort, false);
			image.addEventListener('abort', abort, false);
			image.addEventListener('load', load, false);
		}
		else {
			image.onerror = image.onabort = abort;
			image.onload = load;
		}

		return this;
	};

	/**
	 * Private API to load an image
	 * @param {String} src
	 * @param {Number} index
	 * @returns {PreLoader}
	 * @private
	 */
	PreLoader.prototype._load = function(src, index){
		/*jshint -W058 */
		var image = new Image;

		this._addEvents(image, src, index);

		// actually load
		image.src = src;

		return this;
	};

	/**
	 * Move up the queue index
	 * @param {Number} index
	 * @returns {PreLoader}
	 * @private
	 */
	PreLoader.prototype._loadNext = function(index){
		// when pipeline loading is enabled, calls next item
		index++;
		this.queue[index] && this._load(this.queue[index], index);

		return this;
	};

	/**
	 * Iterates through the queue of images to load
	 * @returns {PreLoader}
	 */
	PreLoader.prototype.processQueue = function(){
		// runs through all queued items.
		var i = 0,
			queue = this.queue,
			len = queue.length;

		// process all queue items
		this.reset();

		if (!this.options.pipeline) for (; i < len; ++i) this._load(queue[i], i);
		else this._load(queue[0], 0);

		return this;
	};

	/*jshint validthis:true */
	/**
	 * Internal checker on the queue progress
	 * @param {String} src
	 * @param {Object} image
	 * @returns {PreLoader}
	 * @private
	 */
	function _checkProgress(src, image){
		// intermediate checker for queue remaining. not exported.
		// called on preLoader instance as scope
		var args = [],
			o = this.options;

		// call onProgress
		o.onProgress && src && o.onProgress.call(this, src, image, this.completed.length);

		if (this.completed.length + this.errors.length === this.queue.length){
			args.push(this.completed);
			this.errors.length && args.push(this.errors);
			o.onComplete.apply(this, args);
		}

		return this;
	}
	/*jshint validthis:false */

	/**
	 * Static method that loads images lazily from DOM based upon data-preload attribute
	 * @param {Object} options= optional options to pass to PreLoader
	 * @returns {PreLoader} instance
	 */
	PreLoader.lazyLoad = function(options){
		if (!options)
			options = {};

		var lazyImages = document.querySelectorAll(options.selector || 'img[data-preload]'),
			i = 0,
			l = lazyImages.length,
			toLoad = [],
			oldProgress;

		for (; i < l; i++) toLoad.push(lazyImages[i].getAttribute('data-preload'));

		options.onProgress && (oldProgress = options.onProgress);
		options.onProgress = function(item, imgEl, index){
			lazyImages[index-1].src = item;
			lazyImages[index-1].removeAttribute('data-preload');
			oldProgress && oldProgress.apply(this, arguments);
		};

		return toLoad.length ? new PreLoader(toLoad, options) : null;
	};

	if (true){
		// we have an AMD loader.
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){
			return PreLoader;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else {
		this.preLoader = PreLoader;
	}
}).call(this);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var globals = __webpack_require__(0);
var nationData = __webpack_require__(2);
var taskList = __webpack_require__(8);

function initTasks() {

  nationData.forEach(function (d){ 
    d.orig_code = d.code;
  });

  globals.trials = taskList[globals.ordering];    

  max_trials = globals.trials.length;

  // globals.trials = tutorial_tasks.concat(test_tasks);
  console.log('task_list', globals.trials);

  globals.log_message = { 
    "TimeStamp": new Date().valueOf(),
    "user_id": globals.userID, 
    "participant": globals.participant,
    "ordering": globals.ordering,
    "condition": globals.condition,
    "Event":"Load",
    "Width": window.innerWidth, 
    "Height": window.innerHeight,
    "Mode": (window.innerWidth > window.innerHeight) ? 'landscape' : 'portrait'
  };

  console.log("Load", globals.log_message);


}

module.exports = initTasks;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

var taskList = [
	// [  
	// 	{
	// 		"task_index": -3,
	// 		"x": "Energy Consumption",
	// 		"y": "GDP Per Capita",
	// 		"prompt": "Select the country that had the largest change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
	// 		"num_responses": 1,
	// 		"correct_responses": ["Norway"],
	// 		"yearMin": 1980,
	// 		"yearMax": 2000,
	// 		"tutorial": true,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": -2,
	// 		"x": "Number of Personal Computers",
	// 		"y": "GDP Per Capita",
	// 		"prompt": "Select <span class='instruction_number'>three</span> countries with rapid growth in the <span class='instruction_emphasis'>Number of Personal Computers</span> between 1985 and 2000.",
	// 		"num_responses": 3,
	// 		"correct_responses": ["Denmark","Iceland","Norway","Sweden","United States","Australia"],
	// 		"yearMin": 1985,
	// 		"yearMax": 2000,
	// 		"tutorial": true,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": -1,
	// 		"x": "Number of Personal Computers",
	// 		"y": "Life Expectancy",
	// 		"prompt": "Select <span class='instruction_number'>one</span> foo country with little growth in the <span class='instruction_emphasis'>Number of Personal Computers</span>.",
	// 		"num_responses": 1,
	// 		"correct_responses": ["Hungary"],
	// 		"yearMin": 1985,
	// 		"yearMax": 2000,
	// 		"tutorial": true,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": 0,
	// 		"x": "Population",
	// 		"y": "GDP Per Capita",
	// 		"prompt": "Select the <span class='instruction_number'>two</span> countries having the largest <span class='instruction_emphasis'>Population</span> in the year 2000.",
	// 		"num_responses": 2,
	// 		"correct_responses": ["India","China"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": true
	// 	},
	// 	{
	// 		"task_index": 1,
	// 		"x": "Indexed Energy Consumption",
	// 		"y": "Indexed GDP",
	// 		"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Energy Consumption</span> grew faster than their <span class='instruction_emphasis'>Indexed GDP</span>.",
	// 		"num_responses": 2,
	// 		"correct_responses": ["India","China"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": 2,
	// 		"x": "Energy Consumption",
	// 		"y": "GDP Per Capita",
	// 		"prompt": "Select <span class='instruction_number'>three</span> countries that had little change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
	// 		"num_responses": 3,
	// 		"correct_responses": ["Gambia","Liberia","Rwanda"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": false
	// 	},	
	// 	{
	// 		"task_index": 3,
	// 		"x": "Life Expectancy",
	// 		"y": "Infant Mortality",
	// 		"prompt": "Select <span class='instruction_number'>one</span> country with a decreasing <span class='instruction_emphasis'>Infant Mortality</span> rate, but little change in <span class='instruction_emphasis'>Life Expectancy</span>.",
	// 		"num_responses": 1,
	// 		"correct_responses": ["Hungary"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": 4,
	// 		"x": "Life Expectancy",
	// 		"y": "Infant Mortality",
	// 		"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased first, then increased later.",
	// 		"num_responses": 2,
	// 		"correct_responses": ["Liberia","Rwanda"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": 5,
	// 		"x": "Life Expectancy",
	// 		"y": "Infant Mortality",
	// 		"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased the most.",
	// 		"num_responses": 2,
	// 		"correct_responses": ["Gambia","Saudi Arabia"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": 6,
	// 		"x": "Indexed Energy Consumption",
	// 		"y": "Indexed Population",
	// 		"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Population</span> grew faster than their <span class='instruction_emphasis'>Indexed Energy Consumption</span>.",
	// 		"num_responses": 2,
	// 		"correct_responses": ["India","China"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": 7,
	// 		"x": "Life Expectancy (Women)",
	// 		"y": "Life Expectancy (Men)",
	// 		"prompt": "Select <span class='instruction_number'>one</span> country where <span class='instruction_emphasis'>Life Expectancy</span> (<span class='instruction_emphasis'>Women</span> & <span class='instruction_emphasis'>Men</span>) increased first and decreased later.",
	// 		"num_responses": 1,
	// 		"correct_responses": ["Liberia","Rwanda"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": 8,
	// 		"x": "Arable Area",
	// 		"y": "Population",
	// 		"prompt": "Select <span class='instruction_number'>one</span> country that had a decrease in <span class='instruction_emphasis'>Arable Area</span>, even as their <span class='instruction_emphasis'>Population</span> increased.",
	// 		"num_responses": 1,
	// 		"correct_responses": ["United States"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": false
	// 	},
	// 	{
	// 		"task_index": 9,
	// 		"x": "Arable Area",
	// 		"y": "Population",
	// 		"prompt": "Select <span class='instruction_number'>one</span> country that had an increase in <span class='instruction_emphasis'>Arable Area</span>, but only a slight increase in <span class='instruction_emphasis'>Population</span>.",
	// 		"num_responses": 1,
	// 		"correct_responses": ["Australia"],
	// 		"yearMin": 1975,
	// 		"yearMax": 2000,
	// 		"tutorial": false,
	// 		"quality_control": false
	// 	}
	// ],
	[
		{
			"task_index": -3,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select the country that had the largest change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Norway"
			],
			"yearMin": 1980,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -2,
			"x": "Number of Personal Computers",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries with rapid growth in the <span class='instruction_emphasis'>Number of Personal Computers</span> between 1985 and 2000.",
			"num_responses": 3,
			"correct_responses": [
				"Denmark",
				"Iceland",
				"Norway",
				"Sweden",
				"United States",
				"Australia"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -1,
			"x": "Number of Personal Computers",
			"y": "Life Expectancy",
			"prompt": "Select <span class='instruction_number'>one</span> foo country with little growth in the <span class='instruction_emphasis'>Number of Personal Computers</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": 1,
			"x": "Indexed Energy Consumption",
			"y": "Indexed GDP",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Energy Consumption</span> grew faster than their <span class='instruction_emphasis'>Indexed GDP</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 0,
			"x": "Population",
			"y": "GDP Per Capita",
			"prompt": "Select the <span class='instruction_number'>two</span> countries having the largest <span class='instruction_emphasis'>Population</span> in the year 2000.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": true
		},
		{
			"task_index": 3,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>one</span> country with a decreasing <span class='instruction_emphasis'>Infant Mortality</span> rate, but little change in <span class='instruction_emphasis'>Life Expectancy</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 9,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had an increase in <span class='instruction_emphasis'>Arable Area</span>, but only a slight increase in <span class='instruction_emphasis'>Population</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Australia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 4,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased first, then increased later.",
			"num_responses": 2,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 8,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had a decrease in <span class='instruction_emphasis'>Arable Area</span>, even as their <span class='instruction_emphasis'>Population</span> increased.",
			"num_responses": 1,
			"correct_responses": [
				"United States"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 2,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries that had little change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 3,
			"correct_responses": [
				"Gambia",
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 7,
			"x": "Life Expectancy (Women)",
			"y": "Life Expectancy (Men)",
			"prompt": "Select <span class='instruction_number'>one</span> country where <span class='instruction_emphasis'>Life Expectancy</span> (<span class='instruction_emphasis'>Women</span> & <span class='instruction_emphasis'>Men</span>) increased first and decreased later.",
			"num_responses": 1,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 5,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased the most.",
			"num_responses": 2,
			"correct_responses": [
				"Gambia",
				"Saudi Arabia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 6,
			"x": "Indexed Energy Consumption",
			"y": "Indexed Population",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Population</span> grew faster than their <span class='instruction_emphasis'>Indexed Energy Consumption</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		}
	],
	[
		{
			"task_index": -3,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select the country that had the largest change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Norway"
			],
			"yearMin": 1980,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -2,
			"x": "Number of Personal Computers",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries with rapid growth in the <span class='instruction_emphasis'>Number of Personal Computers</span> between 1985 and 2000.",
			"num_responses": 3,
			"correct_responses": [
				"Denmark",
				"Iceland",
				"Norway",
				"Sweden",
				"United States",
				"Australia"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -1,
			"x": "Number of Personal Computers",
			"y": "Life Expectancy",
			"prompt": "Select <span class='instruction_number'>one</span> foo country with little growth in the <span class='instruction_emphasis'>Number of Personal Computers</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": 3,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>one</span> country with a decreasing <span class='instruction_emphasis'>Infant Mortality</span> rate, but little change in <span class='instruction_emphasis'>Life Expectancy</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 6,
			"x": "Indexed Energy Consumption",
			"y": "Indexed Population",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Population</span> grew faster than their <span class='instruction_emphasis'>Indexed Energy Consumption</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 4,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased first, then increased later.",
			"num_responses": 2,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 9,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had an increase in <span class='instruction_emphasis'>Arable Area</span>, but only a slight increase in <span class='instruction_emphasis'>Population</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Australia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 2,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries that had little change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 3,
			"correct_responses": [
				"Gambia",
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 8,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had a decrease in <span class='instruction_emphasis'>Arable Area</span>, even as their <span class='instruction_emphasis'>Population</span> increased.",
			"num_responses": 1,
			"correct_responses": [
				"United States"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 7,
			"x": "Life Expectancy (Women)",
			"y": "Life Expectancy (Men)",
			"prompt": "Select <span class='instruction_number'>one</span> country where <span class='instruction_emphasis'>Life Expectancy</span> (<span class='instruction_emphasis'>Women</span> & <span class='instruction_emphasis'>Men</span>) increased first and decreased later.",
			"num_responses": 1,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 0,
			"x": "Population",
			"y": "GDP Per Capita",
			"prompt": "Select the <span class='instruction_number'>two</span> countries having the largest <span class='instruction_emphasis'>Population</span> in the year 2000.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": true
		},
		{
			"task_index": 5,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased the most.",
			"num_responses": 2,
			"correct_responses": [
				"Gambia",
				"Saudi Arabia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 1,
			"x": "Indexed Energy Consumption",
			"y": "Indexed GDP",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Energy Consumption</span> grew faster than their <span class='instruction_emphasis'>Indexed GDP</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		}
	],
	[
		{
			"task_index": -3,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select the country that had the largest change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Norway"
			],
			"yearMin": 1980,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -2,
			"x": "Number of Personal Computers",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries with rapid growth in the <span class='instruction_emphasis'>Number of Personal Computers</span> between 1985 and 2000.",
			"num_responses": 3,
			"correct_responses": [
				"Denmark",
				"Iceland",
				"Norway",
				"Sweden",
				"United States",
				"Australia"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -1,
			"x": "Number of Personal Computers",
			"y": "Life Expectancy",
			"prompt": "Select <span class='instruction_number'>one</span> foo country with little growth in the <span class='instruction_emphasis'>Number of Personal Computers</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": 4,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased first, then increased later.",
			"num_responses": 2,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 1,
			"x": "Indexed Energy Consumption",
			"y": "Indexed GDP",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Energy Consumption</span> grew faster than their <span class='instruction_emphasis'>Indexed GDP</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 5,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased the most.",
			"num_responses": 2,
			"correct_responses": [
				"Gambia",
				"Saudi Arabia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 9,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had an increase in <span class='instruction_emphasis'>Arable Area</span>, but only a slight increase in <span class='instruction_emphasis'>Population</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Australia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 3,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>one</span> country with a decreasing <span class='instruction_emphasis'>Infant Mortality</span> rate, but little change in <span class='instruction_emphasis'>Life Expectancy</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 0,
			"x": "Population",
			"y": "GDP Per Capita",
			"prompt": "Select the <span class='instruction_number'>two</span> countries having the largest <span class='instruction_emphasis'>Population</span> in the year 2000.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": true
		},
		{
			"task_index": 7,
			"x": "Life Expectancy (Women)",
			"y": "Life Expectancy (Men)",
			"prompt": "Select <span class='instruction_number'>one</span> country where <span class='instruction_emphasis'>Life Expectancy</span> (<span class='instruction_emphasis'>Women</span> & <span class='instruction_emphasis'>Men</span>) increased first and decreased later.",
			"num_responses": 1,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 2,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries that had little change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 3,
			"correct_responses": [
				"Gambia",
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 8,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had a decrease in <span class='instruction_emphasis'>Arable Area</span>, even as their <span class='instruction_emphasis'>Population</span> increased.",
			"num_responses": 1,
			"correct_responses": [
				"United States"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 6,
			"x": "Indexed Energy Consumption",
			"y": "Indexed Population",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Population</span> grew faster than their <span class='instruction_emphasis'>Indexed Energy Consumption</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		}
	],
	[
		{
			"task_index": -3,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select the country that had the largest change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Norway"
			],
			"yearMin": 1980,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -2,
			"x": "Number of Personal Computers",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries with rapid growth in the <span class='instruction_emphasis'>Number of Personal Computers</span> between 1985 and 2000.",
			"num_responses": 3,
			"correct_responses": [
				"Denmark",
				"Iceland",
				"Norway",
				"Sweden",
				"United States",
				"Australia"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -1,
			"x": "Number of Personal Computers",
			"y": "Life Expectancy",
			"prompt": "Select <span class='instruction_number'>one</span> foo country with little growth in the <span class='instruction_emphasis'>Number of Personal Computers</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": 6,
			"x": "Indexed Energy Consumption",
			"y": "Indexed Population",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Population</span> grew faster than their <span class='instruction_emphasis'>Indexed Energy Consumption</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 8,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had a decrease in <span class='instruction_emphasis'>Arable Area</span>, even as their <span class='instruction_emphasis'>Population</span> increased.",
			"num_responses": 1,
			"correct_responses": [
				"United States"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 5,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased the most.",
			"num_responses": 2,
			"correct_responses": [
				"Gambia",
				"Saudi Arabia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 0,
			"x": "Population",
			"y": "GDP Per Capita",
			"prompt": "Select the <span class='instruction_number'>two</span> countries having the largest <span class='instruction_emphasis'>Population</span> in the year 2000.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": true
		},
		{
			"task_index": 7,
			"x": "Life Expectancy (Women)",
			"y": "Life Expectancy (Men)",
			"prompt": "Select <span class='instruction_number'>one</span> country where <span class='instruction_emphasis'>Life Expectancy</span> (<span class='instruction_emphasis'>Women</span> & <span class='instruction_emphasis'>Men</span>) increased first and decreased later.",
			"num_responses": 1,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 3,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>one</span> country with a decreasing <span class='instruction_emphasis'>Infant Mortality</span> rate, but little change in <span class='instruction_emphasis'>Life Expectancy</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 2,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries that had little change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 3,
			"correct_responses": [
				"Gambia",
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 4,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased first, then increased later.",
			"num_responses": 2,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 1,
			"x": "Indexed Energy Consumption",
			"y": "Indexed GDP",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Energy Consumption</span> grew faster than their <span class='instruction_emphasis'>Indexed GDP</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 9,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had an increase in <span class='instruction_emphasis'>Arable Area</span>, but only a slight increase in <span class='instruction_emphasis'>Population</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Australia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		}
	],
	[
		{
			"task_index": -3,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select the country that had the largest change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Norway"
			],
			"yearMin": 1980,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -2,
			"x": "Number of Personal Computers",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries with rapid growth in the <span class='instruction_emphasis'>Number of Personal Computers</span> between 1985 and 2000.",
			"num_responses": 3,
			"correct_responses": [
				"Denmark",
				"Iceland",
				"Norway",
				"Sweden",
				"United States",
				"Australia"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": -1,
			"x": "Number of Personal Computers",
			"y": "Life Expectancy",
			"prompt": "Select <span class='instruction_number'>one</span> foo country with little growth in the <span class='instruction_emphasis'>Number of Personal Computers</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1985,
			"yearMax": 2000,
			"tutorial": true,
			"quality_control": false
		},
		{
			"task_index": 7,
			"x": "Life Expectancy (Women)",
			"y": "Life Expectancy (Men)",
			"prompt": "Select <span class='instruction_number'>one</span> country where <span class='instruction_emphasis'>Life Expectancy</span> (<span class='instruction_emphasis'>Women</span> & <span class='instruction_emphasis'>Men</span>) increased first and decreased later.",
			"num_responses": 1,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 2,
			"x": "Energy Consumption",
			"y": "GDP Per Capita",
			"prompt": "Select <span class='instruction_number'>three</span> countries that had little change in <span class='instruction_emphasis'>GDP Per Capita</span>.",
			"num_responses": 3,
			"correct_responses": [
				"Gambia",
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 5,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased the most.",
			"num_responses": 2,
			"correct_responses": [
				"Gambia",
				"Saudi Arabia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 6,
			"x": "Indexed Energy Consumption",
			"y": "Indexed Population",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Population</span> grew faster than their <span class='instruction_emphasis'>Indexed Energy Consumption</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 4,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Infant Mortality</span> rate decreased first, then increased later.",
			"num_responses": 2,
			"correct_responses": [
				"Liberia",
				"Rwanda"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 1,
			"x": "Indexed Energy Consumption",
			"y": "Indexed GDP",
			"prompt": "Select <span class='instruction_number'>two</span> countries whose <span class='instruction_emphasis'>Indexed Energy Consumption</span> grew faster than their <span class='instruction_emphasis'>Indexed GDP</span>.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 3,
			"x": "Life Expectancy",
			"y": "Infant Mortality",
			"prompt": "Select <span class='instruction_number'>one</span> country with a decreasing <span class='instruction_emphasis'>Infant Mortality</span> rate, but little change in <span class='instruction_emphasis'>Life Expectancy</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Hungary"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 8,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had a decrease in <span class='instruction_emphasis'>Arable Area</span>, even as their <span class='instruction_emphasis'>Population</span> increased.",
			"num_responses": 1,
			"correct_responses": [
				"United States"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		},
		{
			"task_index": 0,
			"x": "Population",
			"y": "GDP Per Capita",
			"prompt": "Select the <span class='instruction_number'>two</span> countries having the largest <span class='instruction_emphasis'>Population</span> in the year 2000.",
			"num_responses": 2,
			"correct_responses": [
				"India",
				"China"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": true
		},
		{
			"task_index": 9,
			"x": "Arable Area",
			"y": "Population",
			"prompt": "Select <span class='instruction_number'>one</span> country that had an increase in <span class='instruction_emphasis'>Arable Area</span>, but only a slight increase in <span class='instruction_emphasis'>Population</span>.",
			"num_responses": 1,
			"correct_responses": [
				"Australia"
			],
			"yearMin": 1975,
			"yearMax": 2000,
			"tutorial": false,
			"quality_control": false
		}
	]
];

module.exports = taskList;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var d3 = __webpack_require__(1);
var globals = __webpack_require__(0);
var chart = __webpack_require__(3);
var nationData = __webpack_require__(2);

function sandbox () {

  suppress_touch_val_feedback = false;
  suppress_touch_feedback = false;
  globals.trial_response = [];
  
  var checkExist;    
  var checkTouch;
  
  function getDims() {
    height = window.innerHeight;
    width = window.innerWidth;
    svg_dim = d3.min([height,width]) - 2;
    inner_padding = svg_dim * 0.1;
    chart_dim = svg_dim * 0.8;
  }
  
  function draw() {
  
    getDims();
        
    d3.select('#main_svg')
    .style('height',svg_dim + 'px')
    .style('width',svg_dim + 'px');

    d3.select('#selector_div')
    .style('height', function(){
    if (height < width) {
      return (height) + 'px';
    }
    else {
      var menubar_height = width / 7;
      var remaining_height = height - svg_dim - menubar_height - 10; 
      return (remaining_height) + 'px';
    }
    })
    .style('width', function(){
      if (height < width) {
        var menubar_width = height / 7;
        var remaining_width = width - svg_dim - menubar_width; 
        return (remaining_width) + 'px';
      }
      else {        
        return (width) + 'px';
      }      
    })
    .style('float', (height < width) ? 'right' : 'unset')
    .style('left', (height < width) ? (svg_dim) + 'px' : 'unset');
      

    chart_g.attr('transform','translate(' + inner_padding + ',' + inner_padding + ')');
  
    d3.selectAll('.guide').remove();
    chart_instance.lines('off'); 
    chart_instance.animation('off');
    chart_instance.facets('off');
    chart_instance.current_year(globals.param_yearMin);

    chart_g.call(chart_instance);
    chart_g.call(chart_instance);    
  
    d3.selectAll('.toolbar')
    .style('position','absolute')
    .style('top', height < width ? '0px' : (svg_dim) + 'px')
    .style('right', height < width ? '0px' : 'unset')
    .style('width', height < width ? (height / 7) + 'px'  : width + 'px')
    .style('height',  height < width ? height + 'px'  : (width / 7) + 'px');
  
    d3.selectAll('.img_btn_enabled')
    .style('margin', height < width ? '0px' : '2px')
    .style('height', height < width ? (height / 7 - 6) + 'px' : (width / 7 - 6) + 'px')
    .style('width', width < height ? (width / 7 - 6) + 'px' : (height / 7 - 6) + 'px'); 

    // d3.select('#sandbox_div')
    // .style('height', function(){
    //   return svg_dim + (height < width ? (height / 7 - 6) : (width / 7 - 6)) + 'px'; 
    // });

  }
  
  function toggleLines () {
    chart_instance.this_chart().interrupt();
    if (chart_instance.lines() == "on") {
      chart_instance.lines("off");
    }
    else if (chart_instance.lines() == "off") {
      chart_instance.lines("on"); 
    }
    chart_g.call(chart_instance);
    globals.log_message = { 
      "TimeStamp": new Date().valueOf(),
      "user_id": globals.userID, 
      "Event": "SandBoxEvent",
      "EventType": "toggleLines", 
      "Status": chart_instance.lines()
    };
    console.log("SandBoxEvent", globals.log_message);


    document.getElementById('sandbox_div').focus();
  }

  function toggleAnimate () {
    chart_instance.this_chart().interrupt();
    if (chart_instance.animation() == "on") {
      chart_instance.current_year(Math.floor(chart_instance.current_year()));
      chart_instance.animation("off");
      d3.select('#next_btn')
      .attr('class','img_btn_enabled')
      .transition()
      .duration(250)
      .ease(d3.easeCubic)
      .attr('src', 'assets/next.svg');
      d3.select('#prev_btn')
      .attr('class','img_btn_enabled');
    }
    else if (chart_instance.animation() == "off") {
      chart_instance.animation("on"); 
      d3.select('#next_btn')
      .attr('class','img_btn_disabled')
      .transition()
      .duration(250)
      .ease(d3.easeCubic)
      .attr('src', 'assets/next_gold.svg');
      d3.select('#prev_btn')
      .attr('class','img_btn_disabled');
    }
    chart_g.call(chart_instance);
    globals.log_message = { 
      "TimeStamp": new Date().valueOf(),
      "user_id": globals.userID, 
      "Event": "SandBoxEvent",
      "EventType": "toggleAnimate", 
      "Status": chart_instance.animation()
    };
    console.log("SandBoxEvent", globals.log_message);


    document.getElementById('sandbox_div').focus();
  }
  
  function toggleFacets () {
    chart_instance.this_chart().interrupt();
    if (chart_instance.facets() == "on") {
      chart_instance.facets("off");      
    }
    else if (chart_instance.facets() == "off") {
      chart_instance.facets("on");      
    }
    chart_g.call(chart_instance);

    globals.log_message = { 
      "TimeStamp": new Date().valueOf(),
      "user_id": globals.userID, 
      "Event": "SandBoxEvent",
      "EventType": "toggleFacets", 
      "Status": chart_instance.facets()
    };
    console.log("SandBoxEvent", globals.log_message);


    document.getElementById('sandbox_div').focus();
  }

  function loadData () {     

    checkExist = setInterval(function() {
      if (all_data != undefined) {        
        chart_g.datum(all_data);
        draw();    

        hideAddressBar();

        d3.select('#sandbox_div')
        .style('visibility','visible');

        globals.log_message = { 
          "TimeStamp": new Date().valueOf(),
          "user_id": globals.userID, 
          "Event": "SandBoxEvent",
          "EventType": "loadData", 
        };
        console.log("SandBoxEvent", globals.log_message);


        clearInterval(checkExist);
      }
    }, 100); // check every 100ms

    chart_instance = chart();    
  
    main_svg = d3.select('#main_svg').remove();
  
    main_svg = d3.select('#sandbox_div').append('svg')
    .attr('id','main_svg');      
  
    defs = d3.select('#main_svg').append('defs');
  
    chart_g = main_svg.append('g')
    .attr('id','chart_g');      

    
    document.getElementById('sandbox_div').focus();

    // var orientation_div = d3.select('#sandbox_div').append('div')
    // .attr('id','orientation_div')
    // .attr('tabindex',0);

    // orientation_div.append('span')
    // .attr('id','orientation_span')
    // .html('<span class="instruction_emphasis">TooSmallForMultiples</span>');

  } 
    
  /** INIT **/
  
  d3.select('body').append('div')
  .attr('id','sandbox_div')
  .attr('tabindex',0);

  d3.select('body').append('div')
  .attr('id','selector_div')
  .style('bottom','0px')
  .style('position', 'absolute')
  .attr('tabindex',0);

  all_data = nationData;  
  var codes = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P"]; //,
  codes = shuffle(codes);
  all_data.forEach(function (d,i){ 
    d.code = codes[i]; 
  });
    
  loadData(); 

  function exitHandler () {
    globals.log_message = { 
      "TimeStamp": new Date().valueOf(),
      "Event": "SandBox_Closed",
      "user_id": globals.userID
    };
    console.log("SandBox_Closed", globals.log_message);

    
    document.getElementById('sandbox_div').remove();
    if (document.getElementById('selector_div') != undefined) {      
      document.getElementById('selector_div').remove();                    
    } 
    loadMenu();
    hideAddressBar();   
  }

  var menubar = d3.select('#sandbox_div').append('div')
  .attr('class','toolbar')
  .attr('id','menubar');
  
  menubar.append("input")
  .attr('class', 'img_btn_enabled')
  .attr('id','fullscreen_btn')
  .attr('disabled', null)
  .attr('type','image')
  .attr('name','Exit')
  .attr('title', 'Exit')
  .attr('src', 'assets/fullscreen.png')
  .on('touchstart',function(){
    d3.event.preventDefault();
    exitHandler();
  });

  menubar.append("input")
  .attr('class', 'img_btn_enabled')
  .attr('id','na_btn')
  .attr('type','image')
  .attr('name','MiscToggle')
  .attr('title', 'MiscToggle')
  .attr('src', 'assets/na.svg')
  .on('touchstart', function() {
    d3.event.preventDefault(); 
  });    

  menubar.append("input")
  .attr('class', 'img_btn_enabled')
  .attr('type','image')
  .attr('name','LineToggle')
  .attr('title', 'LineToggle')
  .attr('src', 'assets/line.svg')
  .on('touchstart', function() {
    d3.event.preventDefault();
    toggleLines();
  });

  menubar.append("input")
  .attr('class', 'img_btn_enabled')
  .attr('type','image')
  .attr('name','FacetToggle')
  .attr('title', 'FacetToggle')
  .attr('src', 'assets/grid.svg')
  .on('touchstart', function() {
    d3.event.preventDefault();
    toggleFacets();
  });  

  menubar.append("input")
  .attr('class', 'img_btn_enabled')
  .attr('type','image')
  .attr('name','AnimateToggle')
  .attr('title', 'AnimateToggle')
  .attr('src', 'assets/play.svg')
  .on('touchstart', function() {
    d3.event.preventDefault();
    toggleAnimate();
  });  

  menubar.append("input")
  .attr('class', 'img_btn_enabled')
  .attr('id','prev_btn')
  .attr('type','image')
  .attr('name','PrevToggle')
  .attr('title', 'PrevToggle')
  .attr('src', 'assets/prev.svg')
  .on('touchstart', function() {    
    d3.event.preventDefault();
    d3.select(this).transition()
    .duration(250)
    .ease(d3.easeCubic)
    .attr('src', 'assets/prev_gold.svg')
    .transition()
    .duration(250)
    .ease(d3.easeCubic)
    .attr('src', 'assets/prev.svg');
    chart_instance.this_chart().interrupt();

    if (chart_instance.animation() == 'off'){

      if (chart_instance.current_year() == chart_instance.params().yearMin) {
        chart_instance.current_year(chart_instance.params().yearMax);
      }
      else {
        var prev_year = chart_instance.current_year() - 1;
        chart_instance.current_year(prev_year);
      }
      chart_g.call(chart_instance);

      checkTouch = setInterval(function() {
        if (chart_instance.current_year() == chart_instance.params().yearMin) {
          chart_instance.current_year(chart_instance.params().yearMax);
        }
        else {
          var prev_year = chart_instance.current_year() - 1;
          chart_instance.current_year(prev_year);
        }
        chart_g.call(chart_instance);
      }, 500); // check every 500ms if touch is ongoing          

    }
  })
  .on('touchend', function(){
    d3.event.preventDefault();
    clearInterval(checkTouch);
  });    

  menubar.append("input")
  .attr('class', 'img_btn_enabled')
  .attr('id','next_btn')
  .attr('type','image') 
  .attr('name','NextToggle')
  .attr('title', 'NextToggle')
  .attr('src', 'assets/next.svg')
  .on('touchstart', function() {    
    d3.event.preventDefault();
    d3.select(this).transition()
    .duration(250)
    .ease(d3.easeCubic)
    .attr('src', 'assets/next_gold.svg')
    .transition()
    .duration(250)
    .ease(d3.easeCubic)
    .attr('src', 'assets/next.svg');
    chart_instance.this_chart().interrupt();

    if (chart_instance.animation() == 'off'){

      if (chart_instance.current_year() == chart_instance.params().yearMax) {
        chart_instance.loop_count(chart_instance.loop_count + 1);
        chart_instance.current_year(chart_instance.params().yearMin);
      }
      else {
        var next_year = chart_instance.current_year() + 1;
        chart_instance.current_year(next_year);
      }
      chart_g.call(chart_instance);

      checkTouch = setInterval(function() {
        if (chart_instance.current_year() == chart_instance.params().yearMax) {
          chart_instance.loop_count(chart_instance.loop_count + 1);
          chart_instance.current_year(chart_instance.params().yearMin);
        }
        else {
          var next_year = chart_instance.current_year() + 1;
        chart_instance.current_year(next_year);
        }
        chart_g.call(chart_instance);
      }, 500); // check every 500ms if touch is ongoing          

    }
  })
  .on('touchend', function(){
    d3.event.preventDefault();
    clearInterval(checkTouch);
  });    

}

module.exports = sandbox;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var d3 = __webpack_require__(1);
var globals = __webpack_require__(0);

function consent (scene) {  
  
  /** INIT **/
  
  d3.select('body').append('div')
  .attr('id','consent_div')
  .attr('tabindex',0)
  .on('touchstart', function() {    
    d3.event.preventDefault(); 
  });  

  var consent_content_div = d3.select('#consent_div').append('div')
  .attr('class','toolbar')
  .style('width','100%')
  .style('height',(window.innerHeight - 50) + 'px')
  .attr('id','consent_content_div')
  .on('touchstart', function() {    
    d3.event.preventDefault(); 
  });  

  switch (scene) {

    case 0:

      consent_content_div.append('span')
      .attr('class','consent_text')
      .html('<span class="instruction_emphasis">Microsoft Research<br>Project Participation Consent Form</span><br>' +
      '<span style="text-align:left; font-size:0.7em;"><p>Thank you for deciding to volunteer in a Microsoft Corporation research project. The purpose of this project is to study the perception of statistical charts on mobile phones. You have no obligation to participate and you may decide to terminate your participation at any time. You also understand that the researcher has the right to withdraw you from participation in the project at any time. Below is a description of the research project, and your consent to participate. Read this information carefully.</p></span>')
      .on('touchstart', function() {    
        d3.event.preventDefault(); 
      });    
      
      d3.select('#consent_div')
      .style('visibility','visible');

    break;
    
    case 1:

      consent_content_div.append('span')
      .attr('class','consent_text')
      .html(
        '<span class="instruction_emphasis">Title of Experiment:</span><br>' +
        '<span style="text-align:left; font-size:0.9em;"><p><em>Bubble Charts on Mobile Phones</em></p></span>' +        
        '<span class="instruction_emphasis">Procedure:</span><br>' +
        '<span style="text-align:left; font-size:0.7em;"><p>The experiment will take approximately <span class="instruction_emphasis">15 minutes</span> to complete. You will be asked to respond to a series of questions relating to  <span class="instruction_emphasis">bubble charts</span>, a type of chart that will be explained shortly. Sessions will be logged anonymously to calculate accuracy and response times. The experimental procedure is as follows:</p>' +
        '<ol>' +
        '<li> An introductory tutorial.' +
        '<li> <span class="instruction_emphasis">13 presentations</span> of bubble charts, each with an associated question.' +
        '<li> An exit survey.' +
       
        '</ol></span>'
        
      )
      .on('touchstart', function() {    
        d3.event.preventDefault(); 
      });    
      
      d3.select('#consent_div')
      .style('visibility','visible');

    break;

    case 2:

      consent_content_div.append('span')
      .attr('class','consent_text')
      .html(
        '<span class="instruction_emphasis">Personal Information:</span><br>' +
        '<span style="text-align:left; font-size:0.7em;"><p>This waiver is intended to give you informed consent regarding your participation in this project and also to protect your personally identifiable information by not asking for specific details, such as your name. By clicking “I agree” at the end of this form, you are agreeing that you’ve had time to read and consider this consent waiver and are comfortable with what is being asked of you as a participant. Aside from your Mechanical Turk ID, no personal information will be collected during this study. Your Mechanical Turk ID will not be shared outside of Microsoft Research and the confines of this study without your permission, and will be promptly deleted after compensation has been successfully provided (30 days or less). De-identified data may be used for future research or given to another investigator for future use without additional consent (cont.).</p></span>'        
      )
      .on('touchstart', function() {    
        d3.event.preventDefault(); 
      });    
      
      d3.select('#consent_div')
      .style('visibility','visible');

    break;

    case 3:

      consent_content_div.append('span')
      .attr('class','consent_text')
      .html(
        '<span class="instruction_emphasis">Personal Information (cont.):</span><br>' +
        '<span style="text-align:left; font-size:0.7em;"><p>If you wish to review or copy any personal information you provided during the study, or if you want us to delete or correct any such data, email your request to the lead researcher Matthew Brehmer (<a href="mailto:mabrehme@microsoft.com" target="_blank">mabrehme@microsoft.com</a>). If you have a privacy concern, complaint, or a question for the Chief Privacy Officer/Data Protection Officer of Microsoft, please contact us by using our <a href="https://go.microsoft.com/fwlink/?LinkId=321116" target="_blank">Web form</a>). We will respond to questions or concerns within 30 days. For additional information on how Microsoft handles your personal information, please see the <a href="https://privacy.microsoft.com/en-us/privacystatement" target="_blank">Microsoft Privacy Statement</a>).</p></span>'    
      )
      .on('touchstart', function() {    
        d3.event.preventDefault(); 
      });    
      
      d3.select('#consent_div')
      .style('visibility','visible');

    break;

    case 4:

      consent_content_div.append('span')
      .attr('class','consent_text')
      .html(
        '<span class="instruction_emphasis">Research Results & Feedback:</span><br>' +
        '<span style="text-align:left; font-size:0.7em;"><p>Microsoft will own all of the research data and analysis and other results (collectively “Research Results”) generated from the information you provide and your participation in the research project. You may also provide suggestions, comments or other feedback (“Feedback”) to Microsoft with respect to the research project. Feedback is entirely voluntary, and Microsoft shall be free to use, disclose, reproduce, license, or otherwise distribute, and leverage the Feedback and Research Results.</p></span>'    
      )
      .on('touchstart', function() {    
        d3.event.preventDefault(); 
      });    
      
      d3.select('#consent_div')
      .style('visibility','visible');

    break;

    case 5:

      consent_content_div.append('span')
      .attr('class','consent_text')
      .html(
        '<span class="instruction_emphasis">Benefits and Risks:</span><br>' +
        '<span style="text-align:left; font-size:0.7em;"><p><span class="instruction_emphasis">Benefits</span>: The research team expects to better understand the perception of statistical charts on mobile phones. You will receive the specified payment after completing the HIT as well as any public benefit that may come these Research Results being shared with the greater scientific community.</p></span>' +
        '<span style="text-align:left; font-size:0.7em;"><p><span class="instruction_emphasis">Risks</span>: During your participation, you may experience risk that should not be any more significant than the risks you experience in your regular daily routine. Loss of time and compensation are also risks, particularly if you lose internet connectivity and are unable to complete the HIT. (cont.)</p></span>'        
      )
      .on('touchstart', function() {    
        d3.event.preventDefault(); 
      });    
      
      d3.select('#consent_div')
      .style('visibility','visible');

    break;

    case 6:

      consent_content_div.append('span')
      .attr('class','consent_text')
      .html(
        '<span class="instruction_emphasis">Benefits and Risks (cont.):</span><br>' +
        '<span style="text-align:left; font-size:0.7em;"><p>You accept the risks described on the previous page and whatever consequences may come of those risks, however unlikely, unless caused by our negligence or intentional misconduct. You hereby release Microsoft and its affiliates from any claim you may have now or in the future arising from such risks or consequences. In addition, you agree that Microsoft will not be liable for any loss, damages or injuries that may come of improper use of the study prototype, equipment, facilities, or any other deviations from the instructions provided by the research team. Don’t participate in this study if you feel you may not be able to safely participate in any way including due to any physical or mental illness, condition or limitation. You agree to immediately notify the research team of any incident or issue or unanticipated risk or incident.</p></span>'        
      )
      .on('touchstart', function() {    
        d3.event.preventDefault(); 
      });    
      
      d3.select('#consent_div')
      .style('visibility','visible');

    break;    

    case 7:
    
      consent_content_div.append('span')
      .attr('class','consent_text')
      .html(         
        '<span class="instruction_emphasis">Your Authority to Participate:</span><br>' +
        '<span style="text-align:left; font-size:0.7em;"><p>You represent that you have the full right and authority to sign this form, and if you are a minor that you have the consent (as indicated below) of your legal guardian to sign and acknowledge this form. By clicking “I agree” below, you confirm that you understand the purpose of the project and how it will be conducted and consent to participate on the terms set forth above. Should you have any questions concerning this project, please contact Matthew Brehmer (<a href="mailto:mabrehme@microsoft.com" target="_blank">mabrehme@microsoft.com</a>). Please confirm your acceptance by clicking “I agree” below. Upon request, a copy of this consent form will be provided to you for your records. On behalf of Microsoft, we thank you for your contribution and look forward to your research session.</p></span>' + '<span style="text-align:left; font-size:0.7em;"><p>Do you understand and consent to these terms?</p></span>'        
      )
      .on('touchstart', function() {    
        d3.event.preventDefault(); 
      });    
      
      d3.select('#consent_div')
      .style('visibility','visible');

    break;
    
    default: // return to main menu

      d3.select('#consent_div').remove();
      if (document.getElementById('consent_div') != undefined) {      
        document.getElementById('consent_div').remove(); 
      }

      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "Event": "ConsentComplete",
        "user_id": globals.userID
      };

      console.log("ConsentComplete", globals.log_message);

      
      consent_complete = true;
      loadMenu();
      hideAddressBar();   

    break;
  }
  
  d3.select('#consent_div').append('input')
  .attr('class', 'menu_btn_enabled')
  .attr('id','submit_btn')
  .attr('type','button')
  .attr('value', scene == 7 ? 'I AGREE' : 'NEXT')
  .attr('title', scene == 7 ? 'I AGREE' : 'NEXT')
  .on('touchstart', function() {    

    d3.event.preventDefault();  
    
    d3.select('#consent_div').remove();
    if (document.getElementById('consent_div') != undefined) {      
      document.getElementById('consent_div').remove(); 
    }

    globals.log_message = { 
      "TimeStamp": new Date().valueOf(),
      "user_id": globals.userID,
      "Event": "Consent",
      "Scene": scene + 1
    };

    console.log("Consent", globals.log_message);

    consent(scene + 1);
  });
 
}

module.exports = consent;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var d3 = __webpack_require__(1);
var globals = __webpack_require__(0);
var chart = __webpack_require__(3);
var nationData = __webpack_require__(2);
var countrySelector = __webpack_require__(4);

function introduction (scene) {

  suppress_touch_feedback = true;
  suppress_touch_val_feedback = true;
  globals.trial_response = [];
  chart_stage = -1;

  var checkExist;  
  var checkTouch;
  var attempts = 0;

  chart_instance = chart();

  all_data = nationData;  
  var codes = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P"]; //,
  codes = shuffle(codes);
  all_data.forEach(function (d,i){ 
    d.code = codes[i]; 
  });
    
  function getDims() {
    height = window.innerHeight;
    width = window.innerWidth;
    svg_dim = d3.min([height,width]) - 2;
    inner_padding = svg_dim * 0.1;
    chart_dim = svg_dim * 0.8;
  }

  function draw() {
  
    getDims();
        
    d3.select('#main_svg')
    .style('height',svg_dim + 'px')
    .style('width',svg_dim + 'px');
    
    chart_g.attr('transform','translate(' + inner_padding + ',' + inner_padding + ')');
  
    d3.selectAll('.guide').remove();
    chart_instance.lines('off'); 
    chart_instance.animation('off');
    chart_instance.facets('off');
    chart_instance.current_year(globals.param_yearMin);

    chart_g.call(chart_instance);
    d3.selectAll('.mark').style('display','none');
    d3.select('.year_indicator').style('display','none');
    chart_g.call(chart_instance);
  
  }

  function loadData () {     

    checkExist = setInterval(function() {
      if (all_data != undefined) {        
        chart_g.datum(all_data);
        draw();    
        
        hideAddressBar();

        d3.select('#introduction_div')
        .style('visibility','visible');

        globals.log_message = { 
          "TimeStamp": new Date().valueOf(),
          "user_id": globals.userID, 
          "Event": "IntroEvent",
          "EventType": "loadData", 
        };

        console.log("IntroEvent", globals.log_message);

        clearInterval(checkExist);
      }
    }, 100); // check every 100ms

    chart_instance = chart();
  
    main_svg = d3.select('#main_svg').remove();
  
    main_svg = d3.select('#introduction_div').append('svg')
    .attr('id','main_svg')
    .style('margin-top',-40 + 'px');  
  
    defs = d3.select('#main_svg').append('defs');
  
    chart_g = main_svg.append('g')
    .attr('id','chart_g');    
    
    document.getElementById('introduction_div').focus();

  } 

  function build_chart(stage) {

    switch (stage) {

      case 0:

        instruction_text.html('6. In this experiment, you will view charts depicting numerical values. In this example, <span class="instruction_emphasis">Life Expectancy</span> increases from left to right, and <span class="instruction_emphasis">GDP Per Capita</span> (a common economic indicator) increases from bottom to top.'); 
        loadData();

        break;

      case 1:

        instruction_text.html('7. Each of the circles below represents a country, where the <span class="instruction_emphasis">size</span> of a circle represents the corresponding country\'s <span class="instruction_emphasis">Population</span>.<br><br>'); 

        d3.selectAll('.mark').select('circle')
        .style('fill','#54b2fc');
        d3.selectAll('.mark').select('text').style('display','none');
        d3.selectAll('.mark').style('display',null);
        chart_instance.animation('off');
        chart_g.call(chart_instance);

        break;

      case 2:

        instruction_text.html('8. In this experiment, we won\'t use the real names of countries. Instead, we will assign each country a letter, and we will color the countries according to the continent in which they can be found.<br>'); 

        var scale_reg = chart_instance.scale_reg();
        var color_param = chart_instance.params().color;

        d3.selectAll('.mark').select('circle')
        .style('fill',function(d){
          return scale_reg(d[color_param]);
        });
        d3.selectAll('.mark').select('text').style('display',null);
        d3.selectAll('.mark').style('display',null);

        break;

      case 3:

        instruction_text.html('9. This chart reflects the 1975 <span class="instruction_emphasis">Life Expectancy</span>, <span class="instruction_emphasis">GDP Per Capita</span>, and <span class="instruction_emphasis">Population</span> values for these countries.<br><br>'); 

        d3.select('.year_indicator').style('display',null);

        break;

      case 4:

        instruction_text.html('10. The animation shows how the <span class="instruction_emphasis">Life Expectancy</span>, <span class="instruction_emphasis">GDP Per Capita</span>, and <span class="instruction_emphasis">Population</span> of these countries changed between 1975 and 2000. The animation will start over after reaching the year 2000.<br>'); 

        chart_instance.animation('on');
        chart_g.call(chart_instance);

        break;

      case 5:

        switch (globals.condition) {

          case 'stepper':

            instruction_text.html('11. <span class="instruction_emphasis">Tap or hold</span> the buttons below to navigate in time. The <span class="instruction_emphasis">ring</span> (bottom-right) must be complete to continue.'); 

            addmenu();
            chart_instance.current_year(globals.param_yearMin);
            chart_instance.animation('off');
            chart_instance.loop_count(0);
            update_outer_progress(1 / 25);
            chart_g.call(chart_instance);
            d3.select('#submit_btn').attr('class','menu_btn_disabled').attr('disabled',true);


            break;

          case 'animation':

            instruction_text.html('11. The ring (bottom-right) will show the <span class="instruction_emphasis">progress of the animation</span>. You may proceed once the ring is complete.'); 

            addmenu();
            chart_instance.current_year(globals.param_yearMin);
            chart_instance.loop_count(0);
            update_outer_progress(1 / 25);
            chart_instance.animation('on');
            chart_g.call(chart_instance);
            d3.select('#submit_btn').attr('class','menu_btn_disabled').attr('disabled',true);

            break;

          case 'multiples':

            instruction_text.html('11. Here\'s another way to show the same data. Instead of a single chart, each country has its own chart, where the <span class="instruction_emphasis">dot corresponds to the final values</span>, and each country\'s trajectory is drawn as a line.');

            d3.select('.year_indicator').style('display','none');
            chart_instance.animation('off');
            chart_instance.current_year(globals.param_yearMax);
            chart_instance.lines('on');
            chart_instance.facets('on');
            chart_g.call(chart_instance);
            // d3.select('#submit_btn').attr('class','menu_btn_disabled').attr('disabled',true);

            break;

          default:

            break;

        }       

        break;

      case 6:
      
        instruction_text.html('');        
        
        var intro_content_div = d3.select('#introduction_div')
        .append('div')
        .attr('class','toolbar')
        .style('width','100%')
        .style('height',(window.innerHeight - 50) + 'px')
        .attr('id','intro_content_div');   

        intro_content_div.append('span')
        .attr('class','consent_text')
        .html('<span style="text-align:left; font-size:0.8em;">12. In the experiment, you\'ll be asked to select one or more countries based on their characteristics.' + 
        '<br><br>In some cases, there may be more correct responses than required responses, and the order in which you select responses does not matter.' + 
        '<br><br>If you change your mind about a selection, tap it again to de-select it.' + 
        '<br><br>Tap <span class="instruction_emphasis">NEXT</span> to perform a practice trial.</span>');   

        d3.select('#main_svg').style('display','none');
        d3.select('#menubar').style('display','none');

        switch (globals.condition) {

          case 'stepper':

            chart_instance.current_year(globals.param_yearMin);
            chart_instance.animation('off');
            chart_instance.loop_count(0);
            update_outer_progress(1 / 25);
            chart_g.call(chart_instance);

            break;

          case 'animation':

            chart_instance.current_year(globals.param_yearMin);
            chart_instance.loop_count(0);
            update_outer_progress(1 / 25);
            chart_instance.animation('on');
            chart_g.call(chart_instance);

            break;

          case 'multiples':

            chart_instance.animation('off');
            chart_instance.current_year(globals.param_yearMax);
            chart_instance.loop_count(0);
            update_outer_progress(0 / 25);
            chart_instance.lines('on');
            chart_instance.facets('on');
            addmenu();
            chart_g.call(chart_instance);

            break;

          default:

            break;

        }       

        d3.select('#menubar').style('display','none');
       
        break;

      case 7:

        d3.select('#instruction_text').remove();
        d3.select('#intro_content_div').remove();
        d3.select('#submit_btn').style('display','none');
        d3.select('#instruction_div').style('display','none');
        d3.select('.year_indicator').style('display','none');
        d3.selectAll('.mark').style('display','none');
        d3.selectAll('.line').style('display','none');
        d3.select('#main_svg').style('display',null)        
        .style('margin-top',0 + 'px'); 
        
        d3.select('#introduction_div').append('div')
        .attr('class', 'feedback_btn_enabled')
        .style('border-color','transparent')
        .style('top',(svg_dim + 5) + 'px')
        .attr('id','start_btn')
        .style('height','125px');

        d3.select('#start_btn').append('span')
        .attr('id','button_text')
        .html('<span>Take note of the <span class="instruction_emphasis" style="color:gold;">two chart axes</span> above and this instruction:</span><br>' + (globals.condition != 'multiples' ? ' View <span class=\'instruction_emphasis\'>all years</span>, s' : 'S') + 'elect <span class="instruction_number">three</span> countries that are <span class="instruction_emphasis">labeled with VOWELS</span>.<br>' + '<span id="time_warning">You may proceed after <span class="instruction_emphasis">5 seconds</span>.</span>' + '<span id="time_delay_message"  style="display:none;">Tap on this message to start this <span class="instruction_emphasis">PRACTICE</span> trial.</span>'); 

        setTimeout(function(){
          // allow participant to proceed after 5s

          d3.select('#time_warning')
          .style('display','none');

          d3.select('#time_delay_message')
          .style('display',null);

          d3.select('#start_btn')
          .style('border-color','#fff')
          .on('touchstart', function() {   
            d3.select('#start_btn').remove();
            chart_instance.current_year(globals.condition == 'multiples' ? globals.param_yearMax : globals.param_yearMin);
            chart_instance.loop_count(0);
            update_outer_progress(1 / 25);
            chart_g.call(chart_instance);
            
            d3.selectAll('.mark').style('display',null);
            d3.selectAll('.line').style('display',globals.condition == 'multiples' ? null : 'none');
            d3.select('.year_indicator').style('display',null);
            d3.select('#menubar').style('display',null);

            d3.select('.task_instruction_span')
            .html((globals.condition != 'multiples' ? ' View <span class=\'instruction_emphasis\'>all years</span>, s' : 'S') + 'elect <span class="instruction_number">three</span> countries that are <span class="instruction_emphasis">labeled with VOWELS</span> using the buttons below, then tap \'DONE\'.');  

            countrySelector();      
          }); 
        }, 5000); 

        break;

      default:

        chart_instance.animation('off');
        chart_instance.current_year(globals.param_yearMax);
        chart_instance.loop_count(0);
        update_outer_progress(0 / 25);
        chart_g.call(chart_instance);

        d3.select('#introduction_div').remove();
        if (document.getElementById('introduction_div') != undefined) {      
          document.getElementById('introduction_div').remove(); 
        }

        globals.log_message = { 
          "TimeStamp": new Date().valueOf(),
          "user_id": globals.userID,
          "Event": "Intro",
          "Scene": scene + 1
        };

        console.log('Intro',globals.log_message);


        scene = 7;
        introduction(scene);

        break;

    }   

  }
      
  /** INIT **/
  
  d3.select('body').append('div')
  .attr('id','introduction_div')
  .attr('tabindex',0);  

  var instruction_div = d3.select('#introduction_div').append('div')
  .attr('class','toolbar')
  .attr('id','instruction_div');

  var instruction_text = instruction_div.append('span')
  .attr('id','instruction_text');  

  switch (scene) {

    case 0:

      instruction_text.html('Please review the following protocols before beginning the experiment.');    
      d3.select('#introduction_div')
      .style('visibility','visible');

      break;   
      
    case 1:

      instruction_text.html('1. For the duration of this experiment, hold your phone in <span class="instruction_emphasis">portrait mode</span>.');    
      d3.select('#introduction_div')
      .style('visibility','visible'); 

      getDims();

      main_svg = d3.select('#introduction_div').append('svg')
      .attr('id','main_svg')
      .style('height',svg_dim + 'px')
      .style('width',svg_dim + 'px')
      .style('margin-top',-40 + 'px');

      main_svg.append('svg:image')
      .attr('class','instruction_svg')
      .attr("xlink:href", "assets/portrait.svg")
      .attr("width", chart_dim)
      .attr("height", chart_dim)
      .attr("x", inner_padding)
      .attr("y", inner_padding);
          
      document.getElementById('introduction_div').focus();

      break;

    case 2:
  
      instruction_text.html('2. Hold your phone with one hand and use the <span class="instruction_emphasis">index finger on your other hand</span> to touch your phone. It doesn\'t matter which hand holds the phone; just ensure that you are comfortable. However, do not switch the arrangement of your hands during the experiment.');    
      d3.select('#introduction_div')
      .style('visibility','visible'); 

      getDims();

      main_svg = d3.select('#introduction_div').append('svg')
      .attr('id','main_svg')
      .style('height',svg_dim + 'px')
      .style('width',svg_dim + 'px');

      main_svg.append('svg:image')
      .attr('class','instruction_svg')
      .attr("xlink:href", "assets/holdingphone.svg")
      .attr("width", chart_dim)
      .attr("height", chart_dim)
      .attr("x", inner_padding)
      .attr("y", inner_padding);
          
      document.getElementById('introduction_div').focus();

      break;

    case 3:
    
      instruction_text.html('3. Make sure that your phone\'s <span class="instruction_emphasis">brightness</span> level is set to <span class="instruction_emphasis">maximum</span>.');    
      d3.select('#introduction_div')
      .style('visibility','visible'); 

      getDims();

      main_svg = d3.select('#introduction_div').append('svg')
      .attr('id','main_svg')
      .style('height',svg_dim + 'px')
      .style('width',svg_dim + 'px');

      main_svg.append('svg:image')
      .attr('class','instruction_svg')
      .attr("xlink:href", "assets/brightness.svg")
      .attr("width", chart_dim)
      .attr("height", chart_dim)
      .attr("x", inner_padding)
      .attr("y", inner_padding);
          
      document.getElementById('introduction_div').focus();

      break;
    
    case 4:
    
      instruction_text.html('4. Ensure a stable <span class="instruction_emphasis">WiFi</span> network and sufficient <span class="instruction_emphasis">battery power</span> for approximately <span class="instruction_emphasis">20 minutes</span>.');    
      d3.select('#introduction_div')
      .style('visibility','visible'); 

      getDims();

      main_svg = d3.select('#introduction_div').append('svg')
      .attr('id','main_svg')
      .style('height',svg_dim + 'px')
      .style('width',svg_dim + 'px');

      main_svg.append('svg:image')
      .attr('class','instruction_svg')
      .attr("xlink:href", "assets/wifi.svg")
      .attr("width", chart_dim)
      .attr("height", chart_dim)
      .attr("x", inner_padding)
      .attr("y", inner_padding);
          
      document.getElementById('introduction_div').focus();

      break; 
      
    case 5:
    
      instruction_text.html('5. <span class="instruction_emphasis">DO NOT</span> tap your browser\'s back or refresh buttons at any time.');    
      d3.select('#introduction_div')
      .style('visibility','visible'); 

      getDims();

      main_svg = d3.select('#introduction_div').append('svg')
      .attr('id','main_svg')
      .style('height',svg_dim + 'px')
      .style('width',svg_dim + 'px');

      main_svg.append('svg:image')
      .attr('class','instruction_svg')
      .attr("xlink:href", "assets/nonav.svg")
      .attr("width", chart_dim)
      .attr("height", chart_dim)
      .attr("x", inner_padding)
      .attr("y", inner_padding);
          
      document.getElementById('introduction_div').focus();

      break;

    case 6: 

      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "Event": "IntroChartBuild",
        "user_id": globals.userID
      };
  
      console.log("IntroChartBuild", globals.log_message);


      break;
    
    case 7:

      d3.select('#selector_div').remove();
      d3.select('#instruction_div').remove();
      
      var intro_content_div = d3.select('#introduction_div')
      .append('div')
      .attr('class','toolbar')
      .style('width','100%')
      .style('height',(window.innerHeight - 50) + 'px')
      .attr('id','intro_content_div');        

      intro_content_div.append('span')
      .attr('class','consent_text')
      .html('<span style="text-align:left; font-size:0.9em;"><p>Congratulations!<br><br> You are now <span class="instruction_emphasis">ready to begin</span> the experiment, where you will answer 13 questions. </p> ' + 
      '<p>The remainder of the experiment will proceed as follows:</p>' + 
      '<ol>' +
      '<li> <span class="instruction_emphasis">13 questions:</span>' + 
      '<ul>' +
      '<li>These include  <span class="instruction_emphasis">3 practice questions</span> and <span class="instruction_emphasis">10 test questions</span>.' +
      '<li>Some questions may have <span class="instruction_emphasis">multiple correct responses</span>.' +
      '<li>Each question is expected to take under a minute to complete.' + 
      '<li>The question will always be shown below the chart.' +
      '</ul><li> An <span class="instruction_emphasis">exit survey</span> containing <span class="instruction_emphasis">3 questions</span>.' +
     
      '</ol></span>'
      );    

      d3.select('#introduction_div')
      .style('visibility','visible');        

      break;

    default: // return to main menu

      d3.select('#introduction_div').remove();
      if (document.getElementById('introduction_div') != undefined) {      
        document.getElementById('introduction_div').remove(); 
      }

      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "Event": "IntroComplete",
        "user_id": globals.userID
      };

      console.log("IntroComplete", globals.log_message);


      introduction_complete = true;
      suppress_touch_feedback = false;
      suppress_touch_val_feedback = false;
      loadMenu();
      hideAddressBar();   

      break;
  }
  
  d3.select('#introduction_div').append('input')
  .attr('class', 'menu_btn_enabled')
  .attr('id','submit_btn')
  .attr('type','button')
  .attr('value', scene == 16 ? 'BEGIN' : 'NEXT')
  .attr('title', scene == 16 ? 'BEGIN' : 'NEXT')
  .on('touchstart', nextIntroScene);

  function nextIntroScene () {

    d3.event.preventDefault();          

    if (d3.select(this).attr('disabled') == null) {
      if (chart_stage == 7) {
        attempts++;

        d3.select('#main_svg').attr('class','blurme');
        d3.select('#selector_div').remove();
        d3.select('#menubar').style('display','none');

        var score = 0;
        if (globals.trial_response.indexOf('A') != -1) {
          score++;
        }
        if (globals.trial_response.indexOf('E') != -1) {
          score++;
        }
        if (globals.trial_response.indexOf('I') != -1) {
          score++;
        }
        if (globals.trial_response.indexOf('O') != -1) {
          score++;
        }
        if (score != 3) {

          var incorrect_feedback_btn =  d3.select('#introduction_div').append('div')
          .attr('class', 'feedback_btn_enabled')
          .attr('id','feedback_btn')
          .style('background','#ef5350')
          .style('border-color','#fff')        
          .on('touchstart', function() {  

            d3.event.preventDefault(); 

            d3.select('#progress_indicator').style('display',null);
            d3.select('#outer_progress_indicator')
            .attr('display', globals.condition == 'multiples' ? 'none' : null);
            d3.select('#done_btn').attr('class','img_btn_disabled')
            .style('display','none')
            .attr('disabled',true)
            .attr('src', 'assets/na.svg')
            .style('margin', function(){
              return height < width ? '0px' : '2px';
            })
            .attr('height', function(){
              return height < width ? (height / 7 - 6) : (width / 7 - 6);
            })
            .attr('width', function (){
              return width < height ? (width / 7 - 6) : (height / 7 - 6);
            });
            d3.select('#feedback_btn').remove();
            d3.select('#menubar').style('display',null);
            d3.select('#main_svg').attr('class',null);
            globals.num_selected = 0;
            globals.trial_response = [];            
            countrySelector();
            d3.select('#inner_progress_value').attr('d', globals.inner_progress_circle.endAngle(0));
            
            //try again
          });

          incorrect_feedback_btn.append('span')
          .attr('id','button_text')
          .style('color','#111')
          .style('font-weight','400')
          .html(function() {    
            if (attempts > 1) {
              return '<span class="correct_incorrect">INCORRECT</span><br>Tap on this message to try again.<br> (Hint: Vowels include A, E, I, O, & U).';
            }
            else {
              return '<span class="correct_incorrect">INCORRECT</span><br>Tap on this message to try again.';
            }
          }); 

        } 
        else {
          chart_stage++;
          build_chart(chart_stage);
        }
      }
      else if (scene != 5) {
        d3.select('#introduction_div').remove();
        if (document.getElementById('introduction_div') != undefined) {      
          document.getElementById('introduction_div').remove(); 
        }

        globals.log_message = { 
          "TimeStamp": new Date().valueOf(),
          "user_id": globals.userID,
          "Event": "Intro",
          "Scene": scene + 1
        };

        console.log("Intro", globals.log_message);

  
        introduction(scene + 1);
      }
      else {
        chart_stage++;
        build_chart(chart_stage);
      }
    } 
  }

  function addmenu () {
    var menubar = d3.select('#introduction_div').append('div')
    .attr('class','toolbar')
    .attr('id','menubar')
    .style('float', function(){
      return height < width ? 'left' : 'inherit';
    })
    .style('width', function(){
      return height < width ? (height / 7) + 'px'  : width + 'px';
    })
    .style('height', function(){
      return height < width ? height + 'px'  : (width / 7) + 'px';
    });  

    menubar.append("input")
    .attr('class', 'img_btn_disabled')  
    .attr('id','prev_btn')
    .style('display',globals.condition == 'stepper' ? null : 'none')
    .style('margin', function(){
      return height < width ? '0px' : '2px';
    })
    .attr('height', function(){
      return height < width ? (height / 7 - 6) : (width / 7 - 6);
    })
    .attr('width', function (){
      return width < height ? (width / 7 - 6) : (height / 7 - 6);
    })
    .attr('type','image')
    .attr('name','PrevToggle')
    .attr('title', 'PrevToggle')
    .attr('disabled', true)
    .attr('src', globals.condition == 'stepper' ? 'assets/prev_grey.svg' : 'assets/na.svg')
    .on('touchstart', function() {    
      d3.event.preventDefault();          

      if (globals.condition == 'stepper'){

        d3.select(this).attr('src', globals.condition == 'stepper' ? (chart_instance.loop_count() < 1 ? 'assets/prev_grey.svg' : 'assets/prev_gold.svg') : 'assets/na.svg');
        chart_instance.this_chart().interrupt();
        

        if (chart_instance.current_year() != chart_instance.params().yearMin) {      
          var prev_year = chart_instance.current_year() - 1;
          chart_instance.current_year(prev_year);
          var outer_progress =  ((prev_year + 1) - chart_instance.params().yearMin) / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin);
          update_outer_progress(chart_instance.loop_count() + outer_progress);
          
        }
        else if (chart_instance.loop_count() > 0 && chart_instance.current_year() == chart_instance.params().yearMin) {
          chart_instance.current_year(chart_instance.params().yearMax);
          d3.selectAll('.mark').style('display','none');
            d3.selectAll('.path_line').style('display','none');
            setTimeout(function(){
              d3.selectAll('.mark').style('display',null);
              d3.selectAll('.path_line').style('display',null);
            }, 500);
        }
        chart_g.call(chart_instance);

        checkTouch = setInterval(function() {
          if (chart_instance.current_year() != chart_instance.params().yearMin) {
            var prev_year = chart_instance.current_year() - 1;
            chart_instance.current_year(prev_year);   
            var outer_progress =  ((prev_year + 1) - chart_instance.params().yearMin) / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin);
            update_outer_progress(chart_instance.loop_count() + outer_progress);
          }
          else if (chart_instance.loop_count() > 0 && chart_instance.current_year() == chart_instance.params().yearMin) {
            chart_instance.current_year(chart_instance.params().yearMax);
            d3.selectAll('.mark').style('display','none');
            d3.selectAll('.path_line').style('display','none');
            setTimeout(function(){
              d3.selectAll('.mark').style('display',null);
              d3.selectAll('.path_line').style('display',null);
            }, 500);
          }
          chart_g.call(chart_instance);
          
        }, 500); // check every 500ms if touch is ongoing          

      }
    })
    .on('touchend', function(){
      
      d3.event.preventDefault();
      clearInterval(checkTouch);

      if (globals.condition == 'stepper') {
        d3.select(this).attr('class',(chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? 'img_btn_disabled' : 'img_btn_enabled')
        .attr('disabled', (chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? true : null)
        .attr('src', (chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? 'assets/prev_grey.svg' : 'assets/prev.svg');
      }
    });    

    menubar.append("input")
    .attr('id','next_btn')
    .style('display',globals.condition == 'stepper' ? null : 'none')
    .attr('class', globals.condition == 'stepper' ? 'img_btn_enabled' : 'img_btn_disabled')  
    .style('margin', function(){
      return height < width ? '0px' : '2px';
    })
    .attr('height', function(){
      return height < width ? (height / 7 - 6) : (width / 7 - 6);
    })
    .attr('width', function (){
      return width < height ? (width / 7 - 6) : (height / 7 - 6);
    })
    .attr('type','image') 
    .attr('name','NextToggle')
    .attr('title', 'NextToggle')
    .attr('src', globals.condition == 'stepper' ? 'assets/next.svg' : 'assets/na.svg')
    .attr('disabled', globals.condition == 'stepper' ? null : true)
    .on('touchstart', function() {    
      d3.event.preventDefault();    

      if (globals.condition == 'stepper'){

        d3.select(this).attr('src', globals.condition == 'stepper' ? 'assets/next_gold.svg' : 'assets/na.svg');
        chart_instance.this_chart().interrupt();

        if (chart_instance.current_year() == chart_instance.params().yearMax) {
          chart_instance.current_year(chart_instance.params().yearMin);
          d3.selectAll('.mark').style('display','none');
          d3.selectAll('.path_line').style('display','none');
          setTimeout(function(){
            d3.selectAll('.mark').style('display',null);
            d3.selectAll('.path_line').style('display',null);
          }, 500);
        }
        else {
          var next_year = chart_instance.current_year() + 1;
          var outer_progress =  ((next_year + 1) - chart_instance.params().yearMin) / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin);
          update_outer_progress(chart_instance.loop_count() + outer_progress);
          if (chart_instance.current_year() == (chart_instance.params().yearMax - 1)) {
            chart_instance.loop_count(chart_instance.loop_count() + 1);
            // d3.select('#progress_indicator').style('display','none');
            if (chart_stage == 7 && globals.num_selected == 3) {
              
              d3.select('#progress_indicator').style('display','none');
              d3.select('#done_btn').attr('class','img_btn_enabled')
              .style('display',null)
              .attr('disabled',null)
              .attr('src', 'assets/done.svg');
            }
            else {
              d3.select('#submit_btn').attr('class','menu_btn_enabled')
              .attr('disabled',null);
            }
          }
          chart_instance.current_year(next_year);
        }
        chart_g.call(chart_instance);     

        checkTouch = setInterval(function() {
          if (chart_instance.current_year() == chart_instance.params().yearMax) {
            chart_instance.current_year(chart_instance.params().yearMin);
            d3.selectAll('.mark').style('display','none');
            d3.selectAll('.path_line').style('display','none');
            setTimeout(function(){
              d3.selectAll('.mark').style('display',null);
              d3.selectAll('.path_line').style('display',null);
            }, 500);
          }
          else {
            var next_year = chart_instance.current_year() + 1;
            var outer_progress =  ((next_year + 1) - chart_instance.params().yearMin) / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin);
            update_outer_progress(chart_instance.loop_count() + outer_progress);
            if (chart_instance.current_year() == (chart_instance.params().yearMax - 1)) {
              chart_instance.loop_count(chart_instance.loop_count() + 1);
              // d3.select('#progress_indicator').style('display','none');
              if (chart_stage == 7 && globals.num_selected == 3) {                
                d3.select('#progress_indicator').style('display','none');
                d3.select('#done_btn').attr('class','img_btn_enabled')
                .style('display',null)
                .attr('disabled',null)
                .attr('src', 'assets/done.svg');
              }
              else{
                d3.select('#submit_btn').attr('class','menu_btn_enabled')
                .attr('disabled',null);
              }
            }
            chart_instance.current_year(next_year);
          }
          chart_g.call(chart_instance);
        }, 500); // check every 500ms if touch is ongoing    

      }
    })
    .on('touchend', function(){

      d3.event.preventDefault();
      clearInterval(checkTouch);

      d3.select(this).attr('src', globals.condition == 'stepper' ? 'assets/next.svg' : 'assets/na.svg');

      if (globals.condition == 'stepper') {
        d3.select('#prev_btn').attr('class',(chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? 'img_btn_disabled' : 'img_btn_enabled')
        .attr('disabled', (chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? true : null)
        .attr('src', (chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? 'assets/prev_grey.svg' : 'assets/prev.svg');
      }
    });    

    var progress_radius = (height < width ? (height / 7 - 6) : (width / 7 - 6)) / 2;
    var progress_stroke = 2;
    var progress_dim = progress_radius * 2;

    var prompt = menubar.append("div")
    .attr('id','prompt')
    .style('margin','2px')
    .style('height', (progress_dim) + 'px')
    .style('width', (width - progress_dim * (globals.condition == 'stepper' ? 3 : 1) - (globals.condition == 'stepper' ? 24 : 12)) + 'px')
    .on('touchstart', function() {    
      d3.event.preventDefault(); 
    });

    prompt.append('span')
    .attr('class','task_instruction_span')
    .html('');      

    //progress indicators
    var progress_colors = {
      outer_fill: 'gold',
      inner_fill: '#fff',
      track: '#999',
      stroke: '#333',
    };

    menubar.append("input")
    .attr('class', 'img_btn_disabled')
    .attr('disabled',true)
    .style('display','none')
    .style('margin','2px')
    .style('height', progress_dim + 'px')
    .style('width', progress_dim + 'px')
    .attr('id','done_btn')
    .attr('type','image')
    .attr('name','Done')
    .attr('title', 'Done')
    .attr('src', 'assets/na.svg')
    .on('touchstart', nextIntroScene);

    var progress_svg = menubar.append("svg")
    .attr('disabled',true)
    .attr('id','progress_indicator')
    .attr('height', progress_dim)
    .attr('width', progress_dim);
    
    globals.outer_progress_circle = d3.arc()
    .startAngle(0)
    .cornerRadius(7.5)
    .innerRadius(progress_radius)
    .outerRadius(progress_radius - 7.5);

    var outer_track_circle = d3.arc()
    .startAngle(0)
    .endAngle(Math.PI * 2)
    .innerRadius(progress_radius)
    .outerRadius(progress_radius - 7.5);

    globals.inner_progress_circle = d3.arc()
    .startAngle(0)
    .cornerRadius(7.5)
    .innerRadius(progress_radius - 7.5)
    .outerRadius(progress_radius - 15);

    var inner_track_circle = d3.arc()
    .startAngle(0)
    .endAngle(Math.PI * 2)
    .innerRadius(progress_radius - 7.5)
    .outerRadius(progress_radius - 15);

    var outer_progress_track = progress_svg.append('g')
    .attr('id','outer_progress_indicator')
    .attr('display', globals.condition == 'multiples' ? 'none' : null)
    .attr('transform', 'translate(' + progress_dim / 2 + ',' + progress_dim / 2 + ')');
    
    outer_progress_track.append('path')
    .attr('fill', progress_colors.track)
    .attr('stroke', progress_colors.stroke)
    .attr('stroke-width', progress_stroke + 'px')
    .attr('d', outer_track_circle);

    outer_progress_track.append('path')
    .attr('id', 'outer_progress_value')
    .attr('fill', progress_colors.outer_fill)
    .attr('stroke', progress_colors.stroke)
    .attr('stroke-width', progress_stroke + 'px')
    .attr('d', globals.inner_progress_circle.endAngle(0));     

    update_outer_progress(1 / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin));

    var inner_progress_track = progress_svg.append('g')
    .attr('id','inner_progress_indicator')
    .attr('display', null)
    .attr('transform', 'translate(' + progress_dim / 2 + ',' + progress_dim / 2 + ')');
    
    inner_progress_track.append('path')
    .attr('fill', progress_colors.track)
    .attr('stroke', progress_colors.stroke)
    .attr('stroke-width', progress_stroke + 'px')
    .attr('d', inner_track_circle);

    inner_progress_track.append('path')
    .attr('id', 'inner_progress_value')
    .attr('fill', progress_colors.inner_fill)
    .attr('stroke', progress_colors.stroke)
    .attr('stroke-width', progress_stroke + 'px')
    .attr('d', globals.inner_progress_circle.endAngle(0));
  }

  function update_outer_progress(progress) {
    if (globals.condition != 'multiples') {
      d3.select('#outer_progress_value').attr('d', globals.outer_progress_circle.endAngle((Math.PI * 2) * progress));
    }
  } 
 
}

module.exports = introduction;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var d3 = __webpack_require__(1);
var Clipboard = __webpack_require__(13);
var globals = __webpack_require__(0);

function questionnaire (scene) {

  var likert_rb;

  var clip = new Clipboard('.btn'); 

  clip.on("success", function(e) {

    globals.log_message = { 
      "TimeStamp": new Date().valueOf(),
      "Event": "CodeCopied",
      "user_id": globals.userID,
      "code": e.text
    };

    console.log("CodeCopied", globals.log_message);


  });
  clip.on("error", function(e) {
    console.error('Action:', e.action);
    console.error('Trigger:', e.trigger);  

  });

  d3.select('#questionnaire_div').remove();
  if (document.getElementById('questionnaire_div') != undefined) {      
    document.getElementById('questionnaire_div').remove(); 
  }
  
  /** INIT **/
  
  d3.select('body').append('div')
  .attr('id','questionnaire_div')
  .attr('tabindex',0);  

  var instruction_div = d3.select('#questionnaire_div').append('div')
  .attr('class','toolbar')
  .style('height','150px')
  .style('padding-bottom','50%')
  .attr('id','instruction_div');

  var instruction_text = instruction_div.append('span')
  .attr('id','instruction_text');  

  switch (scene) {

    case 0:

      instruction_text.html('<span class="instruction_emphasis">Congratulations!</span><br>You have completed the study tasks. Please take a moment to respond to three questions about the chart design used in this study.');    

      d3.select('#questionnaire_div').append('input')
      .attr('class', 'menu_btn_enabled')
      .attr('id','submit_btn')
      .attr('type','button')
      .attr('value','NEXT')
      .attr('title', 'NEXT')
      .on('touchstart', function() {   
        
        d3.event.preventDefault();
        
        globals.log_message = { 
          "TimeStamp": new Date().valueOf(),
          "user_id": globals.userID,
          "Event": "Survey",
          "Scene": scene + 1
        };
        
        console.log("Survey", globals.log_message);


        questionnaire(scene + 1);        
        
      });

      break;  

    case 1:
    
      instruction_text.html('1. Prior to this experiment, how <span class="instruction_emphasis">familiar</span> were you with the type of chart used in this experiment on a scale ranging from <span class="instruction_emphasis">1</span> (not familiar at all) to <span class="instruction_emphasis">5</span> (very familiar)?');    

      var familiarity = 0;

      d3.select('#questionnaire_div').append('input')
      .attr('class', 'menu_btn_disabled')
      .attr('disabled', true)
      .attr('id','submit_btn')
      .attr('type','button')
      .attr('value','NEXT')
      .attr('title', 'NEXT')
      .on('touchstart', function() { 

        d3.event.preventDefault(); 
        
        if (d3.select(this).attr('disabled') == null) {

          globals.log_message = { 
            "TimeStamp": new Date().valueOf(),
            "user_id": globals.userID,
            "Event": "Survey",
            "Question": "Familiarity",
            "Response": familiarity
          };
          
          console.log("Survey", globals.log_message);

  
          questionnaire(scene + 1);          
        
        }
        
      });

      likert_rb = d3.select('#questionnaire_div').selectAll(".menu_btn_enabled")
      .data([1,2,3,4,5])
      .enter();     

      setTimeout(function(){
        likert_rb.append('input')
        .attr('class', 'menu_btn_enabled')
        .style('width','18%')
        .style('margin-left','1%')      
        .style('margin-right','1%')
        .style('transform','translate(0,0)')
        .attr('type','button')
        .attr('value',function(d){
          return(d);
        })
        .attr('title', function(d){
          return(d);
        })
        .on('touchstart', function(d) {  

          d3.event.preventDefault(); 
          
          d3.selectAll('.menu_btn_enabled').style('border', '1px solid #ccc');           
          d3.select(this).style('border', '5px solid gold');

          familiarity = d;  

          d3.select('#submit_btn').attr('class', 'menu_btn_enabled')
          .attr('disabled', null);
            
        });                   
      }, 500);    

      break;

    case 2:
    
      instruction_text.html('2. Throughout this experiment, how <span class="instruction_emphasis">confident</span> were you when responding to the questions on a scale ranging from <span class="instruction_emphasis">1</span> (not confident at all) to <span class="instruction_emphasis">5</span> (completely confident)?');    

      var confidence = 0;

      d3.select('#questionnaire_div').append('input')
      .attr('class', 'menu_btn_disabled')
      .attr('disabled', true)
      .attr('id','submit_btn')
      .attr('type','button')
      .attr('value','NEXT')
      .attr('title', 'NEXT')
      .on('touchstart', function() { 

        d3.event.preventDefault(); 
        
        if (d3.select(this).attr('disabled') == null) {

          globals.log_message = { 
            "TimeStamp": new Date().valueOf(),
            "user_id": globals.userID,
            "Event": "Survey",
            "Question": "Confidence",
            "Response": confidence
          };
          
          console.log("Survey", globals.log_message);


          questionnaire(scene + 1);          
        }

      });

      likert_rb = d3.select('#questionnaire_div').selectAll(".menu_btn_enabled")
      .data([1,2,3,4,5])
      .enter();     

      setTimeout(function(){
        likert_rb.append('input')
        .attr('class', 'menu_btn_enabled')
        .style('width','18%')
        .style('margin-left','1%')      
        .style('margin-right','1%')
        .style('transform','translate(0,0)')
        .attr('type','button')
        .attr('value',function(d){
          return(d);
        })
        .attr('title', function(d){
          return(d);
        })
        .on('touchstart', function(d) {   
          
          d3.event.preventDefault(); 
          
          d3.selectAll('.menu_btn_enabled').style('border', '1px solid #ccc');           
          d3.select(this).style('border', '5px solid gold');
          
          confidence = d;

          d3.select('#submit_btn').attr('class', 'menu_btn_enabled')
          .attr('disabled', null);   
          
        });                   
      }, 500);


      break;

    case 3:
    
      instruction_text.html('3. Throughout this experiment, how <span class="instruction_emphasis">easy</span> was it to answer the questions using the interface provided to you on a scale ranging from <span class="instruction_emphasis">1</span> (very difficult) to <span class="instruction_emphasis">5</span> (very easy)?');    

      var ease = 0;

      d3.select('#questionnaire_div').append('input')
      .attr('class', 'menu_btn_disabled')
      .attr('disabled', true)
      .attr('id','submit_btn')
      .attr('type','button')
      .attr('value','NEXT')
      .attr('title', 'NEXT')
      .on('touchstart', function() { 
        
        d3.event.preventDefault(); 

        if (d3.select(this).attr('disabled') == null) {
         
          globals.log_message = { 
            "TimeStamp": new Date().valueOf(),
            "user_id": globals.userID,
            "Event": "Survey",
            "Question": "Ease",
            "Response": ease
          };
          
          console.log("Survey", globals.log_message);

           
          questionnaire(scene + 1); 
        }

      });

      likert_rb = d3.select('#questionnaire_div').selectAll(".menu_btn_enabled")
      .data([1,2,3,4,5])
      .enter();     

      setTimeout(function(){
        likert_rb.append('input')
        .attr('class', 'menu_btn_enabled')
        .style('width','18%')
        .style('margin-left','1%')      
        .style('margin-right','1%')
        .style('transform','translate(0,0)')
        .attr('type','button')
        .attr('value',function(d){
          return(d);
        })
        .attr('title', function(d){
          return(d);
        })
        .on('touchstart', function(d) {  

          d3.event.preventDefault(); 
                  
          d3.selectAll('.menu_btn_enabled').style('border', '1px solid #ccc');           
          d3.select(this).style('border', '5px solid gold');
          
          ease = d;

          d3.select('#submit_btn').attr('class', 'menu_btn_enabled')
          .attr('disabled', null);      
          
        });          
       
      }, 500);

      break;
    
    default: // return to main menu
          
      d3.select('#instruction_div').remove();
      
      var questionnaire_content_div = d3.select('#questionnaire_div')
      .append('div')
      .attr('class','toolbar')
      .style('width','100%')
      .style('height',(window.innerHeight - 50) + 'px')
      .attr('id','intro_content_div');      
      
      //CHANGE 9907617274 FOR PRODUCTION

      questionnaire_content_div.append('span')
      .attr('class','consent_text')
      .html('<span class="instruction_emphasis">Thank you!</span><br>You have completed the survey and the study. Copy your completion code below. This code will remain valid for 30 minutes:<br><br><span class="instruction_emphasis" id="copy_code" style="user-select:all;">9907617274</span>'
      );          

      d3.select('#questionnaire_div').append('input')
      .attr('class', 'btn')
      .attr('id','submit_btn')
      .attr('type','button')
      .attr('value','Copy 9907617274')
      .attr('title', 'Copy 9907617274')
      .attr('data-clipboard-target','#copy_code')
      .attr('data-clipboard-text', '9907617274');

      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "Event": "SurveyComplete",
        "user_id": globals.userID
      };
      
      console.log("SurveyComplete", globals.log_message);

      
      questionnaire_complete = true;

      break;
  }

  d3.select('#questionnaire_div')
  .style('visibility','visible');

  document.getElementById('questionnaire_div').focus();  
  
}

module.exports = questionnaire;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__(14), __webpack_require__(16), __webpack_require__(17)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports !== "undefined") {
        factory(module, require('./clipboard-action'), require('tiny-emitter'), require('good-listener'));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod, global.clipboardAction, global.tinyEmitter, global.goodListener);
        global.clipboard = mod.exports;
    }
})(this, function (module, _clipboardAction, _tinyEmitter, _goodListener) {
    'use strict';

    var _clipboardAction2 = _interopRequireDefault(_clipboardAction);

    var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);

    var _goodListener2 = _interopRequireDefault(_goodListener);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var Clipboard = function (_Emitter) {
        _inherits(Clipboard, _Emitter);

        /**
         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
         * @param {Object} options
         */
        function Clipboard(trigger, options) {
            _classCallCheck(this, Clipboard);

            var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));

            _this.resolveOptions(options);
            _this.listenClick(trigger);
            return _this;
        }

        /**
         * Defines if attributes would be resolved using internal setter functions
         * or custom functions that were passed in the constructor.
         * @param {Object} options
         */


        _createClass(Clipboard, [{
            key: 'resolveOptions',
            value: function resolveOptions() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
                this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
                this.text = typeof options.text === 'function' ? options.text : this.defaultText;
                this.container = _typeof(options.container) === 'object' ? options.container : document.body;
            }
        }, {
            key: 'listenClick',
            value: function listenClick(trigger) {
                var _this2 = this;

                this.listener = (0, _goodListener2.default)(trigger, 'click', function (e) {
                    return _this2.onClick(e);
                });
            }
        }, {
            key: 'onClick',
            value: function onClick(e) {
                var trigger = e.delegateTarget || e.currentTarget;

                if (this.clipboardAction) {
                    this.clipboardAction = null;
                }

                this.clipboardAction = new _clipboardAction2.default({
                    action: this.action(trigger),
                    target: this.target(trigger),
                    text: this.text(trigger),
                    container: this.container,
                    trigger: trigger,
                    emitter: this
                });
            }
        }, {
            key: 'defaultAction',
            value: function defaultAction(trigger) {
                return getAttributeValue('action', trigger);
            }
        }, {
            key: 'defaultTarget',
            value: function defaultTarget(trigger) {
                var selector = getAttributeValue('target', trigger);

                if (selector) {
                    return document.querySelector(selector);
                }
            }
        }, {
            key: 'defaultText',
            value: function defaultText(trigger) {
                return getAttributeValue('text', trigger);
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                this.listener.destroy();

                if (this.clipboardAction) {
                    this.clipboardAction.destroy();
                    this.clipboardAction = null;
                }
            }
        }], [{
            key: 'isSupported',
            value: function isSupported() {
                var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];

                var actions = typeof action === 'string' ? [action] : action;
                var support = !!document.queryCommandSupported;

                actions.forEach(function (action) {
                    support = support && !!document.queryCommandSupported(action);
                });

                return support;
            }
        }]);

        return Clipboard;
    }(_tinyEmitter2.default);

    /**
     * Helper function to retrieve attribute value.
     * @param {String} suffix
     * @param {Element} element
     */
    function getAttributeValue(suffix, element) {
        var attribute = 'data-clipboard-' + suffix;

        if (!element.hasAttribute(attribute)) {
            return;
        }

        return element.getAttribute(attribute);
    }

    module.exports = Clipboard;
});

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__(15)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports !== "undefined") {
        factory(module, require('select'));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod, global.select);
        global.clipboardAction = mod.exports;
    }
})(this, function (module, _select) {
    'use strict';

    var _select2 = _interopRequireDefault(_select);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    var ClipboardAction = function () {
        /**
         * @param {Object} options
         */
        function ClipboardAction(options) {
            _classCallCheck(this, ClipboardAction);

            this.resolveOptions(options);
            this.initSelection();
        }

        /**
         * Defines base properties passed from constructor.
         * @param {Object} options
         */


        _createClass(ClipboardAction, [{
            key: 'resolveOptions',
            value: function resolveOptions() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                this.action = options.action;
                this.container = options.container;
                this.emitter = options.emitter;
                this.target = options.target;
                this.text = options.text;
                this.trigger = options.trigger;

                this.selectedText = '';
            }
        }, {
            key: 'initSelection',
            value: function initSelection() {
                if (this.text) {
                    this.selectFake();
                } else if (this.target) {
                    this.selectTarget();
                }
            }
        }, {
            key: 'selectFake',
            value: function selectFake() {
                var _this = this;

                var isRTL = document.documentElement.getAttribute('dir') == 'rtl';

                this.removeFake();

                this.fakeHandlerCallback = function () {
                    return _this.removeFake();
                };
                this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;

                this.fakeElem = document.createElement('textarea');
                // Prevent zooming on iOS
                this.fakeElem.style.fontSize = '12pt';
                // Reset box model
                this.fakeElem.style.border = '0';
                this.fakeElem.style.padding = '0';
                this.fakeElem.style.margin = '0';
                // Move element out of screen horizontally
                this.fakeElem.style.position = 'absolute';
                this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px';
                // Move element to the same position vertically
                var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                this.fakeElem.style.top = yPosition + 'px';

                this.fakeElem.setAttribute('readonly', '');
                this.fakeElem.value = this.text;

                this.container.appendChild(this.fakeElem);

                this.selectedText = (0, _select2.default)(this.fakeElem);
                this.copyText();
            }
        }, {
            key: 'removeFake',
            value: function removeFake() {
                if (this.fakeHandler) {
                    this.container.removeEventListener('click', this.fakeHandlerCallback);
                    this.fakeHandler = null;
                    this.fakeHandlerCallback = null;
                }

                if (this.fakeElem) {
                    this.container.removeChild(this.fakeElem);
                    this.fakeElem = null;
                }
            }
        }, {
            key: 'selectTarget',
            value: function selectTarget() {
                this.selectedText = (0, _select2.default)(this.target);
                this.copyText();
            }
        }, {
            key: 'copyText',
            value: function copyText() {
                var succeeded = void 0;

                try {
                    succeeded = document.execCommand(this.action);
                } catch (err) {
                    succeeded = false;
                }

                this.handleResult(succeeded);
            }
        }, {
            key: 'handleResult',
            value: function handleResult(succeeded) {
                this.emitter.emit(succeeded ? 'success' : 'error', {
                    action: this.action,
                    text: this.selectedText,
                    trigger: this.trigger,
                    clearSelection: this.clearSelection.bind(this)
                });
            }
        }, {
            key: 'clearSelection',
            value: function clearSelection() {
                if (this.trigger) {
                    this.trigger.focus();
                }

                window.getSelection().removeAllRanges();
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                this.removeFake();
            }
        }, {
            key: 'action',
            set: function set() {
                var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';

                this._action = action;

                if (this._action !== 'copy' && this._action !== 'cut') {
                    throw new Error('Invalid "action" value, use either "copy" or "cut"');
                }
            },
            get: function get() {
                return this._action;
            }
        }, {
            key: 'target',
            set: function set(target) {
                if (target !== undefined) {
                    if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target.nodeType === 1) {
                        if (this.action === 'copy' && target.hasAttribute('disabled')) {
                            throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                        }

                        if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
                            throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                        }

                        this._target = target;
                    } else {
                        throw new Error('Invalid "target" value, use a valid Element');
                    }
                }
            },
            get: function get() {
                return this._target;
            }
        }]);

        return ClipboardAction;
    }();

    module.exports = ClipboardAction;
});

/***/ }),
/* 15 */
/***/ (function(module, exports) {

function select(element) {
    var selectedText;

    if (element.nodeName === 'SELECT') {
        element.focus();

        selectedText = element.value;
    }
    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
        var isReadOnly = element.hasAttribute('readonly');

        if (!isReadOnly) {
            element.setAttribute('readonly', '');
        }

        element.select();
        element.setSelectionRange(0, element.value.length);

        if (!isReadOnly) {
            element.removeAttribute('readonly');
        }

        selectedText = element.value;
    }
    else {
        if (element.hasAttribute('contenteditable')) {
            element.focus();
        }

        var selection = window.getSelection();
        var range = document.createRange();

        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);

        selectedText = selection.toString();
    }

    return selectedText;
}

module.exports = select;


/***/ }),
/* 16 */
/***/ (function(module, exports) {

function E () {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function (name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function (name, callback, ctx) {
    var self = this;
    function listener () {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback
    return this.on(name, listener, ctx);
  },

  emit: function (name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function (name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback)
          liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    (liveEvents.length)
      ? e[name] = liveEvents
      : delete e[name];

    return this;
  }
};

module.exports = E;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

var is = __webpack_require__(18);
var delegate = __webpack_require__(19);

/**
 * Validates all params and calls the right
 * listener function based on its target type.
 *
 * @param {String|HTMLElement|HTMLCollection|NodeList} target
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listen(target, type, callback) {
    if (!target && !type && !callback) {
        throw new Error('Missing required arguments');
    }

    if (!is.string(type)) {
        throw new TypeError('Second argument must be a String');
    }

    if (!is.fn(callback)) {
        throw new TypeError('Third argument must be a Function');
    }

    if (is.node(target)) {
        return listenNode(target, type, callback);
    }
    else if (is.nodeList(target)) {
        return listenNodeList(target, type, callback);
    }
    else if (is.string(target)) {
        return listenSelector(target, type, callback);
    }
    else {
        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
    }
}

/**
 * Adds an event listener to a HTML element
 * and returns a remove listener function.
 *
 * @param {HTMLElement} node
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNode(node, type, callback) {
    node.addEventListener(type, callback);

    return {
        destroy: function() {
            node.removeEventListener(type, callback);
        }
    }
}

/**
 * Add an event listener to a list of HTML elements
 * and returns a remove listener function.
 *
 * @param {NodeList|HTMLCollection} nodeList
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNodeList(nodeList, type, callback) {
    Array.prototype.forEach.call(nodeList, function(node) {
        node.addEventListener(type, callback);
    });

    return {
        destroy: function() {
            Array.prototype.forEach.call(nodeList, function(node) {
                node.removeEventListener(type, callback);
            });
        }
    }
}

/**
 * Add an event listener to a selector
 * and returns a remove listener function.
 *
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenSelector(selector, type, callback) {
    return delegate(document.body, selector, type, callback);
}

module.exports = listen;


/***/ }),
/* 18 */
/***/ (function(module, exports) {

/**
 * Check if argument is a HTML element.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.node = function(value) {
    return value !== undefined
        && value instanceof HTMLElement
        && value.nodeType === 1;
};

/**
 * Check if argument is a list of HTML elements.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.nodeList = function(value) {
    var type = Object.prototype.toString.call(value);

    return value !== undefined
        && (type === '[object NodeList]' || type === '[object HTMLCollection]')
        && ('length' in value)
        && (value.length === 0 || exports.node(value[0]));
};

/**
 * Check if argument is a string.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.string = function(value) {
    return typeof value === 'string'
        || value instanceof String;
};

/**
 * Check if argument is a function.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.fn = function(value) {
    var type = Object.prototype.toString.call(value);

    return type === '[object Function]';
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var closest = __webpack_require__(20);

/**
 * Delegates event to a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function _delegate(element, selector, type, callback, useCapture) {
    var listenerFn = listener.apply(this, arguments);

    element.addEventListener(type, listenerFn, useCapture);

    return {
        destroy: function() {
            element.removeEventListener(type, listenerFn, useCapture);
        }
    }
}

/**
 * Delegates event to a selector.
 *
 * @param {Element|String|Array} [elements]
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function delegate(elements, selector, type, callback, useCapture) {
    // Handle the regular Element usage
    if (typeof elements.addEventListener === 'function') {
        return _delegate.apply(null, arguments);
    }

    // Handle Element-less usage, it defaults to global delegation
    if (typeof type === 'function') {
        // Use `document` as the first parameter, then apply arguments
        // This is a short way to .unshift `arguments` without running into deoptimizations
        return _delegate.bind(null, document).apply(null, arguments);
    }

    // Handle Selector-based usage
    if (typeof elements === 'string') {
        elements = document.querySelectorAll(elements);
    }

    // Handle Array-like based usage
    return Array.prototype.map.call(elements, function (element) {
        return _delegate(element, selector, type, callback, useCapture);
    });
}

/**
 * Finds closest match and invokes callback.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Function}
 */
function listener(element, selector, type, callback) {
    return function(e) {
        e.delegateTarget = closest(e.target, selector);

        if (e.delegateTarget) {
            callback.call(element, e);
        }
    }
}

module.exports = delegate;


/***/ }),
/* 20 */
/***/ (function(module, exports) {

var DOCUMENT_NODE_TYPE = 9;

/**
 * A polyfill for Element.matches()
 */
if (typeof Element !== 'undefined' && !Element.prototype.matches) {
    var proto = Element.prototype;

    proto.matches = proto.matchesSelector ||
                    proto.mozMatchesSelector ||
                    proto.msMatchesSelector ||
                    proto.oMatchesSelector ||
                    proto.webkitMatchesSelector;
}

/**
 * Finds the closest parent that matches a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @return {Function}
 */
function closest (element, selector) {
    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
        if (typeof element.matches === 'function' &&
            element.matches(selector)) {
          return element;
        }
        element = element.parentNode;
    }
}

module.exports = closest;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var d3 = __webpack_require__(1);
var globals = __webpack_require__(0);
var chart = __webpack_require__(3);
var nationData = __webpack_require__(2);
var countrySelector = __webpack_require__(4);

function trial () {

  suppress_touch_val_feedback = true;
  suppress_touch_feedback = true;  
  globals.trial_response = [];
  globals.num_selected = 0;
  
  var checkExist;    
  var checkTouch;
  var trial;
  var giveup;
  
  function getDims() {
    height = window.innerHeight;
    width = window.innerWidth;
    svg_dim = d3.min([height,width]) - 2;
    inner_padding = svg_dim * 0.1;
    chart_dim = svg_dim * 0.8;
  }
  
  function draw() {
          
    d3.select('#main_svg')
    .style('height',svg_dim + 'px')
    .style('width',svg_dim + 'px');
    
    chart_g.attr('transform','translate(' + inner_padding + ',' + inner_padding + ')');
  
    d3.selectAll('.guide').remove();
    chart_instance.lines(globals.lines); 
    chart_instance.animation('off');
    chart_instance.facets(globals.facets);
    chart_instance.current_year(globals.facets == 'on' ? globals.param_yearMax : globals.param_yearMin);

    chart_g.call(chart_instance);
    scale_reg = chart_instance.scale_reg();
    d3.select('.year_indicator').style('display','none');
    d3.selectAll('.mark').style('visibility','hidden');
    chart_g.call(chart_instance);
  
    d3.selectAll('.toolbar')
    .style('float', function(){
      return height < width ? 'left' : 'inherit';
    })
    .style('width', function(){
      return height < width ? (height / 7) + 'px'  : width + 'px';
    })
    .style('height', function(){
      return height < width ? height + 'px'  : (width / 7) + 'px';
    });

    d3.select('#prompt')
    .style('margin', function(){
      return height < width ? '0px' : '2px';
    })
    .style('width', function (){
      return height < width ? (height - (height / 7) * (globals.condition == 'stepper' ? 3 : 1) - 6) + 'px' : (width - (width / 7) * (globals.condition == 'stepper' ? 3 : 1) - 6) + 'px';
    })
    .style('height', function(){
      return height < width ? (height / 7 - 6) : (width / 7 - 6) + 'px';
    }); 

    // d3.select('#trial_div')
    // .style('height', function(){
    //   return svg_dim + (height < width ? (height / 7 - 6) : (width / 7 - 6)) + 'px'; 
    // });

  }
  
  function loadData () {     

    globals.param_x = globals.trials[0].x;
    globals.param_y = globals.trials[0].y;
    globals.param_yearMin = globals.trials[0].yearMin;
    globals.param_yearMax = globals.trials[0].yearMax;

    checkExist = setInterval(function() {
      if (all_data != undefined) {        
        chart_g.datum(all_data);        
        draw();    
        
        nextTrial();
        
        hideAddressBar();

        d3.select('#trial_div')
        .style('visibility','visible');

        clearInterval(checkExist);
      }
    }, 100); // check every 100ms

    chart_instance = chart();    
  
    main_svg = d3.select('#main_svg').remove();
  
    main_svg = d3.select('#trial_div').append('svg')
    .attr('id','main_svg');  
  
    defs = d3.select('#main_svg').append('defs');
  
    chart_g = main_svg.append('g')
    .attr('id','chart_g');    
    
    document.getElementById('trial_div').focus();
  } 

  function nextTrial () {

    d3.selectAll('.mark').style('display',null);
    d3.selectAll('.path_line').style('display',null);
    d3.select('#main_svg').attr('class',null);
    d3.select('#done_btn').attr('class','img_btn_disabled')
    .style('display','none')
    .attr('disabled',true)
    .attr('src', 'assets/na.svg')
    .style('margin', function(){
      return height < width ? '0px' : '2px';
    })
    .attr('height', function(){
      return height < width ? (height / 7 - 6) : (width / 7 - 6);
    })
    .attr('width', function (){
      return width < height ? (width / 7 - 6) : (height / 7 - 6);
    });

    d3.select('#progress_indicator').style('display',null);
    d3.select('#outer_progress_indicator')
    .attr('display', globals.facets == 'on' ? 'none' : null);

    update_outer_progress(1 / 25);
    d3.select('#inner_progress_value').attr('d', globals.inner_progress_circle.endAngle(0));

    d3.select('#menubar').style('display','none');
    d3.select('.year_indicator').style('display','none');
    chart_instance.this_chart().interrupt();

    chart_instance.animation('off');
    chart_g.call(chart_instance);
    
    d3.selectAll('.mark').style('visibility','hidden');
    d3.selectAll('.line').style('visibility','hidden');
    if (document.getElementById('selector_div') != null){
      document.getElementById('selector_div').remove();
    }
    globals.trial_index++;
    globals.trial_response = [];

    if (globals.trial_index != max_trials) {

      var trial_prompt = globals.trials[globals.trial_index].prompt;
      var regex = /<span class='instruction_number'>/gi;
      trial_prompt = trial_prompt.replace(regex,"");
      regex = /<span class='instruction_emphasis'>/gi;
      trial_prompt = trial_prompt.replace(regex,"");
      regex = /<\/span>/gi;
      trial_prompt = trial_prompt.replace(regex,"");

      //init next trial
      trial = {
        user_id: globals.userID,
        ordering: globals.ordering,
        trial_index: globals.trial_index,
        condition: globals.condition,
        task_index: globals.trials[globals.trial_index].task_index,
        x: globals.trials[globals.trial_index].x,
        y: globals.trials[globals.trial_index].y,
        prompt: trial_prompt,
        num_responses: globals.trials[globals.trial_index].num_responses,
        correct_responses: globals.trials[globals.trial_index].correct_responses,
        yearMin: globals.trials[globals.trial_index].yearMin,
        yearMax: globals.trials[globals.trial_index].yearMax,
        tutorial: globals.trials[globals.trial_index].tutorial,
        quality_control: globals.trials[globals.trial_index].quality_control,
        responses: [],
        load_time: new Date().valueOf(),
        reading_time: 0,
        reading_interruptions: 0,
        reading_interruption_time: 0,
        start_time: 0,
        interruptions: 0,
        interruption_time: 0,
        end_time: 0,
        completion_time: 0,
        next_step_count: 0,
        prev_step_count: 0,
        loop_count: 0,
        attempts: 0,
        num_errors: 0,
        error: 0,
        give_up: false
      };

      globals.param_x = globals.trials[globals.trial_index].x;
      globals.param_y = globals.trials[globals.trial_index].y;
      globals.param_yearMin = globals.trials[globals.trial_index].yearMin;
      globals.param_yearMax = globals.trials[globals.trial_index].yearMax;

      chart_instance.params().yearMin = globals.param_yearMin;
      chart_instance.current_year(globals.facets == 'on' ? globals.param_yearMax : globals.param_yearMin);
      chart_instance.params().yearMax = globals.param_yearMax;      
      chart_instance.params().x = globals.param_x;
      chart_instance.params().y = globals.param_y;    
      
      chart_g.call(chart_instance);

      d3.select('#trial_div').append('div')
      .attr('class', 'feedback_btn_enabled')
      .style('top',(svg_dim + 5) + 'px')
      .attr('id','start_btn')
      .style('border-color','transparent')
      .style('height','125px');           

      var eur_hex = scale_reg('EU');
      var eur_color = '';
      switch (eur_hex) {

        case '#fad139':
          eur_color = 'yellow';
          break;

        case '#54b2fc':
          eur_color = 'blue';
          break;

        case '#f67afe':
          eur_color = 'pink';
          break;

        case '#8bba32':
          eur_color = 'green';
          break;

        case '#c29aeb':
          eur_color = 'purple';
          break;

        default:
          eur_color = '';
          break;
      }
      
      var eur_rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(scale_reg('EU'));
      var rgb_result = eur_rgb ? {
        r: parseInt(eur_rgb[1], 16),
        g: parseInt(eur_rgb[2], 16),
        b: parseInt(eur_rgb[3], 16)
      } : null;
      var eur_rgba = 'rgba(' + rgb_result.r + ',' + rgb_result.g + ',' + rgb_result.b + ',0.5)';
      
      var eur = eur_color + " / <span style='font-size:1em; -webkit-text-stroke: 0.5px #fff; color:" + eur_rgba + ";'>⬤</span>";

      globals.trials[globals.trial_index].prompt = globals.trials[globals.trial_index].prompt.replace("foo", eur);

      d3.select('#start_btn').append('span')
      .attr('id','button_text')
      .html((globals.trials[globals.trial_index].tutorial ? '<span>Take note of the <span class="instruction_emphasis" style="color:gold;">two chart axes</span> above and this instruction:</span><br>' : '') + globals.trials[globals.trial_index].prompt + '<br>' + '<span id="time_warning">You may proceed after <span class="instruction_emphasis">5 seconds</span>.</span>' + '<span  id="time_delay_message" style="display:none;">Tap on this message to start ' + (globals.trials[globals.trial_index].tutorial ? 'this <span class="instruction_emphasis">PRACTICE</span> trial' : ('trial <span class="instruction_emphasis">' + ((globals.trial_index - 3) + 1) + '</span> of <span class="instruction_emphasis">' + (globals.trials.length - 3) + '</span>'))  + '<br> and TRIGGER THE TIMER.</span>');  

      setTimeout(function(){
        // allow participant to proceed after 5s

        d3.select('#time_delay_message')
        .style('display',null);

        d3.select('#time_warning')
        .style('display','none');

        d3.select('#start_btn')
        .style('border-color','#fff')
        .on('touchstart', function() {   

          startTrial();
        }); 
      }, 5000);

    }
    else {
      globals.trial_index = -1;
      experiment_complete = true;

      chart_instance.animation('off');
      chart_instance.lines('off');
      chart_instance.facets('off');
      chart_instance.loop_count(0);
      
      globals.animation = 'off';
      globals.lines = 'off';
      globals.facets = 'off';

      chart_g.call(chart_instance);

      globals.log_message = { 
        "TimeStamp": new Date().valueOf(),
        "Event": "TrialsCompleted",
        "user_id": globals.userID
      };

      console.log("TrialsCompleted", globals.log_message);

      document.getElementById('trial_div').remove();
      
      loadMenu();
      hideAddressBar();  
    }
  }

  function startTrial () {

    chart_instance.loop_count(0);

    d3.select('#menubar').style('display',null);
    d3.select('.year_indicator').style('display',null);

    d3.selectAll('.mark').style('visibility','visible');
    d3.selectAll('.line').style('visibility','visible');

    update_outer_progress(1 / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin));

    if (globals.animation == 'on'){
      chart_instance.animation('on');
      chart_g.call(chart_instance);
    }

    d3.selectAll('.img_btn_disabled')
    .style('margin', function(){
      return height < width ? '0px' : '2px';
    })
    .attr('height', function(){
      return height < width ? (height / 7 - 6) : (width / 7 - 6);
    })
    .attr('width', function (){
      return width < height ? (width / 7 - 6) : (height / 7 - 6);
    }); 

    d3.select('#prev_btn').attr('class',(chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? 'img_btn_disabled' : (globals.condition == 'stepper' ? 'img_btn_enabled' : 'img_btn_disabled'))
    .attr('disabled', (chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? true : (globals.condition == 'stepper' ? null : true))
    .attr('src', globals.condition == 'stepper' ? 'assets/prev_grey.svg' : 'assets/na.svg');

    d3.select('#next_btn')
    .attr('class', globals.condition == 'stepper' ? 'img_btn_enabled' : 'img_btn_disabled')
    .attr('disabled', globals.condition == 'stepper' ? null : true)
    .attr('src', globals.condition == 'stepper' ? 'assets/next.svg' : 'assets/na.svg');

    d3.select('#done_btn')
    .style('display','none')
    .attr('class', 'img_btn_disabled')
    .attr('disabled',true);

    trial.interruptions = 0;
    trial.interruption_time = 0;
    trial.start_time = new Date().valueOf();
    
    if (resumptions.length > 0 ) {
      var i = resumptions.length - 1;
      while (resumptions[i].resumption_time > trial.load_time && i >= 0) {
        trial.reading_interruptions++;
        trial.reading_interruption_time += resumptions[i].pause_duration;
        i--;
      }
    }

    trial.reading_time = trial.start_time - trial.load_time - trial.reading_interruption_time;
    
    d3.select('#start_btn').remove();
    countrySelector();
    d3.select('.task_instruction_span').html(globals.trials[globals.trial_index].prompt);   

    if (globals.trials[globals.trial_index].tutorial != true) {
      giveUpLoop();
    }

  }

  function giveUpLoop () {

    giveup = setTimeout(function(){
      // I give up / I don't know option presented after 30s
      d3.select('#main_svg').attr('class','blurme');
      d3.select('#selector_div').style('display','none');
      d3.select('#menubar').style('display','none');

      var keep_going_btn =  d3.select('#trial_div').append('div')
      .attr('class', 'feedback_btn_enabled')
      .attr('id','keep_going_btn')
      .style('background','#8bc34a')
      .style('height','50px')
      .style('border-color','#fff')
      .on('touchstart', function() {  

        d3.event.preventDefault(); 
        
        d3.select('#keep_going_btn').remove();
        d3.select('#give_up_btn').remove();
        d3.select('#menubar').style('display',null);
        d3.select('#main_svg').attr('class',null);
        d3.select('#selector_div').style('display',null);            
        giveUpLoop();
        
      });  

      keep_going_btn.append('span')
      .attr('id','button_text')      
      .style('color','#111')
      .style('font-weight','400')
      .html('<span class="correct_incorrect">NEED MORE TIME?</span><br>Tap on this message if you need more time.'); 

      var give_up_btn =  d3.select('#trial_div').append('div')
      .attr('class', 'feedback_btn_enabled')
      .attr('id','give_up_btn')
      .style('height','50px')
      .style('background','#ef5350')
      .style('border-color','#fff')
      .on('touchstart', function() {  

        d3.event.preventDefault(); 
        
        d3.select('#keep_going_btn').remove();
        d3.select('#give_up_btn').remove();  
        trial.give_up = true;     
        endTrial();            
        
      });  

      give_up_btn.append('span')
      .attr('id','button_text')      
      .style('color','#111')
      .style('font-weight','400')
      .html('<span class="correct_incorrect">GIVE UP?</span><br>Tap on this message if you don\'t know the answer.'); 

    }, 60000);

  }

  function endTrial () {

    clearTimeout(giveup);

    if (d3.select('#done_btn').attr('disabled') == null || trial.give_up) {

      var i = 0;
      trial.num_errors = 0;
      trial.loop_count = chart_instance.loop_count();
      trial.attempts++;

      for (i = 0; i < globals.trial_response.length; i++) {
        if (globals.trials[globals.trial_index].correct_responses.indexOf(globals.trial_response[i]) == -1) {
          trial.num_errors++;
        }
      }

      trial.error = trial.num_errors / globals.trials[globals.trial_index].num_responses;

      if (trial.give_up) {
        trial.num_errors = globals.trials[globals.trial_index].num_responses;
        trial.error = 1;
      }

      if (resumptions.length > 0 ) {
        var j = resumptions.length - 1;
        while (resumptions[j].resumption_time > trial.start_time && j >= 0) {
          trial.interruptions++;
          trial.interruption_time += resumptions[j].pause_duration;
          j--;
        }
      }

      trial.end_time = new Date().valueOf();
      trial.completion_time = trial.end_time - trial.start_time - trial.interruption_time;
      trial.responses = globals.trial_response;

      console.log('TrialComplete', trial);


      if (globals.trials[globals.trial_index].tutorial == true) {

        d3.select('#main_svg').attr('class','blurme');
        d3.select('#selector_div').remove();
        d3.select('#menubar').style('display','none');
        // give feedback for tutorial trials
        if (trial.error != 0){
          //give negative feedback

          var incorrect_feedback_btn =  d3.select('#trial_div').append('div')
          .attr('class', 'feedback_btn_enabled')
          .attr('id','feedback_btn')
          .style('background','#ef5350')
          .style('border-color','#fff')        
          .on('touchstart', function() {  

            d3.event.preventDefault(); 

            if (trial.attempts >= 2) {
              //show hint   
              all_data.forEach(function (d){
                if (globals.trials[globals.trial_index].correct_responses.indexOf(d.name) != -1) {
                  d3.select('#mark_' + d.code).style('display',null);
                  d3.select('#line_' + d.code).select('.path_line').style('display',null);
                }
                else {
                  d3.select('#line_' + d.code).select('.path_line').style('display','none');
                  d3.select('#mark_' + d.code).style('display','none');
                }
              });

              if (trial.attempts <= 3) {
                setTimeout(function(){
                  // Hide the address bar!
                  d3.selectAll('.mark').style('display',null);
                  d3.selectAll('.path_line').style('display',null);
                }, 1500);    
              }
        
            }

            d3.select('#progress_indicator').style('display',null);
            d3.select('#outer_progress_indicator')
            .attr('display', globals.facets == 'on' ? 'none' : null);
            d3.select('#done_btn').attr('class','img_btn_disabled')
            .style('display','none')
            .attr('disabled',true)
            .attr('src', 'assets/na.svg')
            .style('margin', function(){
              return height < width ? '0px' : '2px';
            })
            .attr('height', function(){
              return height < width ? (height / 7 - 6) : (width / 7 - 6);
            })
            .attr('width', function (){
              return width < height ? (width / 7 - 6) : (height / 7 - 6);
            });
            d3.select('#feedback_btn').remove();
            d3.select('#menubar').style('display',null);
            d3.select('#main_svg').attr('class',null);
            globals.num_selected = 0;
            globals.trial_response = [];
            trial.responses = [];
            trial.error = 0;
            trial.num_errors = 0;
            countrySelector();
            d3.select('#inner_progress_value').attr('d', globals.inner_progress_circle.endAngle(0));
            
            //try again
            trial.start_time = new Date().valueOf();
          });  

          incorrect_feedback_btn.append('span')
          .attr('id','button_text')
          .style('color','#111')
          .style('font-weight','400')
          .html(function() {            
            if (trial.attempts > 3) {
              return '<span class="correct_incorrect">INCORRECT</span><br>Tap on this message to see the correct response.';
            } 
            else if (trial.attempts > 1) {
              return '<span class="correct_incorrect">INCORRECT</span><br>Tap on this message to see a brief hint.';
            } 
            else {
               return '<span class="correct_incorrect">INCORRECT</span><br>Tap on this message to try again.';
            }
          }); 
        }
        else {
          //give positive feedback

          d3.select('#selector_div').remove();
          d3.select('#menudiv').remove();
        
          var correct_feedback_btn = d3.select('#trial_div').append('div')
          .attr('class', 'feedback_btn_enabled')
          .attr('id','feedback_btn')
          .style('background','#8bc34a')
          .style('border-color','#fff')
          .on('touchstart', function() { 

            d3.event.preventDefault(); 

            d3.select('#feedback_btn').remove(); 
            if (globals.trial_index == 2) {

              globals.log_message = { 
                "TimeStamp": new Date().valueOf(),
                "Event": "TutorialsCompleted",
                "user_id": globals.userID
              };
        
              console.log("TutorialsCompleted", globals.log_message);


              var timed_trial_warning = d3.select('#trial_div').append('div')
              .attr('class', 'feedback_btn_enabled')
              .attr('id','timed_trial_warning')
              .style('border-color','#fff')
              .on('touchstart', function() {    
                d3.event.preventDefault(); 
                d3.select('#timed_trial_warning').remove(); 
                nextTrial();
              }); 
              
              timed_trial_warning.append('span')
              .attr('id','button_text')
              .style('font-weight','400')
              .html('You have completed the practice trials. Complete the following trials as <span class="instruction_emphasis">quickly</span> and as <span class="instruction_emphasis">accurately</span> as you can. You will not be told if your responses are correct. <br><span class="instruction_emphasis">Tap on this message to continue</span>.');  
            }
            else {
              nextTrial();
            }
             
          });        

          correct_feedback_btn.append('span')
          .attr('id','button_text')
          .style('color','#111')
          .style('font-weight','400')
          .html('<span class="correct_incorrect">CORRECT</span><br>Tap on this message to continue.<br>');  
        }
      }
      else {
        //test trial
        nextTrial();
      }

    }
  }
    
  /** INIT **/
  
  d3.select('body').append('div')
  .attr('id','trial_div')
  .attr('tabindex',0);

  all_data = nationData;  
  var codes = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P"]; //,
  codes = shuffle(codes);
  all_data.forEach(function (d,i){ 
    d.code = codes[i]; 
  });
  loadData(); 

  getDims();

  var menubar = d3.select('#trial_div').append('div')
  .attr('class','toolbar')
  .style('display','none')
  .attr('id','menubar');  

  menubar.append("input")
  .attr('class','img_btn_disabled')  
  .attr('id','prev_btn')
  .attr('type','image')
  .attr('name','PrevToggle')
  .attr('title', 'PrevToggle')
  .attr('disabled', true)
  .style('display',globals.condition == 'stepper' ? null : 'none')
  .attr('src', globals.condition == 'stepper' ? 'assets/prev_grey.svg' : 'assets/na.svg')
  .on('touchstart', function() {    
    d3.event.preventDefault();    

    if (globals.condition == 'stepper'){

      clearTimeout(giveup);
      giveUpLoop();

      d3.select(this).attr('src', globals.condition == 'stepper' ? (chart_instance.loop_count() < 1 ? 'assets/prev_grey.svg' : 'assets/prev_gold.svg') : 'assets/na.svg');
      chart_instance.this_chart().interrupt();      

      if (chart_instance.current_year() != chart_instance.params().yearMin) {      
        var prev_year = chart_instance.current_year() - 1;
        chart_instance.current_year(prev_year);
        var outer_progress =  ((prev_year + 1) - chart_instance.params().yearMin) / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin);
        update_outer_progress(chart_instance.loop_count() + outer_progress);
        
      }
      else if (chart_instance.loop_count() > 0 && chart_instance.current_year() == chart_instance.params().yearMin) {
        chart_instance.current_year(chart_instance.params().yearMax);
        d3.selectAll('.mark').style('display','none');
        d3.selectAll('.path_line').style('display','none');
        setTimeout(function(){
          d3.selectAll('.mark').style('display',null);
          d3.selectAll('.path_line').style('display',null);
        }, 500);
      }
      trial.prev_step_count++;
      chart_g.call(chart_instance);

      checkTouch = setInterval(function() {
        if (chart_instance.current_year() != chart_instance.params().yearMin) {
          var prev_year = chart_instance.current_year() - 1;
          chart_instance.current_year(prev_year);   
          var outer_progress =  ((prev_year + 1) - chart_instance.params().yearMin) / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin);
          update_outer_progress(chart_instance.loop_count() + outer_progress);
        }
        else if (chart_instance.loop_count() > 0 && chart_instance.current_year() == chart_instance.params().yearMin) {
          chart_instance.current_year(chart_instance.params().yearMax);
          d3.selectAll('.mark').style('display','none');
          d3.selectAll('.path_line').style('display','none');
          setTimeout(function(){
            d3.selectAll('.mark').style('display',null);
            d3.selectAll('.path_line').style('display',null);
          }, 500);
        }
        trial.prev_step_count++;
        chart_g.call(chart_instance);
        
      }, 500); // check every 500ms if touch is ongoing          

    }
  })
  .on('touchend', function(){
    
    d3.event.preventDefault();
    clearInterval(checkTouch);

    if (globals.condition == 'stepper') {
      d3.select(this).attr('class',(chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? 'img_btn_disabled' : 'img_btn_enabled')
      .attr('disabled', (chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? true : null)
      .attr('src', (chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? 'assets/prev_grey.svg' : 'assets/prev.svg');
    }
  });    

  menubar.append("input")
  .attr('id','next_btn')
  .attr('class', 'img_btn_disabled')  
  .attr('type','image') 
  .attr('name','NextToggle')
  .attr('title', 'NextToggle')
  .style('display',globals.condition == 'stepper' ? null : 'none')
  .attr('src', globals.condition == 'stepper' ? 'assets/next.svg' : 'assets/na.svg')
  .attr('disabled', globals.condition == 'stepper' ? null : true)
  .on('touchstart', function() {    
    d3.event.preventDefault();    

    if (globals.condition == 'stepper'){

      clearTimeout(giveup);
      giveUpLoop();

      d3.select(this).attr('src', globals.condition == 'stepper' ? 'assets/next_gold.svg' : 'assets/na.svg');
      chart_instance.this_chart().interrupt();

      if (chart_instance.current_year() == chart_instance.params().yearMax) {
        chart_instance.current_year(chart_instance.params().yearMin);
        d3.selectAll('.mark').style('display','none');
        d3.selectAll('.path_line').style('display','none');
        setTimeout(function(){
          d3.selectAll('.mark').style('display',null);
          d3.selectAll('.path_line').style('display',null);
        }, 500);
      }
      else {
        var next_year = chart_instance.current_year() + 1;
        var outer_progress =  ((next_year + 1) - chart_instance.params().yearMin) / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin);
        update_outer_progress(chart_instance.loop_count() + outer_progress);
        if (chart_instance.current_year() == (chart_instance.params().yearMax - 1)) {
          chart_instance.loop_count(chart_instance.loop_count() + 1);
          if (globals.num_selected == globals.trials[globals.trial_index].num_responses){          
            d3.select('#progress_indicator').style('display','none');
            d3.select('#done_btn').attr('class','img_btn_enabled')
            .style('display',null)
            .attr('disabled',null)
            .attr('src', 'assets/done.svg');
          }
        }
        chart_instance.current_year(next_year);
      }
      trial.next_step_count++;
      chart_g.call(chart_instance);     

      checkTouch = setInterval(function() {
        if (chart_instance.current_year() == chart_instance.params().yearMax) {
          chart_instance.current_year(chart_instance.params().yearMin);
          d3.selectAll('.mark').style('display','none');
          d3.selectAll('.path_line').style('display','none');
          setTimeout(function(){
            d3.selectAll('.mark').style('display',null);
            d3.selectAll('.path_line').style('display',null);
          }, 500);
        }
        else {
          var next_year = chart_instance.current_year() + 1;
          var outer_progress =  ((next_year + 1) - chart_instance.params().yearMin) / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin);
          update_outer_progress(chart_instance.loop_count() + outer_progress);
          if (chart_instance.current_year() == (chart_instance.params().yearMax - 1)) {
            chart_instance.loop_count(chart_instance.loop_count() + 1);
            if (globals.num_selected == globals.trials[globals.trial_index].num_responses){          
              d3.select('#progress_indicator').style('display','none');
              d3.select('#done_btn').attr('class','img_btn_enabled')
              .style('display',null)
              .attr('disabled',null)
              .attr('src', 'assets/done.svg');
            }
          }
          chart_instance.current_year(next_year);
        }
        trial.next_step_count++;
        chart_g.call(chart_instance);
      }, 500); // check every 500ms if touch is ongoing    

    }
  })
  .on('touchend', function(){

    d3.event.preventDefault();
    clearInterval(checkTouch);

    d3.select(this).attr('src', globals.condition == 'stepper' ? 'assets/next.svg' : 'assets/na.svg');

    if (globals.condition == 'stepper') {
      d3.select('#prev_btn').attr('class',(chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? 'img_btn_disabled' : 'img_btn_enabled')
      .attr('disabled', (chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? true : null)
      .attr('src', (chart_instance.current_year() == chart_instance.params().yearMin && chart_instance.loop_count() < 1) ? 'assets/prev_grey.svg' : 'assets/prev.svg');
    }

  });    

  var prompt = menubar.append("div")
  .attr('id','prompt')
  .on('touchstart', function() {    
    d3.event.preventDefault(); 
  });

  prompt.append('span')
  .attr('class','task_instruction_span')
  .html('');  

  menubar.append("input")
  .attr('class', 'img_btn_disabled')
  .attr('disabled',true)
  .style('display','none')
  .attr('id','done_btn')
  .attr('type','image')
  .attr('name','Done')
  .attr('title', 'Done')
  .attr('src', 'assets/na.svg')
  .on('touchstart', endTrial);

  //progress indicators
  var progress_colors = {
    outer_fill: 'gold',
    inner_fill: '#fff',
    track: '#999',
    stroke: '#333',
  };

  var progress_radius = (height < width ? (height / 7 - 6) : (width / 7 - 6)) / 2;
  var progress_stroke = 2;
  var progress_dim = progress_radius * 2;

  var progress_svg = menubar.append("svg")
  .attr('disabled',true)
  .attr('id','progress_indicator')
  .attr('height', progress_dim)
  .attr('width', progress_dim);
  
  globals.outer_progress_circle = d3.arc()
  .startAngle(0)
  .cornerRadius(7.5)
  .innerRadius(progress_radius)
  .outerRadius(progress_radius - 7.5);

  var outer_track_circle = d3.arc()
  .startAngle(0)
  .endAngle(Math.PI * 2)
  .innerRadius(progress_radius)
  .outerRadius(progress_radius - 7.5);

  globals.inner_progress_circle = d3.arc()
  .startAngle(0)
  .cornerRadius(7.5)
  .innerRadius(progress_radius - 7.5)
  .outerRadius(progress_radius - 15);

  var inner_track_circle = d3.arc()
  .startAngle(0)
  .endAngle(Math.PI * 2)
  .innerRadius(progress_radius - 7.5)
  .outerRadius(progress_radius - 15);

  var outer_progress_track = progress_svg.append('g')
  .attr('id','outer_progress_indicator')
  .attr('display', globals.facets == 'on' ? 'none' : null)
  .attr('transform', 'translate(' + progress_dim / 2 + ',' + progress_dim / 2 + ')');
  
  outer_progress_track.append('path')
  .attr('fill', progress_colors.track)
  .attr('stroke', progress_colors.stroke)
  .attr('stroke-width', progress_stroke + 'px')
  .attr('d', outer_track_circle);

  outer_progress_track.append('path')
  .attr('id', 'outer_progress_value')
  .attr('fill', progress_colors.outer_fill)
  .attr('stroke', progress_colors.stroke)
  .attr('stroke-width', progress_stroke + 'px')
  .attr('d', globals.inner_progress_circle.endAngle(0));

  function update_outer_progress(progress) {
    d3.select('#outer_progress_value').attr('d', globals.outer_progress_circle.endAngle((Math.PI * 2) * progress));
  } 

  update_outer_progress(1 / ((chart_instance.params().yearMax + 1) - chart_instance.params().yearMin));

  var inner_progress_track = progress_svg.append('g')
  .attr('id','inner_progress_indicator')
  .attr('display', null)
  .attr('transform', 'translate(' + progress_dim / 2 + ',' + progress_dim / 2 + ')');
  
  inner_progress_track.append('path')
  .attr('fill', progress_colors.track)
  .attr('stroke', progress_colors.stroke)
  .attr('stroke-width', progress_stroke + 'px')
  .attr('d', inner_track_circle);

  inner_progress_track.append('path')
  .attr('id', 'inner_progress_value')
  .attr('fill', progress_colors.inner_fill)
  .attr('stroke', progress_colors.stroke)
  .attr('stroke-width', progress_stroke + 'px')
  .attr('d', globals.inner_progress_circle.endAngle(0));
  
}

module.exports = trial;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var d3 = __webpack_require__(1);
var globals = __webpack_require__(0);

function menu () {
    
  /** INIT **/
  
  d3.select('body').append('div')
  .attr('id','menu_div')
  .attr('tabindex',0);  

  var instruction_div = d3.select('#menu_div').append('div')
  .attr('class','toolbar')
  .attr('id','instruction_div')
  .style('height','50px');  

  instruction_div.append('span')
  .attr('id','instruction_text')
  .html('<span class="instruction_emphasis">BUBBLE <span class="instruction_emphasis" id="secret_sandbox">CHARTS</span> ON MOBILE PHONES</span><br>Tap on the buttons below to proceed with the experiment.');  
  
  var navbar = d3.select('#menu_div').append('div')
  .attr('class','toolbar')
  .attr('id','navbar');

  navbar.append("input")
  .attr('class', test_override || !consent_complete ? 'menu_btn_enabled' : 'menu_btn_disabled')
  .attr('disabled', test_override || !consent_complete ? null : true)
  .attr('id','consent_btn')    
  .attr('type','button')
  .attr('value','1. Consent to Participate')
  .attr('title', '1. Consent to Participate');

  navbar.append("input")
  .attr('class', test_override || (!introduction_complete && consent_complete) ? 'menu_btn_enabled' : 'menu_btn_disabled')
  .attr('disabled', test_override || (!introduction_complete && consent_complete) ? null : true)
  .attr('id','introduction_btn')    
  .attr('type','button')
  .attr('value','2. Introduction to the Experiment')
  .attr('title', '2. Introduction to the Experiment');  

  navbar.append("input")
  .attr('id','trial_btn')
  .attr('class', (test_override || (introduction_complete && !experiment_complete)) ? 'menu_btn_enabled' : 'menu_btn_disabled')
  .attr('disabled', (test_override || (introduction_complete && !experiment_complete)) ? null : true)
  .attr('type','button')
  .attr('value','3. Experiment')
  .attr('title', '3. Experiment');

  navbar.append("input")
  .attr('class', (test_override || experiment_complete) ? 'menu_btn_enabled' : 'menu_btn_disabled')
  .attr('disabled', (test_override || experiment_complete) ? null : true)
  .attr('id','questionnaire_btn')    
  .attr('type','button')
  .attr('value','4. Survey & Conclusion')
  .attr('title', '4. Survey & Conclusion');

  d3.select('#menu_div').append('div')
  .attr('class','toolbar')
  .attr('id','menu_footer')
  .html('<span> <a href="mailto:mabrehme@microsoft.com" target="_blank">Contact</a> | <a href="https://go.microsoft.com/fwlink/?LinkId=521839" target="_blank">Privacy & Cookies</a> | <a href="https://www.microsoft.com/en-us/legal/intellectualproperty/copyright/default.aspx" target="_blank">Terms of Use</a> | © 2018 Microsoft</span>');  

  // var param_list = [
  //   "Life Expectancy",
  //   "Income Per Capita ($)",
  //   "GDP Per Capita ($)",
  //   "Fertility Rate",
  //   "CO2 Emissions",
  //   "Population",
  //   "Electricity Consumption (kWh)",
  //   "Infant Mortality (per 1k births)",
  //   "Murder Rate (per 100k)",
  //   "Traffic Mortalities (per 100k)"
  // ];

  // var param_list = [
  //   "Population",
  //   "Arable Area",
  //   "Energy Consumption",
  //   "GDP Per Capita",
  //   "Life Expectancy (Women)",
  //   "Life Expectancy (Men)",
  //   "Life Expectancy",
  //   "Infant Mortality",
  //   "Number of Personal Computers"
  // ];

  // navbar.append("select")
  // .attr('id','x_picker')
  // .attr('class','menu_select_enabled')
  // .on('change', function() {
  //   if (globals.param_y == d3.select(this).property('value')){
  //     d3.select(this).property('value', globals.param_x);
  //     alert('x != y');
  //   }
  //   else{
  //     globals.param_x = d3.select(this).property('value');
  //   }
  //   console.log(globals.param_x);
  // })
  // .selectAll('option')
  // .data(param_list)
  // .enter()
  // .append('option')
  // .attr("value", function (d) { return d; })
  // .text(function (d) { return 'x: ' + d; })
  // .property("selected", function (d) {
  //   return d === globals.param_x;
  // });

  // navbar.append("select")
  // .attr('id','y_picker')
  // .attr('class','menu_select_enabled')  
  // .on('change', function() {
  //   if (globals.param_x == d3.select(this).property('value')){
  //     d3.select(this).property('value', globals.param_y);
  //     alert('y != x');
  //   }
  //   else {
  //     globals.param_y = d3.select(this).property('value');
  //   }
  //   console.log(globals.param_y);
  // })
  // .selectAll('option')
  // .data(param_list)
  // .enter()
  // .append('option')
  // .attr("value", function (d) { return d; })
  // .text(function (d) { return 'y: ' + d; })
  // .property("selected", function (d) {
  //   return d === globals.param_y;
  // });
 
}

module.exports = menu;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

!function(t,n){ true?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n(t.flubber=t.flubber||{})}(this,function(t){"use strict";function n(t){return 10===t||13===t||8232===t||8233===t||32===t||9===t||11===t||12===t||160===t||t>=5760&&an.indexOf(t)>=0}function e(t){switch(32|t){case 109:case 122:case 108:case 104:case 118:case 99:case 115:case 113:case 116:case 97:case 114:return!0}return!1}function r(t){return t>=48&&t<=57}function i(t){return t>=48&&t<=57||43===t||45===t||46===t}function a(t){this.index=0,this.path=t,this.max=t.length,this.result=[],this.param=0,this.err="",this.segmentStart=0,this.data=[]}function o(t){for(;t.index<t.max&&n(t.path.charCodeAt(t.index));)t.index++}function s(t){var n,e=t.index,i=e,a=t.max,o=!1,s=!1,h=!1,u=!1;if(i>=a)return void(t.err="SvgPath: missed param (at pos "+i+")");if(n=t.path.charCodeAt(i),43!==n&&45!==n||(i++,n=i<a?t.path.charCodeAt(i):0),!r(n)&&46!==n)return void(t.err="SvgPath: param should start with 0..9 or `.` (at pos "+i+")");if(46!==n){if(o=48===n,i++,n=i<a?t.path.charCodeAt(i):0,o&&i<a&&n&&r(n))return void(t.err="SvgPath: numbers started with `0` such as `09` are ilegal (at pos "+e+")");for(;i<a&&r(t.path.charCodeAt(i));)i++,s=!0;n=i<a?t.path.charCodeAt(i):0}if(46===n){for(u=!0,i++;r(t.path.charCodeAt(i));)i++,h=!0;n=i<a?t.path.charCodeAt(i):0}if(101===n||69===n){if(u&&!s&&!h)return void(t.err="SvgPath: invalid float exponent (at pos "+i+")");if(i++,n=i<a?t.path.charCodeAt(i):0,43!==n&&45!==n||i++,!(i<a&&r(t.path.charCodeAt(i))))return void(t.err="SvgPath: invalid float exponent (at pos "+i+")");for(;i<a&&r(t.path.charCodeAt(i));)i++}t.index=i,t.param=parseFloat(t.path.slice(e,i))+0}function h(t){var n,e;n=t.path[t.segmentStart],e=n.toLowerCase();var r=t.data;if("m"===e&&r.length>2&&(t.result.push([n,r[0],r[1]]),r=r.slice(2),e="l",n="m"===n?"l":"L"),"r"===e)t.result.push([n].concat(r));else for(;r.length>=rn[e]&&(t.result.push([n].concat(r.splice(0,rn[e]))),rn[e]););}function u(t){var n,r,a,u,c=t.max;if(t.segmentStart=t.index,n=t.path.charCodeAt(t.index),!e(n))return void(t.err="SvgPath: bad command "+t.path[t.index]+" (at pos "+t.index+")");if(a=rn[t.path[t.index].toLowerCase()],t.index++,o(t),t.data=[],!a)return void h(t);for(r=!1;;){for(u=a;u>0;u--){if(s(t),t.err.length)return;t.data.push(t.param),o(t),r=!1,t.index<c&&44===t.path.charCodeAt(t.index)&&(t.index++,o(t),r=!0)}if(!r){if(t.index>=t.max)break;if(!i(t.path.charCodeAt(t.index)))break}}h(t)}function c(t,n){return[t[0]*n[0]+t[2]*n[1],t[1]*n[0]+t[3]*n[1],t[0]*n[2]+t[2]*n[3],t[1]*n[2]+t[3]*n[3],t[0]*n[4]+t[2]*n[5]+t[4],t[1]*n[4]+t[3]*n[5]+t[5]]}function f(){if(!(this instanceof f))return new f;this.queue=[],this.cache=null}function l(t,n,e,r){var i=t*r-n*e<0?-1:1,a=Math.sqrt(t*t+n*n),o=Math.sqrt(t*t+n*n),s=t*e+n*r,h=s/(a*o);return h>1&&(h=1),h<-1&&(h=-1),i*Math.acos(h)}function p(t,n,e,r,i,a,o,s,h,u){var c=u*(t-e)/2+h*(n-r)/2,f=-h*(t-e)/2+u*(n-r)/2,p=o*o,g=s*s,v=c*c,x=f*f,y=p*g-p*x-g*v;y<0&&(y=0),y/=p*x+g*v,y=Math.sqrt(y)*(i===a?-1:1);var d=y*o/s*f,m=y*-s/o*c,M=u*d-h*m+(t+e)/2,w=h*d+u*m+(n+r)/2,b=(c-d)/o,L=(f-m)/s,A=(-c-d)/o,q=(-f-m)/s,k=l(1,0,b,L),P=l(b,L,A,q);return 0===a&&P>0&&(P-=ln),1===a&&P<0&&(P+=ln),[M,w,k,P]}function g(t,n){var e=4/3*Math.tan(n/4),r=Math.cos(t),i=Math.sin(t),a=Math.cos(t+n),o=Math.sin(t+n);return[r,i,r-i*e,i+r*e,a+o*e,o-a*e,a,o]}function v(t,n,e){if(!(this instanceof v))return new v(t,n,e);this.rx=t,this.ry=n,this.ax=e}function x(t){if(!(this instanceof x))return new x(t);var n=on(t);this.segments=n.segments,this.err=n.err,this.__stack=[]}function y(t){var n=t.match(wn);return n?n.map(Number):[]}function d(t,n,e,r,i,a,o,s){this.a={x:t,y:n},this.b={x:e,y:r},this.c={x:i,y:a},this.d={x:o,y:s},null!==o&&void 0!==o&&null!==s&&void 0!==s?(this.getArcLength=_,this.getPoint=L,this.getDerivative=M):(this.getArcLength=A,this.getPoint=b,this.getDerivative=m),this.init()}function m(t,n,e){return{x:2*(1-e)*(t[1]-t[0])+2*e*(t[2]-t[1]),y:2*(1-e)*(n[1]-n[0])+2*e*(n[2]-n[1])}}function M(t,n,e){return b([3*(t[1]-t[0]),3*(t[2]-t[1]),3*(t[3]-t[2])],[3*(n[1]-n[0]),3*(n[2]-n[1]),3*(n[3]-n[2])],e)}function w(t,n,e,r,i){for(var a=1,o=t/n,s=(t-e(r,i,o))/n;a>.001;){var h=e(r,i,o+s),u=e(r,i,o-s),c=Math.abs(t-h)/n,f=Math.abs(t-u)/n;c<a?(a=c,o+=s):f<a?(a=f,o-=s):s/=2}return o}function b(t,n,e){return{x:(1-e)*(1-e)*t[0]+2*(1-e)*e*t[1]+e*e*t[2],y:(1-e)*(1-e)*n[0]+2*(1-e)*e*n[1]+e*e*n[2]}}function L(t,n,e){return{x:(1-e)*(1-e)*(1-e)*t[0]+3*(1-e)*(1-e)*e*t[1]+3*(1-e)*e*e*t[2]+e*e*e*t[3],y:(1-e)*(1-e)*(1-e)*n[0]+3*(1-e)*(1-e)*e*n[1]+3*(1-e)*e*e*n[2]+e*e*e*n[3]}}function A(t,n,e){void 0===e&&(e=1);var r=t[0]-2*t[1]+t[2],i=n[0]-2*n[1]+n[2],a=2*t[1]-2*t[0],o=2*n[1]-2*n[0],s=4*(r*r+i*i),h=4*(r*a+i*o),u=a*a+o*o;if(0===s)return e*Math.sqrt(Math.pow(t[2]-t[0],2)+Math.pow(n[2]-n[0],2));var c=h/(2*s),f=u/s,l=e+c,p=f-c*c;return Math.sqrt(s)/2*(l*Math.sqrt(l*l+p)-c*Math.sqrt(c*c+p)+p*Math.log(Math.abs((l+Math.sqrt(l*l+p))/(c+Math.sqrt(c*c+p)))))}function q(t,n){return qn[t][n]}function k(t,n,e){var r,i,a,o=e.length-1;if(0===o)return 0;if(0===t){for(i=0,a=0;a<=o;a++)i+=q(o,a)*Math.pow(1-n,o-a)*Math.pow(n,a)*e[a];return i}for(r=new Array(o),a=0;a<o;a++)r[a]=o*(e[a+1]-e[a]);return k(t-1,n,r)}function P(t,n,e){var r=k(1,e,t),i=k(1,e,n),a=r*r+i*i;return Math.sqrt(a)}function _(t,n,e){var r,i,a,o;void 0===e&&(e=1);for(r=e/2,i=0,a=0;a<20;a++)o=r*Ln[20][a]+r,i+=An[20][a]*P(t,n,o);return r*i}function E(t,n,e,r){var i=t*r-n*e<0?-1:1,a=t*e+n*r;return a>1&&(a=1),a<-1&&(a=-1),i*Math.acos(a)}function S(t,n,e,r,i,a,o,s,h,u){var c=u*(t-e)/2+h*(n-r)/2,f=-h*(t-e)/2+u*(n-r)/2,l=o*o,p=s*s,g=c*c,v=f*f,x=l*p-l*v-p*g;x<0&&(x=0),x/=l*v+p*g,x=Math.sqrt(x)*(i===a?-1:1);var y=x*o/s*f,d=x*-s/o*c,m=u*y-h*d+(t+e)/2,M=h*y+u*d+(n+r)/2,w=(c-y)/o,b=(f-d)/s,L=(-c-y)/o,A=(-f-d)/s,q=E(1,0,w,b),k=E(w,b,L,A);return 0===a&&k>0&&(k-=kn),1===a&&k<0&&(k+=kn),[m,M,q,k]}function C(t,n){var e=4/3*Math.tan(n/4),r=Math.cos(t),i=Math.sin(t),a=Math.cos(t+n),o=Math.sin(t+n);return[r,i,r-i*e,i+r*e,a+o*e,o-a*e,a,o]}function Z(t,n,e,r,i,a,o,s,h){var u=0,c=[],f=[];Pn(t,n,e,r,i,a,o,s,h).forEach(function(t){var n=new bn(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7]),e=n.getTotalLength();u+=e,c.push(e),f.push(n)}),this.length=u,this.partialLengths=c,this.curves=f}function T(t,n,e,r){this.x0=t,this.x1=n,this.y0=e,this.y1=r}function F(t,n){return Math.sqrt((t[0]-n[0])*(t[0]-n[0])+(t[1]-n[1])*(t[1]-n[1]))}function z(t,n,e){return[t[0]+(n[0]-t[0])*e,t[1]+(n[1]-t[1])*e]}function j(t,n){return F(t,n)<1e-9}function I(t,n,e){var r=t.map(function(t,e){return V(t,n[e])});return function(t){var n=r.map(function(n){return n(t)});return e?H(n):n}}function V(t,n){return function(e){return t.map(function(t,r){return t+e*(n[r]-t)})}}function X(t){return"number"==typeof t&&isFinite(t)}function Y(t){return G(t)?nn(t):[(t[0][0]+t[t.length-1][0])/2,(t[0][1]+t[t.length-1][1])/2]}function G(t){for(var n=0;n<t.length-2;n++){var e=t[n],r=t[n+1],i=t[n+2];if(e[0]*(r[1]-i[1])+r[0]*(i[1]-e[1])+i[0]*(e[1]-r[1]))return!0}return!1}function O(t){return new yn(t).abs()}function D(t){return t.toString().split("M").map(function(t,n){return t=t.trim(),n&&t?"M"+t:t}).filter(function(t){return t})}function H(t){return"M"+t.join("L")+"Z"}function N(t){return D(O(t))}function Q(t,n){var e=O(t);return U(e)||R(e,n)}function U(t){var n=t.segments||[],e=[];if(!n.length||"M"!==n[0][0])return!1;for(var r=0;r<n.length;r++){var i=n[r],a=i[0],o=i[1],s=i[2];if("M"===a&&r||"Z"===a)break;if("M"===a||"L"===a)e.push([o,s]);else if("H"===a)e.push([o,e[e.length-1][1]]);else{if("V"!==a)return!1;e.push([e[e.length-1][0],o])}}return!!e.length&&{ring:e}}function R(t,n){var e,r,i=D(t)[0],a=[],o=3;if(!i)throw new TypeError(Cn);r=B(i),e=r.getTotalLength(),n&&X(n)&&n>0&&(o=Math.max(o,Math.ceil(e/n)));for(var s=0;s<o;s++){var h=r.getPointAtLength(e*s/o);a.push([h.x,h.y])}return{ring:a,skipBisect:!0}}function B(t){if("undefined"!=typeof window&&window&&window.document)try{var n=window.document.createElementNS("http://www.w3.org/2000/svg","path");return n.setAttributeNS(null,"d",t),n}catch(t){}return Sn(t)}function W(t,n){for(var e=t.length+n,r=en(t)/n,i=0,a=0,o=r/2;t.length<e;){var s=t[i],h=t[(i+1)%t.length],u=F(s,h);o<=a+u?(t.splice(i+1,0,u?z(s,h,(o-a)/u):s.slice(0)),o+=r):(a+=u,i++)}}function $(t,n){void 0===n&&(n=1/0);for(var e=0;e<t.length;e++)for(var r=t[e],i=e===t.length-1?t[0]:t[e+1];F(r,i)>n;)i=z(r,i,.5),t.splice(e+1,0,i)}function J(t,n){var e,r,i;if("string"==typeof t){var a=Q(t,n);t=a.ring,i=a.skipBisect}else if(!Array.isArray(t))throw new TypeError(Cn);if(e=t.slice(0),!K(e))throw new TypeError(Cn);return e.length>1&&j(e[0],e[e.length-1])&&e.pop(),r=tn(e),r>0&&e.reverse(),!i&&n&&X(n)&&n>0&&$(e,n),e}function K(t){return t.every(function(t){return Array.isArray(t)&&t.length>=2&&X(t[0])&&X(t[1])})}function tt(t,n,e){var r;return r=t.length-n.length,W(t,r<0?-1*r:0),W(n,r>0?r:0),Tn(t,n),I(t,n,e)}function nt(t,n,e){e=e||2;var r=n&&n.length,i=r?n[0]*e:t.length,a=et(t,0,i,e,!0),o=[];if(!a)return o;var s,h,u,c,f,l,p;if(r&&(a=ut(t,n,a,e)),t.length>80*e){s=u=t[0],h=c=t[1];for(var g=e;g<i;g+=e)f=t[g],l=t[g+1],f<s&&(s=f),l<h&&(h=l),f>u&&(u=f),l>c&&(c=l);p=Math.max(u-s,c-h)}return it(a,o,e,s,h,p),o}function et(t,n,e,r,i){var a,o;if(i===Et(t,n,e,r)>0)for(a=n;a<e;a+=r)o=kt(a,t[a],t[a+1],o);else for(a=e-r;a>=n;a-=r)o=kt(a,t[a],t[a+1],o);return o&&Mt(o,o.next)&&(Pt(o),o=o.next),o}function rt(t,n){if(!t)return t;n||(n=t);var e,r=t;do{if(e=!1,r.steiner||!Mt(r,r.next)&&0!==mt(r.prev,r,r.next))r=r.next;else{if(Pt(r),(r=n=r.prev)===r.next)return null;e=!0}}while(e||r!==n);return n}function it(t,n,e,r,i,a,o){if(t){!o&&a&&pt(t,r,i,a);for(var s,h,u=t;t.prev!==t.next;)if(s=t.prev,h=t.next,a?ot(t,r,i,a):at(t))n.push(s.i/e),n.push(t.i/e),n.push(h.i/e),Pt(t),t=h.next,u=h.next;else if((t=h)===u){o?1===o?(t=st(t,n,e),it(t,n,e,r,i,a,2)):2===o&&ht(t,n,e,r,i,a):it(rt(t),n,e,r,i,a,1);break}}}function at(t){var n=t.prev,e=t,r=t.next;if(mt(n,e,r)>=0)return!1;for(var i=t.next.next;i!==t.prev;){if(yt(n.x,n.y,e.x,e.y,r.x,r.y,i.x,i.y)&&mt(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function ot(t,n,e,r){var i=t.prev,a=t,o=t.next;if(mt(i,a,o)>=0)return!1;for(var s=i.x<a.x?i.x<o.x?i.x:o.x:a.x<o.x?a.x:o.x,h=i.y<a.y?i.y<o.y?i.y:o.y:a.y<o.y?a.y:o.y,u=i.x>a.x?i.x>o.x?i.x:o.x:a.x>o.x?a.x:o.x,c=i.y>a.y?i.y>o.y?i.y:o.y:a.y>o.y?a.y:o.y,f=vt(s,h,n,e,r),l=vt(u,c,n,e,r),p=t.nextZ;p&&p.z<=l;){if(p!==t.prev&&p!==t.next&&yt(i.x,i.y,a.x,a.y,o.x,o.y,p.x,p.y)&&mt(p.prev,p,p.next)>=0)return!1;p=p.nextZ}for(p=t.prevZ;p&&p.z>=f;){if(p!==t.prev&&p!==t.next&&yt(i.x,i.y,a.x,a.y,o.x,o.y,p.x,p.y)&&mt(p.prev,p,p.next)>=0)return!1;p=p.prevZ}return!0}function st(t,n,e){var r=t;do{var i=r.prev,a=r.next.next;!Mt(i,a)&&wt(i,r,r.next,a)&&Lt(i,a)&&Lt(a,i)&&(n.push(i.i/e),n.push(r.i/e),n.push(a.i/e),Pt(r),Pt(r.next),r=t=a),r=r.next}while(r!==t);return r}function ht(t,n,e,r,i,a){var o=t;do{for(var s=o.next.next;s!==o.prev;){if(o.i!==s.i&&dt(o,s)){var h=qt(o,s);return o=rt(o,o.next),h=rt(h,h.next),it(o,n,e,r,i,a),void it(h,n,e,r,i,a)}s=s.next}o=o.next}while(o!==t)}function ut(t,n,e,r){var i,a,o,s,h,u=[];for(i=0,a=n.length;i<a;i++)o=n[i]*r,s=i<a-1?n[i+1]*r:t.length,h=et(t,o,s,r,!1),h===h.next&&(h.steiner=!0),u.push(xt(h));for(u.sort(ct),i=0;i<u.length;i++)ft(u[i],e),e=rt(e,e.next);return e}function ct(t,n){return t.x-n.x}function ft(t,n){if(n=lt(t,n)){var e=qt(n,t);rt(e,e.next)}}function lt(t,n){var e,r=n,i=t.x,a=t.y,o=-1/0;do{if(a<=r.y&&a>=r.next.y){var s=r.x+(a-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(s<=i&&s>o){if(o=s,s===i){if(a===r.y)return r;if(a===r.next.y)return r.next}e=r.x<r.next.x?r:r.next}}r=r.next}while(r!==n);if(!e)return null;if(i===o)return e.prev;var h,u=e,c=e.x,f=e.y,l=1/0;for(r=e.next;r!==u;)i>=r.x&&r.x>=c&&yt(a<f?i:o,a,c,f,a<f?o:i,a,r.x,r.y)&&((h=Math.abs(a-r.y)/(i-r.x))<l||h===l&&r.x>e.x)&&Lt(r,t)&&(e=r,l=h),r=r.next;return e}function pt(t,n,e,r){var i=t;do{null===i.z&&(i.z=vt(i.x,i.y,n,e,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next}while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,gt(i)}function gt(t){var n,e,r,i,a,o,s,h,u=1;do{for(e=t,t=null,a=null,o=0;e;){for(o++,r=e,s=0,n=0;n<u&&(s++,r=r.nextZ);n++);for(h=u;s>0||h>0&&r;)0===s?(i=r,r=r.nextZ,h--):0!==h&&r?e.z<=r.z?(i=e,e=e.nextZ,s--):(i=r,r=r.nextZ,h--):(i=e,e=e.nextZ,s--),a?a.nextZ=i:t=i,i.prevZ=a,a=i;e=r}a.nextZ=null,u*=2}while(o>1);return t}function vt(t,n,e,r,i){return t=32767*(t-e)/i,n=32767*(n-r)/i,t=16711935&(t|t<<8),t=252645135&(t|t<<4),t=858993459&(t|t<<2),t=1431655765&(t|t<<1),n=16711935&(n|n<<8),n=252645135&(n|n<<4),n=858993459&(n|n<<2),n=1431655765&(n|n<<1),t|n<<1}function xt(t){var n=t,e=t;do{n.x<e.x&&(e=n),n=n.next}while(n!==t);return e}function yt(t,n,e,r,i,a,o,s){return(i-o)*(n-s)-(t-o)*(a-s)>=0&&(t-o)*(r-s)-(e-o)*(n-s)>=0&&(e-o)*(a-s)-(i-o)*(r-s)>=0}function dt(t,n){return t.next.i!==n.i&&t.prev.i!==n.i&&!bt(t,n)&&Lt(t,n)&&Lt(n,t)&&At(t,n)}function mt(t,n,e){return(n.y-t.y)*(e.x-n.x)-(n.x-t.x)*(e.y-n.y)}function Mt(t,n){return t.x===n.x&&t.y===n.y}function wt(t,n,e,r){return!!(Mt(t,n)&&Mt(e,r)||Mt(t,r)&&Mt(e,n))||mt(t,n,e)>0!=mt(t,n,r)>0&&mt(e,r,t)>0!=mt(e,r,n)>0}function bt(t,n){var e=t;do{if(e.i!==t.i&&e.next.i!==t.i&&e.i!==n.i&&e.next.i!==n.i&&wt(e,e.next,t,n))return!0;e=e.next}while(e!==t);return!1}function Lt(t,n){return mt(t.prev,t,t.next)<0?mt(t,n,t.next)>=0&&mt(t,t.prev,n)>=0:mt(t,n,t.prev)<0||mt(t,t.next,n)<0}function At(t,n){var e=t,r=!1,i=(t.x+n.x)/2,a=(t.y+n.y)/2;do{e.y>a!=e.next.y>a&&i<(e.next.x-e.x)*(a-e.y)/(e.next.y-e.y)+e.x&&(r=!r),e=e.next}while(e!==t);return r}function qt(t,n){var e=new _t(t.i,t.x,t.y),r=new _t(n.i,n.x,n.y),i=t.next,a=n.prev;return t.next=n,n.prev=t,e.next=i,i.prev=e,r.next=e,e.prev=r,a.next=r,r.prev=a,r}function kt(t,n,e,r){var i=new _t(t,n,e);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function Pt(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function _t(t,n,e){this.i=t,this.x=n,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Et(t,n,e,r){for(var i=0,a=n,o=e-r;a<e;a+=r)i+=(t[o]-t[a])*(t[a+1]+t[o+1]),o=a;return i}function St(t,n){var e=n.id,r=n.bbox,i=null==n.properties?{}:n.properties,a=Ct(t,n);return null==e&&null==r?{type:"Feature",properties:i,geometry:a}:null==r?{type:"Feature",id:e,properties:i,geometry:a}:{type:"Feature",id:e,bbox:r,properties:i,geometry:a}}function Ct(t,n){function e(t,n){n.length&&n.pop();for(var e=u[t<0?~t:t],r=0,i=e.length;r<i;++r)n.push(h(e[r],r));t<0&&Vn(n,i)}function r(t){return h(t)}function i(t){for(var n=[],r=0,i=t.length;r<i;++r)e(t[r],n);return n.length<2&&n.push(n[0]),n}function a(t){for(var n=i(t);n.length<4;)n.push(n[0]);return n}function o(t){return t.map(a)}function s(t){var n,e=t.type;switch(e){case"GeometryCollection":return{type:e,geometries:t.geometries.map(s)};case"Point":n=r(t.coordinates);break;case"MultiPoint":n=t.coordinates.map(r);break;case"LineString":n=i(t.arcs);break;case"MultiLineString":n=t.arcs.map(i);break;case"Polygon":n=o(t.arcs);break;case"MultiPolygon":n=t.arcs.map(o);break;default:return null}return{type:e,coordinates:n}}var h=In(t.transform),u=t.arcs;return s(n)}function Zt(t){for(var n,e=-1,r=t.length,i=t[r-1],a=0;++e<r;)n=i,i=t[e],a+=n[0]*i[1]-n[1]*i[0];return Math.abs(a)}function Tt(t,n){function e(t){switch(t.type){case"GeometryCollection":t.geometries.forEach(e);break;case"Polygon":r(t.arcs);break;case"MultiPolygon":t.arcs.forEach(r)}}function r(t){t.forEach(function(n){n.forEach(function(n){(a[n=n<0?~n:n]||(a[n]=[])).push(t)})}),o.push(t)}function i(n){return Zt(Ct(t,{type:"Polygon",arcs:[n]}).coordinates[0])}var a={},o=[],s=[];return n.forEach(e),o.forEach(function(t){if(!t._){var n=[],e=[t];for(t._=1,s.push(n);t=e.pop();)n.push(t),t.forEach(function(t){t.forEach(function(t){a[t<0?~t:t].forEach(function(t){t._||(t._=1,e.push(t))})})})}}),o.forEach(function(t){delete t._}),{type:"MultiPolygon",arcs:s.map(function(n){var e,r=[];if(n.forEach(function(t){t.forEach(function(t){t.forEach(function(t){a[t<0?~t:t].length<2&&r.push(t)})})}),r=Yn(t,r),(e=r.length)>1)for(var o,s,h=1,u=i(r[0]);h<e;++h)(o=i(r[h]))>u&&(s=r[0],r[0]=r[h],r[h]=s,u=o);return r})}}function Ft(t){return function(n,e){return Dn(t(n),e)}}function zt(t,n){var e={},r={type:"Topology",objects:{triangles:{type:"GeometryCollection",geometries:[]}},arcs:[]};return t.forEach(function(t){var i=[];t.forEach(function(t,a){var o=t[0]<t[1]?t.join(","):t[1]+","+t[0],s=t.map(function(t){return n[t]});o in e?i.push(~e[o]):(i.push(e[o]=r.arcs.length),r.arcs.push(s))}),r.objects.triangles.geometries.push({type:"Polygon",area:Math.abs(tn(t.map(function(t){return n[t[0]]}))),arcs:[i]})}),r.objects.triangles.geometries.sort(function(t,n){return t.area-n.area}),r}function jt(t,n){for(var e=t.objects.triangles.geometries,r=Hn(function(t){return t.area}).left;e.length>n;)!function(){var n=e[0],i=On(e)[0][0],a=e[i],o=Tt(t,[n,a]);o.area=n.area+a.area,o.type="Polygon",o.arcs=o.arcs[0],e.splice(i,1),e.shift(),e.splice(r(e,o.area),0,o)}();if(n>e.length)throw new RangeError("Can't collapse topology into "+n+" pieces.");return Xn(t,t.objects.triangles).features.map(function(t){return t.geometry.coordinates[0].pop(),t.geometry.coordinates[0]})}function It(t){for(var n=zn(t.reduce(function(t,n){return t.concat([n[0]],[n[1]])},[])),e=[],r=0,i=n.length;r<i;r+=3)e.push([[n[r],n[r+1]],[n[r+1],n[r+2]],[n[r+2],n[r]]]);return e}function Vt(t,n,e){function r(t,n,o){void 0===n&&(n=[]),void 0===o&&(o=0);for(var s=0;s<t.length;s++){var h=t.splice(s,1),u=e[h[0]][n.length];o+u<i&&(t.length?r(t.slice(),n.concat(h),o+u):(i=o+u,a=n.concat(h))),t.length&&t.splice(s,0,h[0])}}var i=1/0,a=t.map(function(t,n){return n});return r(a),a}function Xt(t,n){var e=F(Y(t),Y(n));return e*e}function Yt(t,n,e){void 0===e&&(e={});var r=e.maxSegmentLength;void 0===r&&(r=10);var i=e.string;void 0===i&&(i=!0);var a=e.single;void 0===a&&(a=!1);var o=J(t,r);o.length<n.length+2&&W(o,n.length+2-o.length);var s,h=Qn(o,n.length),u=n.map(function(t){return J(t,r)}),c="string"==typeof t&&t;return a&&!n.every(function(t){return"string"==typeof t})||(s=n.slice(0)),Dt(h,u,{match:!0,string:i,single:a,t0:c,t1:s})}function Gt(t,n,e){void 0===e&&(e={});var r=e.maxSegmentLength;void 0===r&&(r=10);var i=e.string;void 0===i&&(i=!0);var a=e.single;void 0===a&&(a=!1);var o=Yt(n,t,{maxSegmentLength:r,string:i,single:a});return a?function(t){return o(1-t)}:o.map(function(t){return function(n){return t(1-n)}})}function Ot(t,n,e){void 0===e&&(e={});var r=e.maxSegmentLength;void 0===r&&(r=10);var i=e.string;void 0===i&&(i=!0);var a=e.single;if(void 0===a&&(a=!1),!Array.isArray(t)||!Array.isArray(n)||t.length!==n.length||!t.length)throw new TypeError(Zn);var o,s,h=function(t){return J(t,r)},u=t.map(h),c=n.map(h);return a?(t.every(function(t){return"string"==typeof t})&&(o=t.slice(0)),n.every(function(t){return"string"==typeof t})&&(s=n.slice(0))):(o=t.slice(0),s=n.slice(0)),Dt(u,c,{string:i,single:a,t0:o,t1:s,match:!1})}function Dt(t,n,e){void 0===e&&(e={});var r=e.string,i=e.single,a=e.t0,o=e.t1,s=e.match,h=s?Un(t,n):t.map(function(t,n){return n}),u=h.map(function(e,i){return tt(t[e],n[i],r)});if(s&&Array.isArray(a)&&(a=h.map(function(t){return a[t]})),i&&r&&(Array.isArray(a)&&(a=a.join(" ")),Array.isArray(o)&&(o=o.join(" "))),i){var c=r?function(t){return u.map(function(n){return n(t)}).join(" ")}:function(t){return u.map(function(n){return n(t)})};return r&&(a||o)?function(t){return t<1e-4&&a||1-t<1e-4&&o||c(t)}:c}return r?(a=Array.isArray(a)?a.map(function(t){return"string"==typeof t&&t}):[],o=Array.isArray(o)?o.map(function(t){return"string"==typeof t&&t}):[],u.map(function(t,n){return a[n]||o[n]?function(e){return e<1e-4&&a[n]||1-e<1e-4&&o[n]||t(e)}:t})):u}function Ht(t,n,e,r,i){return Rt(Bt(t,n,e),r,Jt(t,n,e),2*Math.PI*e,i)}function Nt(t,n,e,r,i){var a=Ht(n,e,r,t,i);return function(t){return a(1-t)}}function Qt(t,n,e,r,i,a){return Rt(Wt(t,n,e,r),i,Kt(t,n,e,r),2*e+2*r,a)}function Ut(t,n,e,r,i,a){var o=Qt(n,e,r,i,t,a);return function(t){return o(1-t)}}function Rt(t,n,e,r,i){void 0===i&&(i={});var a=i.maxSegmentLength;void 0===a&&(a=10);var o=i.string;void 0===o&&(o=!0);var s,h,u=J(n,a);return X(r)&&u.length<r/a&&W(u,Math.ceil(r/a-u.length)),s=t(u),h=I(s,u,o),o?function(t){return t<1e-4?e:h(t)}:h}function Bt(t,n,e){return function(r){var i=Y(r),a=en(r.concat([r[0]])),o=Math.atan2(r[0][1]-i[1],r[0][0]-i[0]),s=0;return r.map(function(i,h){var u;return h&&(s+=F(i,r[h-1])),u=o+2*Math.PI*(a?s/a:h/r.length),[Math.cos(u)*e+t,Math.sin(u)*e+n]})}}function Wt(t,n,e,r){return function(i){var a=Y(i),o=en(i.concat([i[0]])),s=Math.atan2(i[0][1]-a[1],i[0][0]-a[0]),h=0;s<0&&(s=2*Math.PI+s);var u=s/(2*Math.PI);return i.map(function(a,s){s&&(h+=F(a,i[s-1]));var c=$t((u+(o?h/o:s/i.length))%1);return[t+c[0]*e,n+c[1]*r]})}}function $t(t){return t<=1/8?[1,.5+4*t]:t<=3/8?[1.5-4*t,1]:t<=5/8?[0,2.5-4*t]:t<=7/8?[4*t-2.5,0]:[1,4*t-3.5]}function Jt(t,n,e){var r=t-e+","+n,i=t+e+","+n,a="A"+e+","+e+",0,1,1,";return"M"+r+a+i+a+r+"Z"}function Kt(t,n,e,r){var i=t+e,a=n+r;return"M"+t+","+n+"L"+i+","+n+"L"+i+","+a+"L"+t+","+a+"Z"}var tn=function(t){for(var n,e=-1,r=t.length,i=t[r-1],a=0;++e<r;)n=i,i=t[e],a+=n[1]*i[0]-n[0]*i[1];return a/2},nn=function(t){for(var n,e,r=-1,i=t.length,a=0,o=0,s=t[i-1],h=0;++r<i;)n=s,s=t[r],h+=e=n[0]*s[1]-s[0]*n[1],a+=(n[0]+s[0])*e,o+=(n[1]+s[1])*e;return h*=3,[a/h,o/h]},en=function(t){for(var n,e,r=-1,i=t.length,a=t[i-1],o=a[0],s=a[1],h=0;++r<i;)n=o,e=s,a=t[r],o=a[0],s=a[1],n-=o,e-=s,h+=Math.sqrt(n*n+e*e);return h},rn={a:7,c:6,h:1,l:2,m:2,r:4,q:4,s:4,t:2,v:1,z:0},an=[5760,6158,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279],on=function(t){var n=new a(t),e=n.max;for(o(n);n.index<e&&!n.err.length;)u(n);return n.err.length?n.result=[]:n.result.length&&("mM".indexOf(n.result[0][0])<0?(n.err="SvgPath: string should start with `M` or `m`",n.result=[]):n.result[0][0]="M"),{err:n.err,segments:n.result}};f.prototype.matrix=function(t){return 1===t[0]&&0===t[1]&&0===t[2]&&1===t[3]&&0===t[4]&&0===t[5]?this:(this.cache=null,this.queue.push(t),this)},f.prototype.translate=function(t,n){return 0===t&&0===n||(this.cache=null,this.queue.push([1,0,0,1,t,n])),this},f.prototype.scale=function(t,n){return 1===t&&1===n||(this.cache=null,this.queue.push([t,0,0,n,0,0])),this},f.prototype.rotate=function(t,n,e){var r,i,a;return 0!==t&&(this.translate(n,e),r=t*Math.PI/180,i=Math.cos(r),a=Math.sin(r),this.queue.push([i,a,-a,i,0,0]),this.cache=null,this.translate(-n,-e)),this},f.prototype.skewX=function(t){return 0!==t&&(this.cache=null,this.queue.push([1,0,Math.tan(t*Math.PI/180),1,0,0])),this},f.prototype.skewY=function(t){return 0!==t&&(this.cache=null,this.queue.push([1,Math.tan(t*Math.PI/180),0,1,0,0])),this},f.prototype.toArray=function(){var t=this;if(this.cache)return this.cache;if(!this.queue.length)return this.cache=[1,0,0,1,0,0],this.cache;if(this.cache=this.queue[0],1===this.queue.length)return this.cache;for(var n=1;n<this.queue.length;n++)t.cache=c(t.cache,t.queue[n]);return this.cache},f.prototype.calc=function(t,n,e){var r;return this.queue.length?(this.cache||(this.cache=this.toArray()),r=this.cache,[t*r[0]+n*r[2]+(e?0:r[4]),t*r[1]+n*r[3]+(e?0:r[5])]):[t,n]};var sn=f,hn={matrix:!0,scale:!0,rotate:!0,translate:!0,skewX:!0,skewY:!0},un=/\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/,cn=/[\s,]+/,fn=function(t){var n,e,r=new sn;return t.split(un).forEach(function(t){if(t.length){if(void 0!==hn[t])return void(n=t);switch(e=t.split(cn).map(function(t){return+t||0}),n){case"matrix":return void(6===e.length&&r.matrix(e));case"scale":return void(1===e.length?r.scale(e[0],e[0]):2===e.length&&r.scale(e[0],e[1]));case"rotate":return void(1===e.length?r.rotate(e[0],0,0):3===e.length&&r.rotate(e[0],e[1],e[2]));case"translate":return void(1===e.length?r.translate(e[0],0):2===e.length&&r.translate(e[0],e[1]));case"skewX":return void(1===e.length&&r.skewX(e[0]));case"skewY":return void(1===e.length&&r.skewY(e[0]))}}}),r},ln=2*Math.PI,pn=function(t,n,e,r,i,a,o,s,h){var u=Math.sin(h*ln/360),c=Math.cos(h*ln/360),f=c*(t-e)/2+u*(n-r)/2,l=-u*(t-e)/2+c*(n-r)/2;if(0===f&&0===l)return[];if(0===o||0===s)return[];o=Math.abs(o),s=Math.abs(s);var v=f*f/(o*o)+l*l/(s*s);v>1&&(o*=Math.sqrt(v),s*=Math.sqrt(v));var x=p(t,n,e,r,i,a,o,s,u,c),y=[],d=x[2],m=x[3],M=Math.max(Math.ceil(Math.abs(m)/(ln/4)),1);m/=M;for(var w=0;w<M;w++)y.push(g(d,m)),d+=m;return y.map(function(t){for(var n=0;n<t.length;n+=2){var e=t[n+0],r=t[n+1];e*=o,r*=s;var i=c*e-u*r,a=u*e+c*r;t[n+0]=i+x[0],t[n+1]=a+x[1]}return t})},gn=Math.PI/180;v.prototype.transform=function(t){var n=Math.cos(this.ax*gn),e=Math.sin(this.ax*gn),r=[this.rx*(t[0]*n+t[2]*e),this.rx*(t[1]*n+t[3]*e),this.ry*(-t[0]*e+t[2]*n),this.ry*(-t[1]*e+t[3]*n)],i=r[0]*r[0]+r[2]*r[2],a=r[1]*r[1]+r[3]*r[3],o=((r[0]-r[3])*(r[0]-r[3])+(r[2]+r[1])*(r[2]+r[1]))*((r[0]+r[3])*(r[0]+r[3])+(r[2]-r[1])*(r[2]-r[1])),s=(i+a)/2;if(o<1e-10*s)return this.rx=this.ry=Math.sqrt(s),this.ax=0,this;var h=r[0]*r[1]+r[2]*r[3];o=Math.sqrt(o);var u=s+o/2,c=s-o/2;return this.ax=Math.abs(h)<1e-10&&Math.abs(u-a)<1e-10?90:180*Math.atan(Math.abs(h)>Math.abs(u-a)?(u-i)/h:h/(u-a))/Math.PI,this.ax>=0?(this.rx=Math.sqrt(u),this.ry=Math.sqrt(c)):(this.ax+=90,this.rx=Math.sqrt(c),this.ry=Math.sqrt(u)),this},v.prototype.isDegenerate=function(){return this.rx<1e-10*this.ry||this.ry<1e-10*this.rx};var vn=v;x.prototype.__matrix=function(t){var n,e=this;t.queue.length&&this.iterate(function(r,i,a,o){var s,h,u,c;switch(r[0]){case"v":s=t.calc(0,r[1],!0),h=0===s[0]?["v",s[1]]:["l",s[0],s[1]];break;case"V":s=t.calc(a,r[1],!1),h=s[0]===t.calc(a,o,!1)[0]?["V",s[1]]:["L",s[0],s[1]];break;case"h":s=t.calc(r[1],0,!0),h=0===s[1]?["h",s[0]]:["l",s[0],s[1]];break;case"H":s=t.calc(r[1],o,!1),h=s[1]===t.calc(a,o,!1)[1]?["H",s[0]]:["L",s[0],s[1]];break;case"a":case"A":var f=t.toArray(),l=vn(r[1],r[2],r[3]).transform(f);if(f[0]*f[3]-f[1]*f[2]<0&&(r[5]=r[5]?"0":"1"),s=t.calc(r[6],r[7],"a"===r[0]),"A"===r[0]&&r[6]===a&&r[7]===o||"a"===r[0]&&0===r[6]&&0===r[7]){h=["a"===r[0]?"l":"L",s[0],s[1]];break}h=l.isDegenerate()?["a"===r[0]?"l":"L",s[0],s[1]]:[r[0],l.rx,l.ry,l.ax,r[4],r[5],s[0],s[1]];break;case"m":c=i>0,s=t.calc(r[1],r[2],c),h=["m",s[0],s[1]];break;default:for(u=r[0],h=[u],c=u.toLowerCase()===u,n=1;n<r.length;n+=2)s=t.calc(r[n],r[n+1],c),h.push(s[0],s[1])}e.segments[i]=h},!0)},x.prototype.__evaluateStack=function(){var t,n,e=this;if(this.__stack.length){if(1===this.__stack.length)return this.__matrix(this.__stack[0]),void(this.__stack=[]);for(t=sn(),n=this.__stack.length;--n>=0;)t.matrix(e.__stack[n].toArray());this.__matrix(t),this.__stack=[]}},x.prototype.toString=function(){var t,n,e=this,r=[];this.__evaluateStack();for(var i=0;i<this.segments.length;i++)n=e.segments[i][0],t=i>0&&"m"!==n&&"M"!==n&&n===e.segments[i-1][0],r=r.concat(t?e.segments[i].slice(1):e.segments[i]);return r.join(" ").replace(/ ?([achlmqrstvz]) ?/gi,"$1").replace(/ \-/g,"-").replace(/zm/g,"z m")},x.prototype.translate=function(t,n){return this.__stack.push(sn().translate(t,n||0)),this},x.prototype.scale=function(t,n){return this.__stack.push(sn().scale(t,n||0===n?n:t)),this},x.prototype.rotate=function(t,n,e){return this.__stack.push(sn().rotate(t,n||0,e||0)),this},x.prototype.skewX=function(t){return this.__stack.push(sn().skewX(t)),this},x.prototype.skewY=function(t){return this.__stack.push(sn().skewY(t)),this},x.prototype.matrix=function(t){return this.__stack.push(sn().matrix(t)),this},x.prototype.transform=function(t){return t.trim()?(this.__stack.push(fn(t)),this):this},x.prototype.round=function(t){var n,e=0,r=0,i=0,a=0;return t=t||0,this.__evaluateStack(),this.segments.forEach(function(o){var s=o[0].toLowerCase()===o[0];switch(o[0]){case"H":case"h":return s&&(o[1]+=i),i=o[1]-o[1].toFixed(t),void(o[1]=+o[1].toFixed(t));case"V":case"v":return s&&(o[1]+=a),a=o[1]-o[1].toFixed(t),void(o[1]=+o[1].toFixed(t));case"Z":case"z":return i=e,void(a=r);case"M":case"m":return s&&(o[1]+=i,o[2]+=a),i=o[1]-o[1].toFixed(t),a=o[2]-o[2].toFixed(t),e=i,r=a,o[1]=+o[1].toFixed(t),void(o[2]=+o[2].toFixed(t));case"A":case"a":return s&&(o[6]+=i,o[7]+=a),i=o[6]-o[6].toFixed(t),a=o[7]-o[7].toFixed(t),o[1]=+o[1].toFixed(t),o[2]=+o[2].toFixed(t),o[3]=+o[3].toFixed(t+2),o[6]=+o[6].toFixed(t),void(o[7]=+o[7].toFixed(t));default:return n=o.length,s&&(o[n-2]+=i,o[n-1]+=a),i=o[n-2]-o[n-2].toFixed(t),a=o[n-1]-o[n-1].toFixed(t),void o.forEach(function(n,e){e&&(o[e]=+o[e].toFixed(t))})}}),this},x.prototype.iterate=function(t,n){var e,r,i,a=this.segments,o={},s=!1,h=0,u=0,c=0,f=0;if(n||this.__evaluateStack(),a.forEach(function(n,e){var r=t(n,e,h,u);Array.isArray(r)&&(o[e]=r,s=!0);var i=n[0]===n[0].toLowerCase();switch(n[0]){case"m":case"M":return h=n[1]+(i?h:0),u=n[2]+(i?u:0),c=h,void(f=u);case"h":case"H":return void(h=n[1]+(i?h:0));case"v":case"V":return void(u=n[1]+(i?u:0));case"z":case"Z":return h=c,void(u=f);default:h=n[n.length-2]+(i?h:0),u=n[n.length-1]+(i?u:0)}}),!s)return this;for(i=[],e=0;e<a.length;e++)if(void 0!==o[e])for(r=0;r<o[e].length;r++)i.push(o[e][r]);else i.push(a[e]);return this.segments=i,this},x.prototype.abs=function(){return this.iterate(function(t,n,e,r){var i,a=t[0],o=a.toUpperCase();if(a!==o)switch(t[0]=o,a){case"v":return void(t[1]+=r);case"a":return t[6]+=e,void(t[7]+=r);default:for(i=1;i<t.length;i++)t[i]+=i%2?e:r}},!0),this},x.prototype.rel=function(){return this.iterate(function(t,n,e,r){var i,a=t[0],o=a.toLowerCase();if(a!==o&&(0!==n||"M"!==a))switch(t[0]=o,a){case"V":return void(t[1]-=r);case"A":return t[6]-=e,void(t[7]-=r);default:for(i=1;i<t.length;i++)t[i]-=i%2?e:r}},!0),this},x.prototype.unarc=function(){return this.iterate(function(t,n,e,r){var i,a,o,s=[],h=t[0];return"A"!==h&&"a"!==h?null:("a"===h?(a=e+t[6],o=r+t[7]):(a=t[6],o=t[7]),i=pn(e,r,a,o,t[4],t[5],t[1],t[2],t[3]),0===i.length?[["a"===t[0]?"l":"L",t[6],t[7]]]:(i.forEach(function(t){s.push(["C",t[2],t[3],t[4],t[5],t[6],t[7]])}),s))}),this},x.prototype.unshort=function(){var t,n,e,r,i,a=this.segments;return this.iterate(function(o,s,h,u){var c,f=o[0],l=f.toUpperCase();s&&("T"===l?(c="t"===f,e=a[s-1],"Q"===e[0]?(t=e[1]-h,n=e[2]-u):"q"===e[0]?(t=e[1]-e[3],n=e[2]-e[4]):(t=0,n=0),r=-t,i=-n,c||(r+=h,i+=u),a[s]=[c?"q":"Q",r,i,o[1],o[2]]):"S"===l&&(c="s"===f,e=a[s-1],"C"===e[0]?(t=e[3]-h,n=e[4]-u):"c"===e[0]?(t=e[3]-e[5],n=e[4]-e[6]):(t=0,n=0),r=-t,i=-n,c||(r+=h,i+=u),a[s]=[c?"c":"C",r,i,o[1],o[2],o[3],o[4]]))}),this};var xn=x,yn=xn,dn={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},mn=/([astvzqmhlc])([^astvzqmhlc]*)/gi,Mn=function(t){var n=[];return t.replace(mn,function(t,e,r){var i=e.toLowerCase();for(r=y(r),"m"===i&&r.length>2&&(n.push([e].concat(r.splice(0,2))),i="l",e="m"===e?"l":"L");r.length>=0;){if(r.length===dn[i])return r.unshift(e),n.push(r);if(r.length<dn[i])throw new Error("malformed path data");n.push([e].concat(r.splice(0,dn[i])))}}),n},wn=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi,bn=function(t,n,e,r,i,a,o,s){return new d(t,n,e,r,i,a,o,s)};d.prototype={constructor:d,init:function(){this.length=this.getArcLength([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y])},getTotalLength:function(){return this.length},getPointAtLength:function(t){var n=w(t,this.length,this.getArcLength,[this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y]);return this.getPoint([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y],n)},getTangentAtLength:function(t){var n=w(t,this.length,this.getArcLength,[this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y]),e=this.getDerivative([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y],n),r=Math.sqrt(e.x*e.x+e.y*e.y);return r>0?{x:e.x/r,y:e.y/r}:{x:0,y:0}},getPropertiesAtLength:function(t){var n,e=w(t,this.length,this.getArcLength,[this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y]),r=this.getDerivative([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y],e),i=Math.sqrt(r.x*r.x+r.y*r.y);n=i>0?{x:r.x/i,y:r.y/i}:{
x:0,y:0};var a=this.getPoint([this.a.x,this.b.x,this.c.x,this.d.x],[this.a.y,this.b.y,this.c.y,this.d.y],e);return{x:a.x,y:a.y,tangentX:n.x,tangentY:n.y}}};var Ln=[[],[],[-.5773502691896257,.5773502691896257],[0,-.7745966692414834,.7745966692414834],[-.33998104358485626,.33998104358485626,-.8611363115940526,.8611363115940526],[0,-.5384693101056831,.5384693101056831,-.906179845938664,.906179845938664],[.6612093864662645,-.6612093864662645,-.2386191860831969,.2386191860831969,-.932469514203152,.932469514203152],[0,.4058451513773972,-.4058451513773972,-.7415311855993945,.7415311855993945,-.9491079123427585,.9491079123427585],[-.1834346424956498,.1834346424956498,-.525532409916329,.525532409916329,-.7966664774136267,.7966664774136267,-.9602898564975363,.9602898564975363],[0,-.8360311073266358,.8360311073266358,-.9681602395076261,.9681602395076261,-.3242534234038089,.3242534234038089,-.6133714327005904,.6133714327005904],[-.14887433898163122,.14887433898163122,-.4333953941292472,.4333953941292472,-.6794095682990244,.6794095682990244,-.8650633666889845,.8650633666889845,-.9739065285171717,.9739065285171717],[0,-.26954315595234496,.26954315595234496,-.5190961292068118,.5190961292068118,-.7301520055740494,.7301520055740494,-.8870625997680953,.8870625997680953,-.978228658146057,.978228658146057],[-.1252334085114689,.1252334085114689,-.3678314989981802,.3678314989981802,-.5873179542866175,.5873179542866175,-.7699026741943047,.7699026741943047,-.9041172563704749,.9041172563704749,-.9815606342467192,.9815606342467192],[0,-.2304583159551348,.2304583159551348,-.44849275103644687,.44849275103644687,-.6423493394403402,.6423493394403402,-.8015780907333099,.8015780907333099,-.9175983992229779,.9175983992229779,-.9841830547185881,.9841830547185881],[-.10805494870734367,.10805494870734367,-.31911236892788974,.31911236892788974,-.5152486363581541,.5152486363581541,-.6872929048116855,.6872929048116855,-.827201315069765,.827201315069765,-.9284348836635735,.9284348836635735,-.9862838086968123,.9862838086968123],[0,-.20119409399743451,.20119409399743451,-.3941513470775634,.3941513470775634,-.5709721726085388,.5709721726085388,-.7244177313601701,.7244177313601701,-.8482065834104272,.8482065834104272,-.937273392400706,.937273392400706,-.9879925180204854,.9879925180204854],[-.09501250983763744,.09501250983763744,-.2816035507792589,.2816035507792589,-.45801677765722737,.45801677765722737,-.6178762444026438,.6178762444026438,-.755404408355003,.755404408355003,-.8656312023878318,.8656312023878318,-.9445750230732326,.9445750230732326,-.9894009349916499,.9894009349916499],[0,-.17848418149584785,.17848418149584785,-.3512317634538763,.3512317634538763,-.5126905370864769,.5126905370864769,-.6576711592166907,.6576711592166907,-.7815140038968014,.7815140038968014,-.8802391537269859,.8802391537269859,-.9506755217687678,.9506755217687678,-.9905754753144174,.9905754753144174],[-.0847750130417353,.0847750130417353,-.2518862256915055,.2518862256915055,-.41175116146284263,.41175116146284263,-.5597708310739475,.5597708310739475,-.6916870430603532,.6916870430603532,-.8037049589725231,.8037049589725231,-.8926024664975557,.8926024664975557,-.9558239495713977,.9558239495713977,-.9915651684209309,.9915651684209309],[0,-.16035864564022537,.16035864564022537,-.31656409996362983,.31656409996362983,-.46457074137596094,.46457074137596094,-.600545304661681,.600545304661681,-.7209661773352294,.7209661773352294,-.8227146565371428,.8227146565371428,-.9031559036148179,.9031559036148179,-.96020815213483,.96020815213483,-.9924068438435844,.9924068438435844],[-.07652652113349734,.07652652113349734,-.22778585114164507,.22778585114164507,-.37370608871541955,.37370608871541955,-.5108670019508271,.5108670019508271,-.636053680726515,.636053680726515,-.7463319064601508,.7463319064601508,-.8391169718222188,.8391169718222188,-.912234428251326,.912234428251326,-.9639719272779138,.9639719272779138,-.9931285991850949,.9931285991850949],[0,-.1455618541608951,.1455618541608951,-.2880213168024011,.2880213168024011,-.4243421202074388,.4243421202074388,-.5516188358872198,.5516188358872198,-.6671388041974123,.6671388041974123,-.7684399634756779,.7684399634756779,-.8533633645833173,.8533633645833173,-.9200993341504008,.9200993341504008,-.9672268385663063,.9672268385663063,-.9937521706203895,.9937521706203895],[-.06973927331972223,.06973927331972223,-.20786042668822127,.20786042668822127,-.34193582089208424,.34193582089208424,-.469355837986757,.469355837986757,-.5876404035069116,.5876404035069116,-.6944872631866827,.6944872631866827,-.7878168059792081,.7878168059792081,-.8658125777203002,.8658125777203002,-.926956772187174,.926956772187174,-.9700604978354287,.9700604978354287,-.9942945854823992,.9942945854823992],[0,-.1332568242984661,.1332568242984661,-.26413568097034495,.26413568097034495,-.3903010380302908,.3903010380302908,-.5095014778460075,.5095014778460075,-.6196098757636461,.6196098757636461,-.7186613631319502,.7186613631319502,-.8048884016188399,.8048884016188399,-.8767523582704416,.8767523582704416,-.9329710868260161,.9329710868260161,-.9725424712181152,.9725424712181152,-.9947693349975522,.9947693349975522],[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213]],An=[[],[],[1,1],[.8888888888888888,.5555555555555556,.5555555555555556],[.6521451548625461,.6521451548625461,.34785484513745385,.34785484513745385],[.5688888888888889,.47862867049936647,.47862867049936647,.23692688505618908,.23692688505618908],[.3607615730481386,.3607615730481386,.46791393457269104,.46791393457269104,.17132449237917036,.17132449237917036],[.4179591836734694,.3818300505051189,.3818300505051189,.27970539148927664,.27970539148927664,.1294849661688697,.1294849661688697],[.362683783378362,.362683783378362,.31370664587788727,.31370664587788727,.22238103445337448,.22238103445337448,.10122853629037626,.10122853629037626],[.3302393550012598,.1806481606948574,.1806481606948574,.08127438836157441,.08127438836157441,.31234707704000286,.31234707704000286,.26061069640293544,.26061069640293544],[.29552422471475287,.29552422471475287,.26926671930999635,.26926671930999635,.21908636251598204,.21908636251598204,.1494513491505806,.1494513491505806,.06667134430868814,.06667134430868814],[.2729250867779006,.26280454451024665,.26280454451024665,.23319376459199048,.23319376459199048,.18629021092773426,.18629021092773426,.1255803694649046,.1255803694649046,.05566856711617366,.05566856711617366],[.24914704581340277,.24914704581340277,.2334925365383548,.2334925365383548,.20316742672306592,.20316742672306592,.16007832854334622,.16007832854334622,.10693932599531843,.10693932599531843,.04717533638651183,.04717533638651183],[.2325515532308739,.22628318026289723,.22628318026289723,.2078160475368885,.2078160475368885,.17814598076194574,.17814598076194574,.13887351021978725,.13887351021978725,.09212149983772845,.09212149983772845,.04048400476531588,.04048400476531588],[.2152638534631578,.2152638534631578,.2051984637212956,.2051984637212956,.18553839747793782,.18553839747793782,.15720316715819355,.15720316715819355,.12151857068790319,.12151857068790319,.08015808715976021,.08015808715976021,.03511946033175186,.03511946033175186],[.2025782419255613,.19843148532711158,.19843148532711158,.1861610000155622,.1861610000155622,.16626920581699392,.16626920581699392,.13957067792615432,.13957067792615432,.10715922046717194,.10715922046717194,.07036604748810812,.07036604748810812,.03075324199611727,.03075324199611727],[.1894506104550685,.1894506104550685,.18260341504492358,.18260341504492358,.16915651939500254,.16915651939500254,.14959598881657674,.14959598881657674,.12462897125553388,.12462897125553388,.09515851168249279,.09515851168249279,.062253523938647894,.062253523938647894,.027152459411754096,.027152459411754096],[.17944647035620653,.17656270536699264,.17656270536699264,.16800410215645004,.16800410215645004,.15404576107681028,.15404576107681028,.13513636846852548,.13513636846852548,.11188384719340397,.11188384719340397,.08503614831717918,.08503614831717918,.0554595293739872,.0554595293739872,.02414830286854793,.02414830286854793],[.1691423829631436,.1691423829631436,.16427648374583273,.16427648374583273,.15468467512626524,.15468467512626524,.14064291467065065,.14064291467065065,.12255520671147846,.12255520671147846,.10094204410628717,.10094204410628717,.07642573025488905,.07642573025488905,.0497145488949698,.0497145488949698,.02161601352648331,.02161601352648331],[.1610544498487837,.15896884339395434,.15896884339395434,.15276604206585967,.15276604206585967,.1426067021736066,.1426067021736066,.12875396253933621,.12875396253933621,.11156664554733399,.11156664554733399,.09149002162245,.09149002162245,.06904454273764123,.06904454273764123,.0448142267656996,.0448142267656996,.019461788229726478,.019461788229726478],[.15275338713072584,.15275338713072584,.14917298647260374,.14917298647260374,.14209610931838204,.14209610931838204,.13168863844917664,.13168863844917664,.11819453196151841,.11819453196151841,.10193011981724044,.10193011981724044,.08327674157670475,.08327674157670475,.06267204833410907,.06267204833410907,.04060142980038694,.04060142980038694,.017614007139152118,.017614007139152118],[.14608113364969041,.14452440398997005,.14452440398997005,.13988739479107315,.13988739479107315,.13226893863333747,.13226893863333747,.12183141605372853,.12183141605372853,.10879729916714838,.10879729916714838,.09344442345603386,.09344442345603386,.0761001136283793,.0761001136283793,.057134425426857205,.057134425426857205,.036953789770852494,.036953789770852494,.016017228257774335,.016017228257774335],[.13925187285563198,.13925187285563198,.13654149834601517,.13654149834601517,.13117350478706238,.13117350478706238,.12325237681051242,.12325237681051242,.11293229608053922,.11293229608053922,.10041414444288096,.10041414444288096,.08594160621706773,.08594160621706773,.06979646842452049,.06979646842452049,.052293335152683286,.052293335152683286,.03377490158481415,.03377490158481415,.0146279952982722,.0146279952982722],[.13365457218610619,.1324620394046966,.1324620394046966,.12890572218808216,.12890572218808216,.12304908430672953,.12304908430672953,.11499664022241136,.11499664022241136,.10489209146454141,.10489209146454141,.09291576606003515,.09291576606003515,.07928141177671895,.07928141177671895,.06423242140852585,.06423242140852585,.04803767173108467,.04803767173108467,.030988005856979445,.030988005856979445,.013411859487141771,.013411859487141771],[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872]],qn=[[1],[1,1],[1,2,1],[1,3,3,1]],kn=2*Math.PI,Pn=function(t,n,e,r,i,a,o,s,h){var u=Math.sin(i*kn/360),c=Math.cos(i*kn/360),f=c*(t-s)/2+u*(n-h)/2,l=-u*(t-s)/2+c*(n-h)/2;if(0===f&&0===l)return[];if(0===e||0===r)return[];e=Math.abs(e),r=Math.abs(r);var p=f*f/(e*e)+l*l/(r*r);p>1&&(e*=Math.sqrt(p),r*=Math.sqrt(p));var g=S(t,n,s,h,a,o,e,r,u,c),v=[],x=g[2],y=g[3],d=Math.max(Math.ceil(Math.abs(y)/(kn/4)),1);y/=d;for(var m=0;m<d;m++)v.push(C(x,y)),x+=y;return v.map(function(t){for(var n=0;n<t.length;n+=2){var i=t[n+0],a=t[n+1];i*=e,a*=r;var o=c*i-u*a,s=u*i+c*a;t[n+0]=o+g[0],t[n+1]=s+g[1]}return t})},_n=function(t,n,e,r,i,a,o,s,h){return new Z(t,n,e,r,i,a,o,s,h)};Z.prototype={constructor:Z,init:function(){},getTotalLength:function(){return this.length},getPointAtLength:function(t){var n=this;t<0?t=0:t>this.length&&(t=this.length);for(var e=this.partialLengths.length-1;this.partialLengths[e]>=t&&this.partialLengths[e]>0;)e--;e<this.partialLengths.length-1&&e++;for(var r=0,i=0;i<e;i++)r+=n.partialLengths[i];return this.curves[e].getPointAtLength(t-r)},getTangentAtLength:function(t){var n=this;t<0?t=0:t>this.length&&(t=this.length);for(var e=this.partialLengths.length-1;this.partialLengths[e]>=t&&this.partialLengths[e]>0;)e--;e<this.partialLengths.length-1&&e++;for(var r=0,i=0;i<e;i++)r+=n.partialLengths[i];return this.curves[e].getTangentAtLength(t-r)},getPropertiesAtLength:function(t){var n=this.getTangentAtLength(t),e=this.getPointAtLength(t);return{x:e.x,y:e.y,tangentX:n.x,tangentY:n.y}}};var En=function(t,n,e,r){return new T(t,n,e,r)};T.prototype.getTotalLength=function(){return Math.sqrt(Math.pow(this.x0-this.x1,2)+Math.pow(this.y0-this.y1,2))},T.prototype.getPointAtLength=function(t){var n=t/Math.sqrt(Math.pow(this.x0-this.x1,2)+Math.pow(this.y0-this.y1,2)),e=(this.x1-this.x0)*n,r=(this.y1-this.y0)*n;return{x:this.x0+e,y:this.y0+r}},T.prototype.getTangentAtLength=function(){var t=Math.sqrt((this.x1-this.x0)*(this.x1-this.x0)+(this.y1-this.y0)*(this.y1-this.y0));return{x:(this.x1-this.x0)/t,y:(this.y1-this.y0)/t}},T.prototype.getPropertiesAtLength=function(t){var n=this.getPointAtLength(t),e=this.getTangentAtLength();return{x:n.x,y:n.y,tangentX:e.x,tangentY:e.y}};var Sn=function(t){function n(t){if(!t)return null;for(var a,o=Mn(t),s=[0,0],h=[0,0],u=0;u<o.length;u++)"M"===o[u][0]?(s=[o[u][1],o[u][2]],i.push(null)):"m"===o[u][0]?(s=[o[u][1]+s[0],o[u][2]+s[1]],i.push(null)):"L"===o[u][0]?(e+=Math.sqrt(Math.pow(s[0]-o[u][1],2)+Math.pow(s[1]-o[u][2],2)),i.push(new En(s[0],o[u][1],s[1],o[u][2])),s=[o[u][1],o[u][2]]):"l"===o[u][0]?(e+=Math.sqrt(Math.pow(o[u][1],2)+Math.pow(o[u][2],2)),i.push(new En(s[0],o[u][1]+s[0],s[1],o[u][2]+s[1])),s=[o[u][1]+s[0],o[u][2]+s[1]]):"H"===o[u][0]?(e+=Math.abs(s[0]-o[u][1]),i.push(new En(s[0],o[u][1],s[1],s[1])),s[0]=o[u][1]):"h"===o[u][0]?(e+=Math.abs(o[u][1]),i.push(new En(s[0],s[0]+o[u][1],s[1],s[1])),s[0]=o[u][1]+s[0]):"V"===o[u][0]?(e+=Math.abs(s[1]-o[u][1]),i.push(new En(s[0],s[0],s[1],o[u][1])),s[1]=o[u][1]):"v"===o[u][0]?(e+=Math.abs(o[u][1]),i.push(new En(s[0],s[0],s[1],s[1]+o[u][1])),s[1]=o[u][1]+s[1]):"z"===o[u][0]||"Z"===o[u][0]?(e+=Math.sqrt(Math.pow(o[0][1]-s[0],2)+Math.pow(o[0][2]-s[1],2)),i.push(new En(s[0],o[0][1],s[1],o[0][2])),s=[o[0][1],o[0][2]]):"C"===o[u][0]?(a=new bn(s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4],o[u][5],o[u][6]),e+=a.getTotalLength(),s=[o[u][5],o[u][6]],i.push(a)):"c"===o[u][0]?(a=new bn(s[0],s[1],s[0]+o[u][1],s[1]+o[u][2],s[0]+o[u][3],s[1]+o[u][4],s[0]+o[u][5],s[1]+o[u][6]),e+=a.getTotalLength(),s=[o[u][5]+s[0],o[u][6]+s[1]],i.push(a)):"S"===o[u][0]?(a=u>0&&["C","c","S","s"].indexOf(o[u-1][0])>-1?new bn(s[0],s[1],2*s[0]-o[u-1][o[u-1].length-4],2*s[1]-o[u-1][o[u-1].length-3],o[u][1],o[u][2],o[u][3],o[u][4]):new bn(s[0],s[1],s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4]),e+=a.getTotalLength(),s=[o[u][3],o[u][4]],i.push(a)):"s"===o[u][0]?(a=u>0&&["C","c","S","s"].indexOf(o[u-1][0])>-1?new bn(s[0],s[1],s[0]+a.d.x-a.c.x,s[1]+a.d.y-a.c.y,s[0]+o[u][1],s[1]+o[u][2],s[0]+o[u][3],s[1]+o[u][4]):new bn(s[0],s[1],s[0],s[1],s[0]+o[u][1],s[1]+o[u][2],s[0]+o[u][3],s[1]+o[u][4]),e+=a.getTotalLength(),s=[o[u][3]+s[0],o[u][4]+s[1]],i.push(a)):"Q"===o[u][0]?(a=new bn(s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4]),e+=a.getTotalLength(),i.push(a),s=[o[u][3],o[u][4]],h=[o[u][1],o[u][2]]):"q"===o[u][0]?(a=new bn(s[0],s[1],s[0]+o[u][1],s[1]+o[u][2],s[0]+o[u][3],s[1]+o[u][4]),e+=a.getTotalLength(),h=[s[0]+o[u][1],s[1]+o[u][2]],s=[o[u][3]+s[0],o[u][4]+s[1]],i.push(a)):"T"===o[u][0]?(a=u>0&&["Q","q","T","t"].indexOf(o[u-1][0])>-1?new bn(s[0],s[1],2*s[0]-h[0],2*s[1]-h[1],o[u][1],o[u][2]):new En(s[0],o[u][1],s[1],o[u][2]),i.push(a),e+=a.getTotalLength(),h=[2*s[0]-h[0],2*s[1]-h[1]],s=[o[u][1],o[u][2]]):"t"===o[u][0]?(a=u>0&&["Q","q","T","t"].indexOf(o[u-1][0])>-1?new bn(s[0],s[1],2*s[0]-h[0],2*s[1]-h[1],s[0]+o[u][1],s[1]+o[u][2]):new En(s[0],s[0]+o[u][1],s[1],s[1]+o[u][2]),e+=a.getTotalLength(),h=[2*s[0]-h[0],2*s[1]-h[1]],s=[o[u][1]+s[0],o[u][2]+s[0]],i.push(a)):"A"===o[u][0]?(a=new _n(s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4],o[u][5],o[u][6],o[u][7]),e+=a.getTotalLength(),s=[o[u][6],o[u][7]],i.push(a)):"a"===o[u][0]&&(a=new _n(s[0],s[1],o[u][1],o[u][2],o[u][3],o[u][4],o[u][5],s[0]+o[u][6],s[1]+o[u][7]),e+=a.getTotalLength(),s=[s[0]+o[u][6],s[1]+o[u][7]],i.push(a)),r.push(e);return n}var e=0,r=[],i=[];n.getTotalLength=function(){return e},n.getPointAtLength=function(t){var n=a(t);return i[n.i].getPointAtLength(n.fraction)},n.getTangentAtLength=function(t){var n=a(t);return i[n.i].getTangentAtLength(n.fraction)},n.getPropertiesAtLength=function(t){var n=a(t);return i[n.i].getPropertiesAtLength(n.fraction)};var a=function(t){t<0?t=0:t>e&&(t=e);for(var n=r.length-1;r[n]>=t&&r[n]>0;)n--;return n++,{fraction:t-r[n-1],i:n}};return n(t)},Cn='All shapes must be supplied as arrays of [x, y] points or an SVG path string (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d).\nExample valid ways of supplying a shape would be:\n[[0, 0], [10, 0], [10, 10]]\n"M0,0 L10,0 L10,10Z"\n',Zn="flubber.all() expects two arrays of equal length as arguments. Each element in both arrays should be an array of [x, y] points or an SVG path string (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d).",Tn=function(t,n){for(var e,r,i,a=t.length,o=1/0,s=0;s<a;s++)!function(i){r=0,n.forEach(function(n,e){var o=F(t[(i+e)%a],n);r+=o*o}),r<o&&(o=r,e=i)}(s);e&&(i=t.splice(0,e),t.splice.apply(t,[t.length,0].concat(i)))},Fn=function(t,n,e){void 0===e&&(e={});var r=e.maxSegmentLength;void 0===r&&(r=10);var i=e.string;void 0===i&&(i=!0);var a=J(t,r),o=J(n,r),s=tt(a,o,i);return!i||"string"!=typeof t&&"string"!=typeof n?s:function(e){return e<1e-4&&"string"==typeof t?t:1-e<1e-4&&"string"==typeof n?n:s(e)}},zn=nt;nt.deviation=function(t,n,e,r){var i=n&&n.length,a=i?n[0]*e:t.length,o=Math.abs(Et(t,0,a,e));if(i)for(var s=0,h=n.length;s<h;s++){var u=n[s]*e,c=s<h-1?n[s+1]*e:t.length;o-=Math.abs(Et(t,u,c,e))}var f=0;for(s=0;s<r.length;s+=3){var l=r[s]*e,p=r[s+1]*e,g=r[s+2]*e;f+=Math.abs((t[l]-t[g])*(t[p+1]-t[l+1])-(t[l]-t[p])*(t[g+1]-t[l+1]))}return 0===o&&0===f?0:Math.abs((f-o)/o)},nt.flatten=function(t){for(var n=t[0][0].length,e={vertices:[],holes:[],dimensions:n},r=0,i=0;i<t.length;i++){for(var a=0;a<t[i].length;a++)for(var o=0;o<n;o++)e.vertices.push(t[i][a][o]);i>0&&(r+=t[i-1].length,e.holes.push(r))}return e};var jn=function(t){return t},In=function(t){if(null==t)return jn;var n,e,r=t.scale[0],i=t.scale[1],a=t.translate[0],o=t.translate[1];return function(t,s){s||(n=e=0);var h=2,u=t.length,c=new Array(u);for(c[0]=(n+=t[0])*r+a,c[1]=(e+=t[1])*i+o;h<u;)c[h]=t[h],++h;return c}},Vn=function(t,n){for(var e,r=t.length,i=r-n;i<--r;)e=t[i],t[i++]=t[r],t[r]=e},Xn=function(t,n){return"GeometryCollection"===n.type?{type:"FeatureCollection",features:n.geometries.map(function(n){return St(t,n)})}:St(t,n)},Yn=function(t,n){function e(n){var e,r=t.arcs[n<0?~n:n],i=r[0];return t.transform?(e=[0,0],r.forEach(function(t){e[0]+=t[0],e[1]+=t[1]})):e=r[r.length-1],n<0?[e,i]:[i,e]}function r(t,n){for(var e in t){var r=t[e];delete n[r.start],delete r.start,delete r.end,r.forEach(function(t){i[t<0?~t:t]=1}),s.push(r)}}var i={},a={},o={},s=[],h=-1;return n.forEach(function(e,r){var i,a=t.arcs[e<0?~e:e];a.length<3&&!a[1][0]&&!a[1][1]&&(i=n[++h],n[h]=e,n[r]=i)}),n.forEach(function(t){var n,r,i=e(t),s=i[0],h=i[1];if(n=o[s])if(delete o[n.end],n.push(t),n.end=h,r=a[h]){delete a[r.start];var u=r===n?n:n.concat(r);a[u.start=n.start]=o[u.end=r.end]=u}else a[n.start]=o[n.end]=n;else if(n=a[h])if(delete a[n.start],n.unshift(t),n.start=s,r=o[s]){delete o[r.end];var c=r===n?n:r.concat(n);a[c.start=r.start]=o[c.end=n.end]=c}else a[n.start]=o[n.end]=n;else n=[t],a[n.start=s]=o[n.end=h]=n}),r(o,a),r(a,o),n.forEach(function(t){i[t<0?~t:t]||s.push([t])}),s},Gn=function(t,n){for(var e=0,r=t.length;e<r;){var i=e+r>>>1;t[i]<n?e=i+1:r=i}return e},On=function(t){function n(t,n){t.forEach(function(t){t<0&&(t=~t);var e=i[t];e?e.push(n):i[t]=[n]})}function e(t,e){t.forEach(function(t){n(t,e)})}function r(t,n){"GeometryCollection"===t.type?t.geometries.forEach(function(t){r(t,n)}):t.type in o&&o[t.type](t.arcs,n)}var i={},a=t.map(function(){return[]}),o={LineString:n,MultiLineString:e,Polygon:e,MultiPolygon:function(t,n){t.forEach(function(t){e(t,n)})}};t.forEach(r);for(var s in i)for(var h=i[s],u=h.length,c=0;c<u;++c)for(var f=c+1;f<u;++f){var l,p=h[c],g=h[f];(l=a[p])[s=Gn(l,g)]!==g&&l.splice(s,0,g),(l=a[g])[s=Gn(l,p)]!==p&&l.splice(s,0,p)}return a},Dn=function(t,n){return t<n?-1:t>n?1:t>=n?0:NaN},Hn=function(t){return 1===t.length&&(t=Ft(t)),{left:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var a=r+i>>>1;t(n[a],e)<0?r=a+1:i=a}return r},right:function(n,e,r,i){for(null==r&&(r=0),null==i&&(i=n.length);r<i;){var a=r+i>>>1;t(n[a],e)>0?i=a:r=a+1}return r}}},Nn=Hn(Dn),Qn=(Nn.right,Math.sqrt(50),Math.sqrt(10),Math.sqrt(2),function(t,n){return jt(zt(It(t),t),n)}),Un=function(t,n){if(t.length>8)return t.map(function(t,n){return n});var e=t.map(function(t){return n.map(function(n){return Xt(t,n)})});return Vt(t,n,e)};t.interpolate=Fn,t.separate=Yt,t.combine=Gt,t.interpolateAll=Ot,t.splitPathString=N,t.toPathString=H,t.fromCircle=Ht,t.toCircle=Nt,t.fromRect=Qt,t.toRect=Ut,Object.defineProperty(t,"__esModule",{value:!0})});


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYWIxYTc0OTI2ZDA2YmMyZjE5NWIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzL2J1aWxkL2QzLmpzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3N0dWR5RGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvdW50cnlTZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ByZS1sb2FkZXIvcHJlLWxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5pdFRhc2tzLmpzIiwid2VicGFjazovLy8uL3NyYy90YXNrcy90YXNrTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2FuZGJveC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uc2VudC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaW50cm9kdWN0aW9uLmpzIiwid2VicGFjazovLy8uL3NyYy9xdWVzdGlvbm5haXJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGlwYm9hcmQvbGliL2NsaXBib2FyZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xpcGJvYXJkL2xpYi9jbGlwYm9hcmQtYWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZWxlY3Qvc3JjL3NlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGlueS1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nb29kLWxpc3RlbmVyL3NyYy9saXN0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dvb2QtbGlzdGVuZXIvc3JjL2lzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWxlZ2F0ZS9zcmMvZGVsZWdhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlbGVnYXRlL3NyYy9jbG9zZXN0LmpzIiwid2VicGFjazovLy8uL3NyYy90cmlhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWVudS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmx1YmJlci9idWlsZC9mbHViYmVyLm1pbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxNOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELGdCQUFnQjtBQUM5RSw0REFBNEQsZ0JBQWdCOztBQUU1RTs7QUFFQTs7Ozs7Ozs7QUM1R0E7QUFDQTtBQUNBLENBQUMsS0FBNEQ7QUFDN0Q7QUFDQSxzQ0FBc0M7QUFDdEMsQ0FBQyw0QkFBNEI7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQixzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFFQUFxRSxTQUFTO0FBQzlFLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxrRkFBa0YsRUFBRTs7QUFFOUg7QUFDQTtBQUNBLDBDQUEwQyxnQ0FBZ0MsNkRBQTZELEVBQUU7QUFDekk7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QywrQkFBK0IsRUFBRTs7QUFFekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQix3QkFBd0IsRUFBRTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZOztBQUVaO0FBQ0EsOENBQThDLElBQUksT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtGQUFrRixPQUFPO0FBQ3pGO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQsR0FBRztBQUNIO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUZBQXFGLE9BQU87QUFDNUYsK0dBQStHLE9BQU87QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5RkFBeUYsT0FBTztBQUNoRyw4REFBOEQsT0FBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFGQUFxRixPQUFPO0FBQzVGLDRGQUE0RixPQUFPO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MscURBQXFELEVBQUU7QUFDdkYsdUNBQXVDLCtDQUErQyxFQUFFO0FBQ3hGLHFDQUFxQyw2Q0FBNkMsRUFBRTtBQUNwRix3Q0FBd0MsZ0RBQWdEO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlLEVBQUU7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0dBQXNHLE9BQU87QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhKQUE4SixPQUFPO0FBQ3JLLHdIQUF3SCxPQUFPO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0REFBNEQsU0FBUztBQUNyRSw0RUFBNEUsVUFBVTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzRkFBc0YsT0FBTztBQUM3Rix3R0FBd0csT0FBTztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CLEVBQUU7QUFDN0M7QUFDQTs7QUFFQTs7QUFFQSwyREFBMkQsT0FBTztBQUNsRSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxFQUFFO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJEQUEyRCxPQUFPO0FBQ2xFLDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBELE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBFQUEwRSxPQUFPO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFDQUFxQyxFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsdUNBQXVDO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsb0JBQW9CLEVBQUUsT0FBTztBQUN0RSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsa0RBQWtEO0FBQ2xELDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUIsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxRQUFRO0FBQ3JCLFFBQVEsUUFBUTs7QUFFaEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLHdDQUF3QztBQUN4QywyQkFBMkI7QUFDM0I7QUFDQSxLQUFLLE9BQU87QUFDWjtBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQW1DLEdBQUcsbUNBQW1DO0FBQ3ZGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxnQ0FBZ0M7QUFDaEUsY0FBYywwRUFBMEU7QUFDeEYsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyx5RUFBeUU7QUFDdkYsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQyxHQUFHLG1DQUFtQztBQUN2RixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxtQkFBbUI7O0FBRXJIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGtEQUFrRCxlQUFlLFVBQVU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUIsMkJBQTJCLE9BQU87QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxRkFBcUYsT0FBTztBQUM1Riw0RkFBNEYsT0FBTztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrSkFBK0osT0FBTztBQUN0Syx3SEFBd0gsT0FBTztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsUUFBUTtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUZBQXFGLE9BQU87QUFDNUYsK0dBQStHLE9BQU87QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUZBQXlGLE9BQU87QUFDaEcsOERBQThELE9BQU87QUFDckU7QUFDQSx3SUFBd0ksT0FBTztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJELE9BQU87QUFDbEUsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLDJCQUEyQjtBQUNoRSxrQ0FBa0MscUJBQXFCOztBQUV2RDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLDJCQUEyQjtBQUNqRSxtQ0FBbUMscUJBQXFCOztBQUV4RDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QywyQkFBMkI7QUFDbkUscUNBQXFDLHFCQUFxQjs7QUFFMUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSwyREFBMkQsT0FBTztBQUNsRSw4REFBOEQsT0FBTztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBZ0QsRUFBRTtBQUMzRSx3QkFBd0IsbUNBQW1DO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBZ0QsRUFBRTtBQUMzRSx3QkFBd0IsbUNBQW1DO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXLEVBQUU7QUFDcEMsd0JBQXdCLFdBQVc7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsZUFBZSxFQUFFOztBQUV2RDs7QUFFQTtBQUNBLG9DQUFvQyxtQ0FBbUMsRUFBRTtBQUN6RSxxQ0FBcUMsd0JBQXdCLEVBQUU7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxnREFBZ0QsRUFBRTtBQUMzRix1REFBdUQsZ0NBQWdDLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxzSEFBc0gsRUFBRTtBQUMxSixrQ0FBa0Msc0dBQXNHLEVBQUU7QUFDMUksc0NBQXNDLDZHQUE2RyxFQUFFO0FBQ3JKLHVDQUF1Qyw2R0FBNkcsRUFBRTtBQUN0Sjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyw0RkFBNEY7QUFDNUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9CQUFvQixFQUFFLE9BQU87QUFDMUU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0Esd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5RUFBeUUsOENBQThDO0FBQ3ZIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELHFCQUFxQixFQUFFOztBQUV0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYSxrQ0FBa0MsRUFBRSxFQUFFO0FBQ2pHLHdEQUF3RCw4QkFBOEIsRUFBRTtBQUN4Rjs7QUFFQTtBQUNBLDZCQUE2QixpREFBaUQsRUFBRTtBQUNoRiwwQkFBMEIsMkNBQTJDLEVBQUU7QUFDdkUsOEJBQThCLHVEQUF1RCxFQUFFO0FBQ3ZGLHNCQUFzQixjQUFjLGFBQWEsRUFBRTtBQUNuRCwrQkFBK0IsbUNBQW1DLGFBQWEsRUFBRTtBQUNqRixpQ0FBaUMsb0JBQW9CLGFBQWEsRUFBRTtBQUNwRSx5QkFBeUIsWUFBWSxhQUFhO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsZ0JBQWdCLEVBQUU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsR0FBRyxnQkFBZ0I7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBLDZCQUE2QjtBQUM3Qix1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw0QkFBNEIsWUFBWSx5Q0FBeUMsRUFBRTtBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsb0RBQW9EO0FBQ3BELEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBGQUEwRjs7QUFFMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRCxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0Esc0NBQXNDLHFEQUFxRDtBQUMzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRCx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaURBQWlELE9BQU87QUFDeEQ7QUFDQSw0QkFBNEI7QUFDNUIscUNBQXFDLFFBQVE7QUFDN0M7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLDZCQUE2QixFQUFFO0FBQ3RELG9CQUFvQixrQ0FBa0MsRUFBRTtBQUN4RCxvQkFBb0IsZUFBZSxFQUFFO0FBQ3JDLG9CQUFvQixtQ0FBbUMsRUFBRTtBQUN6RCx1QkFBdUIsMkJBQTJCLEVBQUU7QUFDcEQsdUJBQXVCLHFCQUFxQixFQUFFO0FBQzlDLHVCQUF1Qix5QkFBeUIsRUFBRTtBQUNsRCxvQkFBb0Isa0NBQWtDLEVBQUU7QUFDeEQsdUJBQXVCLGtDQUFrQyxFQUFFO0FBQzNEO0FBQ0E7QUFDQSxvQkFBb0IsaURBQWlELEVBQUU7QUFDdkUsb0JBQW9CLG1DQUFtQztBQUN2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLHFJQUFxSTtBQUNySSxxRUFBcUU7QUFDckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1DQUFtQztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFLFFBQVE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0MsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLE9BQU87QUFDaEQsa0hBQWtILE9BQU87QUFDekg7QUFDQSx5QkFBeUIseUVBQXlFO0FBQ2xHLGdCQUFnQiwwRUFBMEU7QUFDMUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQixlQUFlLEVBQUUsRUFBRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQixlQUFlLEVBQUUsRUFBRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdDQUFnQyxFQUFFO0FBQzNHLHlFQUF5RSxnQ0FBZ0MsRUFBRTtBQUMzRzs7QUFFQTtBQUNBLDhDQUE4QyxTQUFTLDhDQUE4QyxFQUFFO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxhQUFhLEVBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNkNBQTZDO0FBQ3BELDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixtQ0FBbUM7QUFDbkMsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIseUJBQXlCLEVBQUU7QUFDcEQsc0JBQXNCLHNCQUFzQixFQUFFO0FBQzlDLHlCQUF5Qix5QkFBeUIsRUFBRTtBQUNwRCx1QkFBdUIsdUJBQXVCLEVBQUU7QUFDaEQsNEJBQTRCLDRCQUE0QixFQUFFO0FBQzFELDBCQUEwQiwwQkFBMEI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUIsc0NBQXNDLEVBQUU7QUFDL0YsOEJBQThCLHFCQUFxQixzQ0FBc0M7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsdUNBQXVDLGdCQUFnQixFQUFFO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZLHdDQUF3QyxFQUFFO0FBQ2pGLHdCQUF3QixZQUFZLHFDQUFxQyxFQUFFO0FBQzNFLDJCQUEyQixZQUFZLHdDQUF3QyxFQUFFO0FBQ2pGLHlCQUF5QixZQUFZLHNDQUFzQyxFQUFFO0FBQzdFLDhCQUE4QixZQUFZLDJDQUEyQyxFQUFFO0FBQ3ZGLDRCQUE0QixZQUFZLHlDQUF5QztBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCLGdCQUFnQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsMERBQTBEO0FBQzFFLFVBQVUsd0RBQXdEO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEMsMENBQTBDO0FBQzFDLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsd0NBQXdDOztBQUUzRDtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxvQ0FBb0MsS0FBSyxFQUFFO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCLE9BQU87QUFDOUQ7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw4REFBOEQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxPQUFPOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQyxxQkFBcUIscUNBQXFDOztBQUUxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrQ0FBK0M7QUFDMUY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVksRUFBRTtBQUN2QjtBQUNBLDBEQUEwRDtBQUMxRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysc0JBQXNCO0FBQ3RCLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQzs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxtQ0FBbUMsRUFBRTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHFCQUFxQixFQUFFO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0VBQXdFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QixFQUFFO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsK0NBQStDO0FBQ3BFLHFCQUFxQiw0Q0FBNEM7QUFDakU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCLEVBQUU7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFlBQVksT0FBTztBQUMxQix1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDLEVBQUU7QUFDOUQseUJBQXlCLGlDQUFpQztBQUMxRCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQXVDO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix5Q0FBeUM7QUFDakU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvRkFBb0Y7QUFDcEYsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhCQUE4QjtBQUMzRCw2QkFBNkIsMENBQTBDLEVBQUU7QUFDekU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsNENBQTRDLEVBQUU7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhLEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0VBQXNFO0FBQ3BHLDhCQUE4QjtBQUM5QiwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxxQ0FBcUMsRUFBRTtBQUM5RixzREFBc0QsK0JBQStCLEVBQUU7O0FBRXZGO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlCQUF5QixFQUFFO0FBQzVELCtCQUErQix5QkFBeUIsRUFBRTtBQUMxRCxrQ0FBa0MseUJBQXlCLEVBQUU7QUFDN0Qsa0NBQWtDLHlCQUF5QixFQUFFOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0VBQXNFO0FBQ3BHLDhCQUE4QjtBQUM5Qiw4QkFBOEIsb0ZBQW9GO0FBQ2xILG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFELDhCQUE4Qiw0QkFBNEI7QUFDMUQsOEJBQThCLDRCQUE0Qiw0RkFBNEY7QUFDdEosbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEIsb0ZBQW9GLDBFQUEwRTtBQUM1TCw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzRUFBc0U7QUFDcEcsOEJBQThCLDRCQUE0QjtBQUMxRCw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRCw4QkFBOEIsa0RBQWtEO0FBQ2hGLDhCQUE4Qiw0QkFBNEI7QUFDMUQsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCLGtHQUFrRztBQUNoSSw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsc0VBQXNFO0FBQ3BHLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLDRCQUE0QjtBQUMxRCw4QkFBOEIsa0RBQWtEO0FBQ2hGLDhCQUE4Qiw0QkFBNEI7QUFDMUQsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCLGtHQUFrRztBQUNoSSw4QkFBOEI7QUFDOUIsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSw4QkFBOEIsc0VBQXNFO0FBQ3BHLDhCQUE4QjtBQUM5Qiw4QkFBOEIsMERBQTBEO0FBQ3hGLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFO0FBQ3hELHlCQUF5QiwyQkFBMkIsRUFBRTtBQUN0RCwwQkFBMEIsNEJBQTRCLEVBQUU7QUFDeEQsaURBQWlELG1EQUFtRDtBQUNwRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0VBQXNFO0FBQ3BHLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUVBQWlFLE9BQU87QUFDeEU7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE9BQU87QUFDdEIsaUVBQWlFLE9BQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQsbUJBQW1CLE9BQU87QUFDMUIsc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUUsT0FBTztBQUMxRSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QyxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsMEJBQTBCLEVBQUU7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwQkFBMEIsRUFBRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLFFBQVE7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQ0FBaUMsNEJBQTRCLEVBQUU7QUFDL0QsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0MsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUIsT0FBTztBQUNwQyxLQUFLO0FBQ0w7QUFDQSxZQUFZLGVBQWUsT0FBTztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsMENBQTBDLEVBQUU7QUFDaEc7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0Msa0NBQWtDLEVBQUU7QUFDMUUsbURBQW1ELGdDQUFnQyxFQUFFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isa0JBQWtCLDRCQUE0Qix3REFBd0Q7QUFDdEc7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsc0JBQXNCLEVBQUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0IsRUFBRTtBQUMvRCxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYzs7QUFFNUQsQ0FBQzs7Ozs7OztBQ2orZ0JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCOzs7Ozs7QUNuUkEsU0FBUyxtQkFBTyxDQUFDLENBQUk7QUFDckIsY0FBYyxtQkFBTyxDQUFDLEVBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLENBQVc7O0FBRWpDLHdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBLDZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPLEU7O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQjtBQUNBO0FBQ0EsZ0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFOztBQUVUO0FBQ0EsaUM7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxFO0FBQ1QsTzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQjtBQUNBLGtDO0FBQ0EsT0FBTztBQUNQLHNCO0FBQ0Esa0M7QUFDQSxPQUFPLEU7O0FBRVA7QUFDQSxnQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFM7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEU7O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsOEI7QUFDQSwyQjtBQUNBLHlCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1DO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsbUI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsZTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLGdEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4QjtBQUNBLDJCO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEU7O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMLEc7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDBCOzs7Ozs7QUNoMUJBLFNBQVMsbUJBQU8sQ0FBQyxDQUFJO0FBQ3JCLGlCQUFpQixtQkFBTyxDQUFDLENBQWtCO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyxDQUFXLEU7O0FBRWpDOztBQUVBLGlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCO0FBQ0E7O0FBRUE7O0FBRUEsYzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0U7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEQ7QUFDQTtBQUNBO0FBQ0EsWTtBQUNBO0FBQ0EsTztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFc7QUFDQSxTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTO0FBQ0E7QUFDQSxLQUFLLEU7O0FBRUwsRzs7QUFFQSx3Qjs7QUFFQTtBQUNBLGtDOztBQUVBLGlCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLE9BQU87O0FBRVosRzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0U7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDREO0FBQ0E7QUFDQTtBQUNBLFU7QUFDQTtBQUNBLEs7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QjtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDck1BLFNBQVMsbUJBQU8sQ0FBQyxDQUFJO0FBQ3JCO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsQ0FBWTtBQUNwQyxjQUFjLG1CQUFPLENBQUMsQ0FBVztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFhO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxDQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxFQUFXO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLEVBQWdCO0FBQzNDLG9CQUFvQixtQkFBTyxDQUFDLEVBQWlCO0FBQzdDLFlBQVksbUJBQU8sQ0FBQyxFQUFTO0FBQzdCLHNCQUFzQixtQkFBTyxDQUFDLENBQW1CO0FBQ2pELFdBQVcsbUJBQU8sQ0FBQyxFQUFRLEU7QUFDM0IsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsNEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7O0FBSUEsbUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0EsR0FBRyxFOztBQUVILENBQUMsRTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7O0FBRUEseUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQSx5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLG9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1DO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQSwyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7QUFDQTtBQUNBLEtBQUssRTs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNUOztBQUVBLDJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsRztBQUNBOztBQUVBO0FBQ0EsNEI7O0FBRUEsNEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLGlFO0FBQ0EseUQ7QUFDQSxPOztBQUVBLGlFOztBQUVBLHlEOztBQUVBLCtCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxPO0FBQ0EsVTs7QUFFQTtBQUNBO0FBQ0EsRzs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0EsdUI7O0FBRUEseUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLFk7QUFDQSxHQUFHO0FBQ0gsbUI7QUFDQTs7QUFFQTs7QUFFQSxTOztBQUVBO0FBQ0EsZ0M7QUFDQTtBQUNBOztBQUVBLDZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsSztBQUNBLEdBQUc7O0FBRUg7QUFDQSxnQztBQUNBO0FBQ0E7O0FBRUEsNkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSwrQjtBQUNBLDRCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTzs7QUFFQSw2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLG1EO0FBQ0EsYztBQUNBO0FBQ0EsdUI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxnQztBQUNBO0FBQ0E7O0FBRUEsNkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEs7QUFDQSxHQUFHOztBQUVIO0FBQ0EsZ0M7QUFDQSxpRDtBQUNBO0FBQ0EseUI7O0FBRUEsMkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQSxxQjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLDJEQUEyRDs7QUFFM0QseUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsMEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEU7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7Ozs7OztBQ2ppQkEsbUNBQUM7QUFDRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DLFNBQVM7QUFDN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUssSUFBMEM7QUFDL0M7QUFDQSxFQUFFLG1DQUFPO0FBQ1Q7QUFDQSxHQUFHO0FBQUEsb0dBQUM7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYTs7Ozs7O0FDdE9ELGNBQWMsbUJBQU8sQ0FBQyxDQUFXO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLENBQWtCO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxDQUFrQjs7QUFFekM7O0FBRUEsa0M7QUFDQTtBQUNBLEdBQUc7O0FBRUgsOEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSwyQjs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEI7Ozs7OztBQzFuQ0EsU0FBUyxtQkFBTyxDQUFDLENBQUk7QUFDckIsY0FBYyxtQkFBTyxDQUFDLENBQVc7QUFDakMsWUFBWSxtQkFBTyxDQUFDLENBQVM7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsQ0FBa0I7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4RDtBQUNBO0FBQ0E7QUFDQSxZO0FBQ0E7QUFDQSxPO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsZ0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUY7O0FBRUE7QUFDQTtBQUNBLHVGO0FBQ0EsUUFBUTs7QUFFUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQztBQUNBO0FBQ0E7QUFDQSwyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DO0FBQ0E7QUFDQTtBQUNBLGtDO0FBQ0E7QUFDQTs7QUFFQSwyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLHdCOztBQUVBO0FBQ0Esa0M7QUFDQTtBQUNBLGU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEtBQUssT0FBTzs7QUFFWiw2Qjs7QUFFQTs7QUFFQTtBQUNBLDJCOztBQUVBOztBQUVBO0FBQ0EsMEI7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QjtBQUNBLCtGQUErRjtBQUMvRjtBQUNBLGtDO0FBQ0Esc0I7QUFDQSxHQUFHOztBQUVILGE7O0FBRUE7QUFDQSwyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0Q7QUFDQSx1RDtBQUNBLEs7QUFDQTtBQUNBLHFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QjtBQUNBLEdBQUcsRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxPQUFPOztBQUVkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxPQUFPOztBQUVkO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRTs7QUFFSDs7QUFFQTs7Ozs7OztBQ2xhQSxTQUFTLG1CQUFPLENBQUMsQ0FBSTtBQUNyQixjQUFjLG1CQUFPLENBQUMsQ0FBVzs7QUFFakMsMEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0M7QUFDQSw4QjtBQUNBLEdBQUcsRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7QUFDQSw4QjtBQUNBLEdBQUcsRTs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCO0FBQ3JELG9DO0FBQ0Esa0M7QUFDQSxPQUFPLEU7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0M7QUFDQSxrQztBQUNBLE9BQU8sRTs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBLG9DO0FBQ0Esa0M7QUFDQSxPQUFPLEU7O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQSxvQztBQUNBLGtDO0FBQ0EsT0FBTyxFOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0Esb0M7QUFDQSxrQztBQUNBLE9BQU8sRTs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RCxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0Esb0M7QUFDQSxrQztBQUNBLE9BQU8sRTs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQjtBQUN2RDtBQUNBLG9DO0FBQ0Esa0M7QUFDQSxPQUFPLEU7O0FBRVA7QUFDQTs7QUFFQSxVOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQiw2MEJBQTYwQixpQkFBaUI7QUFDcjVCO0FBQ0Esb0M7QUFDQSxrQztBQUNBLE9BQU8sRTs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0U7QUFDQSx3RDtBQUNBOztBQUVBLDZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSx1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDOztBQUVBLDhCOztBQUVBO0FBQ0EsOEQ7QUFDQSxzRDtBQUNBOztBQUVBLDJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7Ozs7Ozs7QUM3TkEsU0FBUyxtQkFBTyxDQUFDLENBQUk7QUFDckIsY0FBYyxtQkFBTyxDQUFDLENBQVc7QUFDakMsWUFBWSxtQkFBTyxDQUFDLENBQVM7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsQ0FBa0I7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsQ0FBbUI7O0FBRWpEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3QjtBQUNBLCtGQUErRjtBQUMvRjtBQUNBLGtDO0FBQ0Esc0I7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCOztBQUVBO0FBQ0Esa0M7QUFDQTtBQUNBLGU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUssT0FBTzs7QUFFWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0M7O0FBRUE7O0FBRUE7QUFDQSwwQjs7QUFFQTs7QUFFQSxHOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJVO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsK1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZPOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbVI7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaVc7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzTzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUEsK0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUzs7QUFFQTs7QUFFQTs7QUFFQSxrQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBLDBHOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsUzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyRkFBMkYsZ2VBQWdlLHVHOztBQUUzakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9UOztBQUVBLDhCO0FBQ0EsV0FBVyxFO0FBQ1gsU0FBUyxROztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RTtBQUNBLCtEO0FBQ0E7O0FBRUEsK0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBLEs7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDOztBQUVBOztBQUVBOztBQUVBLHNHO0FBQ0E7QUFDQTs7QUFFQSxZOztBQUVBOztBQUVBLG1KO0FBQ0E7QUFDQSxxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVOQUF1TixxSDtBQUN2TjtBQUNBLHFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHVMO0FBQ0E7QUFDQSxxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx3UDtBQUNBO0FBQ0EscUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsWTs7QUFFQTs7QUFFQSw0STtBQUNBO0FBQ0EscUM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsNkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUTs7QUFFQTtBQUNBLHFDOztBQUVBOztBQUVBOztBQUVBO0FBQ0EscUU7QUFDQSw2RDtBQUNBOztBQUVBLDZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOztBQUVBLHNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEU7O0FBRVgsUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUU7QUFDQSwrRDtBQUNBOztBQUVBLCtCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLEU7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7QUFDQSxnQzs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQSwrRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsU0FBUyxPQUFPOztBQUVoQjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEU7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7QUFDQSxnQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTzs7QUFFaEI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0M7QUFDQSxnQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOztBQUVBOztBQUVBOzs7Ozs7O0FDei9CQSxTQUFTLG1CQUFPLENBQUMsQ0FBSTtBQUNyQixnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFXO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyxDQUFXOztBQUVqQzs7QUFFQTs7QUFFQSxtQzs7QUFFQTs7QUFFQSwyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUM7O0FBRUEsR0FBRzs7QUFFSDtBQUNBLGtFO0FBQ0EsMEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDOztBQUVBOztBQUVBOztBQUVBLCtOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DOztBQUVBOztBQUVBLCtCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsaUM7O0FBRUEsT0FBTzs7QUFFUCxZOztBQUVBOztBQUVBLHFVOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7O0FBRUEsa0M7O0FBRUE7O0FBRUEsaUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLG1DOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBLGU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCx1Qzs7QUFFQSxvQzs7QUFFQSw4RTtBQUNBOztBQUVBLDBCOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxFO0FBQ1QsT0FBTyxPOztBQUVQOztBQUVBOztBQUVBLGtVOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7O0FBRUEsa0M7O0FBRUE7O0FBRUEsaUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLG1DO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsZTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULHVDOztBQUVBLG9DOztBQUVBLDhFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQzs7QUFFQSxTQUFTLEU7QUFDVCxPQUFPOzs7QUFHUDs7QUFFQTs7QUFFQSxxVTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DOztBQUVBLGtDOztBQUVBOztBQUVBLGlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxtQztBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBLGU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCx1Qzs7QUFFQSxvQzs7QUFFQSw4RTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0M7O0FBRUEsU0FBUyxFOztBQUVULE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrUUFBK1E7QUFDL1EsUTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx1RDs7QUFFQTs7QUFFQTs7Ozs7OztBQ3RWQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQsUUFBUSxpQ0FBTyxDQUFDLE1BQVEsRUFBRSx1QkFBb0IsRUFBRSx1QkFBYyxFQUFFLHVCQUFlLENBQUMsb0NBQUUsT0FBTztBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUMxRixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsMkNBQTJDO0FBQzlELG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxFOzs7Ozs7QUM5TUQ7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsaUNBQU8sQ0FBQyxNQUFRLEVBQUUsdUJBQVEsQ0FBQyxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzdDLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUMsRTs7Ozs7O0FDcE9EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqRUEsU0FBUyxtQkFBTyxDQUFDLEVBQU07QUFDdkIsZUFBZSxtQkFBTyxDQUFDLEVBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoREEsY0FBYyxtQkFBTyxDQUFDLEVBQVc7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM3RUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQ0EsU0FBUyxtQkFBTyxDQUFDLENBQUk7QUFDckIsY0FBYyxtQkFBTyxDQUFDLENBQVc7QUFDakMsWUFBWSxtQkFBTyxDQUFDLENBQVM7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsQ0FBa0I7QUFDM0Msc0JBQXNCLG1CQUFPLENBQUMsQ0FBbUI7O0FBRWpEOztBQUVBO0FBQ0EsaUM7QUFDQTtBQUNBOztBQUVBLGlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssRTs7QUFFTDtBQUNBO0FBQ0EsdUY7QUFDQSxRQUFROztBQUVSOztBQUVBLHdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0M7QUFDQSxnQztBQUNBLGU7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxPQUFPOztBQUVaLDZCOztBQUVBOztBQUVBO0FBQ0EsMkI7O0FBRUE7O0FBRUE7QUFDQSwwQjs7QUFFQTtBQUNBLEc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhEO0FBQ0E7QUFDQSxrRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSwyREFBMkQsaUNBQWlDLHdCQUF3Qjs7QUFFcEg7O0FBRUE7QUFDQTtBQUNBLHlJQUF5SSxnU0FBZ1MsNFc7O0FBRXphO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQzs7QUFFQTtBQUNBLFNBQVMsRTtBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSx1QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLEU7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7QUFFQSxrQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEO0FBQ0E7O0FBRUEsT0FBTyxFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0M7O0FBRUEsa0M7O0FBRUE7QUFDQSwyQztBQUNBLDZCO0FBQ0EsbUI7O0FBRUEsT0FBTyxFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUg7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOztBQUVBLHNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUTtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEU7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QjtBQUNBO0FBQ0E7QUFDQSxhO0FBQ0E7QUFDQTtBQUNBLGE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEU7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7O0FBRUEsc0M7O0FBRUEsZ0Q7QUFDQTs7QUFFQSxxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDO0FBQ0EsMEM7QUFDQSwyRDtBQUNBO0FBQ0EsZUFBZSxFOztBQUVmO0FBQ0E7QUFDQTtBQUNBLDZWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxFOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0I7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQSxrQztBQUNBLHNCO0FBQ0EsR0FBRztBQUNILGE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7QUFDQSw4Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEM7O0FBRUEsNkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLE9BQU87O0FBRWQ7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDO0FBQ0EsOEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLE9BQU87O0FBRWQ7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUcsRTs7QUFFSDtBQUNBO0FBQ0EsZ0M7QUFDQSw4QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQy81QkEsU0FBUyxtQkFBTyxDQUFDLENBQUk7QUFDckIsY0FBYyxtQkFBTyxDQUFDLENBQVc7O0FBRWpDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQjs7QUFFQTtBQUNBO0FBQ0EsOE07O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVLEVBQUU7QUFDOUMseUJBQXlCLGtCQUFrQixFQUFFO0FBQzdDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxVQUFVLEVBQUU7QUFDOUMseUJBQXlCLGtCQUFrQixFQUFFO0FBQzdDO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBOzs7Ozs7O0FDdElBLGVBQWUsS0FBb0QsaUdBQWlHLEVBQUUsa0JBQWtCLGFBQWEsY0FBYyw2R0FBNkcsY0FBYyxhQUFhLDBHQUEwRyxTQUFTLGNBQWMsb0JBQW9CLGNBQWMsNENBQTRDLGNBQWMsb0hBQW9ILGNBQWMsS0FBSyw2Q0FBNkMsV0FBVyxjQUFjLGdEQUFnRCxrRUFBa0UsNEtBQTRLLFdBQVcsMkpBQTJKLEtBQUssNkJBQTZCLFVBQVUsNkJBQTZCLFdBQVcsYUFBYSx3QkFBd0IsVUFBVSw2QkFBNkIsb0JBQW9CLGlGQUFpRiw0SkFBNEosS0FBSyw2QkFBNkIsS0FBSyxrREFBa0QsY0FBYyxRQUFRLDJDQUEyQyxhQUFhLGlJQUFpSSxVQUFVLHNFQUFzRSxHQUFHLGNBQWMsb0JBQW9CLGdKQUFnSixvRkFBb0YsVUFBVSxFQUFFLFFBQVEsSUFBSSxLQUFLLDRCQUE0QixpR0FBaUcsT0FBTyx3QkFBd0IseUNBQXlDLEtBQUssZ0JBQWdCLDBJQUEwSSxhQUFhLHFDQUFxQyw4QkFBOEIsb0JBQW9CLG1GQUFtRiw4Q0FBOEMsZ0NBQWdDLHVGQUF1RixrREFBa0QsaUlBQWlJLHlEQUF5RCxnQkFBZ0Isb0ZBQW9GLHdDQUF3QyxrQkFBa0IsNENBQTRDLDhCQUE4QixjQUFjLHdDQUF3QyxZQUFZLHdEQUF3RCxjQUFjLGtCQUFrQiwwQkFBMEIsNEJBQTRCLFFBQVEsUUFBUSxTQUFTLFFBQVEsU0FBUyxRQUFRLFNBQVMsUUFBUSw4S0FBOEssa0JBQWtCLE9BQU8sNkVBQTZFLGtCQUFrQixvR0FBb0csc0JBQXNCLG1DQUFtQyxPQUFPLEVBQUUsa0VBQWtFLG1DQUFtQyxTQUFTLGtCQUFrQixPQUFPLHVGQUF1RixrQkFBa0IsT0FBTyxxSkFBcUosa0JBQWtCLGtCQUFrQixnSEFBZ0gseUVBQXlFLGtDQUFrQyw4SEFBOEgsZ0JBQWdCLGdCQUFnQixrQkFBa0IsdUJBQXVCLGtCQUFrQixVQUFVLFlBQVksS0FBSyxtREFBbUQsU0FBUyx1QkFBdUIsSUFBSSx5QkFBeUIsa0JBQWtCLGtCQUFrQixvQ0FBb0Msb0JBQW9CLGtCQUFrQixZQUFZLGtCQUFrQixrQkFBa0IsS0FBSywwQ0FBMEMsV0FBVyxvQkFBb0IsK0JBQStCLDhDQUE4QyxnQ0FBZ0MsdUZBQXVGLGtEQUFrRCxpSUFBaUkseURBQXlELGdCQUFnQixvRkFBb0Ysd0NBQXdDLDhCQUE4QixrQkFBa0IsMENBQTBDLDJFQUEyRSx5QkFBeUIsb0RBQW9ELG9CQUFvQix3Q0FBd0MsZ0JBQWdCLGtFQUFrRSxrQkFBa0IsOENBQThDLGdCQUFnQixtQkFBbUIsa0JBQWtCLDBCQUEwQixpQkFBaUIsRUFBRSxtQkFBbUIsd0JBQXdCLFlBQVksRUFBRSxpQkFBaUIsZ0JBQWdCLG1CQUFtQiwyQkFBMkIsb0JBQW9CLEdBQUcsY0FBYyxzQ0FBc0MsY0FBYyw4RUFBOEUsY0FBYyxZQUFZLGFBQWEsS0FBSyw2QkFBNkIsK0RBQStELFNBQVMsY0FBYyx1QkFBdUIsY0FBYyxpREFBaUQsK0JBQStCLHFCQUFxQixTQUFTLEVBQUUsY0FBYywwQkFBMEIsY0FBYyxlQUFlLGdCQUFnQixXQUFXLG9CQUFvQixjQUFjLDBCQUEwQixxQ0FBcUMsWUFBWSxXQUFXLEtBQUssZ0NBQWdDLDZCQUE2QixrQ0FBa0MsNkNBQTZDLEtBQUssb0JBQW9CLDhCQUE4QixtQkFBbUIsUUFBUSxnQkFBZ0IsMkJBQTJCLDhCQUE4Qix5RUFBeUUsWUFBWSxJQUFJLEtBQUssZ0NBQWdDLGtCQUFrQixPQUFPLHNCQUFzQixjQUFjLDJEQUEyRCwyRUFBMkUsc0NBQXNDLFVBQVUsYUFBYSxnQkFBZ0IsNkNBQTZDLFdBQVcsRUFBRSx3Q0FBd0Msc0VBQXNFLGdCQUFnQixvQkFBb0IsWUFBWSxXQUFXLGdEQUFnRCxTQUFTLCtCQUErQixnQkFBZ0IsVUFBVSx1QkFBdUIsYUFBYSx3QkFBd0Isa0RBQWtELDhDQUE4QyxzR0FBc0csY0FBYywyQkFBMkIsdURBQXVELEVBQUUsbUJBQW1CLE1BQU0seUVBQXlFLG1CQUFtQixPQUFPLDREQUE0RCxlQUFlLGtCQUFrQixxQ0FBcUMsa0JBQWtCLFlBQVksSUFBSSxpRUFBaUUsb0JBQW9CLHlCQUF5Qix1QkFBdUIsUUFBUSw2QkFBNkIsSUFBSSwyQkFBMkIsZUFBZSxLQUFLLDJCQUEyQiwyQ0FBMkMsaUJBQWlCLGVBQWUsU0FBUyxVQUFVLEdBQUcsbUVBQW1FLEtBQUssMkNBQTJDLE1BQU0sZ0JBQWdCLFNBQVMsMkJBQTJCLE1BQU0sbUJBQW1CLGdCQUFnQixnQkFBZ0IsNEdBQTRHLG1CQUFtQixxRkFBcUYsUUFBUSxlQUFlLDBCQUEwQix5QkFBeUIsc0JBQXNCLFdBQVcsRUFBRSx3RUFBd0UsU0FBUyxTQUFTLHFCQUFxQiwwQkFBMEIseUJBQXlCLDBOQUEwTixVQUFVLEVBQUUsZ0dBQWdHLFVBQVUsY0FBYyxVQUFVLEVBQUUsZ0dBQWdHLFVBQVUsU0FBUyxtQkFBbUIsUUFBUSxHQUFHLDJCQUEyQiwwSEFBMEgsYUFBYSxTQUFTLHlCQUF5QixRQUFRLEdBQUcsc0JBQXNCLFdBQVcsRUFBRSx1QkFBdUIsY0FBYywwRUFBMEUsU0FBUyxTQUFTLGFBQWEscUJBQXFCLG1CQUFtQixtQkFBbUIsSUFBSSxpR0FBaUcsbUJBQW1CLFdBQVcsOEJBQThCLFNBQVMsaUJBQWlCLGVBQWUsaUJBQWlCLGNBQWMsY0FBYyxjQUFjLGlCQUFpQiw2QkFBNkIsR0FBRyx3QkFBd0IsZ0RBQWdELGNBQWMsY0FBYyxvQkFBb0IsOEJBQThCLHlCQUF5QixTQUFTLGFBQWEsa0JBQWtCLHVCQUF1Qiw0QkFBNEIsYUFBYSxNQUFNLG1JQUFtSSxTQUFTLHFCQUFxQixRQUFRLEdBQUcsMkVBQTJFLGFBQWEsc0NBQXNDLGVBQWUsd0JBQXdCLEdBQUcsMEJBQTBCLEVBQUUsRUFBRSxvQkFBb0IscUJBQXFCLEtBQUssUUFBUSxZQUFZLHVJQUF1SSxJQUFJLGtCQUFrQixXQUFXLFNBQVMsdUJBQXVCLHNOQUFzTixlQUFlLFlBQVksR0FBRyx3QkFBd0IsYUFBYSxTQUFTLDZCQUE2Qix5RkFBeUYsaUJBQWlCLDJFQUEyRSxtQkFBbUIsOENBQThDLGlCQUFpQiw0QkFBNEIscUJBQXFCLGlHQUFpRyxpQkFBaUIsUUFBUSxHQUFHLG1GQUFtRixTQUFTLGFBQWEsU0FBUyxpQkFBaUIscUdBQXFHLGlCQUFpQix5Q0FBeUMsR0FBRyxnRkFBZ0YsYUFBYSxTQUFTLGlCQUFpQixrRUFBa0UsaUZBQWlGLHFCQUFxQixvQkFBb0IsK0VBQStFLGVBQWUsd0dBQXdHLG1CQUFtQixxSEFBcUgscUJBQXFCLHNCQUFzQixJQUFJLHdDQUF3QyxTQUFTLGlCQUFpQiwyQ0FBMkMsd0JBQXdCLHlCQUF5Qix1Q0FBdUMsVUFBVSw0Q0FBNEMsRUFBRSxvREFBb0QsaUJBQWlCLGdCQUFnQixrQkFBa0IscUNBQXFDLElBQUksc0JBQXNCLGFBQWEsY0FBYyxZQUFZLGNBQWMsNEJBQTRCLElBQUksY0FBYyxrQ0FBa0MsY0FBYyxlQUFlLFdBQVcsY0FBYyxTQUFTLGNBQWMsZ0JBQWdCLGNBQWMsZUFBZSxVQUFVLGdDQUFnQyx1Q0FBdUMsK0JBQStCLE1BQU0sd0NBQXdDLE1BQU0sNkJBQTZCLE1BQU0sc0NBQXNDLE1BQU0sMEJBQTBCLE1BQU0sbUNBQW1DLE1BQU0sb0JBQW9CLE9BQU8sc0JBQXNCLCtCQUErQixZQUFZLGVBQWUsdUNBQXVDLE1BQU0sbUNBQW1DLG1CQUFtQixpQkFBaUIsY0FBYyxlQUFlLGlEQUFpRCxNQUFNLHdCQUF3QixNQUFNLHNDQUFzQyxjQUFjLHNCQUFzQixzQkFBc0IsbUNBQW1DLEVBQUUsWUFBWSxjQUFjLGdCQUFnQix3QkFBd0Isa0JBQWtCLFFBQVEsV0FBVywwQ0FBMEMsU0FBUyxlQUFlLG9CQUFvQixVQUFVLGlDQUFpQyxzQkFBc0IsZ0NBQWdDLHVCQUF1QixFQUFFLEVBQUUsR0FBRyx3QkFBd0IsV0FBVyxHQUFHLDJDQUEyQyxXQUFXLHlCQUF5QixzQkFBc0Isc0JBQXNCLGdDQUFnQyxFQUFFLEVBQUUscURBQXFELElBQUksaURBQWlELFNBQVMsR0FBRyxlQUFlLHFCQUFxQixtQkFBbUIsaUJBQWlCLFFBQVEsSUFBSSx5QkFBeUIsV0FBVyx5Q0FBeUMsVUFBVSw2QkFBNkIsU0FBUyx3QkFBd0IsOERBQThELFlBQVksRUFBRSxpRUFBaUUsdUNBQXVDLGtEQUFrRCxlQUFlLGFBQWEsRUFBRSxvREFBb0QscUJBQXFCLElBQUksaUJBQWlCLDBEQUEwRCxjQUFjLE9BQU8sV0FBVyxhQUFhLDhDQUE4Qyx5R0FBeUcsR0FBRyxpRkFBaUYsMERBQTBELGlFQUFpRSxFQUFFLGVBQWUsb0NBQW9DLCtCQUErQiwwQkFBMEIsSUFBSSwyREFBMkQsU0FBUyxtQkFBbUIsa0JBQWtCLHFDQUFxQyxZQUFZLFdBQVcsS0FBSyx3Q0FBd0MsbUdBQW1HLGdDQUFnQyxTQUFTLEVBQUUsY0FBYyxpQkFBaUIsbUJBQW1CLFdBQVcsbUJBQW1CLGlCQUFpQixFQUFFLHlCQUF5QixtQkFBbUIsZUFBZSxtQkFBbUIsZUFBZSxtQkFBbUIsYUFBYSw4Q0FBOEMsMkNBQTJDLGNBQWMsMEJBQTBCLCtCQUErQix5QkFBeUIsMEJBQTBCLHFDQUFxQyxFQUFFLG1CQUFtQixpQkFBaUIsRUFBRSx5QkFBeUIsbUJBQW1CLGVBQWUsbUJBQW1CLGVBQWUsbUJBQW1CLGNBQWMscUNBQXFDLEVBQUUscUJBQXFCLGNBQWMsbUJBQW1CLG1CQUFtQixlQUFlLEVBQUUsbUJBQW1CLGlCQUFpQixFQUFFLHlCQUF5QixtQkFBbUIsZUFBZSxtQkFBbUIsZUFBZSxtSEFBbUgsc0JBQXNCLGNBQWMsdUJBQXVCLDhCQUE4Qix5QkFBeUIsc0NBQXNDLHlCQUF5Qix1REFBdUQscUNBQXFDLEVBQUUsbUJBQW1CLGlCQUFpQixFQUFFLGtGQUFrRixTQUFTLHdCQUF3Qix1QkFBdUIsRUFBRSw2Q0FBNkMsWUFBWSxrRkFBa0Ysb0JBQW9CLHlCQUF5QixZQUFZLFlBQVksYUFBYSx5QkFBeUIsWUFBWSxHQUFHLDZCQUE2QixvQ0FBb0MsR0FBRywrQ0FBK0MsNEJBQTRCLDBDQUEwQyw0QkFBNEIseUJBQXlCLDhCQUE4QiwwQ0FBMEMsR0FBRyxLQUFLLHVCQUF1QiwrQ0FBK0MsdUJBQXVCLG9CQUFvQixtQkFBbUIsZUFBZSx5QkFBeUIsK0NBQStDLHlCQUF5QixzQkFBc0IsbUJBQW1CLGVBQWUsdUJBQXVCLGlCQUFpQixFQUFFLHlCQUF5QixtQkFBbUIsZUFBZSxtQkFBbUIsaUJBQWlCLHdGQUF3RixxQkFBcUIsR0FBRyxtQkFBbUIsbUJBQW1CLDhFQUE4RSwyQkFBMkIsTUFBTSw4RkFBOEYsR0FBRyxxQkFBcUIsbUJBQW1CLDhFQUE4RSxxQkFBcUIsb0JBQW9CLDJCQUEyQixvQkFBb0IsbUNBQW1DLDBCQUEwQixHQUFHLGVBQWUsOEZBQThGLG1CQUFtQixvREFBb0Qsd0JBQXdCLHFCQUFxQixnQkFBZ0IsMERBQTBELG1CQUFtQix1Q0FBdUMsTUFBTSxtQ0FBbUMsV0FBVyxnQkFBZ0IsaURBQWlELE1BQU0sdUVBQXVFLHNCQUFzQixnQkFBZ0IsdURBQXVELE1BQU0sOERBQThELFNBQVMsS0FBSyw0Q0FBNEMsNEdBQTRHLHVCQUF1QixTQUFTLHlCQUF5QixNQUFNLHlLQUF5Syw4QkFBOEIsK0JBQStCLGlIQUFpSCxxQ0FBcUMsMkVBQTJFLGlDQUFpQywyRUFBMkUsb0NBQW9DLFVBQVUsMkpBQTJKLCtCQUErQiwwRkFBMEYsK0JBQStCLDBGQUEwRixnQ0FBZ0MsV0FBVyxnQ0FBZ0MsaUVBQWlFLG9FQUFvRSxZQUFZLG9CQUFvQixrQ0FBa0Msa0JBQWtCLGtDQUFrQyxNQUFNLDJJQUEySSxhQUFhLDREQUE0RCx3R0FBd0csaUJBQWlCLHVDQUF1QyxhQUFhLG1DQUFtQyxxQ0FBcUMsWUFBWSxLQUFLLG9EQUFvRCwwRkFBMEYsaUdBQWlHLG1HQUFtRyxxREFBcUQsdURBQXVELElBQUksNkNBQTZDLDJGQUEyRix5QkFBeUIseUJBQXlCLDRCQUE0QiwwQkFBMEIsdUNBQXVDLDRGQUE0RixLQUFLLFlBQVksSUFBSSx3QkFBd0IseUJBQXlCLFlBQVksV0FBVyxNQUFNLHNCQUFzQixVQUFVLHdCQUF3Qiw0QkFBNEIsU0FBUyxFQUFFLGdCQUFnQixrQ0FBa0Msb1RBQW9ULGdFQUFnRSwwQkFBMEIsZUFBZSxvQkFBb0IsOE9BQThPLHFDQUFxQyxxREFBcUQsU0FBUyxpQ0FBaUMsYUFBYSwrQ0FBK0MsWUFBWSxhQUFhLGtFQUFrRSxNQUFNLGtGQUFrRixNQUFNLGtFQUFrRSxNQUFNLGtGQUFrRixNQUFNLG9FQUFvRSw2SUFBNkksaUNBQWlDLE1BQU0sNEZBQTRGLE1BQU0sc0RBQXNELE1BQU0sbURBQW1ELFdBQVcsK0NBQStDLGdCQUFnQixLQUFLLHdDQUF3QyxlQUFlLHdCQUF3Qix1RkFBdUYsaUNBQWlDLE9BQU8sa0NBQWtDLGtDQUFrQyxpQ0FBaUMsb0JBQW9CLHVCQUF1QixZQUFZLHVCQUF1QiwwSEFBMEgsa0dBQWtHLHFDQUFxQyxzREFBc0QsaUNBQWlDLDBEQUEwRCxvQ0FBb0Msd0RBQXdELCtCQUErQiw2Q0FBNkMsK0JBQStCLDZDQUE2QyxnQ0FBZ0MsOENBQThDLG1DQUFtQyxxREFBcUQsK0JBQStCLHNCQUFzQix1RUFBdUUsZ0NBQWdDLGFBQWEsdUZBQXVGLHVGQUF1RixxQ0FBcUMsb0pBQW9KLGdOQUFnTixzSUFBc0ksMkJBQTJCLEdBQUcsT0FBTyxtQ0FBbUMsOEJBQThCLHNCQUFzQixxREFBcUQsaUJBQWlCLGdDQUFnQyxnQ0FBZ0MsYUFBYSxtRUFBbUUsNENBQTRDLDRDQUE0QyxxQ0FBcUMseURBQXlELGlCQUFpQixhQUFhLFdBQVcsNkJBQTZCLGNBQWMsb0JBQW9CLGtCQUFrQiw0QkFBNEIsNEJBQTRCLHNDQUFzQywrQkFBK0IsMEJBQTBCLDZCQUE2QixxQ0FBcUMsZ0JBQWdCLFdBQVcsbUJBQW1CLFVBQVUsNEJBQTRCLHNDQUFzQywrQkFBK0IsNENBQTRDLDZCQUE2QixxQ0FBcUMsZ0JBQWdCLFdBQVcsbUJBQW1CLFVBQVUsOEJBQThCLHNDQUFzQyxzQkFBc0IscUxBQXFMLDRDQUE0QyxNQUFNLE9BQU8sZ0NBQWdDLDhCQUE4QixzQ0FBc0MsK0JBQStCLHNWQUFzVixRQUFRLG1CQUFtQix3Q0FBd0Msc0RBQXNELFNBQVMsb0NBQW9DLHNCQUFzQiw0RkFBNEYsWUFBWSxFQUFFLGtEQUFrRCx5REFBeUQsdUNBQXVDLElBQUkscUVBQXFFLCtCQUErQixhQUFhLDhCQUE4QiwyR0FBMkcsMkJBQTJCLG1CQUFtQiw4QkFBOEIscUhBQXFILG9HQUFvRyxnQ0FBZ0Msc1BBQXNQLFlBQVksZ0JBQWdCLEVBQUUsU0FBUyxtQ0FBbUMsd1BBQXdQLE9BQU8sZ0JBQWdCO0FBQzN2K0IsU0FBUyxtR0FBbUcsT0FBTyx5Q0FBeUMsczVWQUFzNVYsMkZBQTJGLHlCQUF5Qix5QkFBeUIsNEJBQTRCLDBCQUEwQix1Q0FBdUMsNEZBQTRGLEtBQUssWUFBWSxJQUFJLHdCQUF3Qix5QkFBeUIsWUFBWSxXQUFXLE1BQU0sc0JBQXNCLFVBQVUsd0JBQXdCLDRCQUE0QixTQUFTLEVBQUUsZ0NBQWdDLGlDQUFpQyxhQUFhLCtCQUErQiwyQkFBMkIsbUJBQW1CLDhCQUE4QixXQUFXLHVDQUF1Qyx1Q0FBdUMsb0RBQW9ELEtBQUssb0NBQW9DLGdCQUFnQixJQUFJLDJCQUEyQiw0Q0FBNEMsZ0NBQWdDLFdBQVcsdUNBQXVDLHVDQUF1QyxvREFBb0QsS0FBSyxvQ0FBb0MsZ0JBQWdCLElBQUksMkJBQTJCLDhDQUE4QyxtQ0FBbUMsNERBQTRELE9BQU8seUNBQXlDLHlCQUF5Qix1QkFBdUIsc0NBQXNDLDBFQUEwRSwwQ0FBMEMsdUhBQXVILE9BQU8seUJBQXlCLDJDQUEyQyx5RkFBeUYsT0FBTyw2Q0FBNkMsK0NBQStDLDJEQUEyRCxPQUFPLHdDQUF3QyxtQkFBbUIsY0FBYyxrQkFBa0Isc0NBQXNDLFdBQVcsbzdGQUFvN0YsU0FBUyxrQkFBa0IsNEJBQTRCLFNBQVMsZ0NBQWdDLFdBQVcsMkNBQTJDLGtDQUFrQyxXQUFXLDZDQUE2QyxxQ0FBcUMsV0FBVyxpREFBaUQsa0JBQWtCLG1CQUFtQixxQkFBcUIsZ0JBQWdCLEtBQUssWUFBWSx3QkFBd0IsWUFBWSxzZUFBc2UsbUNBQW1DLElBQUksaUJBQWlCLDRCQUE0QixzQkFBc0IsT0FBTyxpQkFBaUIsSUFBSSw4REFBOEQsb0JBQW9CLGlCQUFpQixFQUFFLHlCQUF5QixtQkFBbUIsZUFBZSxtQkFBbUIsa0NBQWtDLCtEQUErRCx5RUFBeUUsT0FBTywrQkFBK0IsOERBQThELDRCQUE0QixJQUFJLEtBQUssdUNBQXVDLHlCQUF5QixRQUFRLFFBQVEsV0FBVyxNQUFNLG1DQUFtQyxxRUFBcUUsd0NBQXdDLHdCQUF3Qiw0QkFBNEIsa0NBQWtDLFNBQVMsV0FBVyxLQUFLLFlBQVksY0FBYyxnQkFBZ0IsSUFBSSxnQ0FBZ0Msd0NBQXdDLFVBQVUsbUJBQW1CLFNBQVMsZ0JBQWdCLHFCQUFxQixvRUFBb0UscUJBQXFCLFdBQVcsa0NBQWtDLDBDQUEwQyxJQUFJLGVBQWUsVUFBVSxrQkFBa0IsMkJBQTJCLE1BQU0sMkJBQTJCLGtCQUFrQixxQ0FBcUMsK0RBQStELGVBQWUsRUFBRSxTQUFTLGtCQUFrQixjQUFjLGdDQUFnQyxrREFBa0Qsc0JBQXNCLG1DQUFtQyxnQkFBZ0IsZ0JBQWdCLFdBQVcsb0VBQW9FLGNBQWMsYUFBYSxRQUFRLEtBQUssS0FBSyxXQUFXLCtCQUErQix5QkFBeUIseURBQXlELHdCQUF3Qiw2QkFBNkIsdURBQXVELGtCQUFrQiwwQkFBMEIsb0NBQW9DLDJCQUEyQixtRUFBbUUsZ0JBQWdCLDBCQUEwQixvQ0FBb0MsMkJBQTJCLHFDQUFxQyxzQ0FBc0MseUJBQXlCLElBQUksa0JBQWtCLHVCQUF1QixJQUFJLEVBQUUsY0FBYyxpQkFBaUIsU0FBUyxnQkFBZ0IsZ0JBQWdCLHNCQUFzQixZQUFZLFdBQVcscUJBQXFCLEVBQUUsZ0JBQWdCLHNCQUFzQixPQUFPLEVBQUUsZ0JBQWdCLCtEQUErRCxPQUFPLG1DQUFtQyxRQUFRLG9CQUFvQixTQUFTLEtBQUssb0VBQW9FLHNCQUFzQixPQUFPLElBQUksYUFBYSw2Q0FBNkMsSUFBSSxrQkFBa0IsSUFBSSxLQUFLLG9CQUFvQixrRkFBa0YsU0FBUyxrQkFBa0IsK0JBQStCLGdCQUFnQixnQ0FBZ0MsdUJBQXVCLHlDQUF5QyxJQUFJLEVBQUUsY0FBYyxzQkFBc0IsU0FBUyx5QkFBeUIseUNBQXlDLElBQUksRUFBRSxjQUFjLHNCQUFzQixXQUFXLCtFQUErRSx5QkFBeUIsbUJBQW1CLHlDQUF5QyxTQUFTLEVBQUUsd0JBQXdCLHlCQUF5QixlQUFlLEVBQUUsRUFBRSxrQkFBa0IsbU1BQW1NLFNBQVMsRUFBRSIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGFiMWE3NDkyNmQwNmJjMmYxOTViIiwidmFyIHU7XHJcblxyXG52YXIgZ2xvYmFscyA9IHtcclxuICB3aWR0aDogMCxcclxuICBoZWlnaHQ6IDAsXHJcbiAgc3ZnX2RpbTogdSxcclxuICBpbm5lcl9wYWRkaW5nOiB1LFxyXG4gIGNoYXJ0X2RpbTogdSxcclxuICBwYWRkaW5nOiAwLFxyXG4gIG1haW5fc3ZnOiB1LFxyXG4gIGRlZnM6IHUsXHJcbiAgdXNlcklEOiB1LFxyXG4gIGNoYXJ0X2c6IHUsXHJcblxyXG4gIGNoYXJ0X2luc3RhbmNlOiB1LFxyXG4gIHllYXJfaW5kaWNhdG9yOiB1LFxyXG4gIGFsbF9kYXRhOiB1LCAgXHJcbiAgaGlkZUFkZHJlc3NCYXI6IHUsXHJcbiAgc2h1ZmZsZTogdSxcclxuICBjb25zZW50X2NvbXBsZXRlOiB1LFxyXG4gIGludHJvZHVjdGlvbl9jb21wbGV0ZTogdSxcclxuICBleHBlcmltZW50X2NvbXBsZXRlOiB1LFxyXG4gIHRlc3Rfb3ZlcnJpZGU6IHUsICBcclxuICBsYXN0X3BhdXNlOiB1LFxyXG4gIHJlc3VtcHRpb25zOiB1LFxyXG4gIHRyaWFsX2luZGV4OiB1LFxyXG4gIG1heF90cmlhbHM6IHUsXHJcbiAgb3JkZXJpbmc6IHUsXHJcbiAgcGFydGljaXBhbnQ6IHUsXHJcbiAgdHJpYWxzOiB1LFxyXG4gIHRyaWFsX3Jlc3BvbnNlOiB1LFxyXG4gIGNvbmRpdGlvbjogdSxcclxuICBsaW5lczogdSxcclxuICBmYWNldHM6IHUsXHJcbiAgYW5pbWF0aW9uOiB1LFxyXG4gIG51bV9zZWxlY3RlZDogdSxcclxuICBvdXRlcl9wcm9ncmVzc19jaXJjbGU6IHUsXHJcbiAgaW5uZXJfcHJvZ3Jlc3NfY2lyY2xlOiB1LFxyXG4gIHBhcmFtX3g6ICdMaWZlIEV4cGVjdGFuY3knLFxyXG4gIHBhcmFtX3k6ICdHRFAgUGVyIENhcGl0YScsXHJcbiAgcGFyYW1fcjogJ1BvcHVsYXRpb24nLFxyXG4gIHBhcmFtX3llYXJNaW46IDE5NzUsXHJcbiAgcGFyYW1feWVhck1heDogMjAwMCxcclxuICBsb2dfbWVzc2FnZTogdVxyXG59O1xyXG5cclxudGVzdF9vdmVycmlkZSA9IGZhbHNlO1xyXG5jb25zZW50X2NvbXBsZXRlID0gZmFsc2U7XHJcbmludHJvZHVjdGlvbl9jb21wbGV0ZSA9IGZhbHNlO1xyXG5leHBlcmltZW50X2NvbXBsZXRlID0gZmFsc2U7XHJcbnJlc3VtcHRpb25zID0gW107XHJcbnRyaWFsX2luZGV4ID0gLTE7XHJcbm1heF90cmlhbHMgPSAwO1xyXG5jb25kaXRpb24gPSAnbXVsdGlwbGVzJztcclxub3JkZXJpbmcgPSAwO1xyXG5wYXJ0aWNpcGFudCA9IC0xO1xyXG51c2VySUQgPSAtMTtcclxudHBzID0gMDtcclxudHJpYWxfcmVzcG9uc2UgPSBbXTtcclxubnVtX3NlbGVjdGVkID0gMDtcclxubG9nX21lc3NhZ2UgPSAnJztcclxuXHJcbnNodWZmbGUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICB2YXIgY3VycmVudEluZGV4ID0gYXJyYXkubGVuZ3RoLCB0ZW1wb3JhcnlWYWx1ZSwgcmFuZG9tSW5kZXg7XHJcblxyXG4gIC8vIFdoaWxlIHRoZXJlIHJlbWFpbiBlbGVtZW50cyB0byBzaHVmZmxlLi4uXHJcbiAgd2hpbGUgKDAgIT09IGN1cnJlbnRJbmRleCkge1xyXG5cclxuICAgIC8vIFBpY2sgYSByZW1haW5pbmcgZWxlbWVudC4uLlxyXG4gICAgcmFuZG9tSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjdXJyZW50SW5kZXgpO1xyXG4gICAgY3VycmVudEluZGV4IC09IDE7XHJcblxyXG4gICAgLy8gQW5kIHN3YXAgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50LlxyXG4gICAgdGVtcG9yYXJ5VmFsdWUgPSBhcnJheVtjdXJyZW50SW5kZXhdO1xyXG4gICAgYXJyYXlbY3VycmVudEluZGV4XSA9IGFycmF5W3JhbmRvbUluZGV4XTtcclxuICAgIGFycmF5W3JhbmRvbUluZGV4XSA9IHRlbXBvcmFyeVZhbHVlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFycmF5O1xyXG59O1xyXG5cclxuaGlkZUFkZHJlc3NCYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHJcbiAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgLy8gSGlkZSB0aGUgYWRkcmVzcyBiYXIhXHJcblx0XHR3aW5kb3cuc2Nyb2xsVG8oMCwgMSk7XHJcbiAgfSwgMTApOyAgXHJcbiAgXHJcblxyXG4gIHZhciB0b3VjaHN0YXJ0SGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcclxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoICE9IDEpIHJldHVybjtcclxuICAgIGxhc3RUb3VjaFkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcclxuICB9O1xyXG4gIFxyXG4gIHZhciB0b3VjaG1vdmVIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xyXG4gICAgdmFyIHRvdWNoWSA9IGUudG91Y2hlc1swXS5jbGllbnRZO1xyXG4gICAgdmFyIHRvdWNoWURlbHRhID0gdG91Y2hZIC0gbGFzdFRvdWNoWTtcclxuICAgIGxhc3RUb3VjaFkgPSB0b3VjaFk7XHJcblxyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH07XHJcblxyXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0SGFuZGxlciwge3Bhc3NpdmU6IGZhbHNlIH0pO1xyXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIsIHtwYXNzaXZlOiBmYWxzZSB9KTtcclxuXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbHM7XHJcblxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9nbG9iYWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGh0dHBzOi8vZDNqcy5vcmcgVmVyc2lvbiA0LjkuMS4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmVyc2lvbiA9IFwiNC45LjFcIjtcblxudmFyIGFzY2VuZGluZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufTtcblxudmFyIGJpc2VjdG9yID0gZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGNvbXBhcmUpO1xuICByZXR1cm4ge1xuICAgIGxlZnQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG87XG4gICAgfSxcbiAgICByaWdodDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkO1xuICAgICAgICBlbHNlIGxvID0gbWlkICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsbztcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBhc2NlbmRpbmdDb21wYXJhdG9yKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIHgpIHtcbiAgICByZXR1cm4gYXNjZW5kaW5nKGYoZCksIHgpO1xuICB9O1xufVxuXG52YXIgYXNjZW5kaW5nQmlzZWN0ID0gYmlzZWN0b3IoYXNjZW5kaW5nKTtcbnZhciBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbnZhciBiaXNlY3RMZWZ0ID0gYXNjZW5kaW5nQmlzZWN0LmxlZnQ7XG5cbnZhciBwYWlycyA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gIGlmIChmID09IG51bGwpIGYgPSBwYWlyO1xuICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGggLSAxLCBwID0gYXJyYXlbMF0sIHBhaXJzID0gbmV3IEFycmF5KG4gPCAwID8gMCA6IG4pO1xuICB3aGlsZSAoaSA8IG4pIHBhaXJzW2ldID0gZihwLCBwID0gYXJyYXlbKytpXSk7XG4gIHJldHVybiBwYWlycztcbn07XG5cbmZ1bmN0aW9uIHBhaXIoYSwgYikge1xuICByZXR1cm4gW2EsIGJdO1xufVxuXG52YXIgY3Jvc3MgPSBmdW5jdGlvbih2YWx1ZXMwLCB2YWx1ZXMxLCByZWR1Y2UpIHtcbiAgdmFyIG4wID0gdmFsdWVzMC5sZW5ndGgsXG4gICAgICBuMSA9IHZhbHVlczEubGVuZ3RoLFxuICAgICAgdmFsdWVzID0gbmV3IEFycmF5KG4wICogbjEpLFxuICAgICAgaTAsXG4gICAgICBpMSxcbiAgICAgIGksXG4gICAgICB2YWx1ZTA7XG5cbiAgaWYgKHJlZHVjZSA9PSBudWxsKSByZWR1Y2UgPSBwYWlyO1xuXG4gIGZvciAoaTAgPSBpID0gMDsgaTAgPCBuMDsgKytpMCkge1xuICAgIGZvciAodmFsdWUwID0gdmFsdWVzMFtpMF0sIGkxID0gMDsgaTEgPCBuMTsgKytpMSwgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWR1Y2UodmFsdWUwLCB2YWx1ZXMxW2kxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlcztcbn07XG5cbnZhciBkZXNjZW5kaW5nID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG59O1xuXG52YXIgbnVtYmVyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xufTtcblxudmFyIHZhcmlhbmNlID0gZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG0gPSAwLFxuICAgICAgaSA9IC0xLFxuICAgICAgbWVhbiA9IDAsXG4gICAgICB2YWx1ZSxcbiAgICAgIGRlbHRhLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtID4gMSkgcmV0dXJuIHN1bSAvIChtIC0gMSk7XG59O1xuXG52YXIgZGV2aWF0aW9uID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgdmFyIHYgPSB2YXJpYW5jZShhcnJheSwgZik7XG4gIHJldHVybiB2ID8gTWF0aC5zcXJ0KHYpIDogdjtcbn07XG5cbnZhciBleHRlbnQgPSBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW4sXG4gICAgICBtYXg7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW21pbiwgbWF4XTtcbn07XG5cbnZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG52YXIgbWFwID0gYXJyYXkubWFwO1xuXG52YXIgY29uc3RhbnQgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn07XG5cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgc2VxdWVuY2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSkgfCAwLFxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59O1xuXG52YXIgZTEwID0gTWF0aC5zcXJ0KDUwKTtcbnZhciBlNSA9IE1hdGguc3FydCgxMCk7XG52YXIgZTIgPSBNYXRoLnNxcnQoMik7XG5cbnZhciB0aWNrcyA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgcmV2ZXJzZSA9IHN0b3AgPCBzdGFydCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4sXG4gICAgICB0aWNrcyxcbiAgICAgIHN0ZXA7XG5cbiAgaWYgKHJldmVyc2UpIG4gPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gbjtcblxuICBpZiAoKHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkpID09PSAwIHx8ICFpc0Zpbml0ZShzdGVwKSkgcmV0dXJuIFtdO1xuXG4gIGlmIChzdGVwID4gMCkge1xuICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCk7XG4gICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAvIHN0ZXApO1xuICAgIHRpY2tzID0gbmV3IEFycmF5KG4gPSBNYXRoLmNlaWwoc3RvcCAtIHN0YXJ0ICsgMSkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChzdGFydCArIGkpICogc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgKiBzdGVwKTtcbiAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgKiBzdGVwKTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gTWF0aC5jZWlsKHN0YXJ0IC0gc3RvcCArIDEpKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGlja3NbaV0gPSAoc3RhcnQgLSBpKSAvIHN0ZXA7XG4gIH1cblxuICBpZiAocmV2ZXJzZSkgdGlja3MucmV2ZXJzZSgpO1xuXG4gIHJldHVybiB0aWNrcztcbn07XG5cbmZ1bmN0aW9uIHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBwb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcCkgLyBNYXRoLkxOMTApLFxuICAgICAgZXJyb3IgPSBzdGVwIC8gTWF0aC5wb3coMTAsIHBvd2VyKTtcbiAgcmV0dXJuIHBvd2VyID49IDBcbiAgICAgID8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSkgKiBNYXRoLnBvdygxMCwgcG93ZXIpXG4gICAgICA6IC1NYXRoLnBvdygxMCwgLXBvd2VyKSAvIChlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDEpO1xufVxuXG5mdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAwID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksXG4gICAgICBlcnJvciA9IHN0ZXAwIC8gc3RlcDE7XG4gIGlmIChlcnJvciA+PSBlMTApIHN0ZXAxICo9IDEwO1xuICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcDEgKj0gNTtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTIpIHN0ZXAxICo9IDI7XG4gIHJldHVybiBzdG9wIDwgc3RhcnQgPyAtc3RlcDEgOiBzdGVwMTtcbn1cblxudmFyIHN0dXJnZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIE1hdGguY2VpbChNYXRoLmxvZyh2YWx1ZXMubGVuZ3RoKSAvIE1hdGguTE4yKSArIDE7XG59O1xuXG52YXIgaGlzdG9ncmFtID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IGlkZW50aXR5LFxuICAgICAgZG9tYWluID0gZXh0ZW50LFxuICAgICAgdGhyZXNob2xkID0gc3R1cmdlcztcblxuICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIHgsXG4gICAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHZhbHVlKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIH1cblxuICAgIHZhciB4eiA9IGRvbWFpbih2YWx1ZXMpLFxuICAgICAgICB4MCA9IHh6WzBdLFxuICAgICAgICB4MSA9IHh6WzFdLFxuICAgICAgICB0eiA9IHRocmVzaG9sZCh2YWx1ZXMsIHgwLCB4MSk7XG5cbiAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eikpIHtcbiAgICAgIHR6ID0gdGlja1N0ZXAoeDAsIHgxLCB0eik7XG4gICAgICB0eiA9IHNlcXVlbmNlKE1hdGguY2VpbCh4MCAvIHR6KSAqIHR6LCBNYXRoLmZsb29yKHgxIC8gdHopICogdHosIHR6KTsgLy8gZXhjbHVzaXZlXG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSB0aHJlc2hvbGRzIG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICB2YXIgbSA9IHR6Lmxlbmd0aDtcbiAgICB3aGlsZSAodHpbMF0gPD0geDApIHR6LnNoaWZ0KCksIC0tbTtcbiAgICB3aGlsZSAodHpbbSAtIDFdID4geDEpIHR6LnBvcCgpLCAtLW07XG5cbiAgICB2YXIgYmlucyA9IG5ldyBBcnJheShtICsgMSksXG4gICAgICAgIGJpbjtcblxuICAgIC8vIEluaXRpYWxpemUgYmlucy5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG07ICsraSkge1xuICAgICAgYmluID0gYmluc1tpXSA9IFtdO1xuICAgICAgYmluLngwID0gaSA+IDAgPyB0eltpIC0gMV0gOiB4MDtcbiAgICAgIGJpbi54MSA9IGkgPCBtID8gdHpbaV0gOiB4MTtcbiAgICB9XG5cbiAgICAvLyBBc3NpZ24gZGF0YSB0byBiaW5zIGJ5IHZhbHVlLCBpZ25vcmluZyBhbnkgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICBpZiAoeDAgPD0geCAmJiB4IDw9IHgxKSB7XG4gICAgICAgIGJpbnNbYmlzZWN0UmlnaHQodHosIHgsIDAsIG0pXS5wdXNoKGRhdGFbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiaW5zO1xuICB9XG5cbiAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgaGlzdG9ncmFtKSA6IHZhbHVlO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICB9O1xuXG4gIGhpc3RvZ3JhbS50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIGhpc3RvZ3JhbTtcbn07XG5cbnZhciB0aHJlc2hvbGQgPSBmdW5jdGlvbih2YWx1ZXMsIHAsIHZhbHVlb2YpIHtcbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkgdmFsdWVvZiA9IG51bWJlcjtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIGlmICgocCA9ICtwKSA8PSAwIHx8IG4gPCAyKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzWzBdLCAwLCB2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzW24gLSAxXSwgbiAtIDEsIHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gK3ZhbHVlb2YodmFsdWVzW2kwXSwgaTAsIHZhbHVlcyksXG4gICAgICB2YWx1ZTEgPSArdmFsdWVvZih2YWx1ZXNbaTAgKyAxXSwgaTAgKyAxLCB2YWx1ZXMpO1xuICByZXR1cm4gdmFsdWUwICsgKHZhbHVlMSAtIHZhbHVlMCkgKiAoaSAtIGkwKTtcbn07XG5cbnZhciBmcmVlZG1hbkRpYWNvbmlzID0gZnVuY3Rpb24odmFsdWVzLCBtaW4sIG1heCkge1xuICB2YWx1ZXMgPSBtYXAuY2FsbCh2YWx1ZXMsIG51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDIgKiAodGhyZXNob2xkKHZhbHVlcywgMC43NSkgLSB0aHJlc2hvbGQodmFsdWVzLCAwLjI1KSkgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG59O1xuXG52YXIgc2NvdHQgPSBmdW5jdGlvbih2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMy41ICogZGV2aWF0aW9uKHZhbHVlcykgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG59O1xuXG52YXIgbWF4ID0gZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWF4O1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heDtcbn07XG5cbnZhciBtZWFuID0gZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG0gPSBuLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBzdW0gPSAwO1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkgc3VtICs9IHZhbHVlO1xuICAgICAgZWxzZSAtLW07XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSkgc3VtICs9IHZhbHVlO1xuICAgICAgZWxzZSAtLW07XG4gICAgfVxuICB9XG5cbiAgaWYgKG0pIHJldHVybiBzdW0gLyBtO1xufTtcblxudmFyIG1lZGlhbiA9IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG51bWJlcnMgPSBbXTtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHtcbiAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRocmVzaG9sZChudW1iZXJzLnNvcnQoYXNjZW5kaW5nKSwgMC41KTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uKGFycmF5cykge1xuICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsXG4gICAgICBtLFxuICAgICAgaSA9IC0xLFxuICAgICAgaiA9IDAsXG4gICAgICBtZXJnZWQsXG4gICAgICBhcnJheTtcblxuICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICBtZXJnZWQgPSBuZXcgQXJyYXkoaik7XG5cbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgYXJyYXkgPSBhcnJheXNbbl07XG4gICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlZDtcbn07XG5cbnZhciBtaW4gPSBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW47XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIG1pbiA+IHZhbHVlKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufTtcblxudmFyIHBlcm11dGUgPSBmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICB2YXIgaSA9IGluZGV4ZXMubGVuZ3RoLCBwZXJtdXRlcyA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcbiAgcmV0dXJuIHBlcm11dGVzO1xufTtcblxudmFyIHNjYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGNvbXBhcmUpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIHZhciBuLFxuICAgICAgaSA9IDAsXG4gICAgICBqID0gMCxcbiAgICAgIHhpLFxuICAgICAgeGogPSB2YWx1ZXNbal07XG5cbiAgaWYgKGNvbXBhcmUgPT0gbnVsbCkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGlmIChjb21wYXJlKHhpID0gdmFsdWVzW2ldLCB4aikgPCAwIHx8IGNvbXBhcmUoeGosIHhqKSAhPT0gMCkge1xuICAgICAgeGogPSB4aSwgaiA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXBhcmUoeGosIHhqKSA9PT0gMCkgcmV0dXJuIGo7XG59O1xuXG52YXIgc2h1ZmZsZSA9IGZ1bmN0aW9uKGFycmF5LCBpMCwgaTEpIHtcbiAgdmFyIG0gPSAoaTEgPT0gbnVsbCA/IGFycmF5Lmxlbmd0aCA6IGkxKSAtIChpMCA9IGkwID09IG51bGwgPyAwIDogK2kwKSxcbiAgICAgIHQsXG4gICAgICBpO1xuXG4gIHdoaWxlIChtKSB7XG4gICAgaSA9IE1hdGgucmFuZG9tKCkgKiBtLS0gfCAwO1xuICAgIHQgPSBhcnJheVttICsgaTBdO1xuICAgIGFycmF5W20gKyBpMF0gPSBhcnJheVtpICsgaTBdO1xuICAgIGFycmF5W2kgKyBpMF0gPSB0O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIHN1bSA9IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVzW2ldKSBzdW0gKz0gdmFsdWU7IC8vIE5vdGU6IHplcm8gYW5kIG51bGwgYXJlIGVxdWl2YWxlbnQuXG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgc3VtICs9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdW07XG59O1xuXG52YXIgdHJhbnNwb3NlID0gZnVuY3Rpb24obWF0cml4KSB7XG4gIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICBmb3IgKHZhciBpID0gLTEsIG0gPSBtaW4obWF0cml4LCBsZW5ndGgpLCB0cmFuc3Bvc2UgPSBuZXcgQXJyYXkobSk7ICsraSA8IG07KSB7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47KSB7XG4gICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuc3Bvc2U7XG59O1xuXG5mdW5jdGlvbiBsZW5ndGgoZCkge1xuICByZXR1cm4gZC5sZW5ndGg7XG59XG5cbnZhciB6aXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRyYW5zcG9zZShhcmd1bWVudHMpO1xufTtcblxudmFyIHNsaWNlJDEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbnZhciBpZGVudGl0eSQxID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDtcbn07XG5cbnZhciB0b3AgPSAxO1xudmFyIHJpZ2h0ID0gMjtcbnZhciBib3R0b20gPSAzO1xudmFyIGxlZnQgPSA0O1xudmFyIGVwc2lsb24gPSAxZS02O1xuXG5mdW5jdGlvbiB0cmFuc2xhdGVYKHgpIHtcbiAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKHggKyAwLjUpICsgXCIsMClcIjtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlWSh5KSB7XG4gIHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgKHkgKyAwLjUpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIGNlbnRlcihzY2FsZSkge1xuICB2YXIgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgc2NhbGUuYmFuZHdpZHRoKCkgLSAxKSAvIDI7IC8vIEFkanVzdCBmb3IgMC41cHggb2Zmc2V0LlxuICBpZiAoc2NhbGUucm91bmQoKSkgb2Zmc2V0ID0gTWF0aC5yb3VuZChvZmZzZXQpO1xuICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBzY2FsZShkKSArIG9mZnNldDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW50ZXJpbmcoKSB7XG4gIHJldHVybiAhdGhpcy5fX2F4aXM7XG59XG5cbmZ1bmN0aW9uIGF4aXMob3JpZW50LCBzY2FsZSkge1xuICB2YXIgdGlja0FyZ3VtZW50cyA9IFtdLFxuICAgICAgdGlja1ZhbHVlcyA9IG51bGwsXG4gICAgICB0aWNrRm9ybWF0ID0gbnVsbCxcbiAgICAgIHRpY2tTaXplSW5uZXIgPSA2LFxuICAgICAgdGlja1NpemVPdXRlciA9IDYsXG4gICAgICB0aWNrUGFkZGluZyA9IDMsXG4gICAgICBrID0gb3JpZW50ID09PSB0b3AgfHwgb3JpZW50ID09PSBsZWZ0ID8gLTEgOiAxLFxuICAgICAgeCA9IG9yaWVudCA9PT0gbGVmdCB8fCBvcmllbnQgPT09IHJpZ2h0ID8gXCJ4XCIgOiBcInlcIixcbiAgICAgIHRyYW5zZm9ybSA9IG9yaWVudCA9PT0gdG9wIHx8IG9yaWVudCA9PT0gYm90dG9tID8gdHJhbnNsYXRlWCA6IHRyYW5zbGF0ZVk7XG5cbiAgZnVuY3Rpb24gYXhpcyhjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRpY2tWYWx1ZXMgPT0gbnVsbCA/IChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKSA6IHRpY2tWYWx1ZXMsXG4gICAgICAgIGZvcm1hdCA9IHRpY2tGb3JtYXQgPT0gbnVsbCA/IChzY2FsZS50aWNrRm9ybWF0ID8gc2NhbGUudGlja0Zvcm1hdC5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBpZGVudGl0eSQxKSA6IHRpY2tGb3JtYXQsXG4gICAgICAgIHNwYWNpbmcgPSBNYXRoLm1heCh0aWNrU2l6ZUlubmVyLCAwKSArIHRpY2tQYWRkaW5nLFxuICAgICAgICByYW5nZSA9IHNjYWxlLnJhbmdlKCksXG4gICAgICAgIHJhbmdlMCA9IHJhbmdlWzBdICsgMC41LFxuICAgICAgICByYW5nZTEgPSByYW5nZVtyYW5nZS5sZW5ndGggLSAxXSArIDAuNSxcbiAgICAgICAgcG9zaXRpb24gPSAoc2NhbGUuYmFuZHdpZHRoID8gY2VudGVyIDogaWRlbnRpdHkkMSkoc2NhbGUuY29weSgpKSxcbiAgICAgICAgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dCxcbiAgICAgICAgcGF0aCA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoW251bGxdKSxcbiAgICAgICAgdGljayA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIudGlja1wiKS5kYXRhKHZhbHVlcywgc2NhbGUpLm9yZGVyKCksXG4gICAgICAgIHRpY2tFeGl0ID0gdGljay5leGl0KCksXG4gICAgICAgIHRpY2tFbnRlciA9IHRpY2suZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIiksXG4gICAgICAgIGxpbmUgPSB0aWNrLnNlbGVjdChcImxpbmVcIiksXG4gICAgICAgIHRleHQgPSB0aWNrLnNlbGVjdChcInRleHRcIik7XG5cbiAgICBwYXRoID0gcGF0aC5tZXJnZShwYXRoLmVudGVyKCkuaW5zZXJ0KFwicGF0aFwiLCBcIi50aWNrXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCIjMDAwXCIpKTtcblxuICAgIHRpY2sgPSB0aWNrLm1lcmdlKHRpY2tFbnRlcik7XG5cbiAgICBsaW5lID0gbGluZS5tZXJnZSh0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiMwMDBcIilcbiAgICAgICAgLmF0dHIoeCArIFwiMlwiLCBrICogdGlja1NpemVJbm5lcikpO1xuXG4gICAgdGV4dCA9IHRleHQubWVyZ2UodGlja0VudGVyLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzAwMFwiKVxuICAgICAgICAuYXR0cih4LCBrICogc3BhY2luZylcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBvcmllbnQgPT09IHRvcCA/IFwiMGVtXCIgOiBvcmllbnQgPT09IGJvdHRvbSA/IFwiMC43MWVtXCIgOiBcIjAuMzJlbVwiKSk7XG5cbiAgICBpZiAoY29udGV4dCAhPT0gc2VsZWN0aW9uKSB7XG4gICAgICBwYXRoID0gcGF0aC50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgdGljayA9IHRpY2sudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIGxpbmUgPSBsaW5lLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICB0ZXh0ID0gdGV4dC50cmFuc2l0aW9uKGNvbnRleHQpO1xuXG4gICAgICB0aWNrRXhpdCA9IHRpY2tFeGl0LnRyYW5zaXRpb24oY29udGV4dClcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZXBzaWxvbilcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBpc0Zpbml0ZShkID0gcG9zaXRpb24oZCkpID8gdHJhbnNmb3JtKGQpIDogdGhpcy5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7IH0pO1xuXG4gICAgICB0aWNrRW50ZXJcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZXBzaWxvbilcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHZhciBwID0gdGhpcy5wYXJlbnROb2RlLl9fYXhpczsgcmV0dXJuIHRyYW5zZm9ybShwICYmIGlzRmluaXRlKHAgPSBwKGQpKSA/IHAgOiBwb3NpdGlvbihkKSk7IH0pO1xuICAgIH1cblxuICAgIHRpY2tFeGl0LnJlbW92ZSgpO1xuXG4gICAgcGF0aFxuICAgICAgICAuYXR0cihcImRcIiwgb3JpZW50ID09PSBsZWZ0IHx8IG9yaWVudCA9PSByaWdodFxuICAgICAgICAgICAgPyBcIk1cIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCIsXCIgKyByYW5nZTAgKyBcIkgwLjVWXCIgKyByYW5nZTEgKyBcIkhcIiArIGsgKiB0aWNrU2l6ZU91dGVyXG4gICAgICAgICAgICA6IFwiTVwiICsgcmFuZ2UwICsgXCIsXCIgKyBrICogdGlja1NpemVPdXRlciArIFwiVjAuNUhcIiArIHJhbmdlMSArIFwiVlwiICsgayAqIHRpY2tTaXplT3V0ZXIpO1xuXG4gICAgdGlja1xuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gdHJhbnNmb3JtKHBvc2l0aW9uKGQpKTsgfSk7XG5cbiAgICBsaW5lXG4gICAgICAgIC5hdHRyKHggKyBcIjJcIiwgayAqIHRpY2tTaXplSW5uZXIpO1xuXG4gICAgdGV4dFxuICAgICAgICAuYXR0cih4LCBrICogc3BhY2luZylcbiAgICAgICAgLnRleHQoZm9ybWF0KTtcblxuICAgIHNlbGVjdGlvbi5maWx0ZXIoZW50ZXJpbmcpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgLmF0dHIoXCJmb250LXNpemVcIiwgMTApXG4gICAgICAgIC5hdHRyKFwiZm9udC1mYW1pbHlcIiwgXCJzYW5zLXNlcmlmXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgb3JpZW50ID09PSByaWdodCA/IFwic3RhcnRcIiA6IG9yaWVudCA9PT0gbGVmdCA/IFwiZW5kXCIgOiBcIm1pZGRsZVwiKTtcblxuICAgIHNlbGVjdGlvblxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHsgdGhpcy5fX2F4aXMgPSBwb3NpdGlvbjsgfSk7XG4gIH1cblxuICBheGlzLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlID0gXywgYXhpcykgOiBzY2FsZTtcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRpY2tBcmd1bWVudHMgPSBzbGljZSQxLmNhbGwoYXJndW1lbnRzKSwgYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tBcmd1bWVudHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja0FyZ3VtZW50cyA9IF8gPT0gbnVsbCA/IFtdIDogc2xpY2UkMS5jYWxsKF8pLCBheGlzKSA6IHRpY2tBcmd1bWVudHMuc2xpY2UoKTtcbiAgfTtcblxuICBheGlzLnRpY2tWYWx1ZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlja1ZhbHVlcyA9IF8gPT0gbnVsbCA/IG51bGwgOiBzbGljZSQxLmNhbGwoXyksIGF4aXMpIDogdGlja1ZhbHVlcyAmJiB0aWNrVmFsdWVzLnNsaWNlKCk7XG4gIH07XG5cbiAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tGb3JtYXQgPSBfLCBheGlzKSA6IHRpY2tGb3JtYXQ7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZUlubmVyID0gdGlja1NpemVPdXRlciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZUlubmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplSW5uZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZUlubmVyO1xuICB9O1xuXG4gIGF4aXMudGlja1NpemVPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZU91dGVyID0gK18sIGF4aXMpIDogdGlja1NpemVPdXRlcjtcbiAgfTtcblxuICBheGlzLnRpY2tQYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tQYWRkaW5nID0gK18sIGF4aXMpIDogdGlja1BhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIGF4aXNUb3Aoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXModG9wLCBzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGF4aXNSaWdodChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhyaWdodCwgc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBheGlzQm90dG9tKHNjYWxlKSB7XG4gIHJldHVybiBheGlzKGJvdHRvbSwgc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBheGlzTGVmdChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhsZWZ0LCBzY2FsZSk7XG59XG5cbnZhciBub29wID0ge3ZhbHVlOiBmdW5jdGlvbigpIHt9fTtcblxuZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEodCA9IGFyZ3VtZW50c1tpXSArIFwiXCIpIHx8ICh0IGluIF8pKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbnZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG52YXIgbmFtZXNwYWNlcyA9IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiB4aHRtbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG5cbnZhciBuYW1lc3BhY2UgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lO1xufTtcblxuZnVuY3Rpb24gY3JlYXRvckluaGVyaXQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gdGhpcy5vd25lckRvY3VtZW50LFxuICAgICAgICB1cmkgPSB0aGlzLm5hbWVzcGFjZVVSSTtcbiAgICByZXR1cm4gdXJpID09PSB4aHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSB4aHRtbFxuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSlcbiAgICAgICAgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModXJpLCBuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRvckZpeGVkKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICB9O1xufVxuXG52YXIgY3JlYXRvciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gKGZ1bGxuYW1lLmxvY2FsXG4gICAgICA/IGNyZWF0b3JGaXhlZFxuICAgICAgOiBjcmVhdG9ySW5oZXJpdCkoZnVsbG5hbWUpO1xufTtcblxudmFyIG5leHRJZCA9IDA7XG5cbmZ1bmN0aW9uIGxvY2FsJDEoKSB7XG4gIHJldHVybiBuZXcgTG9jYWw7XG59XG5cbmZ1bmN0aW9uIExvY2FsKCkge1xuICB0aGlzLl8gPSBcIkBcIiArICgrK25leHRJZCkudG9TdHJpbmcoMzYpO1xufVxuXG5Mb2NhbC5wcm90b3R5cGUgPSBsb2NhbCQxLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExvY2FsLFxuICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl87XG4gICAgd2hpbGUgKCEoaWQgaW4gbm9kZSkpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIG5vZGVbaWRdO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG5cbnZhciBtYXRjaGVyID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoc2VsZWN0b3IpO1xuICB9O1xufTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgaWYgKCFlbGVtZW50Lm1hdGNoZXMpIHtcbiAgICB2YXIgdmVuZG9yTWF0Y2hlcyA9IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgfHwgZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgICAgICAgfHwgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yO1xuICAgIG1hdGNoZXIgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmVuZG9yTWF0Y2hlcy5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuXG52YXIgbWF0Y2hlciQxID0gbWF0Y2hlcjtcblxudmFyIGZpbHRlckV2ZW50cyA9IHt9O1xuXG5leHBvcnRzLmV2ZW50ID0gbnVsbDtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2YXIgZWxlbWVudCQxID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAoIShcIm9ubW91c2VlbnRlclwiIGluIGVsZW1lbnQkMSkpIHtcbiAgICBmaWx0ZXJFdmVudHMgPSB7bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIiwgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwifTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJDb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICBsaXN0ZW5lciA9IGNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICghcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGhpcyAmJiAhKHJlbGF0ZWQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGhpcykgJiA4KSkpIHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50MSkge1xuICAgIHZhciBldmVudDAgPSBleHBvcnRzLmV2ZW50OyAvLyBFdmVudHMgY2FuIGJlIHJlZW50cmFudCAoZS5nLiwgZm9jdXMpLlxuICAgIGV4cG9ydHMuZXZlbnQgPSBldmVudDE7XG4gICAgdHJ5IHtcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgdGhpcy5fX2RhdGFfXywgaW5kZXgsIGdyb3VwKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzJDEodHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgd3JhcCA9IGZpbHRlckV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlbmFtZS50eXBlKSA/IGZpbHRlckNvbnRleHRMaXN0ZW5lciA6IGNvbnRleHRMaXN0ZW5lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGdyb3VwKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IHdyYXAodmFsdWUsIGksIGdyb3VwKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLmNhcHR1cmUgPSBjYXB0dXJlKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZX07XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxudmFyIHNlbGVjdGlvbl9vbiA9IGZ1bmN0aW9uKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXMkMSh0eXBlbmFtZSArIFwiXCIpLCBpLCBuID0gdHlwZW5hbWVzLmxlbmd0aCwgdDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgb24gPSB0aGlzLm5vZGUoKS5fX29uO1xuICAgIGlmIChvbikgZm9yICh2YXIgaiA9IDAsIG0gPSBvbi5sZW5ndGgsIG87IGogPCBtOyArK2opIHtcbiAgICAgIGZvciAoaSA9IDAsIG8gPSBvbltqXTsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoKHQgPSB0eXBlbmFtZXNbaV0pLnR5cGUgPT09IG8udHlwZSAmJiB0Lm5hbWUgPT09IG8ubmFtZSkge1xuICAgICAgICAgIHJldHVybiBvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uID0gdmFsdWUgPyBvbkFkZCA6IG9uUmVtb3ZlO1xuICBpZiAoY2FwdHVyZSA9PSBudWxsKSBjYXB0dXJlID0gZmFsc2U7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHRoaXMuZWFjaChvbih0eXBlbmFtZXNbaV0sIHZhbHVlLCBjYXB0dXJlKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICB2YXIgZXZlbnQwID0gZXhwb3J0cy5ldmVudDtcbiAgZXZlbnQxLnNvdXJjZUV2ZW50ID0gZXhwb3J0cy5ldmVudDtcbiAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MDtcbiAgfVxufVxuXG52YXIgc291cmNlRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGN1cnJlbnQgPSBleHBvcnRzLmV2ZW50LCBzb3VyY2U7XG4gIHdoaWxlIChzb3VyY2UgPSBjdXJyZW50LnNvdXJjZUV2ZW50KSBjdXJyZW50ID0gc291cmNlO1xuICByZXR1cm4gY3VycmVudDtcbn07XG5cbnZhciBwb2ludCA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50KSB7XG4gIHZhciBzdmcgPSBub2RlLm93bmVyU1ZHRWxlbWVudCB8fCBub2RlO1xuXG4gIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICB2YXIgcG9pbnQgPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICBwb2ludC54ID0gZXZlbnQuY2xpZW50WCwgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gICAgcG9pbnQgPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0obm9kZS5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgIHJldHVybiBbcG9pbnQueCwgcG9pbnQueV07XG4gIH1cblxuICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIG5vZGUuY2xpZW50TGVmdCwgZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wIC0gbm9kZS5jbGllbnRUb3BdO1xufTtcblxudmFyIG1vdXNlID0gZnVuY3Rpb24obm9kZSkge1xuICB2YXIgZXZlbnQgPSBzb3VyY2VFdmVudCgpO1xuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIGV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gIHJldHVybiBwb2ludChub2RlLCBldmVudCk7XG59O1xuXG5mdW5jdGlvbiBub25lKCkge31cblxudmFyIHNlbGVjdG9yID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBub25lIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG59O1xuXG52YXIgc2VsZWN0aW9uX3NlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvcihzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIHN1Ym5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3QuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCkpKSB7XG4gICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIHN1Ymdyb3VwW2ldID0gc3Vibm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufTtcblxuZnVuY3Rpb24gZW1wdHkkMSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG52YXIgc2VsZWN0b3JBbGwgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IGVtcHR5JDEgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbnZhciBzZWxlY3Rpb25fc2VsZWN0QWxsID0gZnVuY3Rpb24oc2VsZWN0KSB7XG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IHNlbGVjdG9yQWxsKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gW10sIHBhcmVudHMgPSBbXSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKTtcbiAgICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgcGFyZW50cyk7XG59O1xuXG52YXIgc2VsZWN0aW9uX2ZpbHRlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyJDEobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59O1xuXG52YXIgc3BhcnNlID0gZnVuY3Rpb24odXBkYXRlKSB7XG4gIHJldHVybiBuZXcgQXJyYXkodXBkYXRlLmxlbmd0aCk7XG59O1xuXG52YXIgc2VsZWN0aW9uX2VudGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59O1xuXG5mdW5jdGlvbiBFbnRlck5vZGUocGFyZW50LCBkYXR1bSkge1xuICB0aGlzLm93bmVyRG9jdW1lbnQgPSBwYXJlbnQub3duZXJEb2N1bWVudDtcbiAgdGhpcy5uYW1lc3BhY2VVUkkgPSBwYXJlbnQubmFtZXNwYWNlVVJJO1xuICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9fZGF0YV9fID0gZGF0dW07XG59XG5cbkVudGVyTm9kZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFbnRlck5vZGUsXG4gIGFwcGVuZENoaWxkOiBmdW5jdGlvbihjaGlsZCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgdGhpcy5fbmV4dCk7IH0sXG4gIGluc2VydEJlZm9yZTogZnVuY3Rpb24oY2hpbGQsIG5leHQpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHQpOyB9LFxuICBxdWVyeVNlbGVjdG9yOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpOyB9LFxuICBxdWVyeVNlbGVjdG9yQWxsOiBmdW5jdGlvbihzZWxlY3RvcikgeyByZXR1cm4gdGhpcy5fcGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpOyB9XG59O1xuXG52YXIgY29uc3RhbnQkMSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxudmFyIGtleVByZWZpeCA9IFwiJFwiOyAvLyBQcm90ZWN0IGFnYWluc3Qga2V5cyBsaWtlIOKAnF9fcHJvdG9fX+KAnS5cblxuZnVuY3Rpb24gYmluZEluZGV4KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgbm9kZSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBmaXQgaW50byB1cGRhdGUuXG4gIC8vIFB1dCBhbnkgbnVsbCBub2RlcyBpbnRvIGVudGVyLlxuICAvLyBQdXQgYW55IHJlbWFpbmluZyBkYXRhIGludG8gZW50ZXIuXG4gIGZvciAoOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBQdXQgYW55IG5vbi1udWxsIG5vZGVzIHRoYXQgZG9u4oCZdCBmaXQgaW50byBleGl0LlxuICBmb3IgKDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluZEtleShwYXJlbnQsIGdyb3VwLCBlbnRlciwgdXBkYXRlLCBleGl0LCBkYXRhLCBrZXkpIHtcbiAgdmFyIGksXG4gICAgICBub2RlLFxuICAgICAgbm9kZUJ5S2V5VmFsdWUgPSB7fSxcbiAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAga2V5VmFsdWVzID0gbmV3IEFycmF5KGdyb3VwTGVuZ3RoKSxcbiAgICAgIGtleVZhbHVlO1xuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBub2RlLlxuICAvLyBJZiBtdWx0aXBsZSBub2RlcyBoYXZlIHRoZSBzYW1lIGtleSwgdGhlIGR1cGxpY2F0ZXMgYXJlIGFkZGVkIHRvIGV4aXQuXG4gIGZvciAoaSA9IDA7IGkgPCBncm91cExlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgICBpZiAoa2V5VmFsdWUgaW4gbm9kZUJ5S2V5VmFsdWUpIHtcbiAgICAgICAgZXhpdFtpXSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGtleSBmb3IgZWFjaCBkYXR1bS5cbiAgLy8gSWYgdGhlcmUgYSBub2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGtleSwgam9pbiBhbmQgYWRkIGl0IHRvIHVwZGF0ZS5cbiAgLy8gSWYgdGhlcmUgaXMgbm90IChvciB0aGUga2V5IGlzIGEgZHVwbGljYXRlKSwgYWRkIGl0IHRvIGVudGVyLlxuICBmb3IgKGkgPSAwOyBpIDwgZGF0YUxlbmd0aDsgKytpKSB7XG4gICAga2V5VmFsdWUgPSBrZXlQcmVmaXggKyBrZXkuY2FsbChwYXJlbnQsIGRhdGFbaV0sIGksIGRhdGEpO1xuICAgIGlmIChub2RlID0gbm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVdKSB7XG4gICAgICB1cGRhdGVbaV0gPSBub2RlO1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGRhdGFbaV07XG4gICAgICBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltpXSA9IG5ldyBFbnRlck5vZGUocGFyZW50LCBkYXRhW2ldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgYW55IHJlbWFpbmluZyBub2RlcyB0aGF0IHdlcmUgbm90IGJvdW5kIHRvIGRhdGEgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKG5vZGVCeUtleVZhbHVlW2tleVZhbHVlc1tpXV0gPT09IG5vZGUpKSB7XG4gICAgICBleGl0W2ldID0gbm9kZTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNlbGVjdGlvbl9kYXRhID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgZGF0YSA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSksIGogPSAtMTtcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oZCkgeyBkYXRhWysral0gPSBkOyB9KTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBiaW5kID0ga2V5ID8gYmluZEtleSA6IGJpbmRJbmRleCxcbiAgICAgIHBhcmVudHMgPSB0aGlzLl9wYXJlbnRzLFxuICAgICAgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBjb25zdGFudCQxKHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gdmFsdWUuY2FsbChwYXJlbnQsIHBhcmVudCAmJiBwYXJlbnQuX19kYXRhX18sIGosIHBhcmVudHMpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMCwgcHJldmlvdXMsIG5leHQ7IGkwIDwgZGF0YUxlbmd0aDsgKytpMCkge1xuICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IHVwZGF0ZUdyb3VwW2kxXSkgJiYgKytpMSA8IGRhdGFMZW5ndGgpO1xuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gIHVwZGF0ZS5fZW50ZXIgPSBlbnRlcjtcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgcmV0dXJuIHVwZGF0ZTtcbn07XG5cbnZhciBzZWxlY3Rpb25fZXhpdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLl9leGl0IHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59O1xuXG52YXIgc2VsZWN0aW9uX21lcmdlID0gZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHNlbGVjdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihtZXJnZXMsIHRoaXMuX3BhcmVudHMpO1xufTtcblxudmFyIHNlbGVjdGlvbl9vcmRlciA9IGZ1bmN0aW9uKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IG5vZGUubmV4dFNpYmxpbmcpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIHNlbGVjdGlvbl9zb3J0ID0gZnVuY3Rpb24oY29tcGFyZSkge1xuICBpZiAoIWNvbXBhcmUpIGNvbXBhcmUgPSBhc2NlbmRpbmckMTtcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn07XG5cbmZ1bmN0aW9uIGFzY2VuZGluZyQxKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuXG52YXIgc2VsZWN0aW9uX2NhbGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBzZWxlY3Rpb25fbm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaSA9IC0xO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7IG5vZGVzWysraV0gPSB0aGlzOyB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufTtcblxudmFyIHNlbGVjdGlvbl9ub2RlID0gZnVuY3Rpb24oKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgc2VsZWN0aW9uX3NpemUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7ICsrc2l6ZTsgfSk7XG4gIHJldHVybiBzaXplO1xufTtcblxudmFyIHNlbGVjdGlvbl9lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMubm9kZSgpO1xufTtcblxudmFyIHNlbGVjdGlvbl9lYWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBncm91cCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG52YXIgc2VsZWN0aW9uX2F0dHIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn07XG5cbnZhciBkZWZhdWx0VmlldyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLm93bmVyRG9jdW1lbnQgJiYgbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSAvLyBub2RlIGlzIGEgTm9kZVxuICAgICAgfHwgKG5vZGUuZG9jdW1lbnQgJiYgbm9kZSkgLy8gbm9kZSBpcyBhIFdpbmRvd1xuICAgICAgfHwgbm9kZS5kZWZhdWx0VmlldzsgLy8gbm9kZSBpcyBhIERvY3VtZW50XG59O1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNvbnN0YW50KG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHYsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxudmFyIHNlbGVjdGlvbl9zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgICA/IHN0eWxlUmVtb3ZlIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gc3R5bGVGdW5jdGlvblxuICAgICAgICAgICAgOiBzdHlsZUNvbnN0YW50KShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkgPT0gbnVsbCA/IFwiXCIgOiBwcmlvcml0eSkpXG4gICAgICA6IHN0eWxlVmFsdWUodGhpcy5ub2RlKCksIG5hbWUpO1xufTtcblxuZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSlcbiAgICAgIHx8IGRlZmF1bHRWaWV3KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gIH07XG59XG5cbnZhciBzZWxlY3Rpb25fcHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufTtcblxuZnVuY3Rpb24gY2xhc3NBcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy50cmltKCkuc3BsaXQoL158XFxzKy8pO1xufVxuXG5mdW5jdGlvbiBjbGFzc0xpc3Qobm9kZSkge1xuICByZXR1cm4gbm9kZS5jbGFzc0xpc3QgfHwgbmV3IENsYXNzTGlzdChub2RlKTtcbn1cblxuZnVuY3Rpb24gQ2xhc3NMaXN0KG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gIHRoaXMuX25hbWVzID0gY2xhc3NBcnJheShub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIpO1xufVxuXG5DbGFzc0xpc3QucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fbmFtZXMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCB0aGlzLl9uYW1lcy5qb2luKFwiIFwiKSk7XG4gICAgfVxuICB9LFxuICBjb250YWluczogZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpID49IDA7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNsYXNzZWRBZGQobm9kZSwgbmFtZXMpIHtcbiAgdmFyIGxpc3QgPSBjbGFzc0xpc3Qobm9kZSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGxpc3QuYWRkKG5hbWVzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZFJlbW92ZShub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5yZW1vdmUobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkVHJ1ZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZEFkZCh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGYWxzZShuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xhc3NlZFJlbW92ZSh0aGlzLCBuYW1lcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbihuYW1lcywgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICh2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpID8gY2xhc3NlZEFkZCA6IGNsYXNzZWRSZW1vdmUpKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxudmFyIHNlbGVjdGlvbl9jbGFzc2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG5hbWVzID0gY2xhc3NBcnJheShuYW1lICsgXCJcIik7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIGxpc3QgPSBjbGFzc0xpc3QodGhpcy5ub2RlKCkpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghbGlzdC5jb250YWlucyhuYW1lc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGNsYXNzZWRGdW5jdGlvbiA6IHZhbHVlXG4gICAgICA/IGNsYXNzZWRUcnVlXG4gICAgICA6IGNsYXNzZWRGYWxzZSkobmFtZXMsIHZhbHVlKSk7XG59O1xuXG5mdW5jdGlvbiB0ZXh0UmVtb3ZlKCkge1xuICB0aGlzLnRleHRDb250ZW50ID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gdGV4dENvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgfTtcbn1cblxudmFyIHNlbGVjdGlvbl90ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHZhbHVlID09IG51bGxcbiAgICAgICAgICA/IHRleHRSZW1vdmUgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHRleHRGdW5jdGlvblxuICAgICAgICAgIDogdGV4dENvbnN0YW50KSh2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpLnRleHRDb250ZW50O1xufTtcblxuZnVuY3Rpb24gaHRtbFJlbW92ZSgpIHtcbiAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBodG1sQ29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh0bWxGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbnZhciBzZWxlY3Rpb25faHRtbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBodG1sRnVuY3Rpb25cbiAgICAgICAgICA6IGh0bWxDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG59O1xuXG5mdW5jdGlvbiByYWlzZSgpIHtcbiAgaWYgKHRoaXMubmV4dFNpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbn1cblxudmFyIHNlbGVjdGlvbl9yYWlzZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJhaXNlKTtcbn07XG5cbmZ1bmN0aW9uIGxvd2VyKCkge1xuICBpZiAodGhpcy5wcmV2aW91c1NpYmxpbmcpIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcywgdGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpO1xufVxuXG52YXIgc2VsZWN0aW9uX2xvd2VyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gobG93ZXIpO1xufTtcblxudmFyIHNlbGVjdGlvbl9hcHBlbmQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gY29uc3RhbnROdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIHNlbGVjdGlvbl9pbnNlcnQgPSBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgdmFyIGNyZWF0ZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogY3JlYXRvcihuYW1lKSxcbiAgICAgIHNlbGVjdCA9IGJlZm9yZSA9PSBudWxsID8gY29uc3RhbnROdWxsIDogdHlwZW9mIGJlZm9yZSA9PT0gXCJmdW5jdGlvblwiID8gYmVmb3JlIDogc2VsZWN0b3IoYmVmb3JlKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluc2VydEJlZm9yZShjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gcmVtb3ZlKCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59XG5cbnZhciBzZWxlY3Rpb25fcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmVtb3ZlKTtcbn07XG5cbnZhciBzZWxlY3Rpb25fZGF0dW0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufTtcblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChub2RlLCB0eXBlLCBwYXJhbXMpIHtcbiAgdmFyIHdpbmRvdyA9IGRlZmF1bHRWaWV3KG5vZGUpLFxuICAgICAgZXZlbnQgPSB3aW5kb3cuQ3VzdG9tRXZlbnQ7XG5cbiAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXZlbnQgPSBuZXcgZXZlbnQodHlwZSwgcGFyYW1zKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICAgIGlmIChwYXJhbXMpIGV2ZW50LmluaXRFdmVudCh0eXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUpLCBldmVudC5kZXRhaWwgPSBwYXJhbXMuZGV0YWlsO1xuICAgIGVsc2UgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gIH1cblxuICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaENvbnN0YW50KHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hGdW5jdGlvbih0eXBlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkaXNwYXRjaEV2ZW50KHRoaXMsIHR5cGUsIHBhcmFtcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cblxudmFyIHNlbGVjdGlvbl9kaXNwYXRjaCA9IGZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gdGhpcy5lYWNoKCh0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gZGlzcGF0Y2hGdW5jdGlvblxuICAgICAgOiBkaXNwYXRjaENvbnN0YW50KSh0eXBlLCBwYXJhbXMpKTtcbn07XG5cbnZhciByb290ID0gW251bGxdO1xuXG5mdW5jdGlvbiBTZWxlY3Rpb24oZ3JvdXBzLCBwYXJlbnRzKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRdXSwgcm9vdCk7XG59XG5cblNlbGVjdGlvbi5wcm90b3R5cGUgPSBzZWxlY3Rpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2VsZWN0aW9uLFxuICBzZWxlY3Q6IHNlbGVjdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogc2VsZWN0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiBzZWxlY3Rpb25fZmlsdGVyLFxuICBkYXRhOiBzZWxlY3Rpb25fZGF0YSxcbiAgZW50ZXI6IHNlbGVjdGlvbl9lbnRlcixcbiAgZXhpdDogc2VsZWN0aW9uX2V4aXQsXG4gIG1lcmdlOiBzZWxlY3Rpb25fbWVyZ2UsXG4gIG9yZGVyOiBzZWxlY3Rpb25fb3JkZXIsXG4gIHNvcnQ6IHNlbGVjdGlvbl9zb3J0LFxuICBjYWxsOiBzZWxlY3Rpb25fY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX25vZGUsXG4gIHNpemU6IHNlbGVjdGlvbl9zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX2VtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fZWFjaCxcbiAgYXR0cjogc2VsZWN0aW9uX2F0dHIsXG4gIHN0eWxlOiBzZWxlY3Rpb25fc3R5bGUsXG4gIHByb3BlcnR5OiBzZWxlY3Rpb25fcHJvcGVydHksXG4gIGNsYXNzZWQ6IHNlbGVjdGlvbl9jbGFzc2VkLFxuICB0ZXh0OiBzZWxlY3Rpb25fdGV4dCxcbiAgaHRtbDogc2VsZWN0aW9uX2h0bWwsXG4gIHJhaXNlOiBzZWxlY3Rpb25fcmFpc2UsXG4gIGxvd2VyOiBzZWxlY3Rpb25fbG93ZXIsXG4gIGFwcGVuZDogc2VsZWN0aW9uX2FwcGVuZCxcbiAgaW5zZXJ0OiBzZWxlY3Rpb25faW5zZXJ0LFxuICByZW1vdmU6IHNlbGVjdGlvbl9yZW1vdmUsXG4gIGRhdHVtOiBzZWxlY3Rpb25fZGF0dW0sXG4gIG9uOiBzZWxlY3Rpb25fb24sXG4gIGRpc3BhdGNoOiBzZWxlY3Rpb25fZGlzcGF0Y2hcbn07XG5cbnZhciBzZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW1tkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKV1dLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbW3NlbGVjdG9yXV0sIHJvb3QpO1xufTtcblxudmFyIHNlbGVjdEFsbCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCJcbiAgICAgID8gbmV3IFNlbGVjdGlvbihbZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcildLCBbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSlcbiAgICAgIDogbmV3IFNlbGVjdGlvbihbc2VsZWN0b3IgPT0gbnVsbCA/IFtdIDogc2VsZWN0b3JdLCByb290KTtcbn07XG5cbnZhciB0b3VjaCA9IGZ1bmN0aW9uKG5vZGUsIHRvdWNoZXMsIGlkZW50aWZpZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkuY2hhbmdlZFRvdWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCB0b3VjaDsgaSA8IG47ICsraSkge1xuICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gcG9pbnQobm9kZSwgdG91Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIHRvdWNoZXMgPSBmdW5jdGlvbihub2RlLCB0b3VjaGVzKSB7XG4gIGlmICh0b3VjaGVzID09IG51bGwpIHRvdWNoZXMgPSBzb3VyY2VFdmVudCgpLnRvdWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCBwb2ludHMgPSBuZXcgQXJyYXkobik7IGkgPCBuOyArK2kpIHtcbiAgICBwb2ludHNbaV0gPSBwb2ludChub2RlLCB0b3VjaGVzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5mdW5jdGlvbiBub3Byb3BhZ2F0aW9uKCkge1xuICBleHBvcnRzLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG52YXIgbm9ldmVudCA9IGZ1bmN0aW9uKCkge1xuICBleHBvcnRzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV4cG9ydHMuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59O1xuXG52YXIgZHJhZ0Rpc2FibGUgPSBmdW5jdGlvbih2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24kJDEgPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24kJDEub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgfVxufTtcblxuZnVuY3Rpb24geWVzZHJhZyh2aWV3LCBub2NsaWNrKSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24kJDEgPSBzZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgaWYgKG5vY2xpY2spIHtcbiAgICBzZWxlY3Rpb24kJDEub24oXCJjbGljay5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGVjdGlvbiQkMS5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCk7IH0sIDApO1xuICB9XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uJCQxLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSByb290Ll9fbm9zZWxlY3Q7XG4gICAgZGVsZXRlIHJvb3QuX19ub3NlbGVjdDtcbiAgfVxufVxuXG52YXIgY29uc3RhbnQkMiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxuZnVuY3Rpb24gRHJhZ0V2ZW50KHRhcmdldCwgdHlwZSwgc3ViamVjdCwgaWQsIGFjdGl2ZSwgeCwgeSwgZHgsIGR5LCBkaXNwYXRjaCkge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgdGhpcy5pZGVudGlmaWVyID0gaWQ7XG4gIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLmR4ID0gZHg7XG4gIHRoaXMuZHkgPSBkeTtcbiAgdGhpcy5fID0gZGlzcGF0Y2g7XG59XG5cbkRyYWdFdmVudC5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy5fLm9uLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHZhbHVlID09PSB0aGlzLl8gPyB0aGlzIDogdmFsdWU7XG59O1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIkMSgpIHtcbiAgcmV0dXJuICFleHBvcnRzLmV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRhaW5lcigpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFN1YmplY3QoZCkge1xuICByZXR1cm4gZCA9PSBudWxsID8ge3g6IGV4cG9ydHMuZXZlbnQueCwgeTogZXhwb3J0cy5ldmVudC55fSA6IGQ7XG59XG5cbnZhciBkcmFnID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyJDEsXG4gICAgICBjb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyLFxuICAgICAgc3ViamVjdCA9IGRlZmF1bHRTdWJqZWN0LFxuICAgICAgZ2VzdHVyZXMgPSB7fSxcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKFwic3RhcnRcIiwgXCJkcmFnXCIsIFwiZW5kXCIpLFxuICAgICAgYWN0aXZlID0gMCxcbiAgICAgIG1vdXNlZG93bngsXG4gICAgICBtb3VzZWRvd255LFxuICAgICAgbW91c2Vtb3ZpbmcsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiBkcmFnKHNlbGVjdGlvbiQkMSkge1xuICAgIHNlbGVjdGlvbiQkMVxuICAgICAgICAub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBtb3VzZWRvd25lZClcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC5kcmFnXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLmRyYWdcIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuZHJhZyB0b3VjaGNhbmNlbC5kcmFnXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZCgpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGdlc3R1cmUgPSBiZWZvcmVzdGFydChcIm1vdXNlXCIsIGNvbnRhaW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBtb3VzZSwgdGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIWdlc3R1cmUpIHJldHVybjtcbiAgICBzZWxlY3QoZXhwb3J0cy5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC5kcmFnXCIsIG1vdXNldXBwZWQsIHRydWUpO1xuICAgIGRyYWdEaXNhYmxlKGV4cG9ydHMuZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIG1vdXNlbW92aW5nID0gZmFsc2U7XG4gICAgbW91c2Vkb3dueCA9IGV4cG9ydHMuZXZlbnQuY2xpZW50WDtcbiAgICBtb3VzZWRvd255ID0gZXhwb3J0cy5ldmVudC5jbGllbnRZO1xuICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlbW92ZWQoKSB7XG4gICAgbm9ldmVudCgpO1xuICAgIGlmICghbW91c2Vtb3ZpbmcpIHtcbiAgICAgIHZhciBkeCA9IGV4cG9ydHMuZXZlbnQuY2xpZW50WCAtIG1vdXNlZG93bngsIGR5ID0gZXhwb3J0cy5ldmVudC5jbGllbnRZIC0gbW91c2Vkb3dueTtcbiAgICAgIG1vdXNlbW92aW5nID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICB9XG4gICAgZ2VzdHVyZXMubW91c2UoXCJkcmFnXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICBzZWxlY3QoZXhwb3J0cy5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnIG1vdXNldXAuZHJhZ1wiLCBudWxsKTtcbiAgICB5ZXNkcmFnKGV4cG9ydHMuZXZlbnQudmlldywgbW91c2Vtb3ZpbmcpO1xuICAgIG5vZXZlbnQoKTtcbiAgICBnZXN0dXJlcy5tb3VzZShcImVuZFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZCgpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHRvdWNoZXMkJDEgPSBleHBvcnRzLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBjID0gY29udGFpbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIG4gPSB0b3VjaGVzJCQxLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gYmVmb3Jlc3RhcnQodG91Y2hlcyQkMVtpXS5pZGVudGlmaWVyLCBjLCB0b3VjaCwgdGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIHZhciB0b3VjaGVzJCQxID0gZXhwb3J0cy5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMkJDEubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzJCQxW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vZXZlbnQoKTtcbiAgICAgICAgZ2VzdHVyZShcImRyYWdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZCgpIHtcbiAgICB2YXIgdG91Y2hlcyQkMSA9IGV4cG9ydHMuZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzJCQxLmxlbmd0aCwgaSwgZ2VzdHVyZTtcblxuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgNTAwKTsgLy8gR2hvc3QgY2xpY2tzIGFyZSBkZWxheWVkIVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChnZXN0dXJlID0gZ2VzdHVyZXNbdG91Y2hlcyQkMVtpXS5pZGVudGlmaWVyXSkge1xuICAgICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICAgIGdlc3R1cmUoXCJlbmRcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVmb3Jlc3RhcnQoaWQsIGNvbnRhaW5lciwgcG9pbnQsIHRoYXQsIGFyZ3MpIHtcbiAgICB2YXIgcCA9IHBvaW50KGNvbnRhaW5lciwgaWQpLCBzLCBkeCwgZHksXG4gICAgICAgIHN1Ymxpc3RlbmVycyA9IGxpc3RlbmVycy5jb3B5KCk7XG5cbiAgICBpZiAoIWN1c3RvbUV2ZW50KG5ldyBEcmFnRXZlbnQoZHJhZywgXCJiZWZvcmVzdGFydFwiLCBzLCBpZCwgYWN0aXZlLCBwWzBdLCBwWzFdLCAwLCAwLCBzdWJsaXN0ZW5lcnMpLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgoZXhwb3J0cy5ldmVudC5zdWJqZWN0ID0gcyA9IHN1YmplY3QuYXBwbHkodGhhdCwgYXJncykpID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIGR4ID0gcy54IC0gcFswXSB8fCAwO1xuICAgICAgZHkgPSBzLnkgLSBwWzFdIHx8IDA7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KSkgcmV0dXJuO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdlc3R1cmUodHlwZSkge1xuICAgICAgdmFyIHAwID0gcCwgbjtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RhcnRcIjogZ2VzdHVyZXNbaWRdID0gZ2VzdHVyZSwgbiA9IGFjdGl2ZSsrOyBicmVhaztcbiAgICAgICAgY2FzZSBcImVuZFwiOiBkZWxldGUgZ2VzdHVyZXNbaWRdLCAtLWFjdGl2ZTsgLy8gbm9icmVha1xuICAgICAgICBjYXNlIFwiZHJhZ1wiOiBwID0gcG9pbnQoY29udGFpbmVyLCBpZCksIG4gPSBhY3RpdmU7IGJyZWFrO1xuICAgICAgfVxuICAgICAgY3VzdG9tRXZlbnQobmV3IERyYWdFdmVudChkcmFnLCB0eXBlLCBzLCBpZCwgbiwgcFswXSArIGR4LCBwWzFdICsgZHksIHBbMF0gLSBwMFswXSwgcFsxXSAtIHAwWzFdLCBzdWJsaXN0ZW5lcnMpLCBzdWJsaXN0ZW5lcnMuYXBwbHksIHN1Ymxpc3RlbmVycywgW3R5cGUsIHRoYXQsIGFyZ3NdKTtcbiAgICB9O1xuICB9XG5cbiAgZHJhZy5maWx0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZmlsdGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQyKCEhXyksIGRyYWcpIDogZmlsdGVyO1xuICB9O1xuXG4gIGRyYWcuY29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRhaW5lciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMihfKSwgZHJhZykgOiBjb250YWluZXI7XG4gIH07XG5cbiAgZHJhZy5zdWJqZWN0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN1YmplY3QgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDIoXyksIGRyYWcpIDogc3ViamVjdDtcbiAgfTtcblxuICBkcmFnLm9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gbGlzdGVuZXJzLm9uLmFwcGx5KGxpc3RlbmVycywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdmFsdWUgPT09IGxpc3RlbmVycyA/IGRyYWcgOiB2YWx1ZTtcbiAgfTtcblxuICBkcmFnLmNsaWNrRGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xpY2tEaXN0YW5jZTIgPSAoXyA9ICtfKSAqIF8sIGRyYWcpIDogTWF0aC5zcXJ0KGNsaWNrRGlzdGFuY2UyKTtcbiAgfTtcblxuICByZXR1cm4gZHJhZztcbn07XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn07XG5cbmZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cblxuZnVuY3Rpb24gQ29sb3IoKSB7fVxuXG52YXIgZGFya2VyID0gMC43O1xudmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiO1xudmFyIHJlTiA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCI7XG52YXIgcmVQID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCI7XG52YXIgcmVIZXgzID0gL14jKFswLTlhLWZdezN9KSQvO1xudmFyIHJlSGV4NiA9IC9eIyhbMC05YS1mXXs2fSkkLztcbnZhciByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVJLCByZUksIHJlSV0gKyBcIlxcXFwpJFwiKTtcbnZhciByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKTtcbnZhciByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZUksIHJlSSwgcmVJLCByZU5dICsgXCJcXFxcKSRcIik7XG52YXIgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpO1xudmFyIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpO1xudmFyIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiICsgW3JlTiwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKSArIFwiXCI7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG07XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXgzLmV4ZWMoZm9ybWF0KSkgPyAobSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweDBmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkpIC8vICNmMDBcbiAgICAgIDogKG0gPSByZUhleDYuZXhlYyhmb3JtYXQpKSA/IHJnYm4ocGFyc2VJbnQobVsxXSwgMTYpKSAvLyAjZmYwMDAwXG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKVxuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5mdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgUmdiO1xuICBvID0gby5yZ2IoKTtcbiAgcmV0dXJuIG5ldyBSZ2Ioby5yLCBvLmcsIG8uYiwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMuciAmJiB0aGlzLnIgPD0gMjU1KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmcgJiYgdGhpcy5nIDw9IDI1NSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5iICYmIHRoaXMuYiA8PSAyNTUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IHRoaXMub3BhY2l0eTsgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcbiAgICByZXR1cm4gKGEgPT09IDEgPyBcInJnYihcIiA6IFwicmdiYShcIilcbiAgICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5yKSB8fCAwKSkgKyBcIiwgXCJcbiAgICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5nKSB8fCAwKSkgKyBcIiwgXCJcbiAgICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5iKSB8fCAwKSlcbiAgICAgICAgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiBoc2xhKGgsIHMsIGwsIGEpIHtcbiAgaWYgKGEgPD0gMCkgaCA9IHMgPSBsID0gTmFOO1xuICBlbHNlIGlmIChsIDw9IDAgfHwgbCA+PSAxKSBoID0gcyA9IE5hTjtcbiAgZWxzZSBpZiAocyA8PSAwKSBoID0gTmFOO1xuICByZXR1cm4gbmV3IEhzbChoLCBzLCBsLCBhKTtcbn1cblxuZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gaHNsQ29udmVydChoKSA6IG5ldyBIc2woaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBIc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEhzbCwgaHNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gdGhpcy5oICUgMzYwICsgKHRoaXMuaCA8IDApICogMzYwLFxuICAgICAgICBzID0gaXNOYU4oaCkgfHwgaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMsXG4gICAgICAgIGwgPSB0aGlzLmwsXG4gICAgICAgIG0yID0gbCArIChsIDwgMC41ID8gbCA6IDEgLSBsKSAqIHMsXG4gICAgICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGhzbDJyZ2IoaCA+PSAyNDAgPyBoIC0gMjQwIDogaCArIDEyMCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCwgbTEsIG0yKSxcbiAgICAgIGhzbDJyZ2IoaCA8IDEyMCA/IGggKyAyNDAgOiBoIC0gMTIwLCBtMSwgbTIpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfSxcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoMCA8PSB0aGlzLnMgJiYgdGhpcy5zIDw9IDEgfHwgaXNOYU4odGhpcy5zKSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5sICYmIHRoaXMubCA8PSAxKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLm9wYWNpdHkgJiYgdGhpcy5vcGFjaXR5IDw9IDEpO1xuICB9XG59KSk7XG5cbi8qIEZyb20gRnZEIDEzLjM3LCBDU1MgQ29sb3IgTW9kdWxlIExldmVsIDMgKi9cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgbTEsIG0yKSB7XG4gIHJldHVybiAoaCA8IDYwID8gbTEgKyAobTIgLSBtMSkgKiBoIC8gNjBcbiAgICAgIDogaCA8IDE4MCA/IG0yXG4gICAgICA6IGggPCAyNDAgPyBtMSArIChtMiAtIG0xKSAqICgyNDAgLSBoKSAvIDYwXG4gICAgICA6IG0xKSAqIDI1NTtcbn1cblxudmFyIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwO1xudmFyIHJhZDJkZWcgPSAxODAgLyBNYXRoLlBJO1xuXG52YXIgS24gPSAxODtcbnZhciBYbiA9IDAuOTUwNDcwO1xudmFyIFluID0gMTtcbnZhciBabiA9IDEuMDg4ODMwO1xudmFyIHQwID0gNCAvIDI5O1xudmFyIHQxID0gNiAvIDI5O1xudmFyIHQyID0gMyAqIHQxICogdDE7XG52YXIgdDMgPSB0MSAqIHQxICogdDE7XG5cbmZ1bmN0aW9uIGxhYkNvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIExhYikgcmV0dXJuIG5ldyBMYWIoby5sLCBvLmEsIG8uYiwgby5vcGFjaXR5KTtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHtcbiAgICB2YXIgaCA9IG8uaCAqIGRlZzJyYWQ7XG4gICAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XG4gIH1cbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgYiA9IHJnYjJ4eXooby5yKSxcbiAgICAgIGEgPSByZ2IyeHl6KG8uZyksXG4gICAgICBsID0gcmdiMnh5eihvLmIpLFxuICAgICAgeCA9IHh5ejJsYWIoKDAuNDEyNDU2NCAqIGIgKyAwLjM1NzU3NjEgKiBhICsgMC4xODA0Mzc1ICogbCkgLyBYbiksXG4gICAgICB5ID0geHl6MmxhYigoMC4yMTI2NzI5ICogYiArIDAuNzE1MTUyMiAqIGEgKyAwLjA3MjE3NTAgKiBsKSAvIFluKSxcbiAgICAgIHogPSB4eXoybGFiKCgwLjAxOTMzMzkgKiBiICsgMC4xMTkxOTIwICogYSArIDAuOTUwMzA0MSAqIGwpIC8gWm4pO1xuICByZXR1cm4gbmV3IExhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geiksIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGxhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gbGFiQ29udmVydChsKSA6IG5ldyBMYWIobCwgYSwgYiwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBMYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5hID0gK2E7XG4gIHRoaXMuYiA9ICtiO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKExhYiwgbGFiLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgKyBLbiAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLbiAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIHh5ejJyZ2IoIDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeiksIC8vIEQ2NSAtPiBzUkdCXG4gICAgICB4eXoycmdiKC0wLjk2OTI2NjAgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2MCAqIHopLFxuICAgICAgeHl6MnJnYiggMC4wNTU2NDM0ICogeCAtIDAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKiB6KSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuXG5mdW5jdGlvbiB4eXoycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJ4eXooeCkge1xuICByZXR1cm4gKHggLz0gMjU1KSA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gaGNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSByZXR1cm4gbmV3IEhjbChvLmgsIG8uYywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgTGFiKSkgbyA9IGxhYkNvbnZlcnQobyk7XG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiByYWQyZGVnO1xuICByZXR1cm4gbmV3IEhjbChoIDwgMCA/IGggKyAzNjAgOiBoLCBNYXRoLnNxcnQoby5hICogby5hICsgby5iICogby5iKSwgby5sLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBoY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQoaCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMuYyA9ICtjO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShIY2wsIGhjbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCArIEtuICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEtuICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbGFiQ29udmVydCh0aGlzKS5yZ2IoKTtcbiAgfVxufSkpO1xuXG52YXIgQSA9IC0wLjE0ODYxO1xudmFyIEIgPSArMS43ODI3NztcbnZhciBDID0gLTAuMjkyMjc7XG52YXIgRCA9IC0wLjkwNjQ5O1xudmFyIEUgPSArMS45NzI5NDtcbnZhciBFRCA9IEUgKiBEO1xudmFyIEVCID0gRSAqIEI7XG52YXIgQkNfREEgPSBCICogQyAtIEQgKiBBO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXhDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBDdWJlaGVsaXgpIHJldHVybiBuZXcgQ3ViZWhlbGl4KG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIGwgPSAoQkNfREEgKiBiICsgRUQgKiByIC0gRUIgKiBnKSAvIChCQ19EQSArIEVEIC0gRUIpLFxuICAgICAgYmwgPSBiIC0gbCxcbiAgICAgIGsgPSAoRSAqIChnIC0gbCkgLSBDICogYmwpIC8gRCxcbiAgICAgIHMgPSBNYXRoLnNxcnQoayAqIGsgKyBibCAqIGJsKSAvIChFICogbCAqICgxIC0gbCkpLCAvLyBOYU4gaWYgbD0wIG9yIGw9MVxuICAgICAgaCA9IHMgPyBNYXRoLmF0YW4yKGssIGJsKSAqIHJhZDJkZWcgLSAxMjAgOiBOYU47XG4gIHJldHVybiBuZXcgQ3ViZWhlbGl4KGggPCAwID8gaCArIDM2MCA6IGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY3ViZWhlbGl4Q29udmVydChoKSA6IG5ldyBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSkge1xuICB0aGlzLmggPSAraDtcbiAgdGhpcy5zID0gK3M7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLm9wYWNpdHkgPSArb3BhY2l0eTtcbn1cblxuZGVmaW5lKEN1YmVoZWxpeCwgY3ViZWhlbGl4LCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gYnJpZ2h0ZXIgOiBNYXRoLnBvdyhicmlnaHRlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBkYXJrZXIgOiBNYXRoLnBvdyhkYXJrZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoID0gaXNOYU4odGhpcy5oKSA/IDAgOiAodGhpcy5oICsgMTIwKSAqIGRlZzJyYWQsXG4gICAgICAgIGwgPSArdGhpcy5sLFxuICAgICAgICBhID0gaXNOYU4odGhpcy5zKSA/IDAgOiB0aGlzLnMgKiBsICogKDEgLSBsKSxcbiAgICAgICAgY29zaCA9IE1hdGguY29zKGgpLFxuICAgICAgICBzaW5oID0gTWF0aC5zaW4oaCk7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICAyNTUgKiAobCArIGEgKiAoQSAqIGNvc2ggKyBCICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEMgKiBjb3NoICsgRCAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChFICogY29zaCkpLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiBiYXNpcyh0MSwgdjAsIHYxLCB2MiwgdjMpIHtcbiAgdmFyIHQyID0gdDEgKiB0MSwgdDMgPSB0MiAqIHQxO1xuICByZXR1cm4gKCgxIC0gMyAqIHQxICsgMyAqIHQyIC0gdDMpICogdjBcbiAgICAgICsgKDQgLSA2ICogdDIgKyAzICogdDMpICogdjFcbiAgICAgICsgKDEgKyAzICogdDEgKyAzICogdDIgLSAzICogdDMpICogdjJcbiAgICAgICsgdDMgKiB2MykgLyA2O1xufVxuXG52YXIgYmFzaXMkMSA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdCA8PSAwID8gKHQgPSAwKSA6IHQgPj0gMSA/ICh0ID0gMSwgbiAtIDEpIDogTWF0aC5mbG9vcih0ICogbiksXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxuICAgICAgICB2MiA9IHZhbHVlc1tpICsgMV0sXG4gICAgICAgIHYwID0gaSA+IDAgPyB2YWx1ZXNbaSAtIDFdIDogMiAqIHYxIC0gdjIsXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn07XG5cbnZhciBiYXNpc0Nsb3NlZCA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKCgodCAlPSAxKSA8IDAgPyArK3QgOiB0KSAqIG4pLFxuICAgICAgICB2MCA9IHZhbHVlc1soaSArIG4gLSAxKSAlIG5dLFxuICAgICAgICB2MSA9IHZhbHVlc1tpICUgbl0sXG4gICAgICAgIHYyID0gdmFsdWVzWyhpICsgMSkgJSBuXSxcbiAgICAgICAgdjMgPSB2YWx1ZXNbKGkgKyAyKSAlIG5dO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn07XG5cbnZhciBjb25zdGFudCQzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQkMyhpc05hTihhKSA/IGIgOiBhKTtcbn1cblxuZnVuY3Rpb24gZ2FtbWEoeSkge1xuICByZXR1cm4gKHkgPSAreSkgPT09IDEgPyBub2dhbW1hIDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQkMyhpc05hTihhKSA/IGIgOiBhKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9nYW1tYShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQpIDogY29uc3RhbnQkMyhpc05hTihhKSA/IGIgOiBhKTtcbn1cblxudmFyIGludGVycG9sYXRlUmdiID0gKChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciQkMSA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYiQkMShzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvciQkMSgoc3RhcnQgPSByZ2Ioc3RhcnQpKS5yLCAoZW5kID0gcmdiKGVuZCkpLnIpLFxuICAgICAgICBnID0gY29sb3IkJDEoc3RhcnQuZywgZW5kLmcpLFxuICAgICAgICBiID0gY29sb3IkJDEoc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LnIgPSByKHQpO1xuICAgICAgc3RhcnQuZyA9IGcodCk7XG4gICAgICBzdGFydC5iID0gYih0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG5cbiAgcmdiJCQxLmdhbW1hID0gcmdiR2FtbWE7XG5cbiAgcmV0dXJuIHJnYiQkMTtcbn0pKSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvciQkMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciQkMSA9IHJnYihjb2xvcnNbaV0pO1xuICAgICAgcltpXSA9IGNvbG9yJCQxLnIgfHwgMDtcbiAgICAgIGdbaV0gPSBjb2xvciQkMS5nIHx8IDA7XG4gICAgICBiW2ldID0gY29sb3IkJDEuYiB8fCAwO1xuICAgIH1cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvciQkMS5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29sb3IkJDEuciA9IHIodCk7XG4gICAgICBjb2xvciQkMS5nID0gZyh0KTtcbiAgICAgIGNvbG9yJCQxLmIgPSBiKHQpO1xuICAgICAgcmV0dXJuIGNvbG9yJCQxICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMkMSk7XG52YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xuXG52YXIgYXJyYXkkMSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMCxcbiAgICAgIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgeCA9IG5ldyBBcnJheShuYiksXG4gICAgICBjID0gbmV3IEFycmF5KG5iKSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHhbaV0gPSBpbnRlcnBvbGF0ZVZhbHVlKGFbaV0sIGJbaV0pO1xuICBmb3IgKDsgaSA8IG5iOyArK2kpIGNbaV0gPSBiW2ldO1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufTtcblxudmFyIGRhdGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBkID0gbmV3IERhdGU7XG4gIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBkLnNldFRpbWUoYSArIGIgKiB0KSwgZDtcbiAgfTtcbn07XG5cbnZhciByZWludGVycG9sYXRlID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiIC09IGEsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSArIGIgKiB0O1xuICB9O1xufTtcblxudmFyIG9iamVjdCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSB7fSxcbiAgICAgIGMgPSB7fSxcbiAgICAgIGs7XG5cbiAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09IFwib2JqZWN0XCIpIGEgPSB7fTtcbiAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpIGIgPSB7fTtcblxuICBmb3IgKGsgaW4gYikge1xuICAgIGlmIChrIGluIGEpIHtcbiAgICAgIGlba10gPSBpbnRlcnBvbGF0ZVZhbHVlKGFba10sIGJba10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjW2tdID0gYltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn07XG5cbnZhciByZUEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2c7XG52YXIgcmVCID0gbmV3IFJlZ0V4cChyZUEuc291cmNlLCBcImdcIik7XG5cbmZ1bmN0aW9uIHplcm8oYikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uZShiKSB7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGIodCkgKyBcIlwiO1xuICB9O1xufVxuXG52YXIgaW50ZXJwb2xhdGVTdHJpbmcgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBiaSA9IHJlQS5sYXN0SW5kZXggPSByZUIubGFzdEluZGV4ID0gMCwgLy8gc2NhbiBpbmRleCBmb3IgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYW0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYVxuICAgICAgYm0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYlxuICAgICAgYnMsIC8vIHN0cmluZyBwcmVjZWRpbmcgY3VycmVudCBudW1iZXIgaW4gYiwgaWYgYW55XG4gICAgICBpID0gLTEsIC8vIGluZGV4IGluIHNcbiAgICAgIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG5cbiAgLy8gQ29lcmNlIGlucHV0cyB0byBzdHJpbmdzLlxuICBhID0gYSArIFwiXCIsIGIgPSBiICsgXCJcIjtcblxuICAvLyBJbnRlcnBvbGF0ZSBwYWlycyBvZiBudW1iZXJzIGluIGEgJiBiLlxuICB3aGlsZSAoKGFtID0gcmVBLmV4ZWMoYSkpXG4gICAgICAmJiAoYm0gPSByZUIuZXhlYyhiKSkpIHtcbiAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHsgLy8gYSBzdHJpbmcgcHJlY2VkZXMgdGhlIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGJzID0gYi5zbGljZShiaSwgYnMpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJzO1xuICAgIH1cbiAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHsgLy8gbnVtYmVycyBpbiBhICYgYiBtYXRjaFxuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJtO1xuICAgIH0gZWxzZSB7IC8vIGludGVycG9sYXRlIG5vbi1tYXRjaGluZyBudW1iZXJzXG4gICAgICBzWysraV0gPSBudWxsO1xuICAgICAgcS5wdXNoKHtpOiBpLCB4OiByZWludGVycG9sYXRlKGFtLCBibSl9KTtcbiAgICB9XG4gICAgYmkgPSByZUIubGFzdEluZGV4O1xuICB9XG5cbiAgLy8gQWRkIHJlbWFpbnMgb2YgYi5cbiAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICBicyA9IGIuc2xpY2UoYmkpO1xuICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyAvLyBjb2FsZXNjZSB3aXRoIHByZXZpb3VzIHN0cmluZ1xuICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gIH1cblxuICAvLyBTcGVjaWFsIG9wdGltaXphdGlvbiBmb3Igb25seSBhIHNpbmdsZSBtYXRjaC5cbiAgLy8gT3RoZXJ3aXNlLCBpbnRlcnBvbGF0ZSBlYWNoIG9mIHRoZSBudW1iZXJzIGFuZCByZWpvaW4gdGhlIHN0cmluZy5cbiAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IChxWzBdXG4gICAgICA/IG9uZShxWzBdLngpXG4gICAgICA6IHplcm8oYikpXG4gICAgICA6IChiID0gcS5sZW5ndGgsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgICAgIH0pO1xufTtcblxudmFyIGludGVycG9sYXRlVmFsdWUgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudCQzKGIpXG4gICAgICA6ICh0ID09PSBcIm51bWJlclwiID8gcmVpbnRlcnBvbGF0ZVxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gY29sb3IoYikpID8gKGIgPSBjLCBpbnRlcnBvbGF0ZVJnYikgOiBpbnRlcnBvbGF0ZVN0cmluZylcbiAgICAgIDogYiBpbnN0YW5jZW9mIGNvbG9yID8gaW50ZXJwb2xhdGVSZ2JcbiAgICAgIDogYiBpbnN0YW5jZW9mIERhdGUgPyBkYXRlXG4gICAgICA6IEFycmF5LmlzQXJyYXkoYikgPyBhcnJheSQxXG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IHJlaW50ZXJwb2xhdGUpKGEsIGIpO1xufTtcblxudmFyIGludGVycG9sYXRlUm91bmQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKyBiICogdCk7XG4gIH07XG59O1xuXG52YXIgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG5cbnZhciBpZGVudGl0eSQyID0ge1xuICB0cmFuc2xhdGVYOiAwLFxuICB0cmFuc2xhdGVZOiAwLFxuICByb3RhdGU6IDAsXG4gIHNrZXdYOiAwLFxuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcblxudmFyIGRlY29tcG9zZSA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufTtcblxudmFyIGNzc05vZGU7XG52YXIgY3NzUm9vdDtcbnZhciBjc3NWaWV3O1xudmFyIHN2Z05vZGU7XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJub25lXCIpIHJldHVybiBpZGVudGl0eSQyO1xuICBpZiAoIWNzc05vZGUpIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpLCBjc3NSb290ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBjc3NWaWV3ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNzc05vZGUuc3R5bGUudHJhbnNmb3JtID0gdmFsdWU7XG4gIHZhbHVlID0gY3NzVmlldy5nZXRDb21wdXRlZFN0eWxlKGNzc1Jvb3QuYXBwZW5kQ2hpbGQoY3NzTm9kZSksIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJ0cmFuc2Zvcm1cIik7XG4gIGNzc1Jvb3QucmVtb3ZlQ2hpbGQoY3NzTm9kZSk7XG4gIHZhbHVlID0gdmFsdWUuc2xpY2UoNywgLTEpLnNwbGl0KFwiLFwiKTtcbiAgcmV0dXJuIGRlY29tcG9zZSgrdmFsdWVbMF0sICt2YWx1ZVsxXSwgK3ZhbHVlWzJdLCArdmFsdWVbM10sICt2YWx1ZVs0XSwgK3ZhbHVlWzVdKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eSQyO1xuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gIHN2Z05vZGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHZhbHVlKTtcbiAgaWYgKCEodmFsdWUgPSBzdmdOb2RlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpKSByZXR1cm4gaWRlbnRpdHkkMjtcbiAgdmFsdWUgPSB2YWx1ZS5tYXRyaXg7XG4gIHJldHVybiBkZWNvbXBvc2UodmFsdWUuYSwgdmFsdWUuYiwgdmFsdWUuYywgdmFsdWUuZCwgdmFsdWUuZSwgdmFsdWUuZik7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlLCBweENvbW1hLCBweFBhcmVuLCBkZWdQYXJlbikge1xuXG4gIGZ1bmN0aW9uIHBvcChzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID8gcy5wb3AoKSArIFwiIFwiIDogXCJcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgcHhDb21tYSwgbnVsbCwgcHhQYXJlbik7XG4gICAgICBxLnB1c2goe2k6IGkgLSA0LCB4OiByZWludGVycG9sYXRlKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IHJlaW50ZXJwb2xhdGUoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogcmVpbnRlcnBvbGF0ZShhLCBiKX0pO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2V3WChhLCBiLCBzLCBxKSB7XG4gICAgaWYgKGEgIT09IGIpIHtcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwic2tld1goXCIsIG51bGwsIGRlZ1BhcmVuKSAtIDIsIHg6IHJlaW50ZXJwb2xhdGUoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogcmVpbnRlcnBvbGF0ZSh4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiByZWludGVycG9sYXRlKHlhLCB5Yil9KTtcbiAgICB9IGVsc2UgaWYgKHhiICE9PSAxIHx8IHliICE9PSAxKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiArIHhiICsgXCIsXCIgKyB5YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzID0gW10sIC8vIHN0cmluZyBjb25zdGFudHMgYW5kIHBsYWNlaG9sZGVyc1xuICAgICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG4gICAgYSA9IHBhcnNlKGEpLCBiID0gcGFyc2UoYik7XG4gICAgdHJhbnNsYXRlKGEudHJhbnNsYXRlWCwgYS50cmFuc2xhdGVZLCBiLnRyYW5zbGF0ZVgsIGIudHJhbnNsYXRlWSwgcywgcSk7XG4gICAgcm90YXRlKGEucm90YXRlLCBiLnJvdGF0ZSwgcywgcSk7XG4gICAgc2tld1goYS5za2V3WCwgYi5za2V3WCwgcywgcSk7XG4gICAgc2NhbGUoYS5zY2FsZVgsIGEuc2NhbGVZLCBiLnNjYWxlWCwgYi5zY2FsZVksIHMsIHEpO1xuICAgIGEgPSBiID0gbnVsbDsgLy8gZ2NcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHEubGVuZ3RoLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG52YXIgaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZVN2ZywgXCIsIFwiLCBcIilcIiwgXCIpXCIpO1xuXG52YXIgcmhvID0gTWF0aC5TUVJUMjtcbnZhciByaG8yID0gMjtcbnZhciByaG80ID0gNDtcbnZhciBlcHNpbG9uMiA9IDFlLTEyO1xuXG5mdW5jdGlvbiBjb3NoKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSArIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHNpbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbn1cblxuZnVuY3Rpb24gdGFuaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCgyICogeCkpIC0gMSkgLyAoeCArIDEpO1xufVxuXG4vLyBwMCA9IFt1eDAsIHV5MCwgdzBdXG4vLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG52YXIgaW50ZXJwb2xhdGVab29tID0gZnVuY3Rpb24ocDAsIHAxKSB7XG4gIHZhciB1eDAgPSBwMFswXSwgdXkwID0gcDBbMV0sIHcwID0gcDBbMl0sXG4gICAgICB1eDEgPSBwMVswXSwgdXkxID0gcDFbMV0sIHcxID0gcDFbMl0sXG4gICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgIGR5ID0gdXkxIC0gdXkwLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgIGksXG4gICAgICBTO1xuXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgdTAg4omFIHUxLlxuICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgIFMgPSBNYXRoLmxvZyh3MSAvIHcwKSAvIHJobztcbiAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdXgwICsgdCAqIGR4LFxuICAgICAgICB1eTAgKyB0ICogZHksXG4gICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICBdO1xuICAgIH07XG4gIH1cblxuICAvLyBHZW5lcmFsIGNhc2UuXG4gIGVsc2Uge1xuICAgIHZhciBkMSA9IE1hdGguc3FydChkMiksXG4gICAgICAgIGIwID0gKHcxICogdzEgLSB3MCAqIHcwICsgcmhvNCAqIGQyKSAvICgyICogdzAgKiByaG8yICogZDEpLFxuICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLFxuICAgICAgICByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIHMgPSB0ICogUyxcbiAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICB1ID0gdzAgLyAocmhvMiAqIGQxKSAqIChjb3NocjAgKiB0YW5oKHJobyAqIHMgKyByMCkgLSBzaW5oKHIwKSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgIHV5MCArIHUgKiBkeSxcbiAgICAgICAgdzAgKiBjb3NocjAgLyBjb3NoKHJobyAqIHMgKyByMClcbiAgICAgIF07XG4gICAgfTtcbiAgfVxuXG4gIGkuZHVyYXRpb24gPSBTICogMTAwMDtcblxuICByZXR1cm4gaTtcbn07XG5cbmZ1bmN0aW9uIGhzbCQxKGh1ZSQkMSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlJCQxKChzdGFydCA9IGhzbChzdGFydCkpLmgsIChlbmQgPSBoc2woZW5kKSkuaCksXG4gICAgICAgIHMgPSBub2dhbW1hKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbnZhciBoc2wkMiA9IGhzbCQxKGh1ZSk7XG52YXIgaHNsTG9uZyA9IGhzbCQxKG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBsYWIkMShzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gbm9nYW1tYSgoc3RhcnQgPSBsYWIoc3RhcnQpKS5sLCAoZW5kID0gbGFiKGVuZCkpLmwpLFxuICAgICAgYSA9IG5vZ2FtbWEoc3RhcnQuYSwgZW5kLmEpLFxuICAgICAgYiA9IG5vZ2FtbWEoc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgIHN0YXJ0LmEgPSBhKHQpO1xuICAgIHN0YXJ0LmIgPSBiKHQpO1xuICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGhjbCQxKGh1ZSQkMSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlJCQxKChzdGFydCA9IGhjbChzdGFydCkpLmgsIChlbmQgPSBoY2woZW5kKSkuaCksXG4gICAgICAgIGMgPSBub2dhbW1hKHN0YXJ0LmMsIGVuZC5jKSxcbiAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQuYyA9IGModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbnZhciBoY2wkMiA9IGhjbCQxKGh1ZSk7XG52YXIgaGNsTG9uZyA9IGhjbCQxKG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXgkMShodWUkJDEpIHtcbiAgcmV0dXJuIChmdW5jdGlvbiBjdWJlaGVsaXhHYW1tYSh5KSB7XG4gICAgeSA9ICt5O1xuXG4gICAgZnVuY3Rpb24gY3ViZWhlbGl4JCQxKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBoID0gaHVlJCQxKChzdGFydCA9IGN1YmVoZWxpeChzdGFydCkpLmgsIChlbmQgPSBjdWJlaGVsaXgoZW5kKSkuaCksXG4gICAgICAgICAgcyA9IG5vZ2FtbWEoc3RhcnQucywgZW5kLnMpLFxuICAgICAgICAgIGwgPSBub2dhbW1hKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICAgIHN0YXJ0LmwgPSBsKE1hdGgucG93KHQsIHkpKTtcbiAgICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGN1YmVoZWxpeCQkMS5nYW1tYSA9IGN1YmVoZWxpeEdhbW1hO1xuXG4gICAgcmV0dXJuIGN1YmVoZWxpeCQkMTtcbiAgfSkoMSk7XG59XG5cbnZhciBjdWJlaGVsaXgkMiA9IGN1YmVoZWxpeCQxKGh1ZSk7XG52YXIgY3ViZWhlbGl4TG9uZyA9IGN1YmVoZWxpeCQxKG5vZ2FtbWEpO1xuXG52YXIgcXVhbnRpemUgPSBmdW5jdGlvbihpbnRlcnBvbGF0b3IsIG4pIHtcbiAgdmFyIHNhbXBsZXMgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBzYW1wbGVzW2ldID0gaW50ZXJwb2xhdG9yKGkgLyAobiAtIDEpKTtcbiAgcmV0dXJuIHNhbXBsZXM7XG59O1xuXG52YXIgZnJhbWUgPSAwO1xudmFyIHRpbWVvdXQgPSAwO1xudmFyIGludGVydmFsID0gMDtcbnZhciBwb2tlRGVsYXkgPSAxMDAwO1xudmFyIHRhc2tIZWFkO1xudmFyIHRhc2tUYWlsO1xudmFyIGNsb2NrTGFzdCA9IDA7XG52YXIgY2xvY2tOb3cgPSAwO1xudmFyIGNsb2NrU2tldyA9IDA7XG52YXIgY2xvY2sgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwib2JqZWN0XCIgJiYgcGVyZm9ybWFuY2Uubm93ID8gcGVyZm9ybWFuY2UgOiBEYXRlO1xudmFyIHNldEZyYW1lID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDE3KTsgfTtcblxuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gY2xvY2tOb3cgfHwgKHNldEZyYW1lKGNsZWFyTm93KSwgY2xvY2tOb3cgPSBjbG9jay5ub3coKSArIGNsb2NrU2tldyk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyTm93KCkge1xuICBjbG9ja05vdyA9IDA7XG59XG5cbmZ1bmN0aW9uIFRpbWVyKCkge1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fdGltZSA9XG4gIHRoaXMuX25leHQgPSBudWxsO1xufVxuXG5UaW1lci5wcm90b3R5cGUgPSB0aW1lci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUaW1lcixcbiAgcmVzdGFydDogZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FsbGJhY2sgaXMgbm90IGEgZnVuY3Rpb25cIik7XG4gICAgdGltZSA9ICh0aW1lID09IG51bGwgPyBub3coKSA6ICt0aW1lKSArIChkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheSk7XG4gICAgaWYgKCF0aGlzLl9uZXh0ICYmIHRhc2tUYWlsICE9PSB0aGlzKSB7XG4gICAgICBpZiAodGFza1RhaWwpIHRhc2tUYWlsLl9uZXh0ID0gdGhpcztcbiAgICAgIGVsc2UgdGFza0hlYWQgPSB0aGlzO1xuICAgICAgdGFza1RhaWwgPSB0aGlzO1xuICAgIH1cbiAgICB0aGlzLl9jYWxsID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgc2xlZXAoKTtcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHtcbiAgICAgIHRoaXMuX2NhbGwgPSBudWxsO1xuICAgICAgdGhpcy5fdGltZSA9IEluZmluaXR5O1xuICAgICAgc2xlZXAoKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiB0aW1lckZsdXNoKCkge1xuICBub3coKTsgLy8gR2V0IHRoZSBjdXJyZW50IHRpbWUsIGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgKytmcmFtZTsgLy8gUHJldGVuZCB3ZeKAmXZlIHNldCBhbiBhbGFybSwgaWYgd2UgaGF2ZW7igJl0IGFscmVhZHkuXG4gIHZhciB0ID0gdGFza0hlYWQsIGU7XG4gIHdoaWxlICh0KSB7XG4gICAgaWYgKChlID0gY2xvY2tOb3cgLSB0Ll90aW1lKSA+PSAwKSB0Ll9jYWxsLmNhbGwobnVsbCwgZSk7XG4gICAgdCA9IHQuX25leHQ7XG4gIH1cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuICB0cnkge1xuICAgIHRpbWVyRmx1c2goKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmcmFtZSA9IDA7XG4gICAgbmFwKCk7XG4gICAgY2xvY2tOb3cgPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBva2UoKSB7XG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLCB0MSA9IHRhc2tIZWFkLCB0MiwgdGltZSA9IEluZmluaXR5O1xuICB3aGlsZSAodDEpIHtcbiAgICBpZiAodDEuX2NhbGwpIHtcbiAgICAgIGlmICh0aW1lID4gdDEuX3RpbWUpIHRpbWUgPSB0MS5fdGltZTtcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQyID0gdDEuX25leHQsIHQxLl9uZXh0ID0gbnVsbDtcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcbiAgICB9XG4gIH1cbiAgdGFza1RhaWwgPSB0MDtcbiAgc2xlZXAodGltZSk7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgaWYgKGZyYW1lKSByZXR1cm47IC8vIFNvb25lc3QgYWxhcm0gYWxyZWFkeSBzZXQsIG9yIHdpbGwgYmUuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7XG4gIGlmIChkZWxheSA+IDI0KSB7XG4gICAgaWYgKHRpbWUgPCBJbmZpbml0eSkgdGltZW91dCA9IHNldFRpbWVvdXQod2FrZSwgZGVsYXkpO1xuICAgIGlmIChpbnRlcnZhbCkgaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWludGVydmFsKSBjbG9ja0xhc3QgPSBjbG9ja05vdywgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwb2tlLCBwb2tlRGVsYXkpO1xuICAgIGZyYW1lID0gMSwgc2V0RnJhbWUod2FrZSk7XG4gIH1cbn1cblxudmFyIHRpbWVvdXQkMSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgZGVsYXkgPSBkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheTtcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uKGVsYXBzZWQpIHtcbiAgICB0LnN0b3AoKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkICsgZGVsYXkpO1xuICB9LCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufTtcblxudmFyIGludGVydmFsJDEgPSBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXIsIHRvdGFsID0gZGVsYXk7XG4gIGlmIChkZWxheSA9PSBudWxsKSByZXR1cm4gdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSksIHQ7XG4gIGRlbGF5ID0gK2RlbGF5LCB0aW1lID0gdGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZTtcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIGVsYXBzZWQgKz0gdG90YWw7XG4gICAgdC5yZXN0YXJ0KHRpY2ssIHRvdGFsICs9IGRlbGF5LCB0aW1lKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkKTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn07XG5cbnZhciBlbXB0eU9uID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcImVuZFwiLCBcImludGVycnVwdFwiKTtcbnZhciBlbXB0eVR3ZWVuID0gW107XG5cbnZhciBDUkVBVEVEID0gMDtcbnZhciBTQ0hFRFVMRUQgPSAxO1xudmFyIFNUQVJUSU5HID0gMjtcbnZhciBTVEFSVEVEID0gMztcbnZhciBSVU5OSU5HID0gNDtcbnZhciBFTkRJTkcgPSA1O1xudmFyIEVOREVEID0gNjtcblxudmFyIHNjaGVkdWxlID0gZnVuY3Rpb24obm9kZSwgbmFtZSwgaWQsIGluZGV4LCBncm91cCwgdGltaW5nKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZXMpIG5vZGUuX190cmFuc2l0aW9uID0ge307XG4gIGVsc2UgaWYgKGlkIGluIHNjaGVkdWxlcykgcmV0dXJuO1xuICBjcmVhdGUobm9kZSwgaWQsIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGluZGV4OiBpbmRleCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIGdyb3VwOiBncm91cCwgLy8gRm9yIGNvbnRleHQgZHVyaW5nIGNhbGxiYWNrLlxuICAgIG9uOiBlbXB0eU9uLFxuICAgIHR3ZWVuOiBlbXB0eVR3ZWVuLFxuICAgIHRpbWU6IHRpbWluZy50aW1lLFxuICAgIGRlbGF5OiB0aW1pbmcuZGVsYXksXG4gICAgZHVyYXRpb246IHRpbWluZy5kdXJhdGlvbixcbiAgICBlYXNlOiB0aW1pbmcuZWFzZSxcbiAgICB0aW1lcjogbnVsbCxcbiAgICBzdGF0ZTogQ1JFQVRFRFxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGluaXQobm9kZSwgaWQpIHtcbiAgdmFyIHNjaGVkdWxlID0gbm9kZS5fX3RyYW5zaXRpb247XG4gIGlmICghc2NoZWR1bGUgfHwgIShzY2hlZHVsZSA9IHNjaGVkdWxlW2lkXSkgfHwgc2NoZWR1bGUuc3RhdGUgPiBDUkVBVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZVwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBzZXQkMShub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSB8fCBzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZVwiKTtcbiAgcmV0dXJuIHNjaGVkdWxlO1xufVxuXG5mdW5jdGlvbiBnZXQkMShub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSkgdGhyb3cgbmV3IEVycm9yKFwidG9vIGxhdGVcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBzZWxmKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHR3ZWVuO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHNlbGYgdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XG4gIHNlbGYudGltZXIgPSB0aW1lcihzY2hlZHVsZSwgMCwgc2VsZi50aW1lKTtcblxuICBmdW5jdGlvbiBzY2hlZHVsZShlbGFwc2VkKSB7XG4gICAgc2VsZi5zdGF0ZSA9IFNDSEVEVUxFRDtcbiAgICBzZWxmLnRpbWVyLnJlc3RhcnQoc3RhcnQsIHNlbGYuZGVsYXksIHNlbGYudGltZSk7XG5cbiAgICAvLyBJZiB0aGUgZWxhcHNlZCBkZWxheSBpcyBsZXNzIHRoYW4gb3VyIGZpcnN0IHNsZWVwLCBzdGFydCBpbW1lZGlhdGVseS5cbiAgICBpZiAoc2VsZi5kZWxheSA8PSBlbGFwc2VkKSBzdGFydChlbGFwc2VkIC0gc2VsZi5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgdmFyIGksIGosIG4sIG87XG5cbiAgICAvLyBJZiB0aGUgc3RhdGUgaXMgbm90IFNDSEVEVUxFRCwgdGhlbiB3ZSBwcmV2aW91c2x5IGVycm9yZWQgb24gc3RhcnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgIT09IFNDSEVEVUxFRCkgcmV0dXJuIHN0b3AoKTtcblxuICAgIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICAgIG8gPSBzY2hlZHVsZXNbaV07XG4gICAgICBpZiAoby5uYW1lICE9PSBzZWxmLm5hbWUpIGNvbnRpbnVlO1xuXG4gICAgICAvLyBXaGlsZSB0aGlzIGVsZW1lbnQgYWxyZWFkeSBoYXMgYSBzdGFydGluZyB0cmFuc2l0aW9uIGR1cmluZyB0aGlzIGZyYW1lLFxuICAgICAgLy8gZGVmZXIgc3RhcnRpbmcgYW4gaW50ZXJydXB0aW5nIHRyYW5zaXRpb24gdW50aWwgdGhhdCB0cmFuc2l0aW9uIGhhcyBhXG4gICAgICAvLyBjaGFuY2UgdG8gdGljayAoYW5kIHBvc3NpYmx5IGVuZCk7IHNlZSBkMy9kMy10cmFuc2l0aW9uIzU0IVxuICAgICAgaWYgKG8uc3RhdGUgPT09IFNUQVJURUQpIHJldHVybiB0aW1lb3V0JDEoc3RhcnQpO1xuXG4gICAgICAvLyBJbnRlcnJ1cHQgdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBpZiBhbnkuXG4gICAgICAvLyBEaXNwYXRjaCB0aGUgaW50ZXJydXB0IGV2ZW50LlxuICAgICAgaWYgKG8uc3RhdGUgPT09IFJVTk5JTkcpIHtcbiAgICAgICAgby5zdGF0ZSA9IEVOREVEO1xuICAgICAgICBvLnRpbWVyLnN0b3AoKTtcbiAgICAgICAgby5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIG8uaW5kZXgsIG8uZ3JvdXApO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgYW55IHByZS1lbXB0ZWQgdHJhbnNpdGlvbnMuIE5vIGludGVycnVwdCBldmVudCBpcyBkaXNwYXRjaGVkXG4gICAgICAvLyBiZWNhdXNlIHRoZSBjYW5jZWxsZWQgdHJhbnNpdGlvbnMgbmV2ZXIgc3RhcnRlZC4gTm90ZSB0aGF0IHRoaXMgYWxzb1xuICAgICAgLy8gcmVtb3ZlcyB0aGlzIHRyYW5zaXRpb24gZnJvbSB0aGUgcGVuZGluZyBsaXN0IVxuICAgICAgZWxzZSBpZiAoK2kgPCBpZCkge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBkZWxldGUgc2NoZWR1bGVzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlZmVyIHRoZSBmaXJzdCB0aWNrIHRvIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZTsgc2VlIGQzL2QzIzE1NzYuXG4gICAgLy8gTm90ZSB0aGUgdHJhbnNpdGlvbiBtYXkgYmUgY2FuY2VsZWQgYWZ0ZXIgc3RhcnQgYW5kIGJlZm9yZSB0aGUgZmlyc3QgdGljayFcbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBzY2hlZHVsZWQgYmVmb3JlIHRoZSBzdGFydCBldmVudDsgc2VlIGQzL2QzLXRyYW5zaXRpb24jMTYhXG4gICAgLy8gQXNzdW1pbmcgdGhpcyBpcyBzdWNjZXNzZnVsLCBzdWJzZXF1ZW50IGNhbGxiYWNrcyBnbyBzdHJhaWdodCB0byB0aWNrLlxuICAgIHRpbWVvdXQkMShmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzZWxmLnN0YXRlID09PSBTVEFSVEVEKSB7XG4gICAgICAgIHNlbGYuc3RhdGUgPSBSVU5OSU5HO1xuICAgICAgICBzZWxmLnRpbWVyLnJlc3RhcnQodGljaywgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcbiAgICAgICAgdGljayhlbGFwc2VkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIERpc3BhdGNoIHRoZSBzdGFydCBldmVudC5cbiAgICAvLyBOb3RlIHRoaXMgbXVzdCBiZSBkb25lIGJlZm9yZSB0aGUgdHdlZW4gYXJlIGluaXRpYWxpemVkLlxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVElORztcbiAgICBzZWxmLm9uLmNhbGwoXCJzdGFydFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKTtcbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU1RBUlRJTkcpIHJldHVybjsgLy8gaW50ZXJydXB0ZWRcbiAgICBzZWxmLnN0YXRlID0gU1RBUlRFRDtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHR3ZWVuLCBkZWxldGluZyBudWxsIHR3ZWVuLlxuICAgIHR3ZWVuID0gbmV3IEFycmF5KG4gPSBzZWxmLnR3ZWVuLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgaiA9IC0xOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobyA9IHNlbGYudHdlZW5baV0udmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBzZWxmLmluZGV4LCBzZWxmLmdyb3VwKSkge1xuICAgICAgICB0d2VlblsrK2pdID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgdHdlZW4ubGVuZ3RoID0gaiArIDE7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICB2YXIgdCA9IGVsYXBzZWQgPCBzZWxmLmR1cmF0aW9uID8gc2VsZi5lYXNlLmNhbGwobnVsbCwgZWxhcHNlZCAvIHNlbGYuZHVyYXRpb24pIDogKHNlbGYudGltZXIucmVzdGFydChzdG9wKSwgc2VsZi5zdGF0ZSA9IEVORElORywgMSksXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IHR3ZWVuLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICB0d2VlbltpXS5jYWxsKG51bGwsIHQpO1xuICAgIH1cblxuICAgIC8vIERpc3BhdGNoIHRoZSBlbmQgZXZlbnQuXG4gICAgaWYgKHNlbGYuc3RhdGUgPT09IEVORElORykge1xuICAgICAgc2VsZi5vbi5jYWxsKFwiZW5kXCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgICAgc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgc2VsZi5zdGF0ZSA9IEVOREVEO1xuICAgIHNlbGYudGltZXIuc3RvcCgpO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaWRdO1xuICAgIGZvciAodmFyIGkgaW4gc2NoZWR1bGVzKSByZXR1cm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBkZWxldGUgbm9kZS5fX3RyYW5zaXRpb247XG4gIH1cbn1cblxudmFyIGludGVycnVwdCA9IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uLFxuICAgICAgc2NoZWR1bGUsXG4gICAgICBhY3RpdmUsXG4gICAgICBlbXB0eSA9IHRydWUsXG4gICAgICBpO1xuXG4gIGlmICghc2NoZWR1bGVzKSByZXR1cm47XG5cbiAgbmFtZSA9IG5hbWUgPT0gbnVsbCA/IG51bGwgOiBuYW1lICsgXCJcIjtcblxuICBmb3IgKGkgaW4gc2NoZWR1bGVzKSB7XG4gICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkubmFtZSAhPT0gbmFtZSkgeyBlbXB0eSA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGFjdGl2ZSA9IHNjaGVkdWxlLnN0YXRlID4gU1RBUlRJTkcgJiYgc2NoZWR1bGUuc3RhdGUgPCBFTkRJTkc7XG4gICAgc2NoZWR1bGUuc3RhdGUgPSBFTkRFRDtcbiAgICBzY2hlZHVsZS50aW1lci5zdG9wKCk7XG4gICAgaWYgKGFjdGl2ZSkgc2NoZWR1bGUub24uY2FsbChcImludGVycnVwdFwiLCBub2RlLCBub2RlLl9fZGF0YV9fLCBzY2hlZHVsZS5pbmRleCwgc2NoZWR1bGUuZ3JvdXApO1xuICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gIH1cblxuICBpZiAoZW1wdHkpIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbn07XG5cbnZhciBzZWxlY3Rpb25faW50ZXJydXB0ID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIGludGVycnVwdCh0aGlzLCBuYW1lKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB0d2VlblJlbW92ZShpZCwgbmFtZSkge1xuICB2YXIgdHdlZW4wLCB0d2VlbjE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQkMSh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSB0d2VlbjAgPSB0d2VlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjEgPSB0d2VlbjEuc2xpY2UoKTtcbiAgICAgICAgICB0d2VlbjEuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHR3ZWVuRnVuY3Rpb24oaWQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQkMSh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSAodHdlZW4wID0gdHdlZW4pLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciB0ID0ge25hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZX0sIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjFbaV0gPSB0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gbikgdHdlZW4xLnB1c2godCk7XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbnZhciB0cmFuc2l0aW9uX3R3ZWVuID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgbmFtZSArPSBcIlwiO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciB0d2VlbiA9IGdldCQxKHRoaXMubm9kZSgpLCBpZCkudHdlZW47XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0d2Vlbi5sZW5ndGgsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodCA9IHR3ZWVuW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVhY2goKHZhbHVlID09IG51bGwgPyB0d2VlblJlbW92ZSA6IHR3ZWVuRnVuY3Rpb24pKGlkLCBuYW1lLCB2YWx1ZSkpO1xufTtcblxuZnVuY3Rpb24gdHdlZW5WYWx1ZSh0cmFuc2l0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWQgPSB0cmFuc2l0aW9uLl9pZDtcblxuICB0cmFuc2l0aW9uLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjaGVkdWxlID0gc2V0JDEodGhpcywgaWQpO1xuICAgIChzY2hlZHVsZS52YWx1ZSB8fCAoc2NoZWR1bGUudmFsdWUgPSB7fSkpW25hbWVdID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0JDEobm9kZSwgaWQpLnZhbHVlW25hbWVdO1xuICB9O1xufVxuXG52YXIgaW50ZXJwb2xhdGUkJDEgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBjO1xuICByZXR1cm4gKHR5cGVvZiBiID09PSBcIm51bWJlclwiID8gcmVpbnRlcnBvbGF0ZVxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyBpbnRlcnBvbGF0ZVJnYlxuICAgICAgOiAoYyA9IGNvbG9yKGIpKSA/IChiID0gYywgaW50ZXJwb2xhdGVSZ2IpXG4gICAgICA6IGludGVycG9sYXRlU3RyaW5nKShhLCBiKTtcbn07XG5cbmZ1bmN0aW9uIGF0dHJSZW1vdmUkMShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TJDEoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50JDEobmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlMSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gdmFsdWUwID09PSB2YWx1ZTEgPyBudWxsXG4gICAgICAgIDogdmFsdWUwID09PSB2YWx1ZTAwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMkMShmdWxsbmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlMSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlJCQxKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbiQxKG5hbWUsIGludGVycG9sYXRlJCQxLCB2YWx1ZSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIHZhbHVlMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIHZhbHVlMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcbiAgICAgICAgOiB2YWx1ZTAgPT09IHZhbHVlMDAgJiYgdmFsdWUxID09PSB2YWx1ZTEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDEodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxMCA9IHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbk5TJDEoZnVsbG5hbWUsIGludGVycG9sYXRlJCQxLCB2YWx1ZSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIHZhbHVlMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUwLCB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICBpZiAodmFsdWUxID09IG51bGwpIHJldHVybiB2b2lkIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICB2YWx1ZTAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCAmJiB2YWx1ZTEgPT09IHZhbHVlMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSQkMSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEwID0gdmFsdWUxKTtcbiAgfTtcbn1cblxudmFyIHRyYW5zaXRpb25fYXR0ciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBmdWxsbmFtZSA9IG5hbWVzcGFjZShuYW1lKSwgaSA9IGZ1bGxuYW1lID09PSBcInRyYW5zZm9ybVwiID8gaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgOiBpbnRlcnBvbGF0ZSQkMTtcbiAgcmV0dXJuIHRoaXMuYXR0clR3ZWVuKG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TJDEgOiBhdHRyRnVuY3Rpb24kMSkoZnVsbG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJhdHRyLlwiICsgbmFtZSwgdmFsdWUpKVxuICAgICAgOiB2YWx1ZSA9PSBudWxsID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TJDEgOiBhdHRyUmVtb3ZlJDEpKGZ1bGxuYW1lKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyQxIDogYXR0ckNvbnN0YW50JDEpKGZ1bGxuYW1lLCBpLCB2YWx1ZSArIFwiXCIpKTtcbn07XG5cbmZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMsIGkgPSB2YWx1ZS5hcHBseShub2RlLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBpICYmIGZ1bmN0aW9uKHQpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsLCBpKHQpKTtcbiAgICB9O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbmZ1bmN0aW9uIGF0dHJUd2VlbihuYW1lLCB2YWx1ZSkge1xuICBmdW5jdGlvbiB0d2VlbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMsIGkgPSB2YWx1ZS5hcHBseShub2RlLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBpICYmIGZ1bmN0aW9uKHQpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIGkodCkpO1xuICAgIH07XG4gIH1cbiAgdHdlZW4uX3ZhbHVlID0gdmFsdWU7XG4gIHJldHVybiB0d2Vlbjtcbn1cblxudmFyIHRyYW5zaXRpb25fYXR0clR3ZWVuID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGtleSA9IFwiYXR0ci5cIiArIG5hbWU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIChrZXkgPSB0aGlzLnR3ZWVuKGtleSkpICYmIGtleS5fdmFsdWU7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdGhpcy50d2VlbihrZXksIG51bGwpO1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgdmFyIGZ1bGxuYW1lID0gbmFtZXNwYWNlKG5hbWUpO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIChmdWxsbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKShmdWxsbmFtZSwgdmFsdWUpKTtcbn07XG5cbmZ1bmN0aW9uIGRlbGF5RnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9ICt2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWxheUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPSArdmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgIGluaXQodGhpcywgaWQpLmRlbGF5ID0gdmFsdWU7XG4gIH07XG59XG5cbnZhciB0cmFuc2l0aW9uX2RlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZGVsYXlGdW5jdGlvblxuICAgICAgICAgIDogZGVsYXlDb25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0JDEodGhpcy5ub2RlKCksIGlkKS5kZWxheTtcbn07XG5cbmZ1bmN0aW9uIGR1cmF0aW9uRnVuY3Rpb24oaWQsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBzZXQkMSh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Db25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBzZXQkMSh0aGlzLCBpZCkuZHVyYXRpb24gPSB2YWx1ZTtcbiAgfTtcbn1cblxudmFyIHRyYW5zaXRpb25fZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBkdXJhdGlvbkZ1bmN0aW9uXG4gICAgICAgICAgOiBkdXJhdGlvbkNvbnN0YW50KShpZCwgdmFsdWUpKVxuICAgICAgOiBnZXQkMSh0aGlzLm5vZGUoKSwgaWQpLmR1cmF0aW9uO1xufTtcblxuZnVuY3Rpb24gZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCQxKHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XG4gIH07XG59XG5cbnZhciB0cmFuc2l0aW9uX2Vhc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCQxKHRoaXMubm9kZSgpLCBpZCkuZWFzZTtcbn07XG5cbnZhciB0cmFuc2l0aW9uX2ZpbHRlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2ggIT09IFwiZnVuY3Rpb25cIikgbWF0Y2ggPSBtYXRjaGVyJDEobWF0Y2gpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc3ViZ3JvdXAgPSBzdWJncm91cHNbal0gPSBbXSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBtYXRjaC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihzdWJncm91cHMsIHRoaXMuX3BhcmVudHMsIHRoaXMuX25hbWUsIHRoaXMuX2lkKTtcbn07XG5cbnZhciB0cmFuc2l0aW9uX21lcmdlID0gZnVuY3Rpb24odHJhbnNpdGlvbikge1xuICBpZiAodHJhbnNpdGlvbi5faWQgIT09IHRoaXMuX2lkKSB0aHJvdyBuZXcgRXJyb3I7XG5cbiAgZm9yICh2YXIgZ3JvdXBzMCA9IHRoaXMuX2dyb3VwcywgZ3JvdXBzMSA9IHRyYW5zaXRpb24uX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKG1lcmdlcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufTtcblxuZnVuY3Rpb24gc3RhcnQobmFtZSkge1xuICByZXR1cm4gKG5hbWUgKyBcIlwiKS50cmltKCkuc3BsaXQoL158XFxzKy8pLmV2ZXJ5KGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgcmV0dXJuICF0IHx8IHQgPT09IFwic3RhcnRcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRnVuY3Rpb24oaWQsIG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBvbjAsIG9uMSwgc2l0ID0gc3RhcnQobmFtZSkgPyBpbml0IDogc2V0JDE7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzaXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKG5hbWUsIGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG52YXIgdHJhbnNpdGlvbl9vbiA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQkMSh0aGlzLm5vZGUoKSwgaWQpLm9uLm9uKG5hbWUpXG4gICAgICA6IHRoaXMuZWFjaChvbkZ1bmN0aW9uKGlkLCBuYW1lLCBsaXN0ZW5lcikpO1xufTtcblxuZnVuY3Rpb24gcmVtb3ZlRnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fdHJhbnNpdGlvbikgaWYgKCtpICE9PSBpZCkgcmV0dXJuO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfTtcbn1cblxudmFyIHRyYW5zaXRpb25fcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm9uKFwiZW5kLnJlbW92ZVwiLCByZW1vdmVGdW5jdGlvbih0aGlzLl9pZCkpO1xufTtcblxudmFyIHRyYW5zaXRpb25fc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0JCQxKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QkJDEgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0JCQxID0gc2VsZWN0b3Ioc2VsZWN0JCQxKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0JCQxLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICAgIHNjaGVkdWxlKHN1Ymdyb3VwW2ldLCBuYW1lLCBpZCwgaSwgc3ViZ3JvdXAsIGdldCQxKG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufTtcblxudmFyIHRyYW5zaXRpb25fc2VsZWN0QWxsID0gZnVuY3Rpb24oc2VsZWN0JCQxKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkID0gdGhpcy5faWQ7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3QkJDEgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0JCQxID0gc2VsZWN0b3JBbGwoc2VsZWN0JCQxKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBbXSwgcGFyZW50cyA9IFtdLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBmb3IgKHZhciBjaGlsZHJlbiA9IHNlbGVjdCQkMS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSwgY2hpbGQsIGluaGVyaXQgPSBnZXQkMShub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59O1xuXG52YXIgU2VsZWN0aW9uJDEgPSBzZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xuXG52YXIgdHJhbnNpdGlvbl9zZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24kMSh0aGlzLl9ncm91cHMsIHRoaXMuX3BhcmVudHMpO1xufTtcblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUkMShuYW1lLCBpbnRlcnBvbGF0ZSQkMikge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIHZhbHVlMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUwID0gc3R5bGVWYWx1ZSh0aGlzLCBuYW1lKSxcbiAgICAgICAgdmFsdWUxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIHN0eWxlVmFsdWUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcbiAgICAgICAgOiB2YWx1ZTAgPT09IHZhbHVlMDAgJiYgdmFsdWUxID09PSB2YWx1ZTEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDIodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxMCA9IHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlUmVtb3ZlRW5kKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQkMShuYW1lLCBpbnRlcnBvbGF0ZSQkMiwgdmFsdWUxKSB7XG4gIHZhciB2YWx1ZTAwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMCA9IHN0eWxlVmFsdWUodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlJCQyKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24kMShuYW1lLCBpbnRlcnBvbGF0ZSQkMiwgdmFsdWUpIHtcbiAgdmFyIHZhbHVlMDAsXG4gICAgICB2YWx1ZTEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMCA9IHN0eWxlVmFsdWUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgdmFsdWUxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIHN0eWxlVmFsdWUodGhpcywgbmFtZSkpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcbiAgICAgICAgOiB2YWx1ZTAgPT09IHZhbHVlMDAgJiYgdmFsdWUxID09PSB2YWx1ZTEwID8gaW50ZXJwb2xhdGUwXG4gICAgICAgIDogaW50ZXJwb2xhdGUwID0gaW50ZXJwb2xhdGUkJDIodmFsdWUwMCA9IHZhbHVlMCwgdmFsdWUxMCA9IHZhbHVlMSk7XG4gIH07XG59XG5cbnZhciB0cmFuc2l0aW9uX3N0eWxlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gIHZhciBpID0gKG5hbWUgKz0gXCJcIikgPT09IFwidHJhbnNmb3JtXCIgPyBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA6IGludGVycG9sYXRlJCQxO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHRoaXNcbiAgICAgICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZVJlbW92ZSQxKG5hbWUsIGkpKVxuICAgICAgICAgIC5vbihcImVuZC5zdHlsZS5cIiArIG5hbWUsIHN0eWxlUmVtb3ZlRW5kKG5hbWUpKVxuICAgICAgOiB0aGlzLnN0eWxlVHdlZW4obmFtZSwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IHN0eWxlRnVuY3Rpb24kMShuYW1lLCBpLCB0d2VlblZhbHVlKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSkpXG4gICAgICAgICAgOiBzdHlsZUNvbnN0YW50JDEobmFtZSwgaSwgdmFsdWUgKyBcIlwiKSwgcHJpb3JpdHkpO1xufTtcblxuZnVuY3Rpb24gc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLCBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbih0KSB7XG4gICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkodCksIHByaW9yaXR5KTtcbiAgICB9O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbnZhciB0cmFuc2l0aW9uX3N0eWxlVHdlZW4gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn07XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCQxKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRGdW5jdGlvbiQxKHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUxID0gdmFsdWUodGhpcyk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlMSA9PSBudWxsID8gXCJcIiA6IHZhbHVlMTtcbiAgfTtcbn1cblxudmFyIHRyYW5zaXRpb25fdGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLnR3ZWVuKFwidGV4dFwiLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyB0ZXh0RnVuY3Rpb24kMSh0d2VlblZhbHVlKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSkpXG4gICAgICA6IHRleHRDb25zdGFudCQxKHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiKSk7XG59O1xuXG52YXIgdHJhbnNpdGlvbl90cmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuYW1lID0gdGhpcy5fbmFtZSxcbiAgICAgIGlkMCA9IHRoaXMuX2lkLFxuICAgICAgaWQxID0gbmV3SWQoKTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICB2YXIgaW5oZXJpdCA9IGdldCQxKG5vZGUsIGlkMCk7XG4gICAgICAgIHNjaGVkdWxlKG5vZGUsIG5hbWUsIGlkMSwgaSwgZ3JvdXAsIHtcbiAgICAgICAgICB0aW1lOiBpbmhlcml0LnRpbWUgKyBpbmhlcml0LmRlbGF5ICsgaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBkZWxheTogMCxcbiAgICAgICAgICBkdXJhdGlvbjogaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgICBlYXNlOiBpbmhlcml0LmVhc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQxKTtcbn07XG5cbnZhciBpZCA9IDA7XG5cbmZ1bmN0aW9uIFRyYW5zaXRpb24oZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCkge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5faWQgPSBpZDtcbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbihuYW1lKSB7XG4gIHJldHVybiBzZWxlY3Rpb24oKS50cmFuc2l0aW9uKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBuZXdJZCgpIHtcbiAgcmV0dXJuICsraWQ7XG59XG5cbnZhciBzZWxlY3Rpb25fcHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZTtcblxuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB0cmFuc2l0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zaXRpb24sXG4gIHNlbGVjdDogdHJhbnNpdGlvbl9zZWxlY3QsXG4gIHNlbGVjdEFsbDogdHJhbnNpdGlvbl9zZWxlY3RBbGwsXG4gIGZpbHRlcjogdHJhbnNpdGlvbl9maWx0ZXIsXG4gIG1lcmdlOiB0cmFuc2l0aW9uX21lcmdlLFxuICBzZWxlY3Rpb246IHRyYW5zaXRpb25fc2VsZWN0aW9uLFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uX3RyYW5zaXRpb24sXG4gIGNhbGw6IHNlbGVjdGlvbl9wcm90b3R5cGUuY2FsbCxcbiAgbm9kZXM6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9wcm90b3R5cGUubm9kZSxcbiAgc2l6ZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5zaXplLFxuICBlbXB0eTogc2VsZWN0aW9uX3Byb3RvdHlwZS5lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX3Byb3RvdHlwZS5lYWNoLFxuICBvbjogdHJhbnNpdGlvbl9vbixcbiAgYXR0cjogdHJhbnNpdGlvbl9hdHRyLFxuICBhdHRyVHdlZW46IHRyYW5zaXRpb25fYXR0clR3ZWVuLFxuICBzdHlsZTogdHJhbnNpdGlvbl9zdHlsZSxcbiAgc3R5bGVUd2VlbjogdHJhbnNpdGlvbl9zdHlsZVR3ZWVuLFxuICB0ZXh0OiB0cmFuc2l0aW9uX3RleHQsXG4gIHJlbW92ZTogdHJhbnNpdGlvbl9yZW1vdmUsXG4gIHR3ZWVuOiB0cmFuc2l0aW9uX3R3ZWVuLFxuICBkZWxheTogdHJhbnNpdGlvbl9kZWxheSxcbiAgZHVyYXRpb246IHRyYW5zaXRpb25fZHVyYXRpb24sXG4gIGVhc2U6IHRyYW5zaXRpb25fZWFzZVxufTtcblxuZnVuY3Rpb24gbGluZWFyJDEodCkge1xuICByZXR1cm4gK3Q7XG59XG5cbmZ1bmN0aW9uIHF1YWRJbih0KSB7XG4gIHJldHVybiB0ICogdDtcbn1cblxuZnVuY3Rpb24gcXVhZE91dCh0KSB7XG4gIHJldHVybiB0ICogKDIgLSB0KTtcbn1cblxuZnVuY3Rpb24gcXVhZEluT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgOiAtLXQgKiAoMiAtIHQpICsgMSkgLyAyO1xufVxuXG5mdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cblxuZnVuY3Rpb24gY3ViaWNPdXQodCkge1xuICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xufVxuXG5mdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gdCAqIHQgKiB0IDogKHQgLT0gMikgKiB0ICogdCArIDIpIC8gMjtcbn1cblxudmFyIGV4cG9uZW50ID0gMztcblxudmFyIHBvbHlJbiA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seUluKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3codCwgZSk7XG4gIH1cblxuICBwb2x5SW4uZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlJbjtcbn0pKGV4cG9uZW50KTtcblxudmFyIHBvbHlPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlPdXQodCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIGUpO1xuICB9XG5cbiAgcG9seU91dC5leHBvbmVudCA9IGN1c3RvbTtcblxuICByZXR1cm4gcG9seU91dDtcbn0pKGV4cG9uZW50KTtcblxudmFyIHBvbHlJbk91dCA9IChmdW5jdGlvbiBjdXN0b20oZSkge1xuICBlID0gK2U7XG5cbiAgZnVuY3Rpb24gcG9seUluT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyBNYXRoLnBvdyh0LCBlKSA6IDIgLSBNYXRoLnBvdygyIC0gdCwgZSkpIC8gMjtcbiAgfVxuXG4gIHBvbHlJbk91dC5leHBvbmVudCA9IGN1c3RvbTtcblxuICByZXR1cm4gcG9seUluT3V0O1xufSkoZXhwb25lbnQpO1xuXG52YXIgcGkgPSBNYXRoLlBJO1xudmFyIGhhbGZQaSA9IHBpIC8gMjtcblxuZnVuY3Rpb24gc2luSW4odCkge1xuICByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBoYWxmUGkpO1xufVxuXG5mdW5jdGlvbiBzaW5PdXQodCkge1xuICByZXR1cm4gTWF0aC5zaW4odCAqIGhhbGZQaSk7XG59XG5cbmZ1bmN0aW9uIHNpbkluT3V0KHQpIHtcbiAgcmV0dXJuICgxIC0gTWF0aC5jb3MocGkgKiB0KSkgLyAyO1xufVxuXG5mdW5jdGlvbiBleHBJbih0KSB7XG4gIHJldHVybiBNYXRoLnBvdygyLCAxMCAqIHQgLSAxMCk7XG59XG5cbmZ1bmN0aW9uIGV4cE91dCh0KSB7XG4gIHJldHVybiAxIC0gTWF0aC5wb3coMiwgLTEwICogdCk7XG59XG5cbmZ1bmN0aW9uIGV4cEluT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gTWF0aC5wb3coMiwgMTAgKiB0IC0gMTApIDogMiAtIE1hdGgucG93KDIsIDEwIC0gMTAgKiB0KSkgLyAyO1xufVxuXG5mdW5jdGlvbiBjaXJjbGVJbih0KSB7XG4gIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG59XG5cbmZ1bmN0aW9uIGNpcmNsZU91dCh0KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoMSAtIC0tdCAqIHQpO1xufVxuXG5mdW5jdGlvbiBjaXJjbGVJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KSA6IE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpIC8gMjtcbn1cblxudmFyIGIxID0gNCAvIDExO1xudmFyIGIyID0gNiAvIDExO1xudmFyIGIzID0gOCAvIDExO1xudmFyIGI0ID0gMyAvIDQ7XG52YXIgYjUgPSA5IC8gMTE7XG52YXIgYjYgPSAxMCAvIDExO1xudmFyIGI3ID0gMTUgLyAxNjtcbnZhciBiOCA9IDIxIC8gMjI7XG52YXIgYjkgPSA2MyAvIDY0O1xudmFyIGIwID0gMSAvIGIxIC8gYjE7XG5cbmZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcbiAgcmV0dXJuIDEgLSBib3VuY2VPdXQoMSAtIHQpO1xufVxuXG5mdW5jdGlvbiBib3VuY2VPdXQodCkge1xuICByZXR1cm4gKHQgPSArdCkgPCBiMSA/IGIwICogdCAqIHQgOiB0IDwgYjMgPyBiMCAqICh0IC09IGIyKSAqIHQgKyBiNCA6IHQgPCBiNiA/IGIwICogKHQgLT0gYjUpICogdCArIGI3IDogYjAgKiAodCAtPSBiOCkgKiB0ICsgYjk7XG59XG5cbmZ1bmN0aW9uIGJvdW5jZUluT3V0KHQpIHtcbiAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gMSAtIGJvdW5jZU91dCgxIC0gdCkgOiBib3VuY2VPdXQodCAtIDEpICsgMSkgLyAyO1xufVxuXG52YXIgb3ZlcnNob290ID0gMS43MDE1ODtcblxudmFyIGJhY2tJbiA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja0luKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgfVxuXG4gIGJhY2tJbi5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tJbjtcbn0pKG92ZXJzaG9vdCk7XG5cbnZhciBiYWNrT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShzKSB7XG4gIHMgPSArcztcblxuICBmdW5jdGlvbiBiYWNrT3V0KHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfVxuXG4gIGJhY2tPdXQub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrT3V0O1xufSkob3ZlcnNob290KTtcblxudmFyIGJhY2tJbk91dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja0luT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ICo9IDIpIDwgMSA/IHQgKiB0ICogKChzICsgMSkgKiB0IC0gcykgOiAodCAtPSAyKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDIpIC8gMjtcbiAgfVxuXG4gIGJhY2tJbk91dC5vdmVyc2hvb3QgPSBjdXN0b207XG5cbiAgcmV0dXJuIGJhY2tJbk91dDtcbn0pKG92ZXJzaG9vdCk7XG5cbnZhciB0YXUgPSAyICogTWF0aC5QSTtcbnZhciBhbXBsaXR1ZGUgPSAxO1xudmFyIHBlcmlvZCA9IDAuMztcblxudmFyIGVsYXN0aWNJbiA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljSW4odCkge1xuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgMTAgKiAtLXQpICogTWF0aC5zaW4oKHMgLSB0KSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY0luLmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY0luLnBlcmlvZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIGN1c3RvbShhLCBwKTsgfTtcblxuICByZXR1cm4gZWxhc3RpY0luO1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG52YXIgZWxhc3RpY091dCA9IChmdW5jdGlvbiBjdXN0b20oYSwgcCkge1xuICB2YXIgcyA9IE1hdGguYXNpbigxIC8gKGEgPSBNYXRoLm1heCgxLCBhKSkpICogKHAgLz0gdGF1KTtcblxuICBmdW5jdGlvbiBlbGFzdGljT3V0KHQpIHtcbiAgICByZXR1cm4gMSAtIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAodCA9ICt0KSkgKiBNYXRoLnNpbigodCArIHMpIC8gcCk7XG4gIH1cblxuICBlbGFzdGljT3V0LmFtcGxpdHVkZSA9IGZ1bmN0aW9uKGEpIHsgcmV0dXJuIGN1c3RvbShhLCBwICogdGF1KTsgfTtcbiAgZWxhc3RpY091dC5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNPdXQ7XG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cbnZhciBlbGFzdGljSW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luT3V0KHQpIHtcbiAgICByZXR1cm4gKCh0ID0gdCAqIDIgLSAxKSA8IDBcbiAgICAgICAgPyBhICogTWF0aC5wb3coMiwgMTAgKiB0KSAqIE1hdGguc2luKChzIC0gdCkgLyBwKVxuICAgICAgICA6IDIgLSBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigocyArIHQpIC8gcCkpIC8gMjtcbiAgfVxuXG4gIGVsYXN0aWNJbk91dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNJbk91dC5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNJbk91dDtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxudmFyIGRlZmF1bHRUaW1pbmcgPSB7XG4gIHRpbWU6IG51bGwsIC8vIFNldCBvbiB1c2UuXG4gIGRlbGF5OiAwLFxuICBkdXJhdGlvbjogMjUwLFxuICBlYXNlOiBjdWJpY0luT3V0XG59O1xuXG5mdW5jdGlvbiBpbmhlcml0KG5vZGUsIGlkKSB7XG4gIHZhciB0aW1pbmc7XG4gIHdoaWxlICghKHRpbWluZyA9IG5vZGUuX190cmFuc2l0aW9uKSB8fCAhKHRpbWluZyA9IHRpbWluZ1tpZF0pKSB7XG4gICAgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VGltaW5nLnRpbWUgPSBub3coKSwgZGVmYXVsdFRpbWluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cblxudmFyIHNlbGVjdGlvbl90cmFuc2l0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgaWQsXG4gICAgICB0aW1pbmc7XG5cbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBuZXdJZCgpLCAodGltaW5nID0gZGVmYXVsdFRpbWluZykudGltZSA9IG5vdygpLCBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQsIGksIGdyb3VwLCB0aW1pbmcgfHwgaW5oZXJpdChub2RlLCBpZCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVHJhbnNpdGlvbihncm91cHMsIHRoaXMuX3BhcmVudHMsIG5hbWUsIGlkKTtcbn07XG5cbnNlbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJydXB0ID0gc2VsZWN0aW9uX2ludGVycnVwdDtcbnNlbGVjdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvbiA9IHNlbGVjdGlvbl90cmFuc2l0aW9uO1xuXG52YXIgcm9vdCQxID0gW251bGxdO1xuXG52YXIgYWN0aXZlID0gZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGk7XG5cbiAgaWYgKHNjaGVkdWxlcykge1xuICAgIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkuc3RhdGUgPiBTQ0hFRFVMRUQgJiYgc2NoZWR1bGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb24oW1tub2RlXV0sIHJvb3QkMSwgbmFtZSwgK2kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxudmFyIGNvbnN0YW50JDQgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn07XG5cbnZhciBCcnVzaEV2ZW50ID0gZnVuY3Rpb24odGFyZ2V0LCB0eXBlLCBzZWxlY3Rpb24pIHtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xufTtcblxuZnVuY3Rpb24gbm9wcm9wYWdhdGlvbiQxKCkge1xuICBleHBvcnRzLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG52YXIgbm9ldmVudCQxID0gZnVuY3Rpb24oKSB7XG4gIGV4cG9ydHMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXhwb3J0cy5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn07XG5cbnZhciBNT0RFX0RSQUcgPSB7bmFtZTogXCJkcmFnXCJ9O1xudmFyIE1PREVfU1BBQ0UgPSB7bmFtZTogXCJzcGFjZVwifTtcbnZhciBNT0RFX0hBTkRMRSA9IHtuYW1lOiBcImhhbmRsZVwifTtcbnZhciBNT0RFX0NFTlRFUiA9IHtuYW1lOiBcImNlbnRlclwifTtcblxudmFyIFggPSB7XG4gIG5hbWU6IFwieFwiLFxuICBoYW5kbGVzOiBbXCJlXCIsIFwid1wiXS5tYXAodHlwZSksXG4gIGlucHV0OiBmdW5jdGlvbih4LCBlKSB7IHJldHVybiB4ICYmIFtbeFswXSwgZVswXVsxXV0sIFt4WzFdLCBlWzFdWzFdXV07IH0sXG4gIG91dHB1dDogZnVuY3Rpb24oeHkpIHsgcmV0dXJuIHh5ICYmIFt4eVswXVswXSwgeHlbMV1bMF1dOyB9XG59O1xuXG52YXIgWSA9IHtcbiAgbmFtZTogXCJ5XCIsXG4gIGhhbmRsZXM6IFtcIm5cIiwgXCJzXCJdLm1hcCh0eXBlKSxcbiAgaW5wdXQ6IGZ1bmN0aW9uKHksIGUpIHsgcmV0dXJuIHkgJiYgW1tlWzBdWzBdLCB5WzBdXSwgW2VbMV1bMF0sIHlbMV1dXTsgfSxcbiAgb3V0cHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHkgJiYgW3h5WzBdWzFdLCB4eVsxXVsxXV07IH1cbn07XG5cbnZhciBYWSA9IHtcbiAgbmFtZTogXCJ4eVwiLFxuICBoYW5kbGVzOiBbXCJuXCIsIFwiZVwiLCBcInNcIiwgXCJ3XCIsIFwibndcIiwgXCJuZVwiLCBcInNlXCIsIFwic3dcIl0ubWFwKHR5cGUpLFxuICBpbnB1dDogZnVuY3Rpb24oeHkpIHsgcmV0dXJuIHh5OyB9LFxuICBvdXRwdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eTsgfVxufTtcblxudmFyIGN1cnNvcnMgPSB7XG4gIG92ZXJsYXk6IFwiY3Jvc3NoYWlyXCIsXG4gIHNlbGVjdGlvbjogXCJtb3ZlXCIsXG4gIG46IFwibnMtcmVzaXplXCIsXG4gIGU6IFwiZXctcmVzaXplXCIsXG4gIHM6IFwibnMtcmVzaXplXCIsXG4gIHc6IFwiZXctcmVzaXplXCIsXG4gIG53OiBcIm53c2UtcmVzaXplXCIsXG4gIG5lOiBcIm5lc3ctcmVzaXplXCIsXG4gIHNlOiBcIm53c2UtcmVzaXplXCIsXG4gIHN3OiBcIm5lc3ctcmVzaXplXCJcbn07XG5cbnZhciBmbGlwWCA9IHtcbiAgZTogXCJ3XCIsXG4gIHc6IFwiZVwiLFxuICBudzogXCJuZVwiLFxuICBuZTogXCJud1wiLFxuICBzZTogXCJzd1wiLFxuICBzdzogXCJzZVwiXG59O1xuXG52YXIgZmxpcFkgPSB7XG4gIG46IFwic1wiLFxuICBzOiBcIm5cIixcbiAgbnc6IFwic3dcIixcbiAgbmU6IFwic2VcIixcbiAgc2U6IFwibmVcIixcbiAgc3c6IFwibndcIlxufTtcblxudmFyIHNpZ25zWCA9IHtcbiAgb3ZlcmxheTogKzEsXG4gIHNlbGVjdGlvbjogKzEsXG4gIG46IG51bGwsXG4gIGU6ICsxLFxuICBzOiBudWxsLFxuICB3OiAtMSxcbiAgbnc6IC0xLFxuICBuZTogKzEsXG4gIHNlOiArMSxcbiAgc3c6IC0xXG59O1xuXG52YXIgc2lnbnNZID0ge1xuICBvdmVybGF5OiArMSxcbiAgc2VsZWN0aW9uOiArMSxcbiAgbjogLTEsXG4gIGU6IG51bGwsXG4gIHM6ICsxLFxuICB3OiBudWxsLFxuICBudzogLTEsXG4gIG5lOiAtMSxcbiAgc2U6ICsxLFxuICBzdzogKzFcbn07XG5cbmZ1bmN0aW9uIHR5cGUodCkge1xuICByZXR1cm4ge3R5cGU6IHR9O1xufVxuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIoKSB7XG4gIHJldHVybiAhZXhwb3J0cy5ldmVudC5idXR0b247XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRFeHRlbnQoKSB7XG4gIHZhciBzdmcgPSB0aGlzLm93bmVyU1ZHRWxlbWVudCB8fCB0aGlzO1xuICByZXR1cm4gW1swLCAwXSwgW3N2Zy53aWR0aC5iYXNlVmFsLnZhbHVlLCBzdmcuaGVpZ2h0LmJhc2VWYWwudmFsdWVdXTtcbn1cblxuLy8gTGlrZSBkMy5sb2NhbCwgYnV0IHdpdGggdGhlIG5hbWUg4oCcX19icnVzaOKAnSByYXRoZXIgdGhhbiBhdXRvLWdlbmVyYXRlZC5cbmZ1bmN0aW9uIGxvY2FsJCQxKG5vZGUpIHtcbiAgd2hpbGUgKCFub2RlLl9fYnJ1c2gpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gIHJldHVybiBub2RlLl9fYnJ1c2g7XG59XG5cbmZ1bmN0aW9uIGVtcHR5KGV4dGVudCkge1xuICByZXR1cm4gZXh0ZW50WzBdWzBdID09PSBleHRlbnRbMV1bMF1cbiAgICAgIHx8IGV4dGVudFswXVsxXSA9PT0gZXh0ZW50WzFdWzFdO1xufVxuXG5mdW5jdGlvbiBicnVzaFNlbGVjdGlvbihub2RlKSB7XG4gIHZhciBzdGF0ZSA9IG5vZGUuX19icnVzaDtcbiAgcmV0dXJuIHN0YXRlID8gc3RhdGUuZGltLm91dHB1dChzdGF0ZS5zZWxlY3Rpb24pIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gYnJ1c2hYKCkge1xuICByZXR1cm4gYnJ1c2gkMShYKTtcbn1cblxuZnVuY3Rpb24gYnJ1c2hZKCkge1xuICByZXR1cm4gYnJ1c2gkMShZKTtcbn1cblxudmFyIGJydXNoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBicnVzaCQxKFhZKTtcbn07XG5cbmZ1bmN0aW9uIGJydXNoJDEoZGltKSB7XG4gIHZhciBleHRlbnQgPSBkZWZhdWx0RXh0ZW50LFxuICAgICAgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGxpc3RlbmVycyA9IGRpc3BhdGNoKGJydXNoLCBcInN0YXJ0XCIsIFwiYnJ1c2hcIiwgXCJlbmRcIiksXG4gICAgICBoYW5kbGVTaXplID0gNixcbiAgICAgIHRvdWNoZW5kaW5nO1xuXG4gIGZ1bmN0aW9uIGJydXNoKGdyb3VwKSB7XG4gICAgdmFyIG92ZXJsYXkgPSBncm91cFxuICAgICAgICAucHJvcGVydHkoXCJfX2JydXNoXCIsIGluaXRpYWxpemUpXG4gICAgICAuc2VsZWN0QWxsKFwiLm92ZXJsYXlcIilcbiAgICAgIC5kYXRhKFt0eXBlKFwib3ZlcmxheVwiKV0pO1xuXG4gICAgb3ZlcmxheS5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm92ZXJsYXlcIilcbiAgICAgICAgLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKVxuICAgICAgICAuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzLm92ZXJsYXkpXG4gICAgICAubWVyZ2Uob3ZlcmxheSlcbiAgICAgICAgLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGV4dGVudCA9IGxvY2FsJCQxKHRoaXMpLmV4dGVudDtcbiAgICAgICAgICBzZWxlY3QodGhpcylcbiAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIGV4dGVudFswXVswXSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJ5XCIsIGV4dGVudFswXVsxXSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0pXG4gICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSk7XG4gICAgICAgIH0pO1xuXG4gICAgZ3JvdXAuc2VsZWN0QWxsKFwiLnNlbGVjdGlvblwiKVxuICAgICAgLmRhdGEoW3R5cGUoXCJzZWxlY3Rpb25cIildKVxuICAgICAgLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwic2VsZWN0aW9uXCIpXG4gICAgICAgIC5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMuc2VsZWN0aW9uKVxuICAgICAgICAuYXR0cihcImZpbGxcIiwgXCIjNzc3XCIpXG4gICAgICAgIC5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIDAuMylcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCIjZmZmXCIpXG4gICAgICAgIC5hdHRyKFwic2hhcGUtcmVuZGVyaW5nXCIsIFwiY3Jpc3BFZGdlc1wiKTtcblxuICAgIHZhciBoYW5kbGUgPSBncm91cC5zZWxlY3RBbGwoXCIuaGFuZGxlXCIpXG4gICAgICAuZGF0YShkaW0uaGFuZGxlcywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlOyB9KTtcblxuICAgIGhhbmRsZS5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICBoYW5kbGUuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJoYW5kbGUgaGFuZGxlLS1cIiArIGQudHlwZTsgfSlcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gY3Vyc29yc1tkLnR5cGVdOyB9KTtcblxuICAgIGdyb3VwXG4gICAgICAgIC5lYWNoKHJlZHJhdylcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKVxuICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpXG4gICAgICAgIC5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIilcbiAgICAgICAgLm9uKFwibW91c2Vkb3duLmJydXNoIHRvdWNoc3RhcnQuYnJ1c2hcIiwgc3RhcnRlZCk7XG4gIH1cblxuICBicnVzaC5tb3ZlID0gZnVuY3Rpb24oZ3JvdXAsIHNlbGVjdGlvbiQkMSkge1xuICAgIGlmIChncm91cC5zZWxlY3Rpb24pIHtcbiAgICAgIGdyb3VwXG4gICAgICAgICAgLm9uKFwic3RhcnQuYnJ1c2hcIiwgZnVuY3Rpb24oKSB7IGVtaXR0ZXIodGhpcywgYXJndW1lbnRzKS5iZWZvcmVzdGFydCgpLnN0YXJ0KCk7IH0pXG4gICAgICAgICAgLm9uKFwiaW50ZXJydXB0LmJydXNoIGVuZC5icnVzaFwiLCBmdW5jdGlvbigpIHsgZW1pdHRlcih0aGlzLCBhcmd1bWVudHMpLmVuZCgpOyB9KVxuICAgICAgICAgIC50d2VlbihcImJydXNoXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHN0YXRlID0gdGhhdC5fX2JydXNoLFxuICAgICAgICAgICAgICAgIGVtaXQgPSBlbWl0dGVyKHRoYXQsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uMCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24xID0gZGltLmlucHV0KHR5cGVvZiBzZWxlY3Rpb24kJDEgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdGlvbiQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc2VsZWN0aW9uJCQxLCBzdGF0ZS5leHRlbnQpLFxuICAgICAgICAgICAgICAgIGkgPSBpbnRlcnBvbGF0ZVZhbHVlKHNlbGVjdGlvbjAsIHNlbGVjdGlvbjEpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB0d2Vlbih0KSB7XG4gICAgICAgICAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IHQgPT09IDEgJiYgZW1wdHkoc2VsZWN0aW9uMSkgPyBudWxsIDogaSh0KTtcbiAgICAgICAgICAgICAgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgICAgICAgICAgIGVtaXQuYnJ1c2goKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjAgJiYgc2VsZWN0aW9uMSA/IHR3ZWVuIDogdHdlZW4oMSk7XG4gICAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwXG4gICAgICAgICAgLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHRoYXQuX19icnVzaCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24xID0gZGltLmlucHV0KHR5cGVvZiBzZWxlY3Rpb24kJDEgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdGlvbiQkMS5hcHBseSh0aGF0LCBhcmdzKSA6IHNlbGVjdGlvbiQkMSwgc3RhdGUuZXh0ZW50KSxcbiAgICAgICAgICAgICAgICBlbWl0ID0gZW1pdHRlcih0aGF0LCBhcmdzKS5iZWZvcmVzdGFydCgpO1xuXG4gICAgICAgICAgICBpbnRlcnJ1cHQodGhhdCk7XG4gICAgICAgICAgICBzdGF0ZS5zZWxlY3Rpb24gPSBzZWxlY3Rpb24xID09IG51bGwgfHwgZW1wdHkoc2VsZWN0aW9uMSkgPyBudWxsIDogc2VsZWN0aW9uMTtcbiAgICAgICAgICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgICAgICAgZW1pdC5zdGFydCgpLmJydXNoKCkuZW5kKCk7XG4gICAgICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZHJhdygpIHtcbiAgICB2YXIgZ3JvdXAgPSBzZWxlY3QodGhpcyksXG4gICAgICAgIHNlbGVjdGlvbiQkMSA9IGxvY2FsJCQxKHRoaXMpLnNlbGVjdGlvbjtcblxuICAgIGlmIChzZWxlY3Rpb24kJDEpIHtcbiAgICAgIGdyb3VwLnNlbGVjdEFsbChcIi5zZWxlY3Rpb25cIilcbiAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIHNlbGVjdGlvbiQkMVswXVswXSlcbiAgICAgICAgICAuYXR0cihcInlcIiwgc2VsZWN0aW9uJCQxWzBdWzFdKVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgc2VsZWN0aW9uJCQxWzFdWzBdIC0gc2VsZWN0aW9uJCQxWzBdWzBdKVxuICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHNlbGVjdGlvbiQkMVsxXVsxXSAtIHNlbGVjdGlvbiQkMVswXVsxXSk7XG5cbiAgICAgIGdyb3VwLnNlbGVjdEFsbChcIi5oYW5kbGVcIilcbiAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZVtkLnR5cGUubGVuZ3RoIC0gMV0gPT09IFwiZVwiID8gc2VsZWN0aW9uJCQxWzFdWzBdIC0gaGFuZGxlU2l6ZSAvIDIgOiBzZWxlY3Rpb24kJDFbMF1bMF0gLSBoYW5kbGVTaXplIC8gMjsgfSlcbiAgICAgICAgICAuYXR0cihcInlcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlWzBdID09PSBcInNcIiA/IHNlbGVjdGlvbiQkMVsxXVsxXSAtIGhhbmRsZVNpemUgLyAyIDogc2VsZWN0aW9uJCQxWzBdWzFdIC0gaGFuZGxlU2l6ZSAvIDI7IH0pXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGUgPT09IFwiblwiIHx8IGQudHlwZSA9PT0gXCJzXCIgPyBzZWxlY3Rpb24kJDFbMV1bMF0gLSBzZWxlY3Rpb24kJDFbMF1bMF0gKyBoYW5kbGVTaXplIDogaGFuZGxlU2l6ZTsgfSlcbiAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGUgPT09IFwiZVwiIHx8IGQudHlwZSA9PT0gXCJ3XCIgPyBzZWxlY3Rpb24kJDFbMV1bMV0gLSBzZWxlY3Rpb24kJDFbMF1bMV0gKyBoYW5kbGVTaXplIDogaGFuZGxlU2l6ZTsgfSk7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICBncm91cC5zZWxlY3RBbGwoXCIuc2VsZWN0aW9uLC5oYW5kbGVcIilcbiAgICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuICAgICAgICAgIC5hdHRyKFwieFwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwieVwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0dGVyKHRoYXQsIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhhdC5fX2JydXNoLmVtaXR0ZXIgfHwgbmV3IEVtaXR0ZXIodGhhdCwgYXJncyk7XG4gIH1cblxuICBmdW5jdGlvbiBFbWl0dGVyKHRoYXQsIGFyZ3MpIHtcbiAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgdGhpcy5zdGF0ZSA9IHRoYXQuX19icnVzaDtcbiAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gIH1cblxuICBFbWl0dGVyLnByb3RvdHlwZSA9IHtcbiAgICBiZWZvcmVzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKyt0aGlzLmFjdGl2ZSA9PT0gMSkgdGhpcy5zdGF0ZS5lbWl0dGVyID0gdGhpcywgdGhpcy5zdGFydGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnN0YXJ0aW5nKSB0aGlzLnN0YXJ0aW5nID0gZmFsc2UsIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBicnVzaDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVtaXQoXCJicnVzaFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRoaXMuYWN0aXZlID09PSAwKSBkZWxldGUgdGhpcy5zdGF0ZS5lbWl0dGVyLCB0aGlzLmVtaXQoXCJlbmRcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGN1c3RvbUV2ZW50KG5ldyBCcnVzaEV2ZW50KGJydXNoLCB0eXBlLCBkaW0ub3V0cHV0KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSksIGxpc3RlbmVycy5hcHBseSwgbGlzdGVuZXJzLCBbdHlwZSwgdGhpcy50aGF0LCB0aGlzLmFyZ3NdKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc3RhcnRlZCgpIHtcbiAgICBpZiAoZXhwb3J0cy5ldmVudC50b3VjaGVzKSB7IGlmIChleHBvcnRzLmV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA8IGV4cG9ydHMuZXZlbnQudG91Y2hlcy5sZW5ndGgpIHJldHVybiBub2V2ZW50JDEoKTsgfVxuICAgIGVsc2UgaWYgKHRvdWNoZW5kaW5nKSByZXR1cm47XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICB0eXBlID0gZXhwb3J0cy5ldmVudC50YXJnZXQuX19kYXRhX18udHlwZSxcbiAgICAgICAgbW9kZSA9IChleHBvcnRzLmV2ZW50Lm1ldGFLZXkgPyB0eXBlID0gXCJvdmVybGF5XCIgOiB0eXBlKSA9PT0gXCJzZWxlY3Rpb25cIiA/IE1PREVfRFJBRyA6IChleHBvcnRzLmV2ZW50LmFsdEtleSA/IE1PREVfQ0VOVEVSIDogTU9ERV9IQU5ETEUpLFxuICAgICAgICBzaWduWCA9IGRpbSA9PT0gWSA/IG51bGwgOiBzaWduc1hbdHlwZV0sXG4gICAgICAgIHNpZ25ZID0gZGltID09PSBYID8gbnVsbCA6IHNpZ25zWVt0eXBlXSxcbiAgICAgICAgc3RhdGUgPSBsb2NhbCQkMSh0aGF0KSxcbiAgICAgICAgZXh0ZW50ID0gc3RhdGUuZXh0ZW50LFxuICAgICAgICBzZWxlY3Rpb24kJDEgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgIFcgPSBleHRlbnRbMF1bMF0sIHcwLCB3MSxcbiAgICAgICAgTiA9IGV4dGVudFswXVsxXSwgbjAsIG4xLFxuICAgICAgICBFID0gZXh0ZW50WzFdWzBdLCBlMCwgZTEsXG4gICAgICAgIFMgPSBleHRlbnRbMV1bMV0sIHMwLCBzMSxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5LFxuICAgICAgICBtb3ZpbmcsXG4gICAgICAgIHNoaWZ0aW5nID0gc2lnblggJiYgc2lnblkgJiYgZXhwb3J0cy5ldmVudC5zaGlmdEtleSxcbiAgICAgICAgbG9ja1gsXG4gICAgICAgIGxvY2tZLFxuICAgICAgICBwb2ludDAgPSBtb3VzZSh0aGF0KSxcbiAgICAgICAgcG9pbnQgPSBwb2ludDAsXG4gICAgICAgIGVtaXQgPSBlbWl0dGVyKHRoYXQsIGFyZ3VtZW50cykuYmVmb3Jlc3RhcnQoKTtcblxuICAgIGlmICh0eXBlID09PSBcIm92ZXJsYXlcIikge1xuICAgICAgc3RhdGUuc2VsZWN0aW9uID0gc2VsZWN0aW9uJCQxID0gW1xuICAgICAgICBbdzAgPSBkaW0gPT09IFkgPyBXIDogcG9pbnQwWzBdLCBuMCA9IGRpbSA9PT0gWCA/IE4gOiBwb2ludDBbMV1dLFxuICAgICAgICBbZTAgPSBkaW0gPT09IFkgPyBFIDogdzAsIHMwID0gZGltID09PSBYID8gUyA6IG4wXVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdzAgPSBzZWxlY3Rpb24kJDFbMF1bMF07XG4gICAgICBuMCA9IHNlbGVjdGlvbiQkMVswXVsxXTtcbiAgICAgIGUwID0gc2VsZWN0aW9uJCQxWzFdWzBdO1xuICAgICAgczAgPSBzZWxlY3Rpb24kJDFbMV1bMV07XG4gICAgfVxuXG4gICAgdzEgPSB3MDtcbiAgICBuMSA9IG4wO1xuICAgIGUxID0gZTA7XG4gICAgczEgPSBzMDtcblxuICAgIHZhciBncm91cCA9IHNlbGVjdCh0aGF0KVxuICAgICAgICAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcblxuICAgIHZhciBvdmVybGF5ID0gZ3JvdXAuc2VsZWN0QWxsKFwiLm92ZXJsYXlcIilcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlXSk7XG5cbiAgICBpZiAoZXhwb3J0cy5ldmVudC50b3VjaGVzKSB7XG4gICAgICBncm91cFxuICAgICAgICAgIC5vbihcInRvdWNobW92ZS5icnVzaFwiLCBtb3ZlZCwgdHJ1ZSlcbiAgICAgICAgICAub24oXCJ0b3VjaGVuZC5icnVzaCB0b3VjaGNhbmNlbC5icnVzaFwiLCBlbmRlZCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gc2VsZWN0KGV4cG9ydHMuZXZlbnQudmlldylcbiAgICAgICAgICAub24oXCJrZXlkb3duLmJydXNoXCIsIGtleWRvd25lZCwgdHJ1ZSlcbiAgICAgICAgICAub24oXCJrZXl1cC5icnVzaFwiLCBrZXl1cHBlZCwgdHJ1ZSlcbiAgICAgICAgICAub24oXCJtb3VzZW1vdmUuYnJ1c2hcIiwgbW92ZWQsIHRydWUpXG4gICAgICAgICAgLm9uKFwibW91c2V1cC5icnVzaFwiLCBlbmRlZCwgdHJ1ZSk7XG5cbiAgICAgIGRyYWdEaXNhYmxlKGV4cG9ydHMuZXZlbnQudmlldyk7XG4gICAgfVxuXG4gICAgbm9wcm9wYWdhdGlvbiQxKCk7XG4gICAgaW50ZXJydXB0KHRoYXQpO1xuICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgIGVtaXQuc3RhcnQoKTtcblxuICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgdmFyIHBvaW50MSA9IG1vdXNlKHRoYXQpO1xuICAgICAgaWYgKHNoaWZ0aW5nICYmICFsb2NrWCAmJiAhbG9ja1kpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHBvaW50MVswXSAtIHBvaW50WzBdKSA+IE1hdGguYWJzKHBvaW50MVsxXSAtIHBvaW50WzFdKSkgbG9ja1kgPSB0cnVlO1xuICAgICAgICBlbHNlIGxvY2tYID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBvaW50ID0gcG9pbnQxO1xuICAgICAgbW92aW5nID0gdHJ1ZTtcbiAgICAgIG5vZXZlbnQkMSgpO1xuICAgICAgbW92ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdmUoKSB7XG4gICAgICB2YXIgdDtcblxuICAgICAgZHggPSBwb2ludFswXSAtIHBvaW50MFswXTtcbiAgICAgIGR5ID0gcG9pbnRbMV0gLSBwb2ludDBbMV07XG5cbiAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlIE1PREVfU1BBQ0U6XG4gICAgICAgIGNhc2UgTU9ERV9EUkFHOiB7XG4gICAgICAgICAgaWYgKHNpZ25YKSBkeCA9IE1hdGgubWF4KFcgLSB3MCwgTWF0aC5taW4oRSAtIGUwLCBkeCkpLCB3MSA9IHcwICsgZHgsIGUxID0gZTAgKyBkeDtcbiAgICAgICAgICBpZiAoc2lnblkpIGR5ID0gTWF0aC5tYXgoTiAtIG4wLCBNYXRoLm1pbihTIC0gczAsIGR5KSksIG4xID0gbjAgKyBkeSwgczEgPSBzMCArIGR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTU9ERV9IQU5ETEU6IHtcbiAgICAgICAgICBpZiAoc2lnblggPCAwKSBkeCA9IE1hdGgubWF4KFcgLSB3MCwgTWF0aC5taW4oRSAtIHcwLCBkeCkpLCB3MSA9IHcwICsgZHgsIGUxID0gZTA7XG4gICAgICAgICAgZWxzZSBpZiAoc2lnblggPiAwKSBkeCA9IE1hdGgubWF4KFcgLSBlMCwgTWF0aC5taW4oRSAtIGUwLCBkeCkpLCB3MSA9IHcwLCBlMSA9IGUwICsgZHg7XG4gICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgZHkgPSBNYXRoLm1heChOIC0gbjAsIE1hdGgubWluKFMgLSBuMCwgZHkpKSwgbjEgPSBuMCArIGR5LCBzMSA9IHMwO1xuICAgICAgICAgIGVsc2UgaWYgKHNpZ25ZID4gMCkgZHkgPSBNYXRoLm1heChOIC0gczAsIE1hdGgubWluKFMgLSBzMCwgZHkpKSwgbjEgPSBuMCwgczEgPSBzMCArIGR5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTU9ERV9DRU5URVI6IHtcbiAgICAgICAgICBpZiAoc2lnblgpIHcxID0gTWF0aC5tYXgoVywgTWF0aC5taW4oRSwgdzAgLSBkeCAqIHNpZ25YKSksIGUxID0gTWF0aC5tYXgoVywgTWF0aC5taW4oRSwgZTAgKyBkeCAqIHNpZ25YKSk7XG4gICAgICAgICAgaWYgKHNpZ25ZKSBuMSA9IE1hdGgubWF4KE4sIE1hdGgubWluKFMsIG4wIC0gZHkgKiBzaWduWSkpLCBzMSA9IE1hdGgubWF4KE4sIE1hdGgubWluKFMsIHMwICsgZHkgKiBzaWduWSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlMSA8IHcxKSB7XG4gICAgICAgIHNpZ25YICo9IC0xO1xuICAgICAgICB0ID0gdzAsIHcwID0gZTAsIGUwID0gdDtcbiAgICAgICAgdCA9IHcxLCB3MSA9IGUxLCBlMSA9IHQ7XG4gICAgICAgIGlmICh0eXBlIGluIGZsaXBYKSBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29yc1t0eXBlID0gZmxpcFhbdHlwZV1dKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMxIDwgbjEpIHtcbiAgICAgICAgc2lnblkgKj0gLTE7XG4gICAgICAgIHQgPSBuMCwgbjAgPSBzMCwgczAgPSB0O1xuICAgICAgICB0ID0gbjEsIG4xID0gczEsIHMxID0gdDtcbiAgICAgICAgaWYgKHR5cGUgaW4gZmxpcFkpIG92ZXJsYXkuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzW3R5cGUgPSBmbGlwWVt0eXBlXV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uKSBzZWxlY3Rpb24kJDEgPSBzdGF0ZS5zZWxlY3Rpb247IC8vIE1heSBiZSBzZXQgYnkgYnJ1c2gubW92ZSFcbiAgICAgIGlmIChsb2NrWCkgdzEgPSBzZWxlY3Rpb24kJDFbMF1bMF0sIGUxID0gc2VsZWN0aW9uJCQxWzFdWzBdO1xuICAgICAgaWYgKGxvY2tZKSBuMSA9IHNlbGVjdGlvbiQkMVswXVsxXSwgczEgPSBzZWxlY3Rpb24kJDFbMV1bMV07XG5cbiAgICAgIGlmIChzZWxlY3Rpb24kJDFbMF1bMF0gIT09IHcxXG4gICAgICAgICAgfHwgc2VsZWN0aW9uJCQxWzBdWzFdICE9PSBuMVxuICAgICAgICAgIHx8IHNlbGVjdGlvbiQkMVsxXVswXSAhPT0gZTFcbiAgICAgICAgICB8fCBzZWxlY3Rpb24kJDFbMV1bMV0gIT09IHMxKSB7XG4gICAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IFtbdzEsIG4xXSwgW2UxLCBzMV1dO1xuICAgICAgICByZWRyYXcuY2FsbCh0aGF0KTtcbiAgICAgICAgZW1pdC5icnVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgbm9wcm9wYWdhdGlvbiQxKCk7XG4gICAgICBpZiAoZXhwb3J0cy5ldmVudC50b3VjaGVzKSB7XG4gICAgICAgIGlmIChleHBvcnRzLmV2ZW50LnRvdWNoZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICAgICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIDUwMCk7IC8vIEdob3N0IGNsaWNrcyBhcmUgZGVsYXllZCFcbiAgICAgICAgZ3JvdXAub24oXCJ0b3VjaG1vdmUuYnJ1c2ggdG91Y2hlbmQuYnJ1c2ggdG91Y2hjYW5jZWwuYnJ1c2hcIiwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ZXNkcmFnKGV4cG9ydHMuZXZlbnQudmlldywgbW92aW5nKTtcbiAgICAgICAgdmlldy5vbihcImtleWRvd24uYnJ1c2gga2V5dXAuYnJ1c2ggbW91c2Vtb3ZlLmJydXNoIG1vdXNldXAuYnJ1c2hcIiwgbnVsbCk7XG4gICAgICB9XG4gICAgICBncm91cC5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIik7XG4gICAgICBvdmVybGF5LmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29ycy5vdmVybGF5KTtcbiAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24pIHNlbGVjdGlvbiQkMSA9IHN0YXRlLnNlbGVjdGlvbjsgLy8gTWF5IGJlIHNldCBieSBicnVzaC5tb3ZlIChvbiBzdGFydCkhXG4gICAgICBpZiAoZW1wdHkoc2VsZWN0aW9uJCQxKSkgc3RhdGUuc2VsZWN0aW9uID0gbnVsbCwgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgICBlbWl0LmVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleWRvd25lZCgpIHtcbiAgICAgIHN3aXRjaCAoZXhwb3J0cy5ldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMTY6IHsgLy8gU0hJRlRcbiAgICAgICAgICBzaGlmdGluZyA9IHNpZ25YICYmIHNpZ25ZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTg6IHsgLy8gQUxUXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEFORExFKSB7XG4gICAgICAgICAgICBpZiAoc2lnblgpIGUwID0gZTEgLSBkeCAqIHNpZ25YLCB3MCA9IHcxICsgZHggKiBzaWduWDtcbiAgICAgICAgICAgIGlmIChzaWduWSkgczAgPSBzMSAtIGR5ICogc2lnblksIG4wID0gbjEgKyBkeSAqIHNpZ25ZO1xuICAgICAgICAgICAgbW9kZSA9IE1PREVfQ0VOVEVSO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMyOiB7IC8vIFNQQUNFOyB0YWtlcyBwcmlvcml0eSBvdmVyIEFMVFxuICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX0hBTkRMRSB8fCBtb2RlID09PSBNT0RFX0NFTlRFUikge1xuICAgICAgICAgICAgaWYgKHNpZ25YIDwgMCkgZTAgPSBlMSAtIGR4OyBlbHNlIGlmIChzaWduWCA+IDApIHcwID0gdzEgLSBkeDtcbiAgICAgICAgICAgIGlmIChzaWduWSA8IDApIHMwID0gczEgLSBkeTsgZWxzZSBpZiAoc2lnblkgPiAwKSBuMCA9IG4xIC0gZHk7XG4gICAgICAgICAgICBtb2RlID0gTU9ERV9TUEFDRTtcbiAgICAgICAgICAgIG92ZXJsYXkuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZXZlbnQkMSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXVwcGVkKCkge1xuICAgICAgc3dpdGNoIChleHBvcnRzLmV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxNjogeyAvLyBTSElGVFxuICAgICAgICAgIGlmIChzaGlmdGluZykge1xuICAgICAgICAgICAgbG9ja1ggPSBsb2NrWSA9IHNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTg6IHsgLy8gQUxUXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfQ0VOVEVSKSB7XG4gICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxOyBlbHNlIGlmIChzaWduWCA+IDApIHcwID0gdzE7XG4gICAgICAgICAgICBpZiAoc2lnblkgPCAwKSBzMCA9IHMxOyBlbHNlIGlmIChzaWduWSA+IDApIG4wID0gbjE7XG4gICAgICAgICAgICBtb2RlID0gTU9ERV9IQU5ETEU7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzI6IHsgLy8gU1BBQ0VcbiAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9TUEFDRSkge1xuICAgICAgICAgICAgaWYgKGV4cG9ydHMuZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICAgIGlmIChzaWduWCkgZTAgPSBlMSAtIGR4ICogc2lnblgsIHcwID0gdzEgKyBkeCAqIHNpZ25YO1xuICAgICAgICAgICAgICBpZiAoc2lnblkpIHMwID0gczEgLSBkeSAqIHNpZ25ZLCBuMCA9IG4xICsgZHkgKiBzaWduWTtcbiAgICAgICAgICAgICAgbW9kZSA9IE1PREVfQ0VOVEVSO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHNpZ25YIDwgMCkgZTAgPSBlMTsgZWxzZSBpZiAoc2lnblggPiAwKSB3MCA9IHcxO1xuICAgICAgICAgICAgICBpZiAoc2lnblkgPCAwKSBzMCA9IHMxOyBlbHNlIGlmIChzaWduWSA+IDApIG4wID0gbjE7XG4gICAgICAgICAgICAgIG1vZGUgPSBNT0RFX0hBTkRMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG92ZXJsYXkuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzW3R5cGVdKTtcbiAgICAgICAgICAgIG1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9ldmVudCQxKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9fYnJ1c2ggfHwge3NlbGVjdGlvbjogbnVsbH07XG4gICAgc3RhdGUuZXh0ZW50ID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgc3RhdGUuZGltID0gZGltO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGJydXNoLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDQoW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0pLCBicnVzaCkgOiBleHRlbnQ7XG4gIH07XG5cbiAgYnJ1c2guZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNCghIV8pLCBicnVzaCkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgYnJ1c2guaGFuZGxlU2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChoYW5kbGVTaXplID0gK18sIGJydXNoKSA6IGhhbmRsZVNpemU7XG4gIH07XG5cbiAgYnJ1c2gub24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUgPSBsaXN0ZW5lcnMub24uYXBwbHkobGlzdGVuZXJzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbGlzdGVuZXJzID8gYnJ1c2ggOiB2YWx1ZTtcbiAgfTtcblxuICByZXR1cm4gYnJ1c2g7XG59XG5cbnZhciBjb3MgPSBNYXRoLmNvcztcbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBwaSQxID0gTWF0aC5QSTtcbnZhciBoYWxmUGkkMSA9IHBpJDEgLyAyO1xudmFyIHRhdSQxID0gcGkkMSAqIDI7XG52YXIgbWF4JDEgPSBNYXRoLm1heDtcblxuZnVuY3Rpb24gY29tcGFyZVZhbHVlKGNvbXBhcmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZShcbiAgICAgIGEuc291cmNlLnZhbHVlICsgYS50YXJnZXQudmFsdWUsXG4gICAgICBiLnNvdXJjZS52YWx1ZSArIGIudGFyZ2V0LnZhbHVlXG4gICAgKTtcbiAgfTtcbn1cblxudmFyIGNob3JkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYWRBbmdsZSA9IDAsXG4gICAgICBzb3J0R3JvdXBzID0gbnVsbCxcbiAgICAgIHNvcnRTdWJncm91cHMgPSBudWxsLFxuICAgICAgc29ydENob3JkcyA9IG51bGw7XG5cbiAgZnVuY3Rpb24gY2hvcmQobWF0cml4KSB7XG4gICAgdmFyIG4gPSBtYXRyaXgubGVuZ3RoLFxuICAgICAgICBncm91cFN1bXMgPSBbXSxcbiAgICAgICAgZ3JvdXBJbmRleCA9IHNlcXVlbmNlKG4pLFxuICAgICAgICBzdWJncm91cEluZGV4ID0gW10sXG4gICAgICAgIGNob3JkcyA9IFtdLFxuICAgICAgICBncm91cHMgPSBjaG9yZHMuZ3JvdXBzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBzdWJncm91cHMgPSBuZXcgQXJyYXkobiAqIG4pLFxuICAgICAgICBrLFxuICAgICAgICB4LFxuICAgICAgICB4MCxcbiAgICAgICAgZHgsXG4gICAgICAgIGksXG4gICAgICAgIGo7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBzdW0uXG4gICAgayA9IDAsIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHggPSAwLCBqID0gLTE7IHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgIHggKz0gbWF0cml4W2ldW2pdO1xuICAgICAgfVxuICAgICAgZ3JvdXBTdW1zLnB1c2goeCk7XG4gICAgICBzdWJncm91cEluZGV4LnB1c2goc2VxdWVuY2UobikpO1xuICAgICAgayArPSB4O1xuICAgIH1cblxuICAgIC8vIFNvcnQgZ3JvdXBz4oCmXG4gICAgaWYgKHNvcnRHcm91cHMpIGdyb3VwSW5kZXguc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gc29ydEdyb3Vwcyhncm91cFN1bXNbYV0sIGdyb3VwU3Vtc1tiXSk7XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0IHN1Ymdyb3Vwc+KAplxuICAgIGlmIChzb3J0U3ViZ3JvdXBzKSBzdWJncm91cEluZGV4LmZvckVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRTdWJncm91cHMobWF0cml4W2ldW2FdLCBtYXRyaXhbaV1bYl0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBzdW0gdG8gc2NhbGluZyBmYWN0b3IgZm9yIFswLCAycGldLlxuICAgIC8vIFRPRE8gQWxsb3cgc3RhcnQgYW5kIGVuZCBhbmdsZSB0byBiZSBzcGVjaWZpZWQ/XG4gICAgLy8gVE9ETyBBbGxvdyBwYWRkaW5nIHRvIGJlIHNwZWNpZmllZCBhcyBwZXJjZW50YWdlP1xuICAgIGsgPSBtYXgkMSgwLCB0YXUkMSAtIHBhZEFuZ2xlICogbikgLyBrO1xuICAgIGR4ID0gayA/IHBhZEFuZ2xlIDogdGF1JDEgLyBuO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgc3RhcnQgYW5kIGVuZCBhbmdsZSBmb3IgZWFjaCBncm91cCBhbmQgc3ViZ3JvdXAuXG4gICAgLy8gTm90ZTogT3BlcmEgaGFzIGEgYnVnIHJlb3JkZXJpbmcgb2JqZWN0IGxpdGVyYWwgcHJvcGVydGllcyFcbiAgICB4ID0gMCwgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgeDAgPSB4LCBqID0gLTE7IHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgIHZhciBkaSA9IGdyb3VwSW5kZXhbaV0sXG4gICAgICAgICAgICBkaiA9IHN1Ymdyb3VwSW5kZXhbZGldW2pdLFxuICAgICAgICAgICAgdiA9IG1hdHJpeFtkaV1bZGpdLFxuICAgICAgICAgICAgYTAgPSB4LFxuICAgICAgICAgICAgYTEgPSB4ICs9IHYgKiBrO1xuICAgICAgICBzdWJncm91cHNbZGogKiBuICsgZGldID0ge1xuICAgICAgICAgIGluZGV4OiBkaSxcbiAgICAgICAgICBzdWJpbmRleDogZGosXG4gICAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgICAgZW5kQW5nbGU6IGExLFxuICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBncm91cHNbZGldID0ge1xuICAgICAgICBpbmRleDogZGksXG4gICAgICAgIHN0YXJ0QW5nbGU6IHgwLFxuICAgICAgICBlbmRBbmdsZTogeCxcbiAgICAgICAgdmFsdWU6IGdyb3VwU3Vtc1tkaV1cbiAgICAgIH07XG4gICAgICB4ICs9IGR4O1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGNob3JkcyBmb3IgZWFjaCAobm9uLWVtcHR5KSBzdWJncm91cC1zdWJncm91cCBsaW5rLlxuICAgIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGogPSBpIC0gMTsgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN1Ymdyb3Vwc1tqICogbiArIGldLFxuICAgICAgICAgICAgdGFyZ2V0ID0gc3ViZ3JvdXBzW2kgKiBuICsgal07XG4gICAgICAgIGlmIChzb3VyY2UudmFsdWUgfHwgdGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgY2hvcmRzLnB1c2goc291cmNlLnZhbHVlIDwgdGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgID8ge3NvdXJjZTogdGFyZ2V0LCB0YXJnZXQ6IHNvdXJjZX1cbiAgICAgICAgICAgICAgOiB7c291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydENob3JkcyA/IGNob3Jkcy5zb3J0KHNvcnRDaG9yZHMpIDogY2hvcmRzO1xuICB9XG5cbiAgY2hvcmQucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSBtYXgkMSgwLCBfKSwgY2hvcmQpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgY2hvcmQuc29ydEdyb3VwcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0R3JvdXBzID0gXywgY2hvcmQpIDogc29ydEdyb3VwcztcbiAgfTtcblxuICBjaG9yZC5zb3J0U3ViZ3JvdXBzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvcnRTdWJncm91cHMgPSBfLCBjaG9yZCkgOiBzb3J0U3ViZ3JvdXBzO1xuICB9O1xuXG4gIGNob3JkLnNvcnRDaG9yZHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gc29ydENob3JkcyA9IG51bGwgOiAoc29ydENob3JkcyA9IGNvbXBhcmVWYWx1ZShfKSkuXyA9IF8sIGNob3JkKSA6IHNvcnRDaG9yZHMgJiYgc29ydENob3Jkcy5fO1xuICB9O1xuXG4gIHJldHVybiBjaG9yZDtcbn07XG5cbnZhciBzbGljZSQyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG52YXIgY29uc3RhbnQkNSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxudmFyIHBpJDIgPSBNYXRoLlBJO1xudmFyIHRhdSQyID0gMiAqIHBpJDI7XG52YXIgZXBzaWxvbiQxID0gMWUtNjtcbnZhciB0YXVFcHNpbG9uID0gdGF1JDIgLSBlcHNpbG9uJDE7XG5cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5fID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIG5ldyBQYXRoO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHBhdGgucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGF0aCxcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuXyArPSBcIlpcIjtcbiAgICB9XG4gIH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJRXCIgKyAoK3gxKSArIFwiLFwiICsgKCt5MSkgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkNcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKCt4MikgKyBcIixcIiArICgreTIpICsgXCIsXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgfSxcbiAgYXJjVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByKSB7XG4gICAgeDEgPSAreDEsIHkxID0gK3kxLCB4MiA9ICt4MiwgeTIgPSAreTIsIHIgPSArcjtcbiAgICB2YXIgeDAgPSB0aGlzLl94MSxcbiAgICAgICAgeTAgPSB0aGlzLl95MSxcbiAgICAgICAgeDIxID0geDIgLSB4MSxcbiAgICAgICAgeTIxID0geTIgLSB5MSxcbiAgICAgICAgeDAxID0geDAgLSB4MSxcbiAgICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDEseTEpLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3IsIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4MCx5MCk/IERvIG5vdGhpbmcuXG4gICAgZWxzZSBpZiAoIShsMDFfMiA+IGVwc2lsb24kMSkpIHt9XG5cbiAgICAvLyBPciwgYXJlICh4MCx5MCksICh4MSx5MSkgYW5kICh4Mix5MikgY29sbGluZWFyP1xuICAgIC8vIEVxdWl2YWxlbnRseSwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgyLHkyKT9cbiAgICAvLyBPciwgaXMgdGhlIHJhZGl1cyB6ZXJvPyBMaW5lIHRvICh4MSx5MSkuXG4gICAgZWxzZSBpZiAoIShNYXRoLmFicyh5MDEgKiB4MjEgLSB5MjEgKiB4MDEpID4gZXBzaWxvbiQxKSB8fCAhcikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBkcmF3IGFuIGFyYyFcbiAgICBlbHNlIHtcbiAgICAgIHZhciB4MjAgPSB4MiAtIHgwLFxuICAgICAgICAgIHkyMCA9IHkyIC0geTAsXG4gICAgICAgICAgbDIxXzIgPSB4MjEgKiB4MjEgKyB5MjEgKiB5MjEsXG4gICAgICAgICAgbDIwXzIgPSB4MjAgKiB4MjAgKyB5MjAgKiB5MjAsXG4gICAgICAgICAgbDIxID0gTWF0aC5zcXJ0KGwyMV8yKSxcbiAgICAgICAgICBsMDEgPSBNYXRoLnNxcnQobDAxXzIpLFxuICAgICAgICAgIGwgPSByICogTWF0aC50YW4oKHBpJDIgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbiQxKSB7XG4gICAgICAgIHRoaXMuXyArPSBcIkxcIiArICh4MSArIHQwMSAqIHgwMSkgKyBcIixcIiArICh5MSArIHQwMSAqIHkwMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDAsXCIgKyAoKyh5MDEgKiB4MjAgPiB4MDEgKiB5MjApKSArIFwiLFwiICsgKHRoaXMuX3gxID0geDEgKyB0MjEgKiB4MjEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSArIHQyMSAqIHkyMSk7XG4gICAgfVxuICB9LFxuICBhcmM6IGZ1bmN0aW9uKHgsIHksIHIsIGEwLCBhMSwgY2N3KSB7XG4gICAgeCA9ICt4LCB5ID0gK3ksIHIgPSArcjtcbiAgICB2YXIgZHggPSByICogTWF0aC5jb3MoYTApLFxuICAgICAgICBkeSA9IHIgKiBNYXRoLnNpbihhMCksXG4gICAgICAgIHgwID0geCArIGR4LFxuICAgICAgICB5MCA9IHkgKyBkeSxcbiAgICAgICAgY3cgPSAxIF4gY2N3LFxuICAgICAgICBkYSA9IGNjdyA/IGEwIC0gYTEgOiBhMSAtIGEwO1xuXG4gICAgLy8gSXMgdGhlIHJhZGl1cyBuZWdhdGl2ZT8gRXJyb3IuXG4gICAgaWYgKHIgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgcik7XG5cbiAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgwLHkwKS5cbiAgICBpZiAodGhpcy5feDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuXyArPSBcIk1cIiArIHgwICsgXCIsXCIgKyB5MDtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgwLHkwKSBub3QgY29pbmNpZGVudCB3aXRoIHRoZSBwcmV2aW91cyBwb2ludD8gTGluZSB0byAoeDAseTApLlxuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0geDApID4gZXBzaWxvbiQxIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbiQxKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyB4MCArIFwiLFwiICsgeTA7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgZW1wdHk/IFdl4oCZcmUgZG9uZS5cbiAgICBpZiAoIXIpIHJldHVybjtcblxuICAgIC8vIERvZXMgdGhlIGFuZ2xlIGdvIHRoZSB3cm9uZyB3YXk/IEZsaXAgdGhlIGRpcmVjdGlvbi5cbiAgICBpZiAoZGEgPCAwKSBkYSA9IGRhICUgdGF1JDIgKyB0YXUkMjtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbiQxKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCxcIiArICgrKGRhID49IHBpJDIpKSArIFwiLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHggKyByICogTWF0aC5jb3MoYTEpKSArIFwiLFwiICsgKHRoaXMuX3kxID0geSArIHIgKiBNYXRoLnNpbihhMSkpO1xuICAgIH1cbiAgfSxcbiAgcmVjdDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuICAgIHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MCA9IHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTAgPSB0aGlzLl95MSA9ICt5KSArIFwiaFwiICsgKCt3KSArIFwidlwiICsgKCtoKSArIFwiaFwiICsgKC13KSArIFwiWlwiO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuXztcbiAgfVxufTtcblxuZnVuY3Rpb24gZGVmYXVsdFNvdXJjZShkKSB7XG4gIHJldHVybiBkLnNvdXJjZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRhcmdldChkKSB7XG4gIHJldHVybiBkLnRhcmdldDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJhZGl1cyhkKSB7XG4gIHJldHVybiBkLnJhZGl1cztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFN0YXJ0QW5nbGUoZCkge1xuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0RW5kQW5nbGUoZCkge1xuICByZXR1cm4gZC5lbmRBbmdsZTtcbn1cblxudmFyIHJpYmJvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc291cmNlID0gZGVmYXVsdFNvdXJjZSxcbiAgICAgIHRhcmdldCA9IGRlZmF1bHRUYXJnZXQsXG4gICAgICByYWRpdXMgPSBkZWZhdWx0UmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZSA9IGRlZmF1bHRTdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBkZWZhdWx0RW5kQW5nbGUsXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiByaWJib24oKSB7XG4gICAgdmFyIGJ1ZmZlcixcbiAgICAgICAgYXJndiA9IHNsaWNlJDIuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICBzID0gc291cmNlLmFwcGx5KHRoaXMsIGFyZ3YpLFxuICAgICAgICB0ID0gdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3YpLFxuICAgICAgICBzciA9ICtyYWRpdXMuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSBzLCBhcmd2KSksXG4gICAgICAgIHNhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndikgLSBoYWxmUGkkMSxcbiAgICAgICAgc2ExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndikgLSBoYWxmUGkkMSxcbiAgICAgICAgc3gwID0gc3IgKiBjb3Moc2EwKSxcbiAgICAgICAgc3kwID0gc3IgKiBzaW4oc2EwKSxcbiAgICAgICAgdHIgPSArcmFkaXVzLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gdCwgYXJndikpLFxuICAgICAgICB0YTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3YpIC0gaGFsZlBpJDEsXG4gICAgICAgIHRhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3YpIC0gaGFsZlBpJDE7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG5cbiAgICBjb250ZXh0Lm1vdmVUbyhzeDAsIHN5MCk7XG4gICAgY29udGV4dC5hcmMoMCwgMCwgc3IsIHNhMCwgc2ExKTtcbiAgICBpZiAoc2EwICE9PSB0YTAgfHwgc2ExICE9PSB0YTEpIHsgLy8gVE9ETyBzciAhPT0gdHI/XG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oMCwgMCwgdHIgKiBjb3ModGEwKSwgdHIgKiBzaW4odGEwKSk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCB0ciwgdGEwLCB0YTEpO1xuICAgIH1cbiAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oMCwgMCwgc3gwLCBzeTApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIHJpYmJvbi5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ1KCtfKSwgcmliYm9uKSA6IHJhZGl1cztcbiAgfTtcblxuICByaWJib24uc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ1KCtfKSwgcmliYm9uKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgcmliYm9uLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ1KCtfKSwgcmliYm9uKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIHJpYmJvbi5zb3VyY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc291cmNlID0gXywgcmliYm9uKSA6IHNvdXJjZTtcbiAgfTtcblxuICByaWJib24udGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIHJpYmJvbikgOiB0YXJnZXQ7XG4gIH07XG5cbiAgcmliYm9uLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIHJpYmJvbikgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiByaWJib247XG59O1xuXG52YXIgcHJlZml4ID0gXCIkXCI7XG5cbmZ1bmN0aW9uIE1hcCgpIHt9XG5cbk1hcC5wcm90b3R5cGUgPSBtYXAkMS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBNYXAsXG4gIGhhczogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIChwcmVmaXggKyBrZXkpIGluIHRoaXM7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXNbcHJlZml4ICsga2V5XTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdGhpc1twcmVmaXggKyBrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIHByb3BlcnR5ID0gcHJlZml4ICsga2V5O1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmIGRlbGV0ZSB0aGlzW3Byb3BlcnR5XTtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBkZWxldGUgdGhpc1twcm9wZXJ0eV07XG4gIH0sXG4gIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGtleXMucHVzaChwcm9wZXJ0eS5zbGljZSgxKSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH0sXG4gIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSB2YWx1ZXMucHVzaCh0aGlzW3Byb3BlcnR5XSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSxcbiAgZW50cmllczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZW50cmllcy5wdXNoKHtrZXk6IHByb3BlcnR5LnNsaWNlKDEpLCB2YWx1ZTogdGhpc1twcm9wZXJ0eV19KTtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSArK3NpemU7XG4gICAgcmV0dXJuIHNpemU7XG4gIH0sXG4gIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBlYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGYodGhpc1twcm9wZXJ0eV0sIHByb3BlcnR5LnNsaWNlKDEpLCB0aGlzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gbWFwJDEob2JqZWN0LCBmKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwO1xuXG4gIC8vIENvcHkgY29uc3RydWN0b3IuXG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXApIG9iamVjdC5lYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHsgbWFwLnNldChrZXksIHZhbHVlKTsgfSk7XG5cbiAgLy8gSW5kZXggYXJyYXkgYnkgbnVtZXJpYyBpbmRleCBvciBzcGVjaWZpZWQga2V5IGZ1bmN0aW9uLlxuICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgICAgbztcblxuICAgIGlmIChmID09IG51bGwpIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGksIG9iamVjdFtpXSk7XG4gICAgZWxzZSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChmKG8gPSBvYmplY3RbaV0sIGksIG9iamVjdCksIG8pO1xuICB9XG5cbiAgLy8gQ29udmVydCBvYmplY3QgdG8gbWFwLlxuICBlbHNlIGlmIChvYmplY3QpIGZvciAodmFyIGtleSBpbiBvYmplY3QpIG1hcC5zZXQoa2V5LCBvYmplY3Rba2V5XSk7XG5cbiAgcmV0dXJuIG1hcDtcbn1cblxudmFyIG5lc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGtleXMgPSBbXSxcbiAgICAgIHNvcnRLZXlzID0gW10sXG4gICAgICBzb3J0VmFsdWVzLFxuICAgICAgcm9sbHVwLFxuICAgICAgbmVzdDtcblxuICBmdW5jdGlvbiBhcHBseShhcnJheSwgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSB7XG4gICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSByZXR1cm4gcm9sbHVwICE9IG51bGxcbiAgICAgICAgPyByb2xsdXAoYXJyYXkpIDogKHNvcnRWYWx1ZXMgIT0gbnVsbFxuICAgICAgICA/IGFycmF5LnNvcnQoc29ydFZhbHVlcylcbiAgICAgICAgOiBhcnJheSk7XG5cbiAgICB2YXIgaSA9IC0xLFxuICAgICAgICBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBrZXkgPSBrZXlzW2RlcHRoKytdLFxuICAgICAgICBrZXlWYWx1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHZhbHVlc0J5S2V5ID0gbWFwJDEoKSxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICByZXN1bHQgPSBjcmVhdGVSZXN1bHQoKTtcblxuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWVzID0gdmFsdWVzQnlLZXkuZ2V0KGtleVZhbHVlID0ga2V5KHZhbHVlID0gYXJyYXlbaV0pICsgXCJcIikpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbdmFsdWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZXNCeUtleS5lYWNoKGZ1bmN0aW9uKHZhbHVlcywga2V5KSB7XG4gICAgICBzZXRSZXN1bHQocmVzdWx0LCBrZXksIGFwcGx5KHZhbHVlcywgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cmllcyhtYXAsIGRlcHRoKSB7XG4gICAgaWYgKCsrZGVwdGggPiBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcDtcbiAgICB2YXIgYXJyYXksIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCAtIDFdO1xuICAgIGlmIChyb2xsdXAgIT0gbnVsbCAmJiBkZXB0aCA+PSBrZXlzLmxlbmd0aCkgYXJyYXkgPSBtYXAuZW50cmllcygpO1xuICAgIGVsc2UgYXJyYXkgPSBbXSwgbWFwLmVhY2goZnVuY3Rpb24odiwgaykgeyBhcnJheS5wdXNoKHtrZXk6IGssIHZhbHVlczogZW50cmllcyh2LCBkZXB0aCl9KTsgfSk7XG4gICAgcmV0dXJuIHNvcnRLZXkgIT0gbnVsbCA/IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpOyB9KSA6IGFycmF5O1xuICB9XG5cbiAgcmV0dXJuIG5lc3QgPSB7XG4gICAgb2JqZWN0OiBmdW5jdGlvbihhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU9iamVjdCwgc2V0T2JqZWN0KTsgfSxcbiAgICBtYXA6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApOyB9LFxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBlbnRyaWVzKGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCksIDApOyB9LFxuICAgIGtleTogZnVuY3Rpb24oZCkgeyBrZXlzLnB1c2goZCk7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRLZXlzOiBmdW5jdGlvbihvcmRlcikgeyBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxuICAgIHNvcnRWYWx1ZXM6IGZ1bmN0aW9uKG9yZGVyKSB7IHNvcnRWYWx1ZXMgPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgcm9sbHVwOiBmdW5jdGlvbihmKSB7IHJvbGx1cCA9IGY7IHJldHVybiBuZXN0OyB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3QoKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gc2V0T2JqZWN0KG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXAoKSB7XG4gIHJldHVybiBtYXAkMSgpO1xufVxuXG5mdW5jdGlvbiBzZXRNYXAobWFwLCBrZXksIHZhbHVlKSB7XG4gIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIFNldCgpIHt9XG5cbnZhciBwcm90byA9IG1hcCQxLnByb3RvdHlwZTtcblxuU2V0LnByb3RvdHlwZSA9IHNldCQyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNldCxcbiAgaGFzOiBwcm90by5oYXMsXG4gIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YWx1ZSArPSBcIlwiO1xuICAgIHRoaXNbcHJlZml4ICsgdmFsdWVdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZTogcHJvdG8ucmVtb3ZlLFxuICBjbGVhcjogcHJvdG8uY2xlYXIsXG4gIHZhbHVlczogcHJvdG8ua2V5cyxcbiAgc2l6ZTogcHJvdG8uc2l6ZSxcbiAgZW1wdHk6IHByb3RvLmVtcHR5LFxuICBlYWNoOiBwcm90by5lYWNoXG59O1xuXG5mdW5jdGlvbiBzZXQkMihvYmplY3QsIGYpIHtcbiAgdmFyIHNldCA9IG5ldyBTZXQ7XG5cbiAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFNldCkgb2JqZWN0LmVhY2goZnVuY3Rpb24odmFsdWUpIHsgc2V0LmFkZCh2YWx1ZSk7IH0pO1xuXG4gIC8vIE90aGVyd2lzZSwgYXNzdW1lIGl04oCZcyBhbiBhcnJheS5cbiAgZWxzZSBpZiAob2JqZWN0KSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IG9iamVjdC5sZW5ndGg7XG4gICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIHNldC5hZGQob2JqZWN0W2ldKTtcbiAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBzZXQuYWRkKGYob2JqZWN0W2ldLCBpLCBvYmplY3QpKTtcbiAgfVxuXG4gIHJldHVybiBzZXQ7XG59XG5cbnZhciBrZXlzID0gZnVuY3Rpb24obWFwKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBtYXApIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn07XG5cbnZhciB2YWx1ZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSB2YWx1ZXMucHVzaChtYXBba2V5XSk7XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG52YXIgZW50cmllcyA9IGZ1bmN0aW9uKG1hcCkge1xuICB2YXIgZW50cmllcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSBlbnRyaWVzLnB1c2goe2tleToga2V5LCB2YWx1ZTogbWFwW2tleV19KTtcbiAgcmV0dXJuIGVudHJpZXM7XG59O1xuXG5mdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyBjb2x1bW5zLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdXCI7XG4gIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xuICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICByZXR1cm4gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xuICB9O1xufVxuXG4vLyBDb21wdXRlIHVuaXF1ZSBjb2x1bW5zIGluIG9yZGVyIG9mIGRpc2NvdmVyeS5cbmZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgY29sdW1ucyA9IFtdO1xuXG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gcm93KSB7XG4gICAgICBpZiAoIShjb2x1bW4gaW4gY29sdW1uU2V0KSkge1xuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbHVtbnM7XG59XG5cbnZhciBkc3YgPSBmdW5jdGlvbihkZWxpbWl0ZXIpIHtcbiAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cChcIltcXFwiXCIgKyBkZWxpbWl0ZXIgKyBcIlxcblxccl1cIiksXG4gICAgICBkZWxpbWl0ZXJDb2RlID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG5cbiAgZnVuY3Rpb24gcGFyc2UodGV4dCwgZikge1xuICAgIHZhciBjb252ZXJ0LCBjb2x1bW5zLCByb3dzID0gcGFyc2VSb3dzKHRleHQsIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgaWYgKGNvbnZlcnQpIHJldHVybiBjb252ZXJ0KHJvdywgaSAtIDEpO1xuICAgICAgY29sdW1ucyA9IHJvdywgY29udmVydCA9IGYgPyBjdXN0b21Db252ZXJ0ZXIocm93LCBmKSA6IG9iamVjdENvbnZlcnRlcihyb3cpO1xuICAgIH0pO1xuICAgIHJvd3MuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVJvd3ModGV4dCwgZikge1xuICAgIHZhciBFT0wgPSB7fSwgLy8gc2VudGluZWwgdmFsdWUgZm9yIGVuZC1vZi1saW5lXG4gICAgICAgIEVPRiA9IHt9LCAvLyBzZW50aW5lbCB2YWx1ZSBmb3IgZW5kLW9mLWZpbGVcbiAgICAgICAgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICBOID0gdGV4dC5sZW5ndGgsXG4gICAgICAgIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICBuID0gMCwgLy8gdGhlIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgdCwgLy8gdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgZW9sOyAvLyBpcyB0aGUgY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0w/XG5cbiAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgIGlmIChJID49IE4pIHJldHVybiBFT0Y7IC8vIHNwZWNpYWwgY2FzZTogZW5kIG9mIGZpbGVcbiAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MOyAvLyBzcGVjaWFsIGNhc2U6IGVuZCBvZiBsaW5lXG5cbiAgICAgIC8vIHNwZWNpYWwgY2FzZTogcXVvdGVzXG4gICAgICB2YXIgaiA9IEksIGM7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSAzNCkge1xuICAgICAgICB2YXIgaSA9IGo7XG4gICAgICAgIHdoaWxlIChpKysgPCBOKSB7XG4gICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpKSA9PT0gMzQpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDEpICE9PSAzNCkgYnJlYWs7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEkgPSBpICsgMjtcbiAgICAgICAgYyA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgIGlmIChjID09PSAxMykge1xuICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpICsgMikgPT09IDEwKSArK0k7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMTApIHtcbiAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tbW9uIGNhc2U6IGZpbmQgbmV4dCBkZWxpbWl0ZXIgb3IgbmV3bGluZVxuICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgIHZhciBrID0gMTtcbiAgICAgICAgYyA9IHRleHQuY2hhckNvZGVBdChJKyspO1xuICAgICAgICBpZiAoYyA9PT0gMTApIGVvbCA9IHRydWU7IC8vIFxcblxuICAgICAgICBlbHNlIGlmIChjID09PSAxMykgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSAxMCkgKytJLCArK2s7IH0gLy8gXFxyfFxcclxcblxuICAgICAgICBlbHNlIGlmIChjICE9PSBkZWxpbWl0ZXJDb2RlKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgSSAtIGspO1xuICAgICAgfVxuXG4gICAgICAvLyBzcGVjaWFsIGNhc2U6IGxhc3QgdG9rZW4gYmVmb3JlIEVPRlxuICAgICAgcmV0dXJuIHRleHQuc2xpY2Uoaik7XG4gICAgfVxuXG4gICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgdmFyIGEgPSBbXTtcbiAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSB7XG4gICAgICAgIGEucHVzaCh0KTtcbiAgICAgICAgdCA9IHRva2VuKCk7XG4gICAgICB9XG4gICAgICBpZiAoZiAmJiAoYSA9IGYoYSwgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICByb3dzLnB1c2goYSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIFtjb2x1bW5zLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpXS5jb25jYXQocm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbY29sdW1uXSk7XG4gICAgICB9KS5qb2luKGRlbGltaXRlcik7XG4gICAgfSkpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3dzKHJvd3MpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZm9ybWF0Um93KS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93KHJvdykge1xuICAgIHJldHVybiByb3cubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQgPT0gbnVsbCA/IFwiXCJcbiAgICAgICAgOiByZUZvcm1hdC50ZXN0KHRleHQgKz0gXCJcIikgPyBcIlxcXCJcIiArIHRleHQucmVwbGFjZSgvXFxcIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCJcbiAgICAgICAgOiB0ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZm9ybWF0Um93czogZm9ybWF0Um93c1xuICB9O1xufTtcblxudmFyIGNzdiA9IGRzdihcIixcIik7XG5cbnZhciBjc3ZQYXJzZSA9IGNzdi5wYXJzZTtcbnZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xudmFyIGNzdkZvcm1hdCA9IGNzdi5mb3JtYXQ7XG52YXIgY3N2Rm9ybWF0Um93cyA9IGNzdi5mb3JtYXRSb3dzO1xuXG52YXIgdHN2ID0gZHN2KFwiXFx0XCIpO1xuXG52YXIgdHN2UGFyc2UgPSB0c3YucGFyc2U7XG52YXIgdHN2UGFyc2VSb3dzID0gdHN2LnBhcnNlUm93cztcbnZhciB0c3ZGb3JtYXQgPSB0c3YuZm9ybWF0O1xudmFyIHRzdkZvcm1hdFJvd3MgPSB0c3YuZm9ybWF0Um93cztcblxudmFyIGNlbnRlciQxID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgbm9kZXM7XG5cbiAgaWYgKHggPT0gbnVsbCkgeCA9IDA7XG4gIGlmICh5ID09IG51bGwpIHkgPSAwO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBub2RlLFxuICAgICAgICBzeCA9IDAsXG4gICAgICAgIHN5ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgc3ggKz0gbm9kZS54LCBzeSArPSBub2RlLnk7XG4gICAgfVxuXG4gICAgZm9yIChzeCA9IHN4IC8gbiAtIHgsIHN5ID0gc3kgLyBuIC0geSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54IC09IHN4LCBub2RlLnkgLT0gc3k7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gK18sIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufTtcblxudmFyIGNvbnN0YW50JDYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn07XG5cbnZhciBqaWdnbGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDFlLTY7XG59O1xuXG52YXIgdHJlZV9hZGQgPSBmdW5jdGlvbihkKSB7XG4gIHZhciB4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSxcbiAgICAgIHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpO1xuICByZXR1cm4gYWRkKHRoaXMuY292ZXIoeCwgeSksIHgsIHksIGQpO1xufTtcblxuZnVuY3Rpb24gYWRkKHRyZWUsIHgsIHksIGQpIHtcbiAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gdHJlZTsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0cmVlLl9yb290LFxuICAgICAgbGVhZiA9IHtkYXRhOiBkfSxcbiAgICAgIHgwID0gdHJlZS5feDAsXG4gICAgICB5MCA9IHRyZWUuX3kwLFxuICAgICAgeDEgPSB0cmVlLl94MSxcbiAgICAgIHkxID0gdHJlZS5feTEsXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgeHAsXG4gICAgICB5cCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBGaW5kIHRoZSBleGlzdGluZyBsZWFmIGZvciB0aGUgbmV3IHBvaW50LCBvciBhZGQgaXQuXG4gIHdoaWxlIChub2RlLmxlbmd0aCkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmIChwYXJlbnQgPSBub2RlLCAhKG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xuICB9XG5cbiAgLy8gSXMgdGhlIG5ldyBwb2ludCBpcyBleGFjdGx5IGNvaW5jaWRlbnQgd2l0aCB0aGUgZXhpc3RpbmcgcG9pbnQ/XG4gIHhwID0gK3RyZWUuX3guY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICB5cCA9ICt0cmVlLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgaWYgKHggPT09IHhwICYmIHkgPT09IHlwKSByZXR1cm4gbGVhZi5uZXh0ID0gbm9kZSwgcGFyZW50ID8gcGFyZW50W2ldID0gbGVhZiA6IHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIE90aGVyd2lzZSwgc3BsaXQgdGhlIGxlYWYgbm9kZSB1bnRpbCB0aGUgb2xkIGFuZCBuZXcgcG9pbnQgYXJlIHNlcGFyYXRlZC5cbiAgZG8ge1xuICAgIHBhcmVudCA9IHBhcmVudCA/IHBhcmVudFtpXSA9IG5ldyBBcnJheSg0KSA6IHRyZWUuX3Jvb3QgPSBuZXcgQXJyYXkoNCk7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gIH0gd2hpbGUgKChpID0gYm90dG9tIDw8IDEgfCByaWdodCkgPT09IChqID0gKHlwID49IHltKSA8PCAxIHwgKHhwID49IHhtKSkpO1xuICByZXR1cm4gcGFyZW50W2pdID0gbm9kZSwgcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbn1cblxuZnVuY3Rpb24gYWRkQWxsKGRhdGEpIHtcbiAgdmFyIGQsIGksIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeHogPSBuZXcgQXJyYXkobiksXG4gICAgICB5eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHgwID0gSW5maW5pdHksXG4gICAgICB5MCA9IEluZmluaXR5LFxuICAgICAgeDEgPSAtSW5maW5pdHksXG4gICAgICB5MSA9IC1JbmZpbml0eTtcblxuICAvLyBDb21wdXRlIHRoZSBwb2ludHMgYW5kIHRoZWlyIGV4dGVudC5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkID0gZGF0YVtpXSkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgY29udGludWU7XG4gICAgeHpbaV0gPSB4O1xuICAgIHl6W2ldID0geTtcbiAgICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gICAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICAgIGlmICh5IDwgeTApIHkwID0geTtcbiAgICBpZiAoeSA+IHkxKSB5MSA9IHk7XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlIG5vICh2YWxpZCkgcG9pbnRzLCBpbmhlcml0IHRoZSBleGlzdGluZyBleHRlbnQuXG4gIGlmICh4MSA8IHgwKSB4MCA9IHRoaXMuX3gwLCB4MSA9IHRoaXMuX3gxO1xuICBpZiAoeTEgPCB5MCkgeTAgPSB0aGlzLl95MCwgeTEgPSB0aGlzLl95MTtcblxuICAvLyBFeHBhbmQgdGhlIHRyZWUgdG8gY292ZXIgdGhlIG5ldyBwb2ludHMuXG4gIHRoaXMuY292ZXIoeDAsIHkwKS5jb3Zlcih4MSwgeTEpO1xuXG4gIC8vIEFkZCB0aGUgbmV3IHBvaW50cy5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGFkZCh0aGlzLCB4eltpXSwgeXpbaV0sIGRhdGFbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciB0cmVlX2NvdmVyID0gZnVuY3Rpb24oeCwgeSkge1xuICBpZiAoaXNOYU4oeCA9ICt4KSB8fCBpc05hTih5ID0gK3kpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTE7XG5cbiAgLy8gSWYgdGhlIHF1YWR0cmVlIGhhcyBubyBleHRlbnQsIGluaXRpYWxpemUgdGhlbS5cbiAgLy8gSW50ZWdlciBleHRlbnQgYXJlIG5lY2Vzc2FyeSBzbyB0aGF0IGlmIHdlIGxhdGVyIGRvdWJsZSB0aGUgZXh0ZW50LFxuICAvLyB0aGUgZXhpc3RpbmcgcXVhZHJhbnQgYm91bmRhcmllcyBkb27igJl0IGNoYW5nZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3IhXG4gIGlmIChpc05hTih4MCkpIHtcbiAgICB4MSA9ICh4MCA9IE1hdGguZmxvb3IoeCkpICsgMTtcbiAgICB5MSA9ICh5MCA9IE1hdGguZmxvb3IoeSkpICsgMTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZG91YmxlIHJlcGVhdGVkbHkgdG8gY292ZXIuXG4gIGVsc2UgaWYgKHgwID4geCB8fCB4ID4geDEgfHwgeTAgPiB5IHx8IHkgPiB5MSkge1xuICAgIHZhciB6ID0geDEgLSB4MCxcbiAgICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgaTtcblxuICAgIHN3aXRjaCAoaSA9ICh5IDwgKHkwICsgeTEpIC8gMikgPDwgMSB8ICh4IDwgKHgwICsgeDEpIC8gMikpIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICBkbyBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIHdoaWxlICh6ICo9IDIsIHgxID0geDAgKyB6LCB5MSA9IHkwICsgeiwgeCA+IHgxIHx8IHkgPiB5MSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIGRvIHBhcmVudCA9IG5ldyBBcnJheSg0KSwgcGFyZW50W2ldID0gbm9kZSwgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgd2hpbGUgKHogKj0gMiwgeDAgPSB4MSAtIHosIHkxID0geTAgKyB6LCB4MCA+IHggfHwgeSA+IHkxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgZG8gcGFyZW50ID0gbmV3IEFycmF5KDQpLCBwYXJlbnRbaV0gPSBub2RlLCBub2RlID0gcGFyZW50O1xuICAgICAgICB3aGlsZSAoeiAqPSAyLCB4MSA9IHgwICsgeiwgeTAgPSB5MSAtIHosIHggPiB4MSB8fCB5MCA+IHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICBkbyBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIHdoaWxlICh6ICo9IDIsIHgwID0geDEgLSB6LCB5MCA9IHkxIC0geiwgeDAgPiB4IHx8IHkwID4geSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIC8vIElmIHRoZSBxdWFkdHJlZSBjb3ZlcnMgdGhlIHBvaW50IGFscmVhZHksIGp1c3QgcmV0dXJuLlxuICBlbHNlIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIHRyZWVfZGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IFtdO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyBkYXRhLnB1c2gobm9kZS5kYXRhKTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbnZhciB0cmVlX2V4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5jb3ZlcigrX1swXVswXSwgK19bMF1bMV0pLmNvdmVyKCtfWzFdWzBdLCArX1sxXVsxXSlcbiAgICAgIDogaXNOYU4odGhpcy5feDApID8gdW5kZWZpbmVkIDogW1t0aGlzLl94MCwgdGhpcy5feTBdLCBbdGhpcy5feDEsIHRoaXMuX3kxXV07XG59O1xuXG52YXIgUXVhZCA9IGZ1bmN0aW9uKG5vZGUsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMueDAgPSB4MDtcbiAgdGhpcy55MCA9IHkwO1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbn07XG5cbnZhciB0cmVlX2ZpbmQgPSBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgdmFyIGRhdGEsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgeDMgPSB0aGlzLl94MSxcbiAgICAgIHkzID0gdGhpcy5feTEsXG4gICAgICBxdWFkcyA9IFtdLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBxLFxuICAgICAgaTtcblxuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB4MCwgeTAsIHgzLCB5MykpO1xuICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICBlbHNlIHtcbiAgICB4MCA9IHggLSByYWRpdXMsIHkwID0geSAtIHJhZGl1cztcbiAgICB4MyA9IHggKyByYWRpdXMsIHkzID0geSArIHJhZGl1cztcbiAgICByYWRpdXMgKj0gcmFkaXVzO1xuICB9XG5cbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuXG4gICAgLy8gU3RvcCBzZWFyY2hpbmcgaWYgdGhpcyBxdWFkcmFudCBjYW7igJl0IGNvbnRhaW4gYSBjbG9zZXIgbm9kZS5cbiAgICBpZiAoIShub2RlID0gcS5ub2RlKVxuICAgICAgICB8fCAoeDEgPSBxLngwKSA+IHgzXG4gICAgICAgIHx8ICh5MSA9IHEueTApID4geTNcbiAgICAgICAgfHwgKHgyID0gcS54MSkgPCB4MFxuICAgICAgICB8fCAoeTIgPSBxLnkxKSA8IHkwKSBjb250aW51ZTtcblxuICAgIC8vIEJpc2VjdCB0aGUgY3VycmVudCBxdWFkcmFudC5cbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MSArIHgyKSAvIDIsXG4gICAgICAgICAgeW0gPSAoeTEgKyB5MikgLyAyO1xuXG4gICAgICBxdWFkcy5wdXNoKFxuICAgICAgICBuZXcgUXVhZChub2RlWzNdLCB4bSwgeW0sIHgyLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMl0sIHgxLCB5bSwgeG0sIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsxXSwgeG0sIHkxLCB4MiwgeW0pLFxuICAgICAgICBuZXcgUXVhZChub2RlWzBdLCB4MSwgeTEsIHhtLCB5bSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFZpc2l0IHRoZSBjbG9zZXN0IHF1YWRyYW50IGZpcnN0LlxuICAgICAgaWYgKGkgPSAoeSA+PSB5bSkgPDwgMSB8ICh4ID49IHhtKSkge1xuICAgICAgICBxID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdID0gcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV0gPSBxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZpc2l0IHRoaXMgcG9pbnQuIChWaXNpdGluZyBjb2luY2lkZW50IHBvaW50cyBpc27igJl0IG5lY2Vzc2FyeSEpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgZHggPSB4IC0gK3RoaXMuX3guY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGR5ID0geSAtICt0aGlzLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGQyIDwgcmFkaXVzKSB7XG4gICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHJhZGl1cyA9IGQyKTtcbiAgICAgICAgeDAgPSB4IC0gZCwgeTAgPSB5IC0gZDtcbiAgICAgICAgeDMgPSB4ICsgZCwgeTMgPSB5ICsgZDtcbiAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn07XG5cbnZhciB0cmVlX3JlbW92ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICByZXRhaW5lcixcbiAgICAgIHByZXZpb3VzLFxuICAgICAgbmV4dCxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdGhpcztcblxuICAvLyBGaW5kIHRoZSBsZWFmIG5vZGUgZm9yIHRoZSBwb2ludC5cbiAgLy8gV2hpbGUgZGVzY2VuZGluZywgYWxzbyByZXRhaW4gdGhlIGRlZXBlc3QgcGFyZW50IHdpdGggYSBub24tcmVtb3ZlZCBzaWJsaW5nLlxuICBpZiAobm9kZS5sZW5ndGgpIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKCEocGFyZW50ID0gbm9kZSwgbm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgYnJlYWs7XG4gICAgaWYgKHBhcmVudFsoaSArIDEpICYgM10gfHwgcGFyZW50WyhpICsgMikgJiAzXSB8fCBwYXJlbnRbKGkgKyAzKSAmIDNdKSByZXRhaW5lciA9IHBhcmVudCwgaiA9IGk7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBwb2ludCB0byByZW1vdmUuXG4gIHdoaWxlIChub2RlLmRhdGEgIT09IGQpIGlmICghKHByZXZpb3VzID0gbm9kZSwgbm9kZSA9IG5vZGUubmV4dCkpIHJldHVybiB0aGlzO1xuICBpZiAobmV4dCA9IG5vZGUubmV4dCkgZGVsZXRlIG5vZGUubmV4dDtcblxuICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29pbmNpZGVudCBwb2ludHMsIHJlbW92ZSBqdXN0IHRoZSBwb2ludC5cbiAgaWYgKHByZXZpb3VzKSByZXR1cm4gKG5leHQgPyBwcmV2aW91cy5uZXh0ID0gbmV4dCA6IGRlbGV0ZSBwcmV2aW91cy5uZXh0KSwgdGhpcztcblxuICAvLyBJZiB0aGlzIGlzIHRoZSByb290IHBvaW50LCByZW1vdmUgaXQuXG4gIGlmICghcGFyZW50KSByZXR1cm4gdGhpcy5fcm9vdCA9IG5leHQsIHRoaXM7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVhZi5cbiAgbmV4dCA/IHBhcmVudFtpXSA9IG5leHQgOiBkZWxldGUgcGFyZW50W2ldO1xuXG4gIC8vIElmIHRoZSBwYXJlbnQgbm93IGNvbnRhaW5zIGV4YWN0bHkgb25lIGxlYWYsIGNvbGxhcHNlIHN1cGVyZmx1b3VzIHBhcmVudHMuXG4gIGlmICgobm9kZSA9IHBhcmVudFswXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzJdIHx8IHBhcmVudFszXSlcbiAgICAgICYmIG5vZGUgPT09IChwYXJlbnRbM10gfHwgcGFyZW50WzJdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMF0pXG4gICAgICAmJiAhbm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZW1vdmVBbGwoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciB0cmVlX3Jvb3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59O1xuXG52YXIgdHJlZV9zaXplID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gKytzaXplOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBzaXplO1xufTtcblxudmFyIHRyZWVfdmlzaXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgcSwgbm9kZSA9IHRoaXMuX3Jvb3QsIGNoaWxkLCB4MCwgeTAsIHgxLCB5MTtcbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIGlmICghY2FsbGJhY2sobm9kZSA9IHEubm9kZSwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxKSAmJiBub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgdHJlZV92aXNpdEFmdGVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIG5leHQgPSBbXSwgcTtcbiAgaWYgKHRoaXMuX3Jvb3QpIHF1YWRzLnB1c2gobmV3IFF1YWQodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIHZhciBub2RlID0gcS5ub2RlO1xuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEsIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICB9XG4gICAgbmV4dC5wdXNoKHEpO1xuICB9XG4gIHdoaWxlIChxID0gbmV4dC5wb3AoKSkge1xuICAgIGNhbGxiYWNrKHEubm9kZSwgcS54MCwgcS55MCwgcS54MSwgcS55MSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0WChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG52YXIgdHJlZV94ID0gZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl94ID0gXywgdGhpcykgOiB0aGlzLl94O1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdFkoZCkge1xuICByZXR1cm4gZFsxXTtcbn1cblxudmFyIHRyZWVfeSA9IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feSA9IF8sIHRoaXMpIDogdGhpcy5feTtcbn07XG5cbmZ1bmN0aW9uIHF1YWR0cmVlKG5vZGVzLCB4LCB5KSB7XG4gIHZhciB0cmVlID0gbmV3IFF1YWR0cmVlKHggPT0gbnVsbCA/IGRlZmF1bHRYIDogeCwgeSA9PSBudWxsID8gZGVmYXVsdFkgOiB5LCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICByZXR1cm4gbm9kZXMgPT0gbnVsbCA/IHRyZWUgOiB0cmVlLmFkZEFsbChub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIFF1YWR0cmVlKHgsIHksIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgdGhpcy5fcm9vdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbGVhZl9jb3B5KGxlYWYpIHtcbiAgdmFyIGNvcHkgPSB7ZGF0YTogbGVhZi5kYXRhfSwgbmV4dCA9IGNvcHk7XG4gIHdoaWxlIChsZWFmID0gbGVhZi5uZXh0KSBuZXh0ID0gbmV4dC5uZXh0ID0ge2RhdGE6IGxlYWYuZGF0YX07XG4gIHJldHVybiBjb3B5O1xufVxuXG52YXIgdHJlZVByb3RvID0gcXVhZHRyZWUucHJvdG90eXBlID0gUXVhZHRyZWUucHJvdG90eXBlO1xuXG50cmVlUHJvdG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyBRdWFkdHJlZSh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSksXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIG5vZGVzLFxuICAgICAgY2hpbGQ7XG5cbiAgaWYgKCFub2RlKSByZXR1cm4gY29weTtcblxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcblxuICBub2RlcyA9IFt7c291cmNlOiBub2RlLCB0YXJnZXQ6IGNvcHkuX3Jvb3QgPSBuZXcgQXJyYXkoNCl9XTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlLnNvdXJjZVtpXSkge1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDQpfSk7XG4gICAgICAgIGVsc2Ugbm9kZS50YXJnZXRbaV0gPSBsZWFmX2NvcHkoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xudHJlZVByb3RvLmFkZEFsbCA9IGFkZEFsbDtcbnRyZWVQcm90by5jb3ZlciA9IHRyZWVfY292ZXI7XG50cmVlUHJvdG8uZGF0YSA9IHRyZWVfZGF0YTtcbnRyZWVQcm90by5leHRlbnQgPSB0cmVlX2V4dGVudDtcbnRyZWVQcm90by5maW5kID0gdHJlZV9maW5kO1xudHJlZVByb3RvLnJlbW92ZSA9IHRyZWVfcmVtb3ZlO1xudHJlZVByb3RvLnJlbW92ZUFsbCA9IHJlbW92ZUFsbDtcbnRyZWVQcm90by5yb290ID0gdHJlZV9yb290O1xudHJlZVByb3RvLnNpemUgPSB0cmVlX3NpemU7XG50cmVlUHJvdG8udmlzaXQgPSB0cmVlX3Zpc2l0O1xudHJlZVByb3RvLnZpc2l0QWZ0ZXIgPSB0cmVlX3Zpc2l0QWZ0ZXI7XG50cmVlUHJvdG8ueCA9IHRyZWVfeDtcbnRyZWVQcm90by55ID0gdHJlZV95O1xuXG5mdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueCArIGQudng7XG59XG5cbmZ1bmN0aW9uIHkoZCkge1xuICByZXR1cm4gZC55ICsgZC52eTtcbn1cblxudmFyIGNvbGxpZGUgPSBmdW5jdGlvbihyYWRpdXMpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgcmFkaWksXG4gICAgICBzdHJlbmd0aCA9IDEsXG4gICAgICBpdGVyYXRpb25zID0gMTtcblxuICBpZiAodHlwZW9mIHJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSByYWRpdXMgPSBjb25zdGFudCQ2KHJhZGl1cyA9PSBudWxsID8gMSA6ICtyYWRpdXMpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICB0cmVlLFxuICAgICAgICBub2RlLFxuICAgICAgICB4aSxcbiAgICAgICAgeWksXG4gICAgICAgIHJpLFxuICAgICAgICByaTI7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZXJhdGlvbnM7ICsraykge1xuICAgICAgdHJlZSA9IHF1YWR0cmVlKG5vZGVzLCB4LCB5KS52aXNpdEFmdGVyKHByZXBhcmUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHJpID0gcmFkaWlbbm9kZS5pbmRleF0sIHJpMiA9IHJpICogcmk7XG4gICAgICAgIHhpID0gbm9kZS54ICsgbm9kZS52eDtcbiAgICAgICAgeWkgPSBub2RlLnkgKyBub2RlLnZ5O1xuICAgICAgICB0cmVlLnZpc2l0KGFwcGx5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseShxdWFkLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgdmFyIGRhdGEgPSBxdWFkLmRhdGEsIHJqID0gcXVhZC5yLCByID0gcmkgKyByajtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmluZGV4ID4gbm9kZS5pbmRleCkge1xuICAgICAgICAgIHZhciB4ID0geGkgLSBkYXRhLnggLSBkYXRhLnZ4LFxuICAgICAgICAgICAgICB5ID0geWkgLSBkYXRhLnkgLSBkYXRhLnZ5LFxuICAgICAgICAgICAgICBsID0geCAqIHggKyB5ICogeTtcbiAgICAgICAgICBpZiAobCA8IHIgKiByKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZSgpLCBsICs9IHggKiB4O1xuICAgICAgICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUoKSwgbCArPSB5ICogeTtcbiAgICAgICAgICAgIGwgPSAociAtIChsID0gTWF0aC5zcXJ0KGwpKSkgLyBsICogc3RyZW5ndGg7XG4gICAgICAgICAgICBub2RlLnZ4ICs9ICh4ICo9IGwpICogKHIgPSAocmogKj0gcmopIC8gKHJpMiArIHJqKSk7XG4gICAgICAgICAgICBub2RlLnZ5ICs9ICh5ICo9IGwpICogcjtcbiAgICAgICAgICAgIGRhdGEudnggLT0geCAqIChyID0gMSAtIHIpO1xuICAgICAgICAgICAgZGF0YS52eSAtPSB5ICogcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHgwID4geGkgKyByIHx8IHgxIDwgeGkgLSByIHx8IHkwID4geWkgKyByIHx8IHkxIDwgeWkgLSByO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmUocXVhZCkge1xuICAgIGlmIChxdWFkLmRhdGEpIHJldHVybiBxdWFkLnIgPSByYWRpaVtxdWFkLmRhdGEuaW5kZXhdO1xuICAgIGZvciAodmFyIGkgPSBxdWFkLnIgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAocXVhZFtpXSAmJiBxdWFkW2ldLnIgPiBxdWFkLnIpIHtcbiAgICAgICAgcXVhZC5yID0gcXVhZFtpXS5yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xuICAgIHJhZGlpID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgcmFkaWlbbm9kZS5pbmRleF0gPSArcmFkaXVzKG5vZGUsIGksIG5vZGVzKTtcbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5pdGVyYXRpb25zID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgZm9yY2UpIDogaXRlcmF0aW9ucztcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9ICtfLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ2KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufTtcblxuZnVuY3Rpb24gaW5kZXgoZCkge1xuICByZXR1cm4gZC5pbmRleDtcbn1cblxuZnVuY3Rpb24gZmluZChub2RlQnlJZCwgbm9kZUlkKSB7XG4gIHZhciBub2RlID0gbm9kZUJ5SWQuZ2V0KG5vZGVJZCk7XG4gIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZzogXCIgKyBub2RlSWQpO1xuICByZXR1cm4gbm9kZTtcbn1cblxudmFyIGxpbmsgPSBmdW5jdGlvbihsaW5rcykge1xuICB2YXIgaWQgPSBpbmRleCxcbiAgICAgIHN0cmVuZ3RoID0gZGVmYXVsdFN0cmVuZ3RoLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgZGlzdGFuY2UgPSBjb25zdGFudCQ2KDMwKSxcbiAgICAgIGRpc3RhbmNlcyxcbiAgICAgIG5vZGVzLFxuICAgICAgY291bnQsXG4gICAgICBiaWFzLFxuICAgICAgaXRlcmF0aW9ucyA9IDE7XG5cbiAgaWYgKGxpbmtzID09IG51bGwpIGxpbmtzID0gW107XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFN0cmVuZ3RoKGxpbmspIHtcbiAgICByZXR1cm4gMSAvIE1hdGgubWluKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSwgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgayA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaW5rLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgbCwgYjsgaSA8IG47ICsraSkge1xuICAgICAgICBsaW5rID0gbGlua3NbaV0sIHNvdXJjZSA9IGxpbmsuc291cmNlLCB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgeCA9IHRhcmdldC54ICsgdGFyZ2V0LnZ4IC0gc291cmNlLnggLSBzb3VyY2UudnggfHwgamlnZ2xlKCk7XG4gICAgICAgIHkgPSB0YXJnZXQueSArIHRhcmdldC52eSAtIHNvdXJjZS55IC0gc291cmNlLnZ5IHx8IGppZ2dsZSgpO1xuICAgICAgICBsID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICBsID0gKGwgLSBkaXN0YW5jZXNbaV0pIC8gbCAqIGFscGhhICogc3RyZW5ndGhzW2ldO1xuICAgICAgICB4ICo9IGwsIHkgKj0gbDtcbiAgICAgICAgdGFyZ2V0LnZ4IC09IHggKiAoYiA9IGJpYXNbaV0pO1xuICAgICAgICB0YXJnZXQudnkgLT0geSAqIGI7XG4gICAgICAgIHNvdXJjZS52eCArPSB4ICogKGIgPSAxIC0gYik7XG4gICAgICAgIHNvdXJjZS52eSArPSB5ICogYjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBtID0gbGlua3MubGVuZ3RoLFxuICAgICAgICBub2RlQnlJZCA9IG1hcCQxKG5vZGVzLCBpZCksXG4gICAgICAgIGxpbms7XG5cbiAgICBmb3IgKGkgPSAwLCBjb3VudCA9IG5ldyBBcnJheShuKTsgaSA8IG07ICsraSkge1xuICAgICAgbGluayA9IGxpbmtzW2ldLCBsaW5rLmluZGV4ID0gaTtcbiAgICAgIGlmICh0eXBlb2YgbGluay5zb3VyY2UgIT09IFwib2JqZWN0XCIpIGxpbmsuc291cmNlID0gZmluZChub2RlQnlJZCwgbGluay5zb3VyY2UpO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rLnRhcmdldCAhPT0gXCJvYmplY3RcIikgbGluay50YXJnZXQgPSBmaW5kKG5vZGVCeUlkLCBsaW5rLnRhcmdldCk7XG4gICAgICBjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gPSAoY291bnRbbGluay5zb3VyY2UuaW5kZXhdIHx8IDApICsgMTtcbiAgICAgIGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSA9IChjb3VudFtsaW5rLnRhcmdldC5pbmRleF0gfHwgMCkgKyAxO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGJpYXMgPSBuZXcgQXJyYXkobSk7IGkgPCBtOyArK2kpIHtcbiAgICAgIGxpbmsgPSBsaW5rc1tpXSwgYmlhc1tpXSA9IGNvdW50W2xpbmsuc291cmNlLmluZGV4XSAvIChjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gKyBjb3VudFtsaW5rLnRhcmdldC5pbmRleF0pO1xuICAgIH1cblxuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShtKSwgaW5pdGlhbGl6ZVN0cmVuZ3RoKCk7XG4gICAgZGlzdGFuY2VzID0gbmV3IEFycmF5KG0pLCBpbml0aWFsaXplRGlzdGFuY2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVTdHJlbmd0aCgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gK3N0cmVuZ3RoKGxpbmtzW2ldLCBpLCBsaW5rcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZURpc3RhbmNlKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbGlua3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBkaXN0YW5jZXNbaV0gPSArZGlzdGFuY2UobGlua3NbaV0sIGksIGxpbmtzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2UubGlua3MgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGlua3MgPSBfLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IGxpbmtzO1xuICB9O1xuXG4gIGZvcmNlLmlkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlkID0gXywgZm9yY2UpIDogaWQ7XG4gIH07XG5cbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDYoK18pLCBpbml0aWFsaXplU3RyZW5ndGgoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2UgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDYoK18pLCBpbml0aWFsaXplRGlzdGFuY2UoKSwgZm9yY2UpIDogZGlzdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufTtcblxuZnVuY3Rpb24geCQxKGQpIHtcbiAgcmV0dXJuIGQueDtcbn1cblxuZnVuY3Rpb24geSQxKGQpIHtcbiAgcmV0dXJuIGQueTtcbn1cblxudmFyIGluaXRpYWxSYWRpdXMgPSAxMDtcbnZhciBpbml0aWFsQW5nbGUgPSBNYXRoLlBJICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuXG52YXIgc2ltdWxhdGlvbiA9IGZ1bmN0aW9uKG5vZGVzKSB7XG4gIHZhciBzaW11bGF0aW9uLFxuICAgICAgYWxwaGEgPSAxLFxuICAgICAgYWxwaGFNaW4gPSAwLjAwMSxcbiAgICAgIGFscGhhRGVjYXkgPSAxIC0gTWF0aC5wb3coYWxwaGFNaW4sIDEgLyAzMDApLFxuICAgICAgYWxwaGFUYXJnZXQgPSAwLFxuICAgICAgdmVsb2NpdHlEZWNheSA9IDAuNixcbiAgICAgIGZvcmNlcyA9IG1hcCQxKCksXG4gICAgICBzdGVwcGVyID0gdGltZXIoc3RlcCksXG4gICAgICBldmVudCA9IGRpc3BhdGNoKFwidGlja1wiLCBcImVuZFwiKTtcblxuICBpZiAobm9kZXMgPT0gbnVsbCkgbm9kZXMgPSBbXTtcblxuICBmdW5jdGlvbiBzdGVwKCkge1xuICAgIHRpY2soKTtcbiAgICBldmVudC5jYWxsKFwidGlja1wiLCBzaW11bGF0aW9uKTtcbiAgICBpZiAoYWxwaGEgPCBhbHBoYU1pbikge1xuICAgICAgc3RlcHBlci5zdG9wKCk7XG4gICAgICBldmVudC5jYWxsKFwiZW5kXCIsIHNpbXVsYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG5cbiAgICBhbHBoYSArPSAoYWxwaGFUYXJnZXQgLSBhbHBoYSkgKiBhbHBoYURlY2F5O1xuXG4gICAgZm9yY2VzLmVhY2goZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgIGZvcmNlKGFscGhhKTtcbiAgICB9KTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmZ4ID09IG51bGwpIG5vZGUueCArPSBub2RlLnZ4ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICBlbHNlIG5vZGUueCA9IG5vZGUuZngsIG5vZGUudnggPSAwO1xuICAgICAgaWYgKG5vZGUuZnkgPT0gbnVsbCkgbm9kZS55ICs9IG5vZGUudnkgKj0gdmVsb2NpdHlEZWNheTtcbiAgICAgIGVsc2Ugbm9kZS55ID0gbm9kZS5meSwgbm9kZS52eSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZU5vZGVzKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUuaW5kZXggPSBpO1xuICAgICAgaWYgKGlzTmFOKG5vZGUueCkgfHwgaXNOYU4obm9kZS55KSkge1xuICAgICAgICB2YXIgcmFkaXVzID0gaW5pdGlhbFJhZGl1cyAqIE1hdGguc3FydChpKSwgYW5nbGUgPSBpICogaW5pdGlhbEFuZ2xlO1xuICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hTihub2RlLnZ4KSB8fCBpc05hTihub2RlLnZ5KSkge1xuICAgICAgICBub2RlLnZ4ID0gbm9kZS52eSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZUZvcmNlKGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlLmluaXRpYWxpemUpIGZvcmNlLmluaXRpYWxpemUobm9kZXMpO1xuICAgIHJldHVybiBmb3JjZTtcbiAgfVxuXG4gIGluaXRpYWxpemVOb2RlcygpO1xuXG4gIHJldHVybiBzaW11bGF0aW9uID0ge1xuICAgIHRpY2s6IHRpY2ssXG5cbiAgICByZXN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwcGVyLnJlc3RhcnQoc3RlcCksIHNpbXVsYXRpb247XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0ZXBwZXIuc3RvcCgpLCBzaW11bGF0aW9uO1xuICAgIH0sXG5cbiAgICBub2RlczogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZXMgPSBfLCBpbml0aWFsaXplTm9kZXMoKSwgZm9yY2VzLmVhY2goaW5pdGlhbGl6ZUZvcmNlKSwgc2ltdWxhdGlvbikgOiBub2RlcztcbiAgICB9LFxuXG4gICAgYWxwaGE6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGE7XG4gICAgfSxcblxuICAgIGFscGhhTWluOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYU1pbiA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhTWluO1xuICAgIH0sXG5cbiAgICBhbHBoYURlY2F5OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYURlY2F5ID0gK18sIHNpbXVsYXRpb24pIDogK2FscGhhRGVjYXk7XG4gICAgfSxcblxuICAgIGFscGhhVGFyZ2V0OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYVRhcmdldCA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhVGFyZ2V0O1xuICAgIH0sXG5cbiAgICB2ZWxvY2l0eURlY2F5OiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2ZWxvY2l0eURlY2F5ID0gMSAtIF8sIHNpbXVsYXRpb24pIDogMSAtIHZlbG9jaXR5RGVjYXk7XG4gICAgfSxcblxuICAgIGZvcmNlOiBmdW5jdGlvbihuYW1lLCBfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoKF8gPT0gbnVsbCA/IGZvcmNlcy5yZW1vdmUobmFtZSkgOiBmb3JjZXMuc2V0KG5hbWUsIGluaXRpYWxpemVGb3JjZShfKSkpLCBzaW11bGF0aW9uKSA6IGZvcmNlcy5nZXQobmFtZSk7XG4gICAgfSxcblxuICAgIGZpbmQ6IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgICAgZHgsXG4gICAgICAgICAgZHksXG4gICAgICAgICAgZDIsXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBjbG9zZXN0O1xuXG4gICAgICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICAgICAgZWxzZSByYWRpdXMgKj0gcmFkaXVzO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgZHggPSB4IC0gbm9kZS54O1xuICAgICAgICBkeSA9IHkgLSBub2RlLnk7XG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkMiA8IHJhZGl1cykgY2xvc2VzdCA9IG5vZGUsIHJhZGl1cyA9IGQyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uKG5hbWUsIF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IChldmVudC5vbihuYW1lLCBfKSwgc2ltdWxhdGlvbikgOiBldmVudC5vbihuYW1lKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgbWFueUJvZHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgbm9kZSxcbiAgICAgIGFscGhhLFxuICAgICAgc3RyZW5ndGggPSBjb25zdGFudCQ2KC0zMCksXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICBkaXN0YW5jZU1pbjIgPSAxLFxuICAgICAgZGlzdGFuY2VNYXgyID0gSW5maW5pdHksXG4gICAgICB0aGV0YTIgPSAwLjgxO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKF8pIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgdHJlZSA9IHF1YWR0cmVlKG5vZGVzLCB4JDEsIHkkMSkudmlzaXRBZnRlcihhY2N1bXVsYXRlKTtcbiAgICBmb3IgKGFscGhhID0gXywgaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgdHJlZS52aXNpdChhcHBseSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgbm9kZSA9IG5vZGVzW2ldLCBzdHJlbmd0aHNbbm9kZS5pbmRleF0gPSArc3RyZW5ndGgobm9kZSwgaSwgbm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWNjdW11bGF0ZShxdWFkKSB7XG4gICAgdmFyIHN0cmVuZ3RoID0gMCwgcSwgYywgeCQkMSwgeSQkMSwgaTtcblxuICAgIC8vIEZvciBpbnRlcm5hbCBub2RlcywgYWNjdW11bGF0ZSBmb3JjZXMgZnJvbSBjaGlsZCBxdWFkcmFudHMuXG4gICAgaWYgKHF1YWQubGVuZ3RoKSB7XG4gICAgICBmb3IgKHgkJDEgPSB5JCQxID0gaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgaWYgKChxID0gcXVhZFtpXSkgJiYgKGMgPSBxLnZhbHVlKSkge1xuICAgICAgICAgIHN0cmVuZ3RoICs9IGMsIHgkJDEgKz0gYyAqIHEueCwgeSQkMSArPSBjICogcS55O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWFkLnggPSB4JCQxIC8gc3RyZW5ndGg7XG4gICAgICBxdWFkLnkgPSB5JCQxIC8gc3RyZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gRm9yIGxlYWYgbm9kZXMsIGFjY3VtdWxhdGUgZm9yY2VzIGZyb20gY29pbmNpZGVudCBxdWFkcmFudHMuXG4gICAgZWxzZSB7XG4gICAgICBxID0gcXVhZDtcbiAgICAgIHEueCA9IHEuZGF0YS54O1xuICAgICAgcS55ID0gcS5kYXRhLnk7XG4gICAgICBkbyBzdHJlbmd0aCArPSBzdHJlbmd0aHNbcS5kYXRhLmluZGV4XTtcbiAgICAgIHdoaWxlIChxID0gcS5uZXh0KTtcbiAgICB9XG5cbiAgICBxdWFkLnZhbHVlID0gc3RyZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseShxdWFkLCB4MSwgXywgeDIpIHtcbiAgICBpZiAoIXF1YWQudmFsdWUpIHJldHVybiB0cnVlO1xuXG4gICAgdmFyIHgkJDEgPSBxdWFkLnggLSBub2RlLngsXG4gICAgICAgIHkkJDEgPSBxdWFkLnkgLSBub2RlLnksXG4gICAgICAgIHcgPSB4MiAtIHgxLFxuICAgICAgICBsID0geCQkMSAqIHgkJDEgKyB5JCQxICogeSQkMTtcblxuICAgIC8vIEFwcGx5IHRoZSBCYXJuZXMtSHV0IGFwcHJveGltYXRpb24gaWYgcG9zc2libGUuXG4gICAgLy8gTGltaXQgZm9yY2VzIGZvciB2ZXJ5IGNsb3NlIG5vZGVzOyByYW5kb21pemUgZGlyZWN0aW9uIGlmIGNvaW5jaWRlbnQuXG4gICAgaWYgKHcgKiB3IC8gdGhldGEyIDwgbCkge1xuICAgICAgaWYgKGwgPCBkaXN0YW5jZU1heDIpIHtcbiAgICAgICAgaWYgKHgkJDEgPT09IDApIHgkJDEgPSBqaWdnbGUoKSwgbCArPSB4JCQxICogeCQkMTtcbiAgICAgICAgaWYgKHkkJDEgPT09IDApIHkkJDEgPSBqaWdnbGUoKSwgbCArPSB5JCQxICogeSQkMTtcbiAgICAgICAgaWYgKGwgPCBkaXN0YW5jZU1pbjIpIGwgPSBNYXRoLnNxcnQoZGlzdGFuY2VNaW4yICogbCk7XG4gICAgICAgIG5vZGUudnggKz0geCQkMSAqIHF1YWQudmFsdWUgKiBhbHBoYSAvIGw7XG4gICAgICAgIG5vZGUudnkgKz0geSQkMSAqIHF1YWQudmFsdWUgKiBhbHBoYSAvIGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgcG9pbnRzIGRpcmVjdGx5LlxuICAgIGVsc2UgaWYgKHF1YWQubGVuZ3RoIHx8IGwgPj0gZGlzdGFuY2VNYXgyKSByZXR1cm47XG5cbiAgICAvLyBMaW1pdCBmb3JjZXMgZm9yIHZlcnkgY2xvc2Ugbm9kZXM7IHJhbmRvbWl6ZSBkaXJlY3Rpb24gaWYgY29pbmNpZGVudC5cbiAgICBpZiAocXVhZC5kYXRhICE9PSBub2RlIHx8IHF1YWQubmV4dCkge1xuICAgICAgaWYgKHgkJDEgPT09IDApIHgkJDEgPSBqaWdnbGUoKSwgbCArPSB4JCQxICogeCQkMTtcbiAgICAgIGlmICh5JCQxID09PSAwKSB5JCQxID0gamlnZ2xlKCksIGwgKz0geSQkMSAqIHkkJDE7XG4gICAgICBpZiAobCA8IGRpc3RhbmNlTWluMikgbCA9IE1hdGguc3FydChkaXN0YW5jZU1pbjIgKiBsKTtcbiAgICB9XG5cbiAgICBkbyBpZiAocXVhZC5kYXRhICE9PSBub2RlKSB7XG4gICAgICB3ID0gc3RyZW5ndGhzW3F1YWQuZGF0YS5pbmRleF0gKiBhbHBoYSAvIGw7XG4gICAgICBub2RlLnZ4ICs9IHgkJDEgKiB3O1xuICAgICAgbm9kZS52eSArPSB5JCQxICogdztcbiAgICB9IHdoaWxlIChxdWFkID0gcXVhZC5uZXh0KTtcbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNigrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2VNaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2VNaW4yID0gXyAqIF8sIGZvcmNlKSA6IE1hdGguc3FydChkaXN0YW5jZU1pbjIpO1xuICB9O1xuXG4gIGZvcmNlLmRpc3RhbmNlTWF4ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlTWF4MiA9IF8gKiBfLCBmb3JjZSkgOiBNYXRoLnNxcnQoZGlzdGFuY2VNYXgyKTtcbiAgfTtcblxuICBmb3JjZS50aGV0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGV0YTIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KHRoZXRhMik7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufTtcblxudmFyIHgkMiA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQkNigwLjEpLFxuICAgICAgbm9kZXMsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICB4ejtcblxuICBpZiAodHlwZW9mIHggIT09IFwiZnVuY3Rpb25cIikgeCA9IGNvbnN0YW50JDYoeCA9PSBudWxsID8gMCA6ICt4KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnggKz0gKHh6W2ldIC0gbm9kZS54KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB4eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih4eltpXSA9ICt4KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNigrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ2KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB4O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn07XG5cbnZhciB5JDIgPSBmdW5jdGlvbih5KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50JDYoMC4xKSxcbiAgICAgIG5vZGVzLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgeXo7XG5cbiAgaWYgKHR5cGVvZiB5ICE9PSBcImZ1bmN0aW9uXCIpIHkgPSBjb25zdGFudCQ2KHkgPT0gbnVsbCA/IDAgOiAreSk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnZ5ICs9ICh5eltpXSAtIG5vZGUueSkgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgeXogPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeXpbaV0gPSAreShub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDYoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNigrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogeTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59O1xuXG4vLyBDb21wdXRlcyB0aGUgZGVjaW1hbCBjb2VmZmljaWVudCBhbmQgZXhwb25lbnQgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIgeCB3aXRoXG4vLyBzaWduaWZpY2FudCBkaWdpdHMgcCwgd2hlcmUgeCBpcyBwb3NpdGl2ZSBhbmQgcCBpcyBpbiBbMSwgMjFdIG9yIHVuZGVmaW5lZC5cbi8vIEZvciBleGFtcGxlLCBmb3JtYXREZWNpbWFsKDEuMjMpIHJldHVybnMgW1wiMTIzXCIsIDBdLlxudmFyIGZvcm1hdERlY2ltYWwgPSBmdW5jdGlvbih4LCBwKSB7XG4gIGlmICgoaSA9ICh4ID0gcCA/IHgudG9FeHBvbmVudGlhbChwIC0gMSkgOiB4LnRvRXhwb25lbnRpYWwoKSkuaW5kZXhPZihcImVcIikpIDwgMCkgcmV0dXJuIG51bGw7IC8vIE5hTiwgwrFJbmZpbml0eVxuICB2YXIgaSwgY29lZmZpY2llbnQgPSB4LnNsaWNlKDAsIGkpO1xuXG4gIC8vIFRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgdG9FeHBvbmVudGlhbCBlaXRoZXIgaGFzIHRoZSBmb3JtIFxcZFxcLlxcZCtlWy0rXVxcZCtcbiAgLy8gKGUuZy4sIDEuMmUrMykgb3IgdGhlIGZvcm0gXFxkZVstK11cXGQrIChlLmcuLCAxZSszKS5cbiAgcmV0dXJuIFtcbiAgICBjb2VmZmljaWVudC5sZW5ndGggPiAxID8gY29lZmZpY2llbnRbMF0gKyBjb2VmZmljaWVudC5zbGljZSgyKSA6IGNvZWZmaWNpZW50LFxuICAgICt4LnNsaWNlKGkgKyAxKVxuICBdO1xufTtcblxudmFyIGV4cG9uZW50JDEgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ID0gZm9ybWF0RGVjaW1hbChNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xufTtcblxudmFyIGZvcm1hdEdyb3VwID0gZnVuY3Rpb24oZ3JvdXBpbmcsIHRob3VzYW5kcykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIHdpZHRoKSB7XG4gICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGgsXG4gICAgICAgIHQgPSBbXSxcbiAgICAgICAgaiA9IDAsXG4gICAgICAgIGcgPSBncm91cGluZ1swXSxcbiAgICAgICAgbGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChpID4gMCAmJiBnID4gMCkge1xuICAgICAgaWYgKGxlbmd0aCArIGcgKyAxID4gd2lkdGgpIGcgPSBNYXRoLm1heCgxLCB3aWR0aCAtIGxlbmd0aCk7XG4gICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgIGlmICgobGVuZ3RoICs9IGcgKyAxKSA+IHdpZHRoKSBicmVhaztcbiAgICAgIGcgPSBncm91cGluZ1tqID0gKGogKyAxKSAlIGdyb3VwaW5nLmxlbmd0aF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHQucmV2ZXJzZSgpLmpvaW4odGhvdXNhbmRzKTtcbiAgfTtcbn07XG5cbnZhciBmb3JtYXROdW1lcmFscyA9IGZ1bmN0aW9uKG51bWVyYWxzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bMC05XS9nLCBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gbnVtZXJhbHNbK2ldO1xuICAgIH0pO1xuICB9O1xufTtcblxudmFyIGZvcm1hdERlZmF1bHQgPSBmdW5jdGlvbih4LCBwKSB7XG4gIHggPSB4LnRvUHJlY2lzaW9uKHApO1xuXG4gIG91dDogZm9yICh2YXIgbiA9IHgubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKHhbaV0pIHtcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgY2FzZSBcImVcIjogYnJlYWsgb3V0O1xuICAgICAgZGVmYXVsdDogaWYgKGkwID4gMCkgaTAgPSAwOyBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaTAgPiAwID8geC5zbGljZSgwLCBpMCkgKyB4LnNsaWNlKGkxICsgMSkgOiB4O1xufTtcblxudmFyIHByZWZpeEV4cG9uZW50O1xuXG52YXIgZm9ybWF0UHJlZml4QXV0byA9IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXSxcbiAgICAgIGkgPSBleHBvbmVudCAtIChwcmVmaXhFeHBvbmVudCA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50IC8gMykpKSAqIDMpICsgMSxcbiAgICAgIG4gPSBjb2VmZmljaWVudC5sZW5ndGg7XG4gIHJldHVybiBpID09PSBuID8gY29lZmZpY2llbnRcbiAgICAgIDogaSA+IG4gPyBjb2VmZmljaWVudCArIG5ldyBBcnJheShpIC0gbiArIDEpLmpvaW4oXCIwXCIpXG4gICAgICA6IGkgPiAwID8gY29lZmZpY2llbnQuc2xpY2UoMCwgaSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGkpXG4gICAgICA6IFwiMC5cIiArIG5ldyBBcnJheSgxIC0gaSkuam9pbihcIjBcIikgKyBmb3JtYXREZWNpbWFsKHgsIE1hdGgubWF4KDAsIHAgKyBpIC0gMSkpWzBdOyAvLyBsZXNzIHRoYW4gMXkhXG59O1xuXG52YXIgZm9ybWF0Um91bmRlZCA9IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsKHgsIHApO1xuICBpZiAoIWQpIHJldHVybiB4ICsgXCJcIjtcbiAgdmFyIGNvZWZmaWNpZW50ID0gZFswXSxcbiAgICAgIGV4cG9uZW50ID0gZFsxXTtcbiAgcmV0dXJuIGV4cG9uZW50IDwgMCA/IFwiMC5cIiArIG5ldyBBcnJheSgtZXhwb25lbnQpLmpvaW4oXCIwXCIpICsgY29lZmZpY2llbnRcbiAgICAgIDogY29lZmZpY2llbnQubGVuZ3RoID4gZXhwb25lbnQgKyAxID8gY29lZmZpY2llbnQuc2xpY2UoMCwgZXhwb25lbnQgKyAxKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoZXhwb25lbnQgKyAxKVxuICAgICAgOiBjb2VmZmljaWVudCArIG5ldyBBcnJheShleHBvbmVudCAtIGNvZWZmaWNpZW50Lmxlbmd0aCArIDIpLmpvaW4oXCIwXCIpO1xufTtcblxudmFyIGZvcm1hdFR5cGVzID0ge1xuICBcIlwiOiBmb3JtYXREZWZhdWx0LFxuICBcIiVcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gKHggKiAxMDApLnRvRml4ZWQocCk7IH0sXG4gIFwiYlwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDIpOyB9LFxuICBcImNcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4geCArIFwiXCI7IH0sXG4gIFwiZFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDEwKTsgfSxcbiAgXCJlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9FeHBvbmVudGlhbChwKTsgfSxcbiAgXCJmXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9GaXhlZChwKTsgfSxcbiAgXCJnXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIHgudG9QcmVjaXNpb24ocCk7IH0sXG4gIFwib1wiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDgpOyB9LFxuICBcInBcIjogZnVuY3Rpb24oeCwgcCkgeyByZXR1cm4gZm9ybWF0Um91bmRlZCh4ICogMTAwLCBwKTsgfSxcbiAgXCJyXCI6IGZvcm1hdFJvdW5kZWQsXG4gIFwic1wiOiBmb3JtYXRQcmVmaXhBdXRvLFxuICBcIlhcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfSxcbiAgXCJ4XCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpOyB9XG59O1xuXG4vLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW3R5cGVdXG52YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtXFwoIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KFthLXolXSk/JC9pO1xuXG5mdW5jdGlvbiBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIHJldHVybiBuZXcgRm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG59XG5cbmZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUgPSBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlOyAvLyBpbnN0YW5jZW9mXG5cbmZ1bmN0aW9uIEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgaWYgKCEobWF0Y2ggPSByZS5leGVjKHNwZWNpZmllcikpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdDogXCIgKyBzcGVjaWZpZXIpO1xuXG4gIHZhciBtYXRjaCxcbiAgICAgIGZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIixcbiAgICAgIGFsaWduID0gbWF0Y2hbMl0gfHwgXCI+XCIsXG4gICAgICBzaWduID0gbWF0Y2hbM10gfHwgXCItXCIsXG4gICAgICBzeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiLFxuICAgICAgemVybyA9ICEhbWF0Y2hbNV0sXG4gICAgICB3aWR0aCA9IG1hdGNoWzZdICYmICttYXRjaFs2XSxcbiAgICAgIGNvbW1hID0gISFtYXRjaFs3XSxcbiAgICAgIHByZWNpc2lvbiA9IG1hdGNoWzhdICYmICttYXRjaFs4XS5zbGljZSgxKSxcbiAgICAgIHR5cGUgPSBtYXRjaFs5XSB8fCBcIlwiO1xuXG4gIC8vIFRoZSBcIm5cIiB0eXBlIGlzIGFuIGFsaWFzIGZvciBcIixnXCIuXG4gIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgLy8gTWFwIGludmFsaWQgdHlwZXMgdG8gdGhlIGRlZmF1bHQgZm9ybWF0LlxuICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHR5cGUgPSBcIlwiO1xuXG4gIC8vIElmIHplcm8gZmlsbCBpcyBzcGVjaWZpZWQsIHBhZGRpbmcgZ29lcyBhZnRlciBzaWduIGFuZCBiZWZvcmUgZGlnaXRzLlxuICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICB0aGlzLmZpbGwgPSBmaWxsO1xuICB0aGlzLmFsaWduID0gYWxpZ247XG4gIHRoaXMuc2lnbiA9IHNpZ247XG4gIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xuICB0aGlzLnplcm8gPSB6ZXJvO1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuY29tbWEgPSBjb21tYTtcbiAgdGhpcy5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gIHRoaXMudHlwZSA9IHR5cGU7XG59XG5cbkZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZmlsbFxuICAgICAgKyB0aGlzLmFsaWduXG4gICAgICArIHRoaXMuc2lnblxuICAgICAgKyB0aGlzLnN5bWJvbFxuICAgICAgKyAodGhpcy56ZXJvID8gXCIwXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy53aWR0aCA9PSBudWxsID8gXCJcIiA6IE1hdGgubWF4KDEsIHRoaXMud2lkdGggfCAwKSlcbiAgICAgICsgKHRoaXMuY29tbWEgPyBcIixcIiA6IFwiXCIpXG4gICAgICArICh0aGlzLnByZWNpc2lvbiA9PSBudWxsID8gXCJcIiA6IFwiLlwiICsgTWF0aC5tYXgoMCwgdGhpcy5wcmVjaXNpb24gfCAwKSlcbiAgICAgICsgdGhpcy50eXBlO1xufTtcblxudmFyIGlkZW50aXR5JDMgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufTtcblxudmFyIHByZWZpeGVzID0gW1wieVwiLFwielwiLFwiYVwiLFwiZlwiLFwicFwiLFwiblwiLFwiXFx4QjVcIixcIm1cIixcIlwiLFwia1wiLFwiTVwiLFwiR1wiLFwiVFwiLFwiUFwiLFwiRVwiLFwiWlwiLFwiWVwiXTtcblxudmFyIGZvcm1hdExvY2FsZSA9IGZ1bmN0aW9uKGxvY2FsZSkge1xuICB2YXIgZ3JvdXAgPSBsb2NhbGUuZ3JvdXBpbmcgJiYgbG9jYWxlLnRob3VzYW5kcyA/IGZvcm1hdEdyb3VwKGxvY2FsZS5ncm91cGluZywgbG9jYWxlLnRob3VzYW5kcykgOiBpZGVudGl0eSQzLFxuICAgICAgY3VycmVuY3kgPSBsb2NhbGUuY3VycmVuY3ksXG4gICAgICBkZWNpbWFsID0gbG9jYWxlLmRlY2ltYWwsXG4gICAgICBudW1lcmFscyA9IGxvY2FsZS5udW1lcmFscyA/IGZvcm1hdE51bWVyYWxzKGxvY2FsZS5udW1lcmFscykgOiBpZGVudGl0eSQzLFxuICAgICAgcGVyY2VudCA9IGxvY2FsZS5wZXJjZW50IHx8IFwiJVwiO1xuXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIpIHtcbiAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcblxuICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXG4gICAgICAgIGFsaWduID0gc3BlY2lmaWVyLmFsaWduLFxuICAgICAgICBzaWduID0gc3BlY2lmaWVyLnNpZ24sXG4gICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXG4gICAgICAgIHplcm8gPSBzcGVjaWZpZXIuemVybyxcbiAgICAgICAgd2lkdGggPSBzcGVjaWZpZXIud2lkdGgsXG4gICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxuICAgICAgICBwcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uLFxuICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAvLyBGb3IgU0ktcHJlZml4LCB0aGUgc3VmZml4IGlzIGxhemlseSBjb21wdXRlZC5cbiAgICB2YXIgcHJlZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzBdIDogc3ltYm9sID09PSBcIiNcIiAmJiAvW2JveFhdLy50ZXN0KHR5cGUpID8gXCIwXCIgKyB0eXBlLnRvTG93ZXJDYXNlKCkgOiBcIlwiLFxuICAgICAgICBzdWZmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lbMV0gOiAvWyVwXS8udGVzdCh0eXBlKSA/IHBlcmNlbnQgOiBcIlwiO1xuXG4gICAgLy8gV2hhdCBmb3JtYXQgZnVuY3Rpb24gc2hvdWxkIHdlIHVzZT9cbiAgICAvLyBJcyB0aGlzIGFuIGludGVnZXIgdHlwZT9cbiAgICAvLyBDYW4gdGhpcyB0eXBlIGdlbmVyYXRlIGV4cG9uZW50aWFsIG5vdGF0aW9uP1xuICAgIHZhciBmb3JtYXRUeXBlID0gZm9ybWF0VHlwZXNbdHlwZV0sXG4gICAgICAgIG1heWJlU3VmZml4ID0gIXR5cGUgfHwgL1tkZWZncHJzJV0vLnRlc3QodHlwZSk7XG5cbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlmIG5vdCBzcGVjaWZpZWQsXG4gICAgLy8gb3IgY2xhbXAgdGhlIHNwZWNpZmllZCBwcmVjaXNpb24gdG8gdGhlIHN1cHBvcnRlZCByYW5nZS5cbiAgICAvLyBGb3Igc2lnbmlmaWNhbnQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFsxLCAyMV0uXG4gICAgLy8gRm9yIGZpeGVkIHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMCwgMjBdLlxuICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gKHR5cGUgPyA2IDogMTIpXG4gICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxuICAgICAgICAgIGksIG4sIGM7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgdmFyIHZhbHVlTmVnYXRpdmUgPSB2YWx1ZSA8IDA7XG4gICAgICAgIHZhbHVlID0gZm9ybWF0VHlwZShNYXRoLmFicyh2YWx1ZSksIHByZWNpc2lvbik7XG5cbiAgICAgICAgLy8gSWYgYSBuZWdhdGl2ZSB2YWx1ZSByb3VuZHMgdG8gemVybyBkdXJpbmcgZm9ybWF0dGluZywgdHJlYXQgYXMgcG9zaXRpdmUuXG4gICAgICAgIGlmICh2YWx1ZU5lZ2F0aXZlICYmICt2YWx1ZSA9PT0gMCkgdmFsdWVOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgICAgICB2YWx1ZVByZWZpeCA9ICh2YWx1ZU5lZ2F0aXZlID8gKHNpZ24gPT09IFwiKFwiID8gc2lnbiA6IFwiLVwiKSA6IHNpZ24gPT09IFwiLVwiIHx8IHNpZ24gPT09IFwiKFwiID8gXCJcIiA6IHNpZ24pICsgdmFsdWVQcmVmaXg7XG4gICAgICAgIHZhbHVlU3VmZml4ID0gdmFsdWVTdWZmaXggKyAodHlwZSA9PT0gXCJzXCIgPyBwcmVmaXhlc1s4ICsgcHJlZml4RXhwb25lbnQgLyAzXSA6IFwiXCIpICsgKHZhbHVlTmVnYXRpdmUgJiYgc2lnbiA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXCIpO1xuXG4gICAgICAgIC8vIEJyZWFrIHRoZSBmb3JtYXR0ZWQgdmFsdWUgaW50byB0aGUgaW50ZWdlciDigJx2YWx1ZeKAnSBwYXJ0IHRoYXQgY2FuIGJlXG4gICAgICAgIC8vIGdyb3VwZWQsIGFuZCBmcmFjdGlvbmFsIG9yIGV4cG9uZW50aWFsIOKAnHN1ZmZpeOKAnSBwYXJ0IHRoYXQgaXMgbm90LlxuICAgICAgICBpZiAobWF5YmVTdWZmaXgpIHtcbiAgICAgICAgICBpID0gLTEsIG4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgIGlmIChjID0gdmFsdWUuY2hhckNvZGVBdChpKSwgNDggPiBjIHx8IGMgPiA1Nykge1xuICAgICAgICAgICAgICB2YWx1ZVN1ZmZpeCA9IChjID09PSA0NiA/IGRlY2ltYWwgKyB2YWx1ZS5zbGljZShpICsgMSkgOiB2YWx1ZS5zbGljZShpKSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBub3QgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYmVmb3JlIHBhZGRpbmcuXG4gICAgICBpZiAoY29tbWEgJiYgIXplcm8pIHZhbHVlID0gZ3JvdXAodmFsdWUsIEluZmluaXR5KTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFkZGluZy5cbiAgICAgIHZhciBsZW5ndGggPSB2YWx1ZVByZWZpeC5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyB2YWx1ZVN1ZmZpeC5sZW5ndGgsXG4gICAgICAgICAgcGFkZGluZyA9IGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSA6IFwiXCI7XG5cbiAgICAgIC8vIElmIHRoZSBmaWxsIGNoYXJhY3RlciBpcyBcIjBcIiwgZ3JvdXBpbmcgaXMgYXBwbGllZCBhZnRlciBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmIHplcm8pIHZhbHVlID0gZ3JvdXAocGFkZGluZyArIHZhbHVlLCBwYWRkaW5nLmxlbmd0aCA/IHdpZHRoIC0gdmFsdWVTdWZmaXgubGVuZ3RoIDogSW5maW5pdHkpLCBwYWRkaW5nID0gXCJcIjtcblxuICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIGZpbmFsIG91dHB1dCBiYXNlZCBvbiB0aGUgZGVzaXJlZCBhbGlnbm1lbnQuXG4gICAgICBzd2l0Y2ggKGFsaWduKSB7XG4gICAgICAgIGNhc2UgXCI8XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyB2YWx1ZSArIHZhbHVlU3VmZml4ICsgcGFkZGluZzsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI9XCI6IHZhbHVlID0gdmFsdWVQcmVmaXggKyBwYWRkaW5nICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJeXCI6IHZhbHVlID0gcGFkZGluZy5zbGljZSgwLCBsZW5ndGggPSBwYWRkaW5nLmxlbmd0aCA+PiAxKSArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmcuc2xpY2UobGVuZ3RoKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHZhbHVlID0gcGFkZGluZyArIHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeDsgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudW1lcmFscyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9ybWF0LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3BlY2lmaWVyICsgXCJcIjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFByZWZpeChzcGVjaWZpZXIsIHZhbHVlKSB7XG4gICAgdmFyIGYgPSBuZXdGb3JtYXQoKHNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpLCBzcGVjaWZpZXIudHlwZSA9IFwiZlwiLCBzcGVjaWZpZXIpKSxcbiAgICAgICAgZSA9IE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50JDEodmFsdWUpIC8gMykpKSAqIDMsXG4gICAgICAgIGsgPSBNYXRoLnBvdygxMCwgLWUpLFxuICAgICAgICBwcmVmaXggPSBwcmVmaXhlc1s4ICsgZSAvIDNdO1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGYoayAqIHZhbHVlKSArIHByZWZpeDtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IG5ld0Zvcm1hdCxcbiAgICBmb3JtYXRQcmVmaXg6IGZvcm1hdFByZWZpeFxuICB9O1xufTtcblxudmFyIGxvY2FsZSQxO1xuXG5cblxuZGVmYXVsdExvY2FsZSh7XG4gIGRlY2ltYWw6IFwiLlwiLFxuICB0aG91c2FuZHM6IFwiLFwiLFxuICBncm91cGluZzogWzNdLFxuICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUkMSA9IGZvcm1hdExvY2FsZShkZWZpbml0aW9uKTtcbiAgZXhwb3J0cy5mb3JtYXQgPSBsb2NhbGUkMS5mb3JtYXQ7XG4gIGV4cG9ydHMuZm9ybWF0UHJlZml4ID0gbG9jYWxlJDEuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlJDE7XG59XG5cbnZhciBwcmVjaXNpb25GaXhlZCA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIC1leHBvbmVudCQxKE1hdGguYWJzKHN0ZXApKSk7XG59O1xuXG52YXIgcHJlY2lzaW9uUHJlZml4ID0gZnVuY3Rpb24oc3RlcCwgdmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50JDEodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudCQxKE1hdGguYWJzKHN0ZXApKSk7XG59O1xuXG52YXIgcHJlY2lzaW9uUm91bmQgPSBmdW5jdGlvbihzdGVwLCBtYXgpIHtcbiAgc3RlcCA9IE1hdGguYWJzKHN0ZXApLCBtYXggPSBNYXRoLmFicyhtYXgpIC0gc3RlcDtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGV4cG9uZW50JDEobWF4KSAtIGV4cG9uZW50JDEoc3RlcCkpICsgMTtcbn07XG5cbi8vIEFkZHMgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyB3aXRoIHR3aWNlIHRoZSBub3JtYWwgcHJlY2lzaW9uLlxuLy8gUmVmZXJlbmNlOiBKLiBSLiBTaGV3Y2h1aywgQWRhcHRpdmUgUHJlY2lzaW9uIEZsb2F0aW5nLVBvaW50IEFyaXRobWV0aWMgYW5kXG4vLyBGYXN0IFJvYnVzdCBHZW9tZXRyaWMgUHJlZGljYXRlcywgRGlzY3JldGUgJiBDb21wdXRhdGlvbmFsIEdlb21ldHJ5IDE4KDMpXG4vLyAzMDXigJMzNjMgKDE5OTcpLlxuLy8gQ29kZSBhZGFwdGVkIGZyb20gR2VvZ3JhcGhpY0xpYiBieSBDaGFybGVzIEYuIEYuIEthcm5leSxcbi8vIGh0dHA6Ly9nZW9ncmFwaGljbGliLnNvdXJjZWZvcmdlLm5ldC9cblxudmFyIGFkZGVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQWRkZXI7XG59O1xuXG5mdW5jdGlvbiBBZGRlcigpIHtcbiAgdGhpcy5yZXNldCgpO1xufVxuXG5BZGRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBZGRlcixcbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucyA9IC8vIHJvdW5kZWQgdmFsdWVcbiAgICB0aGlzLnQgPSAwOyAvLyBleGFjdCBlcnJvclxuICB9LFxuICBhZGQ6IGZ1bmN0aW9uKHkpIHtcbiAgICBhZGQkMSh0ZW1wLCB5LCB0aGlzLnQpO1xuICAgIGFkZCQxKHRoaXMsIHRlbXAucywgdGhpcy5zKTtcbiAgICBpZiAodGhpcy5zKSB0aGlzLnQgKz0gdGVtcC50O1xuICAgIGVsc2UgdGhpcy5zID0gdGVtcC50O1xuICB9LFxuICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zO1xuICB9XG59O1xuXG52YXIgdGVtcCA9IG5ldyBBZGRlcjtcblxuZnVuY3Rpb24gYWRkJDEoYWRkZXIsIGEsIGIpIHtcbiAgdmFyIHggPSBhZGRlci5zID0gYSArIGIsXG4gICAgICBidiA9IHggLSBhLFxuICAgICAgYXYgPSB4IC0gYnY7XG4gIGFkZGVyLnQgPSAoYSAtIGF2KSArIChiIC0gYnYpO1xufVxuXG52YXIgZXBzaWxvbiQyID0gMWUtNjtcbnZhciBlcHNpbG9uMiQxID0gMWUtMTI7XG52YXIgcGkkMyA9IE1hdGguUEk7XG52YXIgaGFsZlBpJDIgPSBwaSQzIC8gMjtcbnZhciBxdWFydGVyUGkgPSBwaSQzIC8gNDtcbnZhciB0YXUkMyA9IHBpJDMgKiAyO1xuXG52YXIgZGVncmVlcyQxID0gMTgwIC8gcGkkMztcbnZhciByYWRpYW5zID0gcGkkMyAvIDE4MDtcblxudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIGF0YW4gPSBNYXRoLmF0YW47XG52YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xudmFyIGNvcyQxID0gTWF0aC5jb3M7XG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIHNpbiQxID0gTWF0aC5zaW47XG52YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIHRhbiA9IE1hdGgudGFuO1xuXG5mdW5jdGlvbiBhY29zKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpJDMgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+IDEgPyBoYWxmUGkkMiA6IHggPCAtMSA/IC1oYWxmUGkkMiA6IE1hdGguYXNpbih4KTtcbn1cblxuZnVuY3Rpb24gaGF2ZXJzaW4oeCkge1xuICByZXR1cm4gKHggPSBzaW4kMSh4IC8gMikpICogeDtcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cblxuZnVuY3Rpb24gc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cnksIHN0cmVhbSkge1xuICBpZiAoZ2VvbWV0cnkgJiYgc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59XG5cbnZhciBzdHJlYW1PYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgfSxcbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9XG59O1xuXG52YXIgc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICBTcGhlcmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtLnNwaGVyZSgpO1xuICB9LFxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBvYmplY3QgPSBvYmplY3QuY29vcmRpbmF0ZXM7XG4gICAgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICB9LFxuICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbUxpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0sIDApO1xuICB9LFxuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMCk7XG4gIH0sXG4gIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSk7XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgc3RyZWFtKTtcbiAgfSxcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShnZW9tZXRyaWVzW2ldLCBzdHJlYW0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzLCBzdHJlYW0sIGNsb3NlZCkge1xuICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgc3RyZWFtLmxpbmVFbmQoKTtcbn1cblxuZnVuY3Rpb24gc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgc3RyZWFtKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMSk7XG4gIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG59XG5cbnZhciBnZW9TdHJlYW0gPSBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICBpZiAob2JqZWN0ICYmIHN0cmVhbU9iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpKSB7XG4gICAgc3RyZWFtT2JqZWN0VHlwZVtvYmplY3QudHlwZV0ob2JqZWN0LCBzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdCwgc3RyZWFtKTtcbiAgfVxufTtcblxudmFyIGFyZWFSaW5nU3VtID0gYWRkZXIoKTtcblxudmFyIGFyZWFTdW0gPSBhZGRlcigpO1xudmFyIGxhbWJkYTAwO1xudmFyIHBoaTAwO1xudmFyIGxhbWJkYTA7XG52YXIgY29zUGhpMDtcbnZhciBzaW5QaGkwO1xuXG52YXIgYXJlYVN0cmVhbSA9IHtcbiAgcG9pbnQ6IG5vb3AkMSxcbiAgbGluZVN0YXJ0OiBub29wJDEsXG4gIGxpbmVFbmQ6IG5vb3AkMSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBhcmVhUmluZ1N1bS5yZXNldCgpO1xuICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydDtcbiAgICBhcmVhU3RyZWFtLmxpbmVFbmQgPSBhcmVhUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWFSaW5nID0gK2FyZWFSaW5nU3VtO1xuICAgIGFyZWFTdW0uYWRkKGFyZWFSaW5nIDwgMCA/IHRhdSQzICsgYXJlYVJpbmcgOiBhcmVhUmluZyk7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmxpbmVFbmQgPSB0aGlzLnBvaW50ID0gbm9vcCQxO1xuICB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdW0uYWRkKHRhdSQzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXJlYVJpbmdTdGFydCgpIHtcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBhcmVhUmluZ0VuZCgpIHtcbiAgYXJlYVBvaW50KGxhbWJkYTAwLCBwaGkwMCk7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnQ7XG4gIGxhbWJkYTAwID0gbGFtYmRhLCBwaGkwMCA9IHBoaTtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zJDEocGhpID0gcGhpIC8gMiArIHF1YXJ0ZXJQaSksIHNpblBoaTAgPSBzaW4kMShwaGkpO1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICBwaGkgPSBwaGkgLyAyICsgcXVhcnRlclBpOyAvLyBoYWxmIHRoZSBhbmd1bGFyIGRpc3RhbmNlIGZyb20gc291dGggcG9sZVxuXG4gIC8vIFNwaGVyaWNhbCBleGNlc3MgRSBmb3IgYSBzcGhlcmljYWwgdHJpYW5nbGUgd2l0aCB2ZXJ0aWNlczogc291dGggcG9sZSxcbiAgLy8gcHJldmlvdXMgcG9pbnQsIGN1cnJlbnQgcG9pbnQuICBVc2VzIGEgZm9ybXVsYSBkZXJpdmVkIGZyb20gQ2Fnbm9saeKAmXNcbiAgLy8gdGhlb3JlbS4gIFNlZSBUb2RodW50ZXIsIFNwaGVyaWNhbCBUcmlnLiAoMTg3MSksIFNlYy4gMTAzLCBFcS4gKDIpLlxuICB2YXIgZExhbWJkYSA9IGxhbWJkYSAtIGxhbWJkYTAsXG4gICAgICBzZExhbWJkYSA9IGRMYW1iZGEgPj0gMCA/IDEgOiAtMSxcbiAgICAgIGFkTGFtYmRhID0gc2RMYW1iZGEgKiBkTGFtYmRhLFxuICAgICAgY29zUGhpID0gY29zJDEocGhpKSxcbiAgICAgIHNpblBoaSA9IHNpbiQxKHBoaSksXG4gICAgICBrID0gc2luUGhpMCAqIHNpblBoaSxcbiAgICAgIHUgPSBjb3NQaGkwICogY29zUGhpICsgayAqIGNvcyQxKGFkTGFtYmRhKSxcbiAgICAgIHYgPSBrICogc2RMYW1iZGEgKiBzaW4kMShhZExhbWJkYSk7XG4gIGFyZWFSaW5nU3VtLmFkZChhdGFuMih2LCB1KSk7XG5cbiAgLy8gQWR2YW5jZSB0aGUgcHJldmlvdXMgcG9pbnRzLlxuICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zUGhpLCBzaW5QaGkwID0gc2luUGhpO1xufVxuXG52YXIgYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBhcmVhU3VtLnJlc2V0KCk7XG4gIGdlb1N0cmVhbShvYmplY3QsIGFyZWFTdHJlYW0pO1xuICByZXR1cm4gYXJlYVN1bSAqIDI7XG59O1xuXG5mdW5jdGlvbiBzcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gIHJldHVybiBbYXRhbjIoY2FydGVzaWFuWzFdLCBjYXJ0ZXNpYW5bMF0pLCBhc2luKGNhcnRlc2lhblsyXSldO1xufVxuXG5mdW5jdGlvbiBjYXJ0ZXNpYW4oc3BoZXJpY2FsKSB7XG4gIHZhciBsYW1iZGEgPSBzcGhlcmljYWxbMF0sIHBoaSA9IHNwaGVyaWNhbFsxXSwgY29zUGhpID0gY29zJDEocGhpKTtcbiAgcmV0dXJuIFtjb3NQaGkgKiBjb3MkMShsYW1iZGEpLCBjb3NQaGkgKiBzaW4kMShsYW1iZGEpLCBzaW4kMShwaGkpXTtcbn1cblxuZnVuY3Rpb24gY2FydGVzaWFuRG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cblxuZnVuY3Rpb24gY2FydGVzaWFuQ3Jvc3MoYSwgYikge1xuICByZXR1cm4gW2FbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1dO1xufVxuXG4vLyBUT0RPIHJldHVybiBhXG5mdW5jdGlvbiBjYXJ0ZXNpYW5BZGRJblBsYWNlKGEsIGIpIHtcbiAgYVswXSArPSBiWzBdLCBhWzFdICs9IGJbMV0sIGFbMl0gKz0gYlsyXTtcbn1cblxuZnVuY3Rpb24gY2FydGVzaWFuU2NhbGUodmVjdG9yLCBrKSB7XG4gIHJldHVybiBbdmVjdG9yWzBdICogaywgdmVjdG9yWzFdICogaywgdmVjdG9yWzJdICoga107XG59XG5cbi8vIFRPRE8gcmV0dXJuIGRcbmZ1bmN0aW9uIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoZCkge1xuICB2YXIgbCA9IHNxcnQoZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXSArIGRbMl0gKiBkWzJdKTtcbiAgZFswXSAvPSBsLCBkWzFdIC89IGwsIGRbMl0gLz0gbDtcbn1cblxudmFyIGxhbWJkYTAkMTtcbnZhciBwaGkwO1xudmFyIGxhbWJkYTE7XG52YXIgcGhpMTtcbnZhciBsYW1iZGEyO1xudmFyIGxhbWJkYTAwJDE7XG52YXIgcGhpMDAkMTtcbnZhciBwMDtcbnZhciBkZWx0YVN1bSA9IGFkZGVyKCk7XG52YXIgcmFuZ2VzO1xudmFyIHJhbmdlO1xuXG52YXIgYm91bmRzU3RyZWFtID0ge1xuICBwb2ludDogYm91bmRzUG9pbnQsXG4gIGxpbmVTdGFydDogYm91bmRzTGluZVN0YXJ0LFxuICBsaW5lRW5kOiBib3VuZHNMaW5lRW5kLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1JpbmdQb2ludDtcbiAgICBib3VuZHNTdHJlYW0ubGluZVN0YXJ0ID0gYm91bmRzUmluZ1N0YXJ0O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lRW5kID0gYm91bmRzUmluZ0VuZDtcbiAgICBkZWx0YVN1bS5yZXNldCgpO1xuICAgIGFyZWFTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1BvaW50O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lU3RhcnQgPSBib3VuZHNMaW5lU3RhcnQ7XG4gICAgYm91bmRzU3RyZWFtLmxpbmVFbmQgPSBib3VuZHNMaW5lRW5kO1xuICAgIGlmIChhcmVhUmluZ1N1bSA8IDApIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCksIHBoaTAgPSAtKHBoaTEgPSA5MCk7XG4gICAgZWxzZSBpZiAoZGVsdGFTdW0gPiBlcHNpbG9uJDIpIHBoaTEgPSA5MDtcbiAgICBlbHNlIGlmIChkZWx0YVN1bSA8IC1lcHNpbG9uJDIpIHBoaTAgPSAtOTA7XG4gICAgcmFuZ2VbMF0gPSBsYW1iZGEwJDEsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYm91bmRzUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgcmFuZ2VzLnB1c2gocmFuZ2UgPSBbbGFtYmRhMCQxID0gbGFtYmRhLCBsYW1iZGExID0gbGFtYmRhXSk7XG4gIGlmIChwaGkgPCBwaGkwKSBwaGkwID0gcGhpO1xuICBpZiAocGhpID4gcGhpMSkgcGhpMSA9IHBoaTtcbn1cblxuZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIHZhciBwID0gY2FydGVzaWFuKFtsYW1iZGEgKiByYWRpYW5zLCBwaGkgKiByYWRpYW5zXSk7XG4gIGlmIChwMCkge1xuICAgIHZhciBub3JtYWwgPSBjYXJ0ZXNpYW5Dcm9zcyhwMCwgcCksXG4gICAgICAgIGVxdWF0b3JpYWwgPSBbbm9ybWFsWzFdLCAtbm9ybWFsWzBdLCAwXSxcbiAgICAgICAgaW5mbGVjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKGVxdWF0b3JpYWwsIG5vcm1hbCk7XG4gICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbmZsZWN0aW9uKTtcbiAgICBpbmZsZWN0aW9uID0gc3BoZXJpY2FsKGluZmxlY3Rpb24pO1xuICAgIHZhciBkZWx0YSA9IGxhbWJkYSAtIGxhbWJkYTIsXG4gICAgICAgIHNpZ24kJDEgPSBkZWx0YSA+IDAgPyAxIDogLTEsXG4gICAgICAgIGxhbWJkYWkgPSBpbmZsZWN0aW9uWzBdICogZGVncmVlcyQxICogc2lnbiQkMSxcbiAgICAgICAgcGhpaSxcbiAgICAgICAgYW50aW1lcmlkaWFuID0gYWJzKGRlbHRhKSA+IDE4MDtcbiAgICBpZiAoYW50aW1lcmlkaWFuIF4gKHNpZ24kJDEgKiBsYW1iZGEyIDwgbGFtYmRhaSAmJiBsYW1iZGFpIDwgc2lnbiQkMSAqIGxhbWJkYSkpIHtcbiAgICAgIHBoaWkgPSBpbmZsZWN0aW9uWzFdICogZGVncmVlcyQxO1xuICAgICAgaWYgKHBoaWkgPiBwaGkxKSBwaGkxID0gcGhpaTtcbiAgICB9IGVsc2UgaWYgKGxhbWJkYWkgPSAobGFtYmRhaSArIDM2MCkgJSAzNjAgLSAxODAsIGFudGltZXJpZGlhbiBeIChzaWduJCQxICogbGFtYmRhMiA8IGxhbWJkYWkgJiYgbGFtYmRhaSA8IHNpZ24kJDEgKiBsYW1iZGEpKSB7XG4gICAgICBwaGlpID0gLWluZmxlY3Rpb25bMV0gKiBkZWdyZWVzJDE7XG4gICAgICBpZiAocGhpaSA8IHBoaTApIHBoaTAgPSBwaGlpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGhpIDwgcGhpMCkgcGhpMCA9IHBoaTtcbiAgICAgIGlmIChwaGkgPiBwaGkxKSBwaGkxID0gcGhpO1xuICAgIH1cbiAgICBpZiAoYW50aW1lcmlkaWFuKSB7XG4gICAgICBpZiAobGFtYmRhIDwgbGFtYmRhMikge1xuICAgICAgICBpZiAoYW5nbGUobGFtYmRhMCQxLCBsYW1iZGEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSkgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhbmdsZShsYW1iZGEsIGxhbWJkYTEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSkgbGFtYmRhMCQxID0gbGFtYmRhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGFtYmRhMSA+PSBsYW1iZGEwJDEpIHtcbiAgICAgICAgaWYgKGxhbWJkYSA8IGxhbWJkYTAkMSkgbGFtYmRhMCQxID0gbGFtYmRhO1xuICAgICAgICBpZiAobGFtYmRhID4gbGFtYmRhMSkgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsYW1iZGEgPiBsYW1iZGEyKSB7XG4gICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYSwgbGFtYmRhMSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKSBsYW1iZGEwJDEgPSBsYW1iZGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmFuZ2VzLnB1c2gocmFuZ2UgPSBbbGFtYmRhMCQxID0gbGFtYmRhLCBsYW1iZGExID0gbGFtYmRhXSk7XG4gIH1cbiAgaWYgKHBoaSA8IHBoaTApIHBoaTAgPSBwaGk7XG4gIGlmIChwaGkgPiBwaGkxKSBwaGkxID0gcGhpO1xuICBwMCA9IHAsIGxhbWJkYTIgPSBsYW1iZGE7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0xpbmVTdGFydCgpIHtcbiAgYm91bmRzU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xufVxuXG5mdW5jdGlvbiBib3VuZHNMaW5lRW5kKCkge1xuICByYW5nZVswXSA9IGxhbWJkYTAkMSwgcmFuZ2VbMV0gPSBsYW1iZGExO1xuICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNQb2ludDtcbiAgcDAgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBib3VuZHNSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgaWYgKHAwKSB7XG4gICAgdmFyIGRlbHRhID0gbGFtYmRhIC0gbGFtYmRhMjtcbiAgICBkZWx0YVN1bS5hZGQoYWJzKGRlbHRhKSA+IDE4MCA/IGRlbHRhICsgKGRlbHRhID4gMCA/IDM2MCA6IC0zNjApIDogZGVsdGEpO1xuICB9IGVsc2Uge1xuICAgIGxhbWJkYTAwJDEgPSBsYW1iZGEsIHBoaTAwJDEgPSBwaGk7XG4gIH1cbiAgYXJlYVN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gIGxpbmVQb2ludChsYW1iZGEsIHBoaSk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc1JpbmdTdGFydCgpIHtcbiAgYXJlYVN0cmVhbS5saW5lU3RhcnQoKTtcbn1cblxuZnVuY3Rpb24gYm91bmRzUmluZ0VuZCgpIHtcbiAgYm91bmRzUmluZ1BvaW50KGxhbWJkYTAwJDEsIHBoaTAwJDEpO1xuICBhcmVhU3RyZWFtLmxpbmVFbmQoKTtcbiAgaWYgKGFicyhkZWx0YVN1bSkgPiBlcHNpbG9uJDIpIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCk7XG4gIHJhbmdlWzBdID0gbGFtYmRhMCQxLCByYW5nZVsxXSA9IGxhbWJkYTE7XG4gIHAwID0gbnVsbDtcbn1cblxuLy8gRmluZHMgdGhlIGxlZnQtcmlnaHQgZGlzdGFuY2UgYmV0d2VlbiB0d28gbG9uZ2l0dWRlcy5cbi8vIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIChsYW1iZGExIC0gbGFtYmRhMCArIDM2MMKwKSAlIDM2MMKwLCBleGNlcHQgdGhhdCB3ZSB3YW50XG4vLyB0aGUgZGlzdGFuY2UgYmV0d2VlbiDCsTE4MMKwIHRvIGJlIDM2MMKwLlxuZnVuY3Rpb24gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkge1xuICByZXR1cm4gKGxhbWJkYTEgLT0gbGFtYmRhMCkgPCAwID8gbGFtYmRhMSArIDM2MCA6IGxhbWJkYTE7XG59XG5cbmZ1bmN0aW9uIHJhbmdlQ29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VDb250YWlucyhyYW5nZSwgeCkge1xuICByZXR1cm4gcmFuZ2VbMF0gPD0gcmFuZ2VbMV0gPyByYW5nZVswXSA8PSB4ICYmIHggPD0gcmFuZ2VbMV0gOiB4IDwgcmFuZ2VbMF0gfHwgcmFuZ2VbMV0gPCB4O1xufVxuXG52YXIgYm91bmRzID0gZnVuY3Rpb24oZmVhdHVyZSkge1xuICB2YXIgaSwgbiwgYSwgYiwgbWVyZ2VkLCBkZWx0YU1heCwgZGVsdGE7XG5cbiAgcGhpMSA9IGxhbWJkYTEgPSAtKGxhbWJkYTAkMSA9IHBoaTAgPSBJbmZpbml0eSk7XG4gIHJhbmdlcyA9IFtdO1xuICBnZW9TdHJlYW0oZmVhdHVyZSwgYm91bmRzU3RyZWFtKTtcblxuICAvLyBGaXJzdCwgc29ydCByYW5nZXMgYnkgdGhlaXIgbWluaW11bSBsb25naXR1ZGVzLlxuICBpZiAobiA9IHJhbmdlcy5sZW5ndGgpIHtcbiAgICByYW5nZXMuc29ydChyYW5nZUNvbXBhcmUpO1xuXG4gICAgLy8gVGhlbiwgbWVyZ2UgYW55IHJhbmdlcyB0aGF0IG92ZXJsYXAuXG4gICAgZm9yIChpID0gMSwgYSA9IHJhbmdlc1swXSwgbWVyZ2VkID0gW2FdOyBpIDwgbjsgKytpKSB7XG4gICAgICBiID0gcmFuZ2VzW2ldO1xuICAgICAgaWYgKHJhbmdlQ29udGFpbnMoYSwgYlswXSkgfHwgcmFuZ2VDb250YWlucyhhLCBiWzFdKSkge1xuICAgICAgICBpZiAoYW5nbGUoYVswXSwgYlsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSkgYVsxXSA9IGJbMV07XG4gICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzBdID0gYlswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZC5wdXNoKGEgPSBiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCBmaW5kIHRoZSBsYXJnZXN0IGdhcCBiZXR3ZWVuIHRoZSBtZXJnZWQgcmFuZ2VzLlxuICAgIC8vIFRoZSBmaW5hbCBib3VuZGluZyBib3ggd2lsbCBiZSB0aGUgaW52ZXJzZSBvZiB0aGlzIGdhcC5cbiAgICBmb3IgKGRlbHRhTWF4ID0gLUluZmluaXR5LCBuID0gbWVyZ2VkLmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbWVyZ2VkW25dOyBpIDw9IG47IGEgPSBiLCArK2kpIHtcbiAgICAgIGIgPSBtZXJnZWRbaV07XG4gICAgICBpZiAoKGRlbHRhID0gYW5nbGUoYVsxXSwgYlswXSkpID4gZGVsdGFNYXgpIGRlbHRhTWF4ID0gZGVsdGEsIGxhbWJkYTAkMSA9IGJbMF0sIGxhbWJkYTEgPSBhWzFdO1xuICAgIH1cbiAgfVxuXG4gIHJhbmdlcyA9IHJhbmdlID0gbnVsbDtcblxuICByZXR1cm4gbGFtYmRhMCQxID09PSBJbmZpbml0eSB8fCBwaGkwID09PSBJbmZpbml0eVxuICAgICAgPyBbW05hTiwgTmFOXSwgW05hTiwgTmFOXV1cbiAgICAgIDogW1tsYW1iZGEwJDEsIHBoaTBdLCBbbGFtYmRhMSwgcGhpMV1dO1xufTtcblxudmFyIFcwO1xudmFyIFcxO1xudmFyIFgwO1xudmFyIFkwO1xudmFyIFowO1xudmFyIFgxO1xudmFyIFkxO1xudmFyIFoxO1xudmFyIFgyO1xudmFyIFkyO1xudmFyIFoyO1xudmFyIGxhbWJkYTAwJDI7XG52YXIgcGhpMDAkMjtcbnZhciB4MDtcbnZhciB5MDtcbnZhciB6MDsgLy8gcHJldmlvdXMgcG9pbnRcblxudmFyIGNlbnRyb2lkU3RyZWFtID0ge1xuICBzcGhlcmU6IG5vb3AkMSxcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQsXG4gIGxpbmVTdGFydDogY2VudHJvaWRMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZFJpbmdTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICB9XG59O1xuXG4vLyBBcml0aG1ldGljIG1lYW4gb2YgQ2FydGVzaWFuIHZlY3RvcnMuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyQxKHBoaSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oY29zUGhpICogY29zJDEobGFtYmRhKSwgY29zUGhpICogc2luJDEobGFtYmRhKSwgc2luJDEocGhpKSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeCwgeSwgeikge1xuICArK1cwO1xuICBYMCArPSAoeCAtIFgwKSAvIFcwO1xuICBZMCArPSAoeSAtIFkwKSAvIFcwO1xuICBaMCArPSAoeiAtIFowKSAvIFcwO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyQxKHBoaSk7XG4gIHgwID0gY29zUGhpICogY29zJDEobGFtYmRhKTtcbiAgeTAgPSBjb3NQaGkgKiBzaW4kMShsYW1iZGEpO1xuICB6MCA9IHNpbiQxKHBoaSk7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnQ7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyQxKHBoaSksXG4gICAgICB4ID0gY29zUGhpICogY29zJDEobGFtYmRhKSxcbiAgICAgIHkgPSBjb3NQaGkgKiBzaW4kMShsYW1iZGEpLFxuICAgICAgeiA9IHNpbiQxKHBoaSksXG4gICAgICB3ID0gYXRhbjIoc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICBXMSArPSB3O1xuICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVFbmQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuLy8gU2VlIEouIEUuIEJyb2NrLCBUaGUgSW5lcnRpYSBUZW5zb3IgZm9yIGEgU3BoZXJpY2FsIFRyaWFuZ2xlLFxuLy8gSi4gQXBwbGllZCBNZWNoYW5pY3MgNDIsIDIzOSAoMTk3NSkuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQoKSB7XG4gIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYTAwJDIsIHBoaTAwJDIpO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1BvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhMDAkMiA9IGxhbWJkYSwgcGhpMDAkMiA9IHBoaTtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUmluZ1BvaW50O1xuICB2YXIgY29zUGhpID0gY29zJDEocGhpKTtcbiAgeDAgPSBjb3NQaGkgKiBjb3MkMShsYW1iZGEpO1xuICB5MCA9IGNvc1BoaSAqIHNpbiQxKGxhbWJkYSk7XG4gIHowID0gc2luJDEocGhpKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zJDEocGhpKSxcbiAgICAgIHggPSBjb3NQaGkgKiBjb3MkMShsYW1iZGEpLFxuICAgICAgeSA9IGNvc1BoaSAqIHNpbiQxKGxhbWJkYSksXG4gICAgICB6ID0gc2luJDEocGhpKSxcbiAgICAgIGN4ID0geTAgKiB6IC0gejAgKiB5LFxuICAgICAgY3kgPSB6MCAqIHggLSB4MCAqIHosXG4gICAgICBjeiA9IHgwICogeSAtIHkwICogeCxcbiAgICAgIG0gPSBzcXJ0KGN4ICogY3ggKyBjeSAqIGN5ICsgY3ogKiBjeiksXG4gICAgICB3ID0gYXNpbihtKSwgLy8gbGluZSB3ZWlnaHQgPSBhbmdsZVxuICAgICAgdiA9IG0gJiYgLXcgLyBtOyAvLyBhcmVhIHdlaWdodCBtdWx0aXBsaWVyXG4gIFgyICs9IHYgKiBjeDtcbiAgWTIgKz0gdiAqIGN5O1xuICBaMiArPSB2ICogY3o7XG4gIFcxICs9IHc7XG4gIFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gIFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gIFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbnZhciBjZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBXMCA9IFcxID1cbiAgWDAgPSBZMCA9IFowID1cbiAgWDEgPSBZMSA9IFoxID1cbiAgWDIgPSBZMiA9IFoyID0gMDtcbiAgZ2VvU3RyZWFtKG9iamVjdCwgY2VudHJvaWRTdHJlYW0pO1xuXG4gIHZhciB4ID0gWDIsXG4gICAgICB5ID0gWTIsXG4gICAgICB6ID0gWjIsXG4gICAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIC8vIElmIHRoZSBhcmVhLXdlaWdodGVkIGNjZW50cm9pZCBpcyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBsZW5ndGgtd2VpZ2h0ZWQgY2NlbnRyb2lkLlxuICBpZiAobSA8IGVwc2lsb24yJDEpIHtcbiAgICB4ID0gWDEsIHkgPSBZMSwgeiA9IFoxO1xuICAgIC8vIElmIHRoZSBmZWF0dXJlIGhhcyB6ZXJvIGxlbmd0aCwgZmFsbCBiYWNrIHRvIGFyaXRobWV0aWMgbWVhbiBvZiBwb2ludCB2ZWN0b3JzLlxuICAgIGlmIChXMSA8IGVwc2lsb24kMikgeCA9IFgwLCB5ID0gWTAsIHogPSBaMDtcbiAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgIC8vIElmIHRoZSBmZWF0dXJlIHN0aWxsIGhhcyBhbiB1bmRlZmluZWQgY2NlbnRyb2lkLCB0aGVuIHJldHVybi5cbiAgICBpZiAobSA8IGVwc2lsb24yJDEpIHJldHVybiBbTmFOLCBOYU5dO1xuICB9XG5cbiAgcmV0dXJuIFthdGFuMih5LCB4KSAqIGRlZ3JlZXMkMSwgYXNpbih6IC8gc3FydChtKSkgKiBkZWdyZWVzJDFdO1xufTtcblxudmFyIGNvbnN0YW50JDcgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn07XG5cbnZhciBjb21wb3NlID0gZnVuY3Rpb24oYSwgYikge1xuXG4gIGZ1bmN0aW9uIGNvbXBvc2UoeCwgeSkge1xuICAgIHJldHVybiB4ID0gYSh4LCB5KSwgYih4WzBdLCB4WzFdKTtcbiAgfVxuXG4gIGlmIChhLmludmVydCAmJiBiLmludmVydCkgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBiLmludmVydCh4LCB5KSwgeCAmJiBhLmludmVydCh4WzBdLCB4WzFdKTtcbiAgfTtcblxuICByZXR1cm4gY29tcG9zZTtcbn07XG5cbmZ1bmN0aW9uIHJvdGF0aW9uSWRlbnRpdHkobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFtsYW1iZGEgPiBwaSQzID8gbGFtYmRhIC0gdGF1JDMgOiBsYW1iZGEgPCAtcGkkMyA/IGxhbWJkYSArIHRhdSQzIDogbGFtYmRhLCBwaGldO1xufVxuXG5yb3RhdGlvbklkZW50aXR5LmludmVydCA9IHJvdGF0aW9uSWRlbnRpdHk7XG5cbmZ1bmN0aW9uIHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHJldHVybiAoZGVsdGFMYW1iZGEgJT0gdGF1JDMpID8gKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyBjb21wb3NlKHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSwgcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkpXG4gICAgOiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkpXG4gICAgOiAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpXG4gICAgOiByb3RhdGlvbklkZW50aXR5KTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gIHJldHVybiBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBsYW1iZGEgKz0gZGVsdGFMYW1iZGEsIFtsYW1iZGEgPiBwaSQzID8gbGFtYmRhIC0gdGF1JDMgOiBsYW1iZGEgPCAtcGkkMyA/IGxhbWJkYSArIHRhdSQzIDogbGFtYmRhLCBwaGldO1xuICB9O1xufVxuXG5mdW5jdGlvbiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICB2YXIgcm90YXRpb24gPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpO1xuICByb3RhdGlvbi5pbnZlcnQgPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoLWRlbHRhTGFtYmRhKTtcbiAgcmV0dXJuIHJvdGF0aW9uO1xufVxuXG5mdW5jdGlvbiByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHZhciBjb3NEZWx0YVBoaSA9IGNvcyQxKGRlbHRhUGhpKSxcbiAgICAgIHNpbkRlbHRhUGhpID0gc2luJDEoZGVsdGFQaGkpLFxuICAgICAgY29zRGVsdGFHYW1tYSA9IGNvcyQxKGRlbHRhR2FtbWEpLFxuICAgICAgc2luRGVsdGFHYW1tYSA9IHNpbiQxKGRlbHRhR2FtbWEpO1xuXG4gIGZ1bmN0aW9uIHJvdGF0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIGNvc1BoaSA9IGNvcyQxKHBoaSksXG4gICAgICAgIHggPSBjb3MkMShsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luJDEobGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeiA9IHNpbiQxKHBoaSksXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFQaGkgKyB4ICogc2luRGVsdGFQaGk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hIC0gayAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSAtIHogKiBzaW5EZWx0YVBoaSksXG4gICAgICBhc2luKGsgKiBjb3NEZWx0YUdhbW1hICsgeSAqIHNpbkRlbHRhR2FtbWEpXG4gICAgXTtcbiAgfVxuXG4gIHJvdGF0aW9uLmludmVydCA9IGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIGNvc1BoaSA9IGNvcyQxKHBoaSksXG4gICAgICAgIHggPSBjb3MkMShsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luJDEobGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeiA9IHNpbiQxKHBoaSksXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFHYW1tYSAtIHkgKiBzaW5EZWx0YUdhbW1hO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSArIHogKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgKyBrICogc2luRGVsdGFQaGkpLFxuICAgICAgYXNpbihrICogY29zRGVsdGFQaGkgLSB4ICogc2luRGVsdGFQaGkpXG4gICAgXTtcbiAgfTtcblxuICByZXR1cm4gcm90YXRpb247XG59XG5cbnZhciByb3RhdGlvbiA9IGZ1bmN0aW9uKHJvdGF0ZSkge1xuICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKHJvdGF0ZVswXSAqIHJhZGlhbnMsIHJvdGF0ZVsxXSAqIHJhZGlhbnMsIHJvdGF0ZS5sZW5ndGggPiAyID8gcm90YXRlWzJdICogcmFkaWFucyA6IDApO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmQoY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzWzBdICo9IGRlZ3JlZXMkMSwgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcyQxLCBjb29yZGluYXRlcztcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcyA9IHJvdGF0ZS5pbnZlcnQoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkZWdyZWVzJDEsIGNvb3JkaW5hdGVzWzFdICo9IGRlZ3JlZXMkMSwgY29vcmRpbmF0ZXM7XG4gIH07XG5cbiAgcmV0dXJuIGZvcndhcmQ7XG59O1xuXG4vLyBHZW5lcmF0ZXMgYSBjaXJjbGUgY2VudGVyZWQgYXQgWzDCsCwgMMKwXSwgd2l0aCBhIGdpdmVuIHJhZGl1cyBhbmQgcHJlY2lzaW9uLlxuZnVuY3Rpb24gY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCB0MCwgdDEpIHtcbiAgaWYgKCFkZWx0YSkgcmV0dXJuO1xuICB2YXIgY29zUmFkaXVzID0gY29zJDEocmFkaXVzKSxcbiAgICAgIHNpblJhZGl1cyA9IHNpbiQxKHJhZGl1cyksXG4gICAgICBzdGVwID0gZGlyZWN0aW9uICogZGVsdGE7XG4gIGlmICh0MCA9PSBudWxsKSB7XG4gICAgdDAgPSByYWRpdXMgKyBkaXJlY3Rpb24gKiB0YXUkMztcbiAgICB0MSA9IHJhZGl1cyAtIHN0ZXAgLyAyO1xuICB9IGVsc2Uge1xuICAgIHQwID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDApO1xuICAgIHQxID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDEpO1xuICAgIGlmIChkaXJlY3Rpb24gPiAwID8gdDAgPCB0MSA6IHQwID4gdDEpIHQwICs9IGRpcmVjdGlvbiAqIHRhdSQzO1xuICB9XG4gIGZvciAodmFyIHBvaW50LCB0ID0gdDA7IGRpcmVjdGlvbiA+IDAgPyB0ID4gdDEgOiB0IDwgdDE7IHQgLT0gc3RlcCkge1xuICAgIHBvaW50ID0gc3BoZXJpY2FsKFtjb3NSYWRpdXMsIC1zaW5SYWRpdXMgKiBjb3MkMSh0KSwgLXNpblJhZGl1cyAqIHNpbiQxKHQpXSk7XG4gICAgc3RyZWFtLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgc2lnbmVkIGFuZ2xlIG9mIGEgY2FydGVzaWFuIHBvaW50IHJlbGF0aXZlIHRvIFtjb3NSYWRpdXMsIDAsIDBdLlxuZnVuY3Rpb24gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgcG9pbnQpIHtcbiAgcG9pbnQgPSBjYXJ0ZXNpYW4ocG9pbnQpLCBwb2ludFswXSAtPSBjb3NSYWRpdXM7XG4gIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UocG9pbnQpO1xuICB2YXIgcmFkaXVzID0gYWNvcygtcG9pbnRbMV0pO1xuICByZXR1cm4gKCgtcG9pbnRbMl0gPCAwID8gLXJhZGl1cyA6IHJhZGl1cykgKyB0YXUkMyAtIGVwc2lsb24kMikgJSB0YXUkMztcbn1cblxudmFyIGNpcmNsZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2VudGVyID0gY29uc3RhbnQkNyhbMCwgMF0pLFxuICAgICAgcmFkaXVzID0gY29uc3RhbnQkNyg5MCksXG4gICAgICBwcmVjaXNpb24gPSBjb25zdGFudCQ3KDYpLFxuICAgICAgcmluZyxcbiAgICAgIHJvdGF0ZSxcbiAgICAgIHN0cmVhbSA9IHtwb2ludDogcG9pbnR9O1xuXG4gIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICByaW5nLnB1c2goeCA9IHJvdGF0ZSh4LCB5KSk7XG4gICAgeFswXSAqPSBkZWdyZWVzJDEsIHhbMV0gKj0gZGVncmVlcyQxO1xuICB9XG5cbiAgZnVuY3Rpb24gY2lyY2xlKCkge1xuICAgIHZhciBjID0gY2VudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIgPSByYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnMsXG4gICAgICAgIHAgPSBwcmVjaXNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnM7XG4gICAgcmluZyA9IFtdO1xuICAgIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoLWNbMF0gKiByYWRpYW5zLCAtY1sxXSAqIHJhZGlhbnMsIDApLmludmVydDtcbiAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByLCBwLCAxKTtcbiAgICBjID0ge3R5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogW3JpbmddfTtcbiAgICByaW5nID0gcm90YXRlID0gbnVsbDtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGNpcmNsZS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQ3KFsrX1swXSwgK19bMV1dKSwgY2lyY2xlKSA6IGNlbnRlcjtcbiAgfTtcblxuICBjaXJjbGUucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkNygrXyksIGNpcmNsZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgY2lyY2xlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjaXNpb24gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDcoK18pLCBjaXJjbGUpIDogcHJlY2lzaW9uO1xuICB9O1xuXG4gIHJldHVybiBjaXJjbGU7XG59O1xuXG52YXIgY2xpcEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGluZXMgPSBbXSxcbiAgICAgIGxpbmU7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGxpbmUucHVzaChbeCwgeV0pO1xuICAgIH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGxpbmVzLnB1c2gobGluZSA9IFtdKTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IG5vb3AkMSxcbiAgICByZWpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICB9LFxuICAgIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbGluZXM7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgbGluZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBjbGlwTGluZSA9IGZ1bmN0aW9uKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICB0MCA9IDAsXG4gICAgICB0MSA9IDEsXG4gICAgICBkeCA9IGJ4IC0gYXgsXG4gICAgICBkeSA9IGJ5IC0gYXksXG4gICAgICByO1xuXG4gIHIgPSB4MCAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geDEgLSBheDtcbiAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgciA9IHkwIC0gYXk7XG4gIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB5MSAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICBpZiAodDAgPiAwKSBhWzBdID0gYXggKyB0MCAqIGR4LCBhWzFdID0gYXkgKyB0MCAqIGR5O1xuICBpZiAodDEgPCAxKSBiWzBdID0gYXggKyB0MSAqIGR4LCBiWzFdID0gYXkgKyB0MSAqIGR5O1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBwb2ludEVxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYWJzKGFbMF0gLSBiWzBdKSA8IGVwc2lsb24kMiAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgZXBzaWxvbiQyO1xufTtcblxuZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHBvaW50LCBwb2ludHMsIG90aGVyLCBlbnRyeSkge1xuICB0aGlzLnggPSBwb2ludDtcbiAgdGhpcy56ID0gcG9pbnRzO1xuICB0aGlzLm8gPSBvdGhlcjsgLy8gYW5vdGhlciBpbnRlcnNlY3Rpb25cbiAgdGhpcy5lID0gZW50cnk7IC8vIGlzIGFuIGVudHJ5P1xuICB0aGlzLnYgPSBmYWxzZTsgLy8gdmlzaXRlZFxuICB0aGlzLm4gPSB0aGlzLnAgPSBudWxsOyAvLyBuZXh0ICYgcHJldmlvdXNcbn1cblxuLy8gQSBnZW5lcmFsaXplZCBwb2x5Z29uIGNsaXBwaW5nIGFsZ29yaXRobTogZ2l2ZW4gYSBwb2x5Z29uIHRoYXQgaGFzIGJlZW4gY3V0XG4vLyBpbnRvIGl0cyB2aXNpYmxlIGxpbmUgc2VnbWVudHMsIGFuZCByZWpvaW5zIHRoZSBzZWdtZW50cyBieSBpbnRlcnBvbGF0aW5nXG4vLyBhbG9uZyB0aGUgY2xpcCBlZGdlLlxudmFyIGNsaXBQb2x5Z29uID0gZnVuY3Rpb24oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKSB7XG4gIHZhciBzdWJqZWN0ID0gW10sXG4gICAgICBjbGlwID0gW10sXG4gICAgICBpLFxuICAgICAgbjtcblxuICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICBpZiAoKG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEpIDw9IDApIHJldHVybjtcbiAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl0sIHg7XG5cbiAgICAvLyBJZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIG9mIGEgc2VnbWVudCBhcmUgY29pbmNpZGVudCwgdGhlbiB0cmVhdCBhcyBhXG4gICAgLy8gY2xvc2VkIHJpbmcuIFRPRE8gaWYgYWxsIHJpbmdzIGFyZSBjbG9zZWQsIHRoZW4gdGhlIHdpbmRpbmcgb3JkZXIgb2YgdGhlXG4gICAgLy8gZXh0ZXJpb3IgcmluZyBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHAwID0gc2VnbWVudFtpXSlbMF0sIHAwWzFdKTtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBzZWdtZW50LCBudWxsLCB0cnVlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIG51bGwsIHgsIGZhbHNlKSk7XG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBzZWdtZW50LCBudWxsLCBmYWxzZSkpO1xuICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBudWxsLCB4LCB0cnVlKSk7XG4gIH0pO1xuXG4gIGlmICghc3ViamVjdC5sZW5ndGgpIHJldHVybjtcblxuICBjbGlwLnNvcnQoY29tcGFyZUludGVyc2VjdGlvbik7XG4gIGxpbmskMShzdWJqZWN0KTtcbiAgbGluayQxKGNsaXApO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBjbGlwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNsaXBbaV0uZSA9IHN0YXJ0SW5zaWRlID0gIXN0YXJ0SW5zaWRlO1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSxcbiAgICAgIHBvaW50cyxcbiAgICAgIHBvaW50O1xuXG4gIHdoaWxlICgxKSB7XG4gICAgLy8gRmluZCBmaXJzdCB1bnZpc2l0ZWQgaW50ZXJzZWN0aW9uLlxuICAgIHZhciBjdXJyZW50ID0gc3RhcnQsXG4gICAgICAgIGlzU3ViamVjdCA9IHRydWU7XG4gICAgd2hpbGUgKGN1cnJlbnQudikgaWYgKChjdXJyZW50ID0gY3VycmVudC5uKSA9PT0gc3RhcnQpIHJldHVybjtcbiAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIGRvIHtcbiAgICAgIGN1cnJlbnQudiA9IGN1cnJlbnQuby52ID0gdHJ1ZTtcbiAgICAgIGlmIChjdXJyZW50LmUpIHtcbiAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICBmb3IgKGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm87XG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICBpc1N1YmplY3QgPSAhaXNTdWJqZWN0O1xuICAgIH0gd2hpbGUgKCFjdXJyZW50LnYpO1xuICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxpbmskMShhcnJheSkge1xuICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSkgcmV0dXJuO1xuICB2YXIgbixcbiAgICAgIGkgPSAwLFxuICAgICAgYSA9IGFycmF5WzBdLFxuICAgICAgYjtcbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBhLm4gPSBiID0gYXJyYXlbaV07XG4gICAgYi5wID0gYTtcbiAgICBhID0gYjtcbiAgfVxuICBhLm4gPSBiID0gYXJyYXlbMF07XG4gIGIucCA9IGE7XG59XG5cbnZhciBjbGlwTWF4ID0gMWU5O1xudmFyIGNsaXBNaW4gPSAtY2xpcE1heDtcblxuLy8gVE9ETyBVc2UgZDMtcG9seWdvbuKAmXMgcG9seWdvbkNvbnRhaW5zIGhlcmUgZm9yIHRoZSByaW5nIGNoZWNrP1xuLy8gVE9ETyBFbGltaW5hdGUgZHVwbGljYXRlIGJ1ZmZlcmluZyBpbiBjbGlwQnVmZmVyIGFuZCBwb2x5Z29uLnB1c2g/XG5cbmZ1bmN0aW9uIGNsaXBFeHRlbnQoeDAsIHkwLCB4MSwgeTEpIHtcblxuICBmdW5jdGlvbiB2aXNpYmxlKHgsIHkpIHtcbiAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgIGlmIChmcm9tID09IG51bGxcbiAgICAgICAgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSlcbiAgICAgICAgfHwgY29tcGFyZVBvaW50KGZyb20sIHRvKSA8IDAgXiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICBkbyBzdHJlYW0ucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcbiAgICAgIHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgZXBzaWxvbiQyID8gZGlyZWN0aW9uID4gMCA/IDAgOiAzXG4gICAgICAgIDogYWJzKHBbMF0gLSB4MSkgPCBlcHNpbG9uJDIgPyBkaXJlY3Rpb24gPiAwID8gMiA6IDFcbiAgICAgICAgOiBhYnMocFsxXSAtIHkwKSA8IGVwc2lsb24kMiA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMFxuICAgICAgICA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjsgLy8gYWJzKHBbMV0gLSB5MSkgPCBlcHNpbG9uXG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZVBvaW50KGEueCwgYi54KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVQb2ludChhLCBiKSB7XG4gICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLFxuICAgICAgICBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYlxuICAgICAgICA6IGNhID09PSAwID8gYlsxXSAtIGFbMV1cbiAgICAgICAgOiBjYSA9PT0gMSA/IGFbMF0gLSBiWzBdXG4gICAgICAgIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXVxuICAgICAgICA6IGJbMF0gLSBhWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sXG4gICAgICAgIGJ1ZmZlclN0cmVhbSA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHJpbmcsXG4gICAgICAgIHhfXywgeV9fLCB2X18sIC8vIGZpcnN0IHBvaW50XG4gICAgICAgIHhfLCB5Xywgdl8sIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGZpcnN0LFxuICAgICAgICBjbGVhbjtcblxuICAgIHZhciBjbGlwU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBwb2x5Z29uU3RhcnQsXG4gICAgICBwb2x5Z29uRW5kOiBwb2x5Z29uRW5kXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGlmICh2aXNpYmxlKHgsIHkpKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbkluc2lkZSgpIHtcbiAgICAgIHZhciB3aW5kaW5nID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBmb3IgKHZhciByaW5nID0gcG9seWdvbltpXSwgaiA9IDEsIG0gPSByaW5nLmxlbmd0aCwgcG9pbnQgPSByaW5nWzBdLCBhMCwgYTEsIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07IGogPCBtOyArK2opIHtcbiAgICAgICAgICBhMCA9IGIwLCBhMSA9IGIxLCBwb2ludCA9IHJpbmdbal0sIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07XG4gICAgICAgICAgaWYgKGExIDw9IHkxKSB7IGlmIChiMSA+IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA+IChiMSAtIGExKSAqICh4MCAtIGEwKSkgKyt3aW5kaW5nOyB9XG4gICAgICAgICAgZWxzZSB7IGlmIChiMSA8PSB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPCAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpIC0td2luZGluZzsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aW5kaW5nO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBnZW9tZXRyeSB3aXRoaW4gYSBwb2x5Z29uIGFuZCB0aGVuIGNsaXAgaXQgZW4gbWFzc2UuXG4gICAgZnVuY3Rpb24gcG9seWdvblN0YXJ0KCkge1xuICAgICAgYWN0aXZlU3RyZWFtID0gYnVmZmVyU3RyZWFtLCBzZWdtZW50cyA9IFtdLCBwb2x5Z29uID0gW10sIGNsZWFuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uRW5kKCkge1xuICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkluc2lkZSgpLFxuICAgICAgICAgIGNsZWFuSW5zaWRlID0gY2xlYW4gJiYgc3RhcnRJbnNpZGUsXG4gICAgICAgICAgdmlzaWJsZSA9IChzZWdtZW50cyA9IG1lcmdlKHNlZ21lbnRzKSkubGVuZ3RoO1xuICAgICAgaWYgKGNsZWFuSW5zaWRlIHx8IHZpc2libGUpIHtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICBpZiAoY2xlYW5JbnNpZGUpIHtcbiAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc3RyZWFtKTtcbiAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgfVxuICAgICAgYWN0aXZlU3RyZWFtID0gc3RyZWFtLCBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgaWYgKHBvbHlnb24pIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgdl8gPSBmYWxzZTtcbiAgICAgIHhfID0geV8gPSBOYU47XG4gICAgfVxuXG4gICAgLy8gVE9ETyByYXRoZXIgdGhhbiBzcGVjaWFsLWNhc2UgcG9seWdvbnMsIHNpbXBseSBoYW5kbGUgdGhlbSBzZXBhcmF0ZWx5LlxuICAgIC8vIElkZWFsbHksIGNvaW5jaWRlbnQgaW50ZXJzZWN0aW9uIHBvaW50cyBzaG91bGQgYmUgaml0dGVyZWQgdG8gYXZvaWRcbiAgICAvLyBjbGlwcGluZyBpc3N1ZXMuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICBpZiAodl9fICYmIHZfKSBidWZmZXJTdHJlYW0ucmVqb2luKCk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyU3RyZWFtLnJlc3VsdCgpKTtcbiAgICAgIH1cbiAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIGlmICh2XykgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgdmFyIHYgPSB2aXNpYmxlKHgsIHkpO1xuICAgICAgaWYgKHBvbHlnb24pIHJpbmcucHVzaChbeCwgeV0pO1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHYgJiYgdl8pIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGEgPSBbeF8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4XykpLCB5XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHlfKSldLFxuICAgICAgICAgICAgICBiID0gW3ggPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4KSksIHkgPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5KSldO1xuICAgICAgICAgIGlmIChjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkpIHtcbiAgICAgICAgICAgIGlmICghdl8pIHtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYVswXSwgYVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYlswXSwgYlsxXSk7XG4gICAgICAgICAgICBpZiAoIXYpIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodikge1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXBTdHJlYW07XG4gIH07XG59XG5cbnZhciBleHRlbnQkMSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeTAgPSAwLFxuICAgICAgeDEgPSA5NjAsXG4gICAgICB5MSA9IDUwMCxcbiAgICAgIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW0sXG4gICAgICBjbGlwO1xuXG4gIHJldHVybiBjbGlwID0ge1xuICAgIHN0cmVhbTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBjbGlwRXh0ZW50KHgwLCB5MCwgeDEsIHkxKShjYWNoZVN0cmVhbSA9IHN0cmVhbSk7XG4gICAgfSxcbiAgICBleHRlbnQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0sIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsLCBjbGlwKSA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBzdW0kMSA9IGFkZGVyKCk7XG5cbnZhciBwb2x5Z29uQ29udGFpbnMgPSBmdW5jdGlvbihwb2x5Z29uLCBwb2ludCkge1xuICB2YXIgbGFtYmRhID0gcG9pbnRbMF0sXG4gICAgICBwaGkgPSBwb2ludFsxXSxcbiAgICAgIG5vcm1hbCA9IFtzaW4kMShsYW1iZGEpLCAtY29zJDEobGFtYmRhKSwgMF0sXG4gICAgICBhbmdsZSA9IDAsXG4gICAgICB3aW5kaW5nID0gMDtcblxuICBzdW0kMS5yZXNldCgpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoIShtID0gKHJpbmcgPSBwb2x5Z29uW2ldKS5sZW5ndGgpKSBjb250aW51ZTtcbiAgICB2YXIgcmluZyxcbiAgICAgICAgbSxcbiAgICAgICAgcG9pbnQwID0gcmluZ1ttIC0gMV0sXG4gICAgICAgIGxhbWJkYTAgPSBwb2ludDBbMF0sXG4gICAgICAgIHBoaTAgPSBwb2ludDBbMV0gLyAyICsgcXVhcnRlclBpLFxuICAgICAgICBzaW5QaGkwID0gc2luJDEocGhpMCksXG4gICAgICAgIGNvc1BoaTAgPSBjb3MkMShwaGkwKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqLCBsYW1iZGEwID0gbGFtYmRhMSwgc2luUGhpMCA9IHNpblBoaTEsIGNvc1BoaTAgPSBjb3NQaGkxLCBwb2ludDAgPSBwb2ludDEpIHtcbiAgICAgIHZhciBwb2ludDEgPSByaW5nW2pdLFxuICAgICAgICAgIGxhbWJkYTEgPSBwb2ludDFbMF0sXG4gICAgICAgICAgcGhpMSA9IHBvaW50MVsxXSAvIDIgKyBxdWFydGVyUGksXG4gICAgICAgICAgc2luUGhpMSA9IHNpbiQxKHBoaTEpLFxuICAgICAgICAgIGNvc1BoaTEgPSBjb3MkMShwaGkxKSxcbiAgICAgICAgICBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxuICAgICAgICAgIHNpZ24kJDEgPSBkZWx0YSA+PSAwID8gMSA6IC0xLFxuICAgICAgICAgIGFic0RlbHRhID0gc2lnbiQkMSAqIGRlbHRhLFxuICAgICAgICAgIGFudGltZXJpZGlhbiA9IGFic0RlbHRhID4gcGkkMyxcbiAgICAgICAgICBrID0gc2luUGhpMCAqIHNpblBoaTE7XG5cbiAgICAgIHN1bSQxLmFkZChhdGFuMihrICogc2lnbiQkMSAqIHNpbiQxKGFic0RlbHRhKSwgY29zUGhpMCAqIGNvc1BoaTEgKyBrICogY29zJDEoYWJzRGVsdGEpKSk7XG4gICAgICBhbmdsZSArPSBhbnRpbWVyaWRpYW4gPyBkZWx0YSArIHNpZ24kJDEgKiB0YXUkMyA6IGRlbHRhO1xuXG4gICAgICAvLyBBcmUgdGhlIGxvbmdpdHVkZXMgZWl0aGVyIHNpZGUgb2YgdGhlIHBvaW504oCZcyBtZXJpZGlhbiAobGFtYmRhKSxcbiAgICAgIC8vIGFuZCBhcmUgdGhlIGxhdGl0dWRlcyBzbWFsbGVyIHRoYW4gdGhlIHBhcmFsbGVsIChwaGkpP1xuICAgICAgaWYgKGFudGltZXJpZGlhbiBeIGxhbWJkYTAgPj0gbGFtYmRhIF4gbGFtYmRhMSA+PSBsYW1iZGEpIHtcbiAgICAgICAgdmFyIGFyYyA9IGNhcnRlc2lhbkNyb3NzKGNhcnRlc2lhbihwb2ludDApLCBjYXJ0ZXNpYW4ocG9pbnQxKSk7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoYXJjKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKG5vcm1hbCwgYXJjKTtcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbnRlcnNlY3Rpb24pO1xuICAgICAgICB2YXIgcGhpQXJjID0gKGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAtMSA6IDEpICogYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICBpZiAocGhpID4gcGhpQXJjIHx8IHBoaSA9PT0gcGhpQXJjICYmIChhcmNbMF0gfHwgYXJjWzFdKSkge1xuICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0LCBkZXRlcm1pbmUgd2hldGhlciB0aGUgU291dGggcG9sZSBpcyBpbnNpZGUgb3Igb3V0c2lkZTpcbiAgLy9cbiAgLy8gSXQgaXMgaW5zaWRlIGlmOlxuICAvLyAqIHRoZSBwb2x5Z29uIHdpbmRzIGFyb3VuZCBpdCBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gIC8vICogdGhlIHBvbHlnb24gZG9lcyBub3QgKGN1bXVsYXRpdmVseSkgd2luZCBhcm91bmQgaXQsIGJ1dCBoYXMgYSBuZWdhdGl2ZVxuICAvLyAgIChjb3VudGVyLWNsb2Nrd2lzZSkgYXJlYS5cbiAgLy9cbiAgLy8gU2Vjb25kLCBjb3VudCB0aGUgKHNpZ25lZCkgbnVtYmVyIG9mIHRpbWVzIGEgc2VnbWVudCBjcm9zc2VzIGEgbGFtYmRhXG4gIC8vIGZyb20gdGhlIHBvaW50IHRvIHRoZSBTb3V0aCBwb2xlLiAgSWYgaXQgaXMgemVybywgdGhlbiB0aGUgcG9pbnQgaXMgdGhlXG4gIC8vIHNhbWUgc2lkZSBhcyB0aGUgU291dGggcG9sZS5cblxuICByZXR1cm4gKGFuZ2xlIDwgLWVwc2lsb24kMiB8fCBhbmdsZSA8IGVwc2lsb24kMiAmJiBzdW0kMSA8IC1lcHNpbG9uJDIpIF4gKHdpbmRpbmcgJiAxKTtcbn07XG5cbnZhciBsZW5ndGhTdW0gPSBhZGRlcigpO1xudmFyIGxhbWJkYTAkMjtcbnZhciBzaW5QaGkwJDE7XG52YXIgY29zUGhpMCQxO1xuXG52YXIgbGVuZ3RoU3RyZWFtID0ge1xuICBzcGhlcmU6IG5vb3AkMSxcbiAgcG9pbnQ6IG5vb3AkMSxcbiAgbGluZVN0YXJ0OiBsZW5ndGhMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IG5vb3AkMSxcbiAgcG9seWdvblN0YXJ0OiBub29wJDEsXG4gIHBvbHlnb25FbmQ6IG5vb3AkMVxufTtcblxuZnVuY3Rpb24gbGVuZ3RoTGluZVN0YXJ0KCkge1xuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludEZpcnN0O1xuICBsZW5ndGhTdHJlYW0ubGluZUVuZCA9IGxlbmd0aExpbmVFbmQ7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aExpbmVFbmQoKSB7XG4gIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFN0cmVhbS5saW5lRW5kID0gbm9vcCQxO1xufVxuXG5mdW5jdGlvbiBsZW5ndGhQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgbGFtYmRhMCQyID0gbGFtYmRhLCBzaW5QaGkwJDEgPSBzaW4kMShwaGkpLCBjb3NQaGkwJDEgPSBjb3MkMShwaGkpO1xuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgc2luUGhpID0gc2luJDEocGhpKSxcbiAgICAgIGNvc1BoaSA9IGNvcyQxKHBoaSksXG4gICAgICBkZWx0YSA9IGFicyhsYW1iZGEgLSBsYW1iZGEwJDIpLFxuICAgICAgY29zRGVsdGEgPSBjb3MkMShkZWx0YSksXG4gICAgICBzaW5EZWx0YSA9IHNpbiQxKGRlbHRhKSxcbiAgICAgIHggPSBjb3NQaGkgKiBzaW5EZWx0YSxcbiAgICAgIHkgPSBjb3NQaGkwJDEgKiBzaW5QaGkgLSBzaW5QaGkwJDEgKiBjb3NQaGkgKiBjb3NEZWx0YSxcbiAgICAgIHogPSBzaW5QaGkwJDEgKiBzaW5QaGkgKyBjb3NQaGkwJDEgKiBjb3NQaGkgKiBjb3NEZWx0YTtcbiAgbGVuZ3RoU3VtLmFkZChhdGFuMihzcXJ0KHggKiB4ICsgeSAqIHkpLCB6KSk7XG4gIGxhbWJkYTAkMiA9IGxhbWJkYSwgc2luUGhpMCQxID0gc2luUGhpLCBjb3NQaGkwJDEgPSBjb3NQaGk7XG59XG5cbnZhciBsZW5ndGgkMSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICBsZW5ndGhTdW0ucmVzZXQoKTtcbiAgZ2VvU3RyZWFtKG9iamVjdCwgbGVuZ3RoU3RyZWFtKTtcbiAgcmV0dXJuICtsZW5ndGhTdW07XG59O1xuXG52YXIgY29vcmRpbmF0ZXMgPSBbbnVsbCwgbnVsbF07XG52YXIgb2JqZWN0JDEgPSB7dHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307XG5cbnZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgY29vcmRpbmF0ZXNbMF0gPSBhO1xuICBjb29yZGluYXRlc1sxXSA9IGI7XG4gIHJldHVybiBsZW5ndGgkMShvYmplY3QkMSk7XG59O1xuXG52YXIgY29udGFpbnNPYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBwb2ludCk7XG4gIH0sXG4gIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc0dlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNvbnRhaW5zR2VvbWV0cnlUeXBlID0ge1xuICBTcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHJldHVybiBjb250YWluc1BvaW50KG9iamVjdC5jb29yZGluYXRlcywgcG9pbnQpO1xuICB9LFxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc1BvaW50KGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHJldHVybiBjb250YWluc0xpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gIH0sXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoY29udGFpbnNMaW5lKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHJldHVybiBjb250YWluc1BvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoY29udGFpbnNQb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc0dlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjb250YWluc0dlb21ldHJ5KGdlb21ldHJ5LCBwb2ludCkge1xuICByZXR1cm4gZ2VvbWV0cnkgJiYgY29udGFpbnNHZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSlcbiAgICAgID8gY29udGFpbnNHZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHBvaW50KVxuICAgICAgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNQb2ludChjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgcmV0dXJuIGRpc3RhbmNlKGNvb3JkaW5hdGVzLCBwb2ludCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zTGluZShjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgdmFyIGFiID0gZGlzdGFuY2UoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdKSxcbiAgICAgIGFvID0gZGlzdGFuY2UoY29vcmRpbmF0ZXNbMF0sIHBvaW50KSxcbiAgICAgIG9iID0gZGlzdGFuY2UocG9pbnQsIGNvb3JkaW5hdGVzWzFdKTtcbiAgcmV0dXJuIGFvICsgb2IgPD0gYWIgKyBlcHNpbG9uJDI7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zUG9seWdvbihjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgcmV0dXJuICEhcG9seWdvbkNvbnRhaW5zKGNvb3JkaW5hdGVzLm1hcChyaW5nUmFkaWFucyksIHBvaW50UmFkaWFucyhwb2ludCkpO1xufVxuXG5mdW5jdGlvbiByaW5nUmFkaWFucyhyaW5nKSB7XG4gIHJldHVybiByaW5nID0gcmluZy5tYXAocG9pbnRSYWRpYW5zKSwgcmluZy5wb3AoKSwgcmluZztcbn1cblxuZnVuY3Rpb24gcG9pbnRSYWRpYW5zKHBvaW50KSB7XG4gIHJldHVybiBbcG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnNdO1xufVxuXG52YXIgY29udGFpbnMgPSBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gIHJldHVybiAob2JqZWN0ICYmIGNvbnRhaW5zT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSlcbiAgICAgID8gY29udGFpbnNPYmplY3RUeXBlW29iamVjdC50eXBlXVxuICAgICAgOiBjb250YWluc0dlb21ldHJ5KShvYmplY3QsIHBvaW50KTtcbn07XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZVgoeTAsIHkxLCBkeSkge1xuICB2YXIgeSA9IHNlcXVlbmNlKHkwLCB5MSAtIGVwc2lsb24kMiwgZHkpLmNvbmNhdCh5MSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiB5Lm1hcChmdW5jdGlvbih5KSB7IHJldHVybiBbeCwgeV07IH0pOyB9O1xufVxuXG5mdW5jdGlvbiBncmF0aWN1bGVZKHgwLCB4MSwgZHgpIHtcbiAgdmFyIHggPSBzZXF1ZW5jZSh4MCwgeDEgLSBlcHNpbG9uJDIsIGR4KS5jb25jYXQoeDEpO1xuICByZXR1cm4gZnVuY3Rpb24oeSkgeyByZXR1cm4geC5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbn1cblxuZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICB2YXIgeDEsIHgwLCBYMSwgWDAsXG4gICAgICB5MSwgeTAsIFkxLCBZMCxcbiAgICAgIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLFxuICAgICAgeCwgeSwgWCwgWSxcbiAgICAgIHByZWNpc2lvbiA9IDIuNTtcblxuICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogbGluZXMoKX07XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICByZXR1cm4gc2VxdWVuY2UoY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKVxuICAgICAgICAuY29uY2F0KHNlcXVlbmNlKGNlaWwoWTAgLyBEWSkgKiBEWSwgWTEsIERZKS5tYXAoWSkpXG4gICAgICAgIC5jb25jYXQoc2VxdWVuY2UoY2VpbCh4MCAvIGR4KSAqIGR4LCB4MSwgZHgpLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBhYnMoeCAlIERYKSA+IGVwc2lsb24kMjsgfSkubWFwKHgpKVxuICAgICAgICAuY29uY2F0KHNlcXVlbmNlKGNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24oeSkgeyByZXR1cm4gYWJzKHkgJSBEWSkgPiBlcHNpbG9uJDI7IH0pLm1hcCh5KSk7XG4gIH1cblxuICBncmF0aWN1bGUubGluZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbGluZXMoKS5tYXAoZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHsgcmV0dXJuIHt0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTsgfSk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLm91dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICBjb29yZGluYXRlczogW1xuICAgICAgICBYKFgwKS5jb25jYXQoXG4gICAgICAgIFkoWTEpLnNsaWNlKDEpLFxuICAgICAgICBYKFgxKS5yZXZlcnNlKCkuc2xpY2UoMSksXG4gICAgICAgIFkoWTApLnJldmVyc2UoKS5zbGljZSgxKSlcbiAgICAgIF1cbiAgICB9O1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLmV4dGVudE1pbm9yKCk7XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNYWpvcihfKS5leHRlbnRNaW5vcihfKTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50TWFqb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW1tYMCwgWTBdLCBbWDEsIFkxXV07XG4gICAgWDAgPSArX1swXVswXSwgWDEgPSArX1sxXVswXTtcbiAgICBZMCA9ICtfWzBdWzFdLCBZMSA9ICtfWzFdWzFdO1xuICAgIGlmIChYMCA+IFgxKSBfID0gWDAsIFgwID0gWDEsIFgxID0gXztcbiAgICBpZiAoWTAgPiBZMSkgXyA9IFkwLCBZMCA9IFkxLCBZMSA9IF87XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50TWlub3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgeDAgPSArX1swXVswXSwgeDEgPSArX1sxXVswXTtcbiAgICB5MCA9ICtfWzBdWzFdLCB5MSA9ICtfWzFdWzFdO1xuICAgIGlmICh4MCA+IHgxKSBfID0geDAsIHgwID0geDEsIHgxID0gXztcbiAgICBpZiAoeTAgPiB5MSkgXyA9IHkwLCB5MCA9IHkxLCB5MSA9IF87XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUuc3RlcE1pbm9yKCk7XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWFqb3IoXykuc3RlcE1pbm9yKF8pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwTWFqb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW0RYLCBEWV07XG4gICAgRFggPSArX1swXSwgRFkgPSArX1sxXTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwTWlub3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW2R4LCBkeV07XG4gICAgZHggPSArX1swXSwgZHkgPSArX1sxXTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJlY2lzaW9uO1xuICAgIHByZWNpc2lvbiA9ICtfO1xuICAgIHggPSBncmF0aWN1bGVYKHkwLCB5MSwgOTApO1xuICAgIHkgPSBncmF0aWN1bGVZKHgwLCB4MSwgcHJlY2lzaW9uKTtcbiAgICBYID0gZ3JhdGljdWxlWChZMCwgWTEsIDkwKTtcbiAgICBZID0gZ3JhdGljdWxlWShYMCwgWDEsIHByZWNpc2lvbik7XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICByZXR1cm4gZ3JhdGljdWxlXG4gICAgICAuZXh0ZW50TWFqb3IoW1stMTgwLCAtOTAgKyBlcHNpbG9uJDJdLCBbMTgwLCA5MCAtIGVwc2lsb24kMl1dKVxuICAgICAgLmV4dGVudE1pbm9yKFtbLTE4MCwgLTgwIC0gZXBzaWxvbiQyXSwgWzE4MCwgODAgKyBlcHNpbG9uJDJdXSk7XG59XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZTEwKCkge1xuICByZXR1cm4gZ3JhdGljdWxlKCkoKTtcbn1cblxudmFyIGludGVycG9sYXRlJDEgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB4MCA9IGFbMF0gKiByYWRpYW5zLFxuICAgICAgeTAgPSBhWzFdICogcmFkaWFucyxcbiAgICAgIHgxID0gYlswXSAqIHJhZGlhbnMsXG4gICAgICB5MSA9IGJbMV0gKiByYWRpYW5zLFxuICAgICAgY3kwID0gY29zJDEoeTApLFxuICAgICAgc3kwID0gc2luJDEoeTApLFxuICAgICAgY3kxID0gY29zJDEoeTEpLFxuICAgICAgc3kxID0gc2luJDEoeTEpLFxuICAgICAga3gwID0gY3kwICogY29zJDEoeDApLFxuICAgICAga3kwID0gY3kwICogc2luJDEoeDApLFxuICAgICAga3gxID0gY3kxICogY29zJDEoeDEpLFxuICAgICAga3kxID0gY3kxICogc2luJDEoeDEpLFxuICAgICAgZCA9IDIgKiBhc2luKHNxcnQoaGF2ZXJzaW4oeTEgLSB5MCkgKyBjeTAgKiBjeTEgKiBoYXZlcnNpbih4MSAtIHgwKSkpLFxuICAgICAgayA9IHNpbiQxKGQpO1xuXG4gIHZhciBpbnRlcnBvbGF0ZSA9IGQgPyBmdW5jdGlvbih0KSB7XG4gICAgdmFyIEIgPSBzaW4kMSh0ICo9IGQpIC8gayxcbiAgICAgICAgQSA9IHNpbiQxKGQgLSB0KSAvIGssXG4gICAgICAgIHggPSBBICoga3gwICsgQiAqIGt4MSxcbiAgICAgICAgeSA9IEEgKiBreTAgKyBCICoga3kxLFxuICAgICAgICB6ID0gQSAqIHN5MCArIEIgKiBzeTE7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHksIHgpICogZGVncmVlcyQxLFxuICAgICAgYXRhbjIoeiwgc3FydCh4ICogeCArIHkgKiB5KSkgKiBkZWdyZWVzJDFcbiAgICBdO1xuICB9IDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFt4MCAqIGRlZ3JlZXMkMSwgeTAgKiBkZWdyZWVzJDFdO1xuICB9O1xuXG4gIGludGVycG9sYXRlLmRpc3RhbmNlID0gZDtcblxuICByZXR1cm4gaW50ZXJwb2xhdGU7XG59O1xuXG52YXIgaWRlbnRpdHkkNCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59O1xuXG52YXIgYXJlYVN1bSQxID0gYWRkZXIoKTtcbnZhciBhcmVhUmluZ1N1bSQxID0gYWRkZXIoKTtcbnZhciB4MDA7XG52YXIgeTAwO1xudmFyIHgwJDE7XG52YXIgeTAkMTtcblxudmFyIGFyZWFTdHJlYW0kMSA9IHtcbiAgcG9pbnQ6IG5vb3AkMSxcbiAgbGluZVN0YXJ0OiBub29wJDEsXG4gIGxpbmVFbmQ6IG5vb3AkMSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtJDEubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydCQxO1xuICAgIGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVJpbmdFbmQkMTtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN0cmVhbSQxLmxpbmVTdGFydCA9IGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVN0cmVhbSQxLnBvaW50ID0gbm9vcCQxO1xuICAgIGFyZWFTdW0kMS5hZGQoYWJzKGFyZWFSaW5nU3VtJDEpKTtcbiAgICBhcmVhUmluZ1N1bSQxLnJlc2V0KCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWEgPSBhcmVhU3VtJDEgLyAyO1xuICAgIGFyZWFTdW0kMS5yZXNldCgpO1xuICAgIHJldHVybiBhcmVhO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcmVhUmluZ1N0YXJ0JDEoKSB7XG4gIGFyZWFTdHJlYW0kMS5wb2ludCA9IGFyZWFQb2ludEZpcnN0JDE7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0JDEoeCwgeSkge1xuICBhcmVhU3RyZWFtJDEucG9pbnQgPSBhcmVhUG9pbnQkMTtcbiAgeDAwID0geDAkMSA9IHgsIHkwMCA9IHkwJDEgPSB5O1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnQkMSh4LCB5KSB7XG4gIGFyZWFSaW5nU3VtJDEuYWRkKHkwJDEgKiB4IC0geDAkMSAqIHkpO1xuICB4MCQxID0geCwgeTAkMSA9IHk7XG59XG5cbmZ1bmN0aW9uIGFyZWFSaW5nRW5kJDEoKSB7XG4gIGFyZWFQb2ludCQxKHgwMCwgeTAwKTtcbn1cblxudmFyIHgwJDIgPSBJbmZpbml0eTtcbnZhciB5MCQyID0geDAkMjtcbnZhciB4MSA9IC14MCQyO1xudmFyIHkxID0geDE7XG5cbnZhciBib3VuZHNTdHJlYW0kMSA9IHtcbiAgcG9pbnQ6IGJvdW5kc1BvaW50JDEsXG4gIGxpbmVTdGFydDogbm9vcCQxLFxuICBsaW5lRW5kOiBub29wJDEsXG4gIHBvbHlnb25TdGFydDogbm9vcCQxLFxuICBwb2x5Z29uRW5kOiBub29wJDEsXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvdW5kcyA9IFtbeDAkMiwgeTAkMl0sIFt4MSwgeTFdXTtcbiAgICB4MSA9IHkxID0gLSh5MCQyID0geDAkMiA9IEluZmluaXR5KTtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBib3VuZHNQb2ludCQxKHgsIHkpIHtcbiAgaWYgKHggPCB4MCQyKSB4MCQyID0geDtcbiAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICBpZiAoeSA8IHkwJDIpIHkwJDIgPSB5O1xuICBpZiAoeSA+IHkxKSB5MSA9IHk7XG59XG5cbi8vIFRPRE8gRW5mb3JjZSBwb3NpdGl2ZSBhcmVhIGZvciBleHRlcmlvciwgbmVnYXRpdmUgYXJlYSBmb3IgaW50ZXJpb3I/XG5cbnZhciBYMCQxID0gMDtcbnZhciBZMCQxID0gMDtcbnZhciBaMCQxID0gMDtcbnZhciBYMSQxID0gMDtcbnZhciBZMSQxID0gMDtcbnZhciBaMSQxID0gMDtcbnZhciBYMiQxID0gMDtcbnZhciBZMiQxID0gMDtcbnZhciBaMiQxID0gMDtcbnZhciB4MDAkMTtcbnZhciB5MDAkMTtcbnZhciB4MCQzO1xudmFyIHkwJDM7XG5cbnZhciBjZW50cm9pZFN0cmVhbSQxID0ge1xuICBwb2ludDogY2VudHJvaWRQb2ludCQxLFxuICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0JDEsXG4gIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCQxLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQkMTtcbiAgICBjZW50cm9pZFN0cmVhbSQxLmxpbmVFbmQgPSBjZW50cm9pZFJpbmdFbmQkMTtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnQkMTtcbiAgICBjZW50cm9pZFN0cmVhbSQxLmxpbmVTdGFydCA9IGNlbnRyb2lkTGluZVN0YXJ0JDE7XG4gICAgY2VudHJvaWRTdHJlYW0kMS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kJDE7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNlbnRyb2lkID0gWjIkMSA/IFtYMiQxIC8gWjIkMSwgWTIkMSAvIFoyJDFdXG4gICAgICAgIDogWjEkMSA/IFtYMSQxIC8gWjEkMSwgWTEkMSAvIFoxJDFdXG4gICAgICAgIDogWjAkMSA/IFtYMCQxIC8gWjAkMSwgWTAkMSAvIFowJDFdXG4gICAgICAgIDogW05hTiwgTmFOXTtcbiAgICBYMCQxID0gWTAkMSA9IFowJDEgPVxuICAgIFgxJDEgPSBZMSQxID0gWjEkMSA9XG4gICAgWDIkMSA9IFkyJDEgPSBaMiQxID0gMDtcbiAgICByZXR1cm4gY2VudHJvaWQ7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnQkMSh4LCB5KSB7XG4gIFgwJDEgKz0geDtcbiAgWTAkMSArPSB5O1xuICArK1owJDE7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0JDEoKSB7XG4gIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RMaW5lO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RMaW5lKHgsIHkpIHtcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRMaW5lO1xuICBjZW50cm9pZFBvaW50JDEoeDAkMyA9IHgsIHkwJDMgPSB5KTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludExpbmUoeCwgeSkge1xuICB2YXIgZHggPSB4IC0geDAkMywgZHkgPSB5IC0geTAkMywgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBYMSQxICs9IHogKiAoeDAkMyArIHgpIC8gMjtcbiAgWTEkMSArPSB6ICogKHkwJDMgKyB5KSAvIDI7XG4gIFoxJDEgKz0gejtcbiAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCQxKCkge1xuICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludCQxO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCQxKCkge1xuICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0UmluZztcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kJDEoKSB7XG4gIGNlbnRyb2lkUG9pbnRSaW5nKHgwMCQxLCB5MDAkMSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdFJpbmcoeCwgeSkge1xuICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludFJpbmc7XG4gIGNlbnRyb2lkUG9pbnQkMSh4MDAkMSA9IHgwJDMgPSB4LCB5MDAkMSA9IHkwJDMgPSB5KTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludFJpbmcoeCwgeSkge1xuICB2YXIgZHggPSB4IC0geDAkMyxcbiAgICAgIGR5ID0geSAtIHkwJDMsXG4gICAgICB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgWDEkMSArPSB6ICogKHgwJDMgKyB4KSAvIDI7XG4gIFkxJDEgKz0geiAqICh5MCQzICsgeSkgLyAyO1xuICBaMSQxICs9IHo7XG5cbiAgeiA9IHkwJDMgKiB4IC0geDAkMyAqIHk7XG4gIFgyJDEgKz0geiAqICh4MCQzICsgeCk7XG4gIFkyJDEgKz0geiAqICh5MCQzICsgeSk7XG4gIFoyJDEgKz0geiAqIDM7XG4gIGNlbnRyb2lkUG9pbnQkMSh4MCQzID0geCwgeTAkMyA9IHkpO1xufVxuXG5mdW5jdGlvbiBQYXRoQ29udGV4dChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5QYXRoQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gIF9yYWRpdXM6IDQuNSxcbiAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gdGhpcy5fcmFkaXVzID0gXywgdGhpcztcbiAgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lID09PSAwKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX3BvaW50ID0gTmFOO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHggKyB0aGlzLl9yYWRpdXMsIHkpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmFyYyh4LCB5LCB0aGlzLl9yYWRpdXMsIDAsIHRhdSQzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXN1bHQ6IG5vb3AkMVxufTtcblxudmFyIGxlbmd0aFN1bSQxID0gYWRkZXIoKTtcbnZhciBsZW5ndGhSaW5nO1xudmFyIHgwMCQyO1xudmFyIHkwMCQyO1xudmFyIHgwJDQ7XG52YXIgeTAkNDtcblxudmFyIGxlbmd0aFN0cmVhbSQxID0ge1xuICBwb2ludDogbm9vcCQxLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFN0cmVhbSQxLnBvaW50ID0gbGVuZ3RoUG9pbnRGaXJzdCQxO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAobGVuZ3RoUmluZykgbGVuZ3RoUG9pbnQkMSh4MDAkMiwgeTAwJDIpO1xuICAgIGxlbmd0aFN0cmVhbSQxLnBvaW50ID0gbm9vcCQxO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFJpbmcgPSB0cnVlO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhSaW5nID0gbnVsbDtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGVuZ3RoID0gK2xlbmd0aFN1bSQxO1xuICAgIGxlbmd0aFN1bSQxLnJlc2V0KCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfVxufTtcblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdCQxKHgsIHkpIHtcbiAgbGVuZ3RoU3RyZWFtJDEucG9pbnQgPSBsZW5ndGhQb2ludCQxO1xuICB4MDAkMiA9IHgwJDQgPSB4LCB5MDAkMiA9IHkwJDQgPSB5O1xufVxuXG5mdW5jdGlvbiBsZW5ndGhQb2ludCQxKHgsIHkpIHtcbiAgeDAkNCAtPSB4LCB5MCQ0IC09IHk7XG4gIGxlbmd0aFN1bSQxLmFkZChzcXJ0KHgwJDQgKiB4MCQ0ICsgeTAkNCAqIHkwJDQpKTtcbiAgeDAkNCA9IHgsIHkwJDQgPSB5O1xufVxuXG5mdW5jdGlvbiBQYXRoU3RyaW5nKCkge1xuICB0aGlzLl9zdHJpbmcgPSBbXTtcbn1cblxuUGF0aFN0cmluZy5wcm90b3R5cGUgPSB7XG4gIF9yYWRpdXM6IDQuNSxcbiAgX2NpcmNsZTogY2lyY2xlJDEoNC41KSxcbiAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoKF8gPSArXykgIT09IHRoaXMuX3JhZGl1cykgdGhpcy5fcmFkaXVzID0gXywgdGhpcy5fY2lyY2xlID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lID09PSAwKSB0aGlzLl9zdHJpbmcucHVzaChcIlpcIik7XG4gICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSk7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJMXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGlmICh0aGlzLl9jaXJjbGUgPT0gbnVsbCkgdGhpcy5fY2lyY2xlID0gY2lyY2xlJDEodGhpcy5fcmFkaXVzKTtcbiAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5LCB0aGlzLl9jaXJjbGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3N0cmluZy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zdHJpbmcuam9pbihcIlwiKTtcbiAgICAgIHRoaXMuX3N0cmluZyA9IFtdO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjaXJjbGUkMShyYWRpdXMpIHtcbiAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXNcbiAgICAgICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAtMiAqIHJhZGl1c1xuICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIDIgKiByYWRpdXNcbiAgICAgICsgXCJ6XCI7XG59XG5cbnZhciBpbmRleCQxID0gZnVuY3Rpb24ocHJvamVjdGlvbiwgY29udGV4dCkge1xuICB2YXIgcG9pbnRSYWRpdXMgPSA0LjUsXG4gICAgICBwcm9qZWN0aW9uU3RyZWFtLFxuICAgICAgY29udGV4dFN0cmVhbTtcblxuICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGNvbnRleHRTdHJlYW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRTdHJlYW0ucmVzdWx0KCk7XG4gIH1cblxuICBwYXRoLmFyZWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGFyZWFTdHJlYW0kMSkpO1xuICAgIHJldHVybiBhcmVhU3RyZWFtJDEucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5tZWFzdXJlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShsZW5ndGhTdHJlYW0kMSkpO1xuICAgIHJldHVybiBsZW5ndGhTdHJlYW0kMS5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oYm91bmRzU3RyZWFtJDEpKTtcbiAgICByZXR1cm4gYm91bmRzU3RyZWFtJDEucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oY2VudHJvaWRTdHJlYW0kMSkpO1xuICAgIHJldHVybiBjZW50cm9pZFN0cmVhbSQxLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0aW9uU3RyZWFtID0gXyA9PSBudWxsID8gKHByb2plY3Rpb24gPSBudWxsLCBpZGVudGl0eSQ0KSA6IChwcm9qZWN0aW9uID0gXykuc3RyZWFtLCBwYXRoKSA6IHByb2plY3Rpb247XG4gIH07XG5cbiAgcGF0aC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgY29udGV4dFN0cmVhbSA9IF8gPT0gbnVsbCA/IChjb250ZXh0ID0gbnVsbCwgbmV3IFBhdGhTdHJpbmcpIDogbmV3IFBhdGhDb250ZXh0KGNvbnRleHQgPSBfKTtcbiAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMocG9pbnRSYWRpdXMpO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIHBhdGgucG9pbnRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcG9pbnRSYWRpdXM7XG4gICAgcG9pbnRSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IChjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtfKSwgK18pO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuXG4gIHJldHVybiBwYXRoLnByb2plY3Rpb24ocHJvamVjdGlvbikuY29udGV4dChjb250ZXh0KTtcbn07XG5cbnZhciBjbGlwID0gZnVuY3Rpb24ocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHN0YXJ0KSB7XG4gIHJldHVybiBmdW5jdGlvbihyb3RhdGUsIHNpbmspIHtcbiAgICB2YXIgbGluZSA9IGNsaXBMaW5lKHNpbmspLFxuICAgICAgICByb3RhdGVkU3RhcnQgPSByb3RhdGUuaW52ZXJ0KHN0YXJ0WzBdLCBzdGFydFsxXSksXG4gICAgICAgIHJpbmdCdWZmZXIgPSBjbGlwQnVmZmVyKCksXG4gICAgICAgIHJpbmdTaW5rID0gY2xpcExpbmUocmluZ0J1ZmZlciksXG4gICAgICAgIHBvbHlnb25TdGFydGVkID0gZmFsc2UsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHNlZ21lbnRzLFxuICAgICAgICByaW5nO1xuXG4gICAgdmFyIGNsaXAgPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRSaW5nO1xuICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBjbGlwLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzZWdtZW50cyA9IG1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkNvbnRhaW5zKHBvbHlnb24sIHJvdGF0ZWRTdGFydCk7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc2luayk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRJbnNpZGUpIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgc2luay5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICB2YXIgcG9pbnQgPSByb3RhdGUobGFtYmRhLCBwaGkpO1xuICAgICAgaWYgKHBvaW50VmlzaWJsZShsYW1iZGEgPSBwb2ludFswXSwgcGhpID0gcG9pbnRbMV0pKSBzaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludExpbmUobGFtYmRhLCBwaGkpIHtcbiAgICAgIHZhciBwb2ludCA9IHJvdGF0ZShsYW1iZGEsIHBoaSk7XG4gICAgICBsaW5lLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcC5wb2ludCA9IHBvaW50TGluZTtcbiAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvaW50UmluZyhsYW1iZGEsIHBoaSkge1xuICAgICAgcmluZy5wdXNoKFtsYW1iZGEsIHBoaV0pO1xuICAgICAgdmFyIHBvaW50ID0gcm90YXRlKGxhbWJkYSwgcGhpKTtcbiAgICAgIHJpbmdTaW5rLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgcmluZ1NpbmsubGluZVN0YXJ0KCk7XG4gICAgICByaW5nID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgIHBvaW50UmluZyhyaW5nWzBdWzBdLCByaW5nWzBdWzFdKTtcbiAgICAgIHJpbmdTaW5rLmxpbmVFbmQoKTtcblxuICAgICAgdmFyIGNsZWFuID0gcmluZ1NpbmsuY2xlYW4oKSxcbiAgICAgICAgICByaW5nU2VnbWVudHMgPSByaW5nQnVmZmVyLnJlc3VsdCgpLFxuICAgICAgICAgIGksIG4gPSByaW5nU2VnbWVudHMubGVuZ3RoLCBtLFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgcG9pbnQ7XG5cbiAgICAgIHJpbmcucG9wKCk7XG4gICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgICByaW5nID0gbnVsbDtcblxuICAgICAgaWYgKCFuKSByZXR1cm47XG5cbiAgICAgIC8vIE5vIGludGVyc2VjdGlvbnMuXG4gICAgICBpZiAoY2xlYW4gJiAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSByaW5nU2VnbWVudHNbMF07XG4gICAgICAgIGlmICgobSA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPiAwKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc2luay5wb2ludCgocG9pbnQgPSBzZWdtZW50W2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVqb2luIGNvbm5lY3RlZCBzZWdtZW50cy5cbiAgICAgIC8vIFRPRE8gcmV1c2UgcmluZ0J1ZmZlci5yZWpvaW4oKT9cbiAgICAgIGlmIChuID4gMSAmJiBjbGVhbiAmIDIpIHJpbmdTZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5wb3AoKS5jb25jYXQocmluZ1NlZ21lbnRzLnNoaWZ0KCkpKTtcblxuICAgICAgc2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMuZmlsdGVyKHZhbGlkU2VnbWVudCkpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwO1xuICB9O1xufTtcblxuZnVuY3Rpb24gdmFsaWRTZWdtZW50KHNlZ21lbnQpIHtcbiAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcbn1cblxuLy8gSW50ZXJzZWN0aW9ucyBhcmUgc29ydGVkIGFsb25nIHRoZSBjbGlwIGVkZ2UuIEZvciBib3RoIGFudGltZXJpZGlhbiBjdXR0aW5nXG4vLyBhbmQgY2lyY2xlIGNsaXBwaW5nLCB0aGUgc2FtZSBjb21wYXJpc29uIGlzIHVzZWQuXG5mdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuICgoYSA9IGEueClbMF0gPCAwID8gYVsxXSAtIGhhbGZQaSQyIC0gZXBzaWxvbiQyIDogaGFsZlBpJDIgLSBhWzFdKVxuICAgICAgIC0gKChiID0gYi54KVswXSA8IDAgPyBiWzFdIC0gaGFsZlBpJDIgLSBlcHNpbG9uJDIgOiBoYWxmUGkkMiAtIGJbMV0pO1xufVxuXG52YXIgY2xpcEFudGltZXJpZGlhbiA9IGNsaXAoXG4gIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgY2xpcEFudGltZXJpZGlhbkxpbmUsXG4gIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZSxcbiAgWy1waSQzLCAtaGFsZlBpJDJdXG4pO1xuXG4vLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzOiAwIC0gdGhlcmUgd2VyZVxuLy8gaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBubyBpbnRlcnNlY3Rpb25zOyAyIC0gdGhlcmUgd2VyZVxuLy8gaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBzaG91bGQgYmUgcmVqb2luZWQuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuTGluZShzdHJlYW0pIHtcbiAgdmFyIGxhbWJkYTAgPSBOYU4sXG4gICAgICBwaGkwID0gTmFOLFxuICAgICAgc2lnbjAgPSBOYU4sXG4gICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuXG4gIHJldHVybiB7XG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIGNsZWFuID0gMTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbihsYW1iZGExLCBwaGkxKSB7XG4gICAgICB2YXIgc2lnbjEgPSBsYW1iZGExID4gMCA/IHBpJDMgOiAtcGkkMyxcbiAgICAgICAgICBkZWx0YSA9IGFicyhsYW1iZGExIC0gbGFtYmRhMCk7XG4gICAgICBpZiAoYWJzKGRlbHRhIC0gcGkkMykgPCBlcHNpbG9uJDIpIHsgLy8gbGluZSBjcm9zc2VzIGEgcG9sZVxuICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCwgcGhpMCA9IChwaGkwICsgcGhpMSkgLyAyID4gMCA/IGhhbGZQaSQyIDogLWhhbGZQaSQyKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMSwgcGhpMCk7XG4gICAgICAgIGNsZWFuID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbjAgIT09IHNpZ24xICYmIGRlbHRhID49IHBpJDMpIHsgLy8gbGluZSBjcm9zc2VzIGFudGltZXJpZGlhblxuICAgICAgICBpZiAoYWJzKGxhbWJkYTAgLSBzaWduMCkgPCBlcHNpbG9uJDIpIGxhbWJkYTAgLT0gc2lnbjAgKiBlcHNpbG9uJDI7IC8vIGhhbmRsZSBkZWdlbmVyYWNpZXNcbiAgICAgICAgaWYgKGFicyhsYW1iZGExIC0gc2lnbjEpIDwgZXBzaWxvbiQyKSBsYW1iZGExIC09IHNpZ24xICogZXBzaWxvbiQyO1xuICAgICAgICBwaGkwID0gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICBjbGVhbiA9IDA7XG4gICAgICB9XG4gICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCA9IGxhbWJkYTEsIHBoaTAgPSBwaGkxKTtcbiAgICAgIHNpZ24wID0gc2lnbjE7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICBsYW1iZGEwID0gcGhpMCA9IE5hTjtcbiAgICB9LFxuICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAyIC0gY2xlYW47IC8vIGlmIGludGVyc2VjdGlvbnMsIHJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKSB7XG4gIHZhciBjb3NQaGkwLFxuICAgICAgY29zUGhpMSxcbiAgICAgIHNpbkxhbWJkYTBMYW1iZGExID0gc2luJDEobGFtYmRhMCAtIGxhbWJkYTEpO1xuICByZXR1cm4gYWJzKHNpbkxhbWJkYTBMYW1iZGExKSA+IGVwc2lsb24kMlxuICAgICAgPyBhdGFuKChzaW4kMShwaGkwKSAqIChjb3NQaGkxID0gY29zJDEocGhpMSkpICogc2luJDEobGFtYmRhMSlcbiAgICAgICAgICAtIHNpbiQxKHBoaTEpICogKGNvc1BoaTAgPSBjb3MkMShwaGkwKSkgKiBzaW4kMShsYW1iZGEwKSlcbiAgICAgICAgICAvIChjb3NQaGkwICogY29zUGhpMSAqIHNpbkxhbWJkYTBMYW1iZGExKSlcbiAgICAgIDogKHBoaTAgKyBwaGkxKSAvIDI7XG59XG5cbmZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgdmFyIHBoaTtcbiAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgIHBoaSA9IGRpcmVjdGlvbiAqIGhhbGZQaSQyO1xuICAgIHN0cmVhbS5wb2ludCgtcGkkMywgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQocGkkMywgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQocGkkMywgMCk7XG4gICAgc3RyZWFtLnBvaW50KHBpJDMsIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpJDMsIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgtcGkkMywgMCk7XG4gICAgc3RyZWFtLnBvaW50KC1waSQzLCBwaGkpO1xuICB9IGVsc2UgaWYgKGFicyhmcm9tWzBdIC0gdG9bMF0pID4gZXBzaWxvbiQyKSB7XG4gICAgdmFyIGxhbWJkYSA9IGZyb21bMF0gPCB0b1swXSA/IHBpJDMgOiAtcGkkMztcbiAgICBwaGkgPSBkaXJlY3Rpb24gKiBsYW1iZGEgLyAyO1xuICAgIHN0cmVhbS5wb2ludCgtbGFtYmRhLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gIH1cbn1cblxudmFyIGNsaXBDaXJjbGUgPSBmdW5jdGlvbihyYWRpdXMsIGRlbHRhKSB7XG4gIHZhciBjciA9IGNvcyQxKHJhZGl1cyksXG4gICAgICBzbWFsbFJhZGl1cyA9IGNyID4gMCxcbiAgICAgIG5vdEhlbWlzcGhlcmUgPSBhYnMoY3IpID4gZXBzaWxvbiQyOyAvLyBUT0RPIG9wdGltaXNlIGZvciB0aGlzIGNvbW1vbiBjYXNlXG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCBmcm9tLCB0byk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIGNvcyQxKGxhbWJkYSkgKiBjb3MkMShwaGkpID4gY3I7XG4gIH1cblxuICAvLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzIHVzZWQgZm9yIHBvbHlnb25cbiAgLy8gY2xpcHBpbmc6IDAgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm9cbiAgLy8gaW50ZXJzZWN0aW9ucyAyIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gIC8vIHNob3VsZCBiZSByZWpvaW5lZC5cbiAgZnVuY3Rpb24gY2xpcExpbmUoc3RyZWFtKSB7XG4gICAgdmFyIHBvaW50MCwgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgYzAsIC8vIGNvZGUgZm9yIHByZXZpb3VzIHBvaW50XG4gICAgICAgIHYwLCAvLyB2aXNpYmlsaXR5IG9mIHByZXZpb3VzIHBvaW50XG4gICAgICAgIHYwMCwgLy8gdmlzaWJpbGl0eSBvZiBmaXJzdCBwb2ludFxuICAgICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2MDAgPSB2MCA9IGZhbHNlO1xuICAgICAgICBjbGVhbiA9IDE7XG4gICAgICB9LFxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwb2ludDEgPSBbbGFtYmRhLCBwaGldLFxuICAgICAgICAgICAgcG9pbnQyLFxuICAgICAgICAgICAgdiA9IHZpc2libGUobGFtYmRhLCBwaGkpLFxuICAgICAgICAgICAgYyA9IHNtYWxsUmFkaXVzXG4gICAgICAgICAgICAgID8gdiA/IDAgOiBjb2RlKGxhbWJkYSwgcGhpKVxuICAgICAgICAgICAgICA6IHYgPyBjb2RlKGxhbWJkYSArIChsYW1iZGEgPCAwID8gcGkkMyA6IC1waSQzKSwgcGhpKSA6IDA7XG4gICAgICAgIGlmICghcG9pbnQwICYmICh2MDAgPSB2MCA9IHYpKSBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIC8vIEhhbmRsZSBkZWdlbmVyYWNpZXMuXG4gICAgICAgIC8vIFRPRE8gaWdub3JlIGlmIG5vdCBjbGlwcGluZyBwb2x5Z29ucy5cbiAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICBpZiAoIXBvaW50MiB8fCBwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQyKSB8fCBwb2ludEVxdWFsKHBvaW50MSwgcG9pbnQyKSkge1xuICAgICAgICAgICAgcG9pbnQxWzBdICs9IGVwc2lsb24kMjtcbiAgICAgICAgICAgIHBvaW50MVsxXSArPSBlcHNpbG9uJDI7XG4gICAgICAgICAgICB2ID0gdmlzaWJsZShwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgLy8gb3V0c2lkZSBnb2luZyBpblxuICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluc2lkZSBnb2luZyBvdXRcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICB9IGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgIHZhciB0O1xuICAgICAgICAgIC8vIElmIHRoZSBjb2RlcyBmb3IgdHdvIHBvaW50cyBhcmUgZGlmZmVyZW50LCBvciBhcmUgYm90aCB6ZXJvLFxuICAgICAgICAgIC8vIGFuZCB0aGVyZSB0aGlzIHNlZ21lbnQgaW50ZXJzZWN0cyB3aXRoIHRoZSBzbWFsbCBjaXJjbGUuXG4gICAgICAgICAgaWYgKCEoYyAmIGMwKSAmJiAodCA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICBpZiAoc21hbGxSYWRpdXMpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQxKSkpIHtcbiAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh2MCkgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgcG9pbnQwID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAvLyBSZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgaWYgdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIGFuZCBsYXN0IHBvaW50cyB3ZXJlIHZpc2libGUuXG4gICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjbGVhbiB8ICgodjAwICYmIHYwKSA8PCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJzZWN0cyB0aGUgZ3JlYXQgY2lyY2xlIGJldHdlZW4gYSBhbmQgYiB3aXRoIHRoZSBjbGlwIGNpcmNsZS5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xuICAgIHZhciBwYSA9IGNhcnRlc2lhbihhKSxcbiAgICAgICAgcGIgPSBjYXJ0ZXNpYW4oYik7XG5cbiAgICAvLyBXZSBoYXZlIHR3byBwbGFuZXMsIG4xLnAgPSBkMSBhbmQgbjIucCA9IGQyLlxuICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIGxpbmUgcCh0KSA9IGMxIG4xICsgYzIgbjIgKyB0IChuMSDiqK8gbjIpLlxuICAgIHZhciBuMSA9IFsxLCAwLCAwXSwgLy8gbm9ybWFsXG4gICAgICAgIG4yID0gY2FydGVzaWFuQ3Jvc3MocGEsIHBiKSxcbiAgICAgICAgbjJuMiA9IGNhcnRlc2lhbkRvdChuMiwgbjIpLFxuICAgICAgICBuMW4yID0gbjJbMF0sIC8vIGNhcnRlc2lhbkRvdChuMSwgbjIpLFxuICAgICAgICBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcblxuICAgIC8vIFR3byBwb2xhciBwb2ludHMuXG4gICAgaWYgKCFkZXRlcm1pbmFudCkgcmV0dXJuICF0d28gJiYgYTtcblxuICAgIHZhciBjMSA9ICBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCxcbiAgICAgICAgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsXG4gICAgICAgIG4xeG4yID0gY2FydGVzaWFuQ3Jvc3MobjEsIG4yKSxcbiAgICAgICAgQSA9IGNhcnRlc2lhblNjYWxlKG4xLCBjMSksXG4gICAgICAgIEIgPSBjYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgIGNhcnRlc2lhbkFkZEluUGxhY2UoQSwgQik7XG5cbiAgICAvLyBTb2x2ZSB8cCh0KXxeMiA9IDEuXG4gICAgdmFyIHUgPSBuMXhuMixcbiAgICAgICAgdyA9IGNhcnRlc2lhbkRvdChBLCB1KSxcbiAgICAgICAgdXUgPSBjYXJ0ZXNpYW5Eb3QodSwgdSksXG4gICAgICAgIHQyID0gdyAqIHcgLSB1dSAqIChjYXJ0ZXNpYW5Eb3QoQSwgQSkgLSAxKTtcblxuICAgIGlmICh0MiA8IDApIHJldHVybjtcblxuICAgIHZhciB0ID0gc3FydCh0MiksXG4gICAgICAgIHEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgLSB0KSAvIHV1KTtcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHEsIEEpO1xuICAgIHEgPSBzcGhlcmljYWwocSk7XG5cbiAgICBpZiAoIXR3bykgcmV0dXJuIHE7XG5cbiAgICAvLyBUd28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICB2YXIgbGFtYmRhMCA9IGFbMF0sXG4gICAgICAgIGxhbWJkYTEgPSBiWzBdLFxuICAgICAgICBwaGkwID0gYVsxXSxcbiAgICAgICAgcGhpMSA9IGJbMV0sXG4gICAgICAgIHo7XG5cbiAgICBpZiAobGFtYmRhMSA8IGxhbWJkYTApIHogPSBsYW1iZGEwLCBsYW1iZGEwID0gbGFtYmRhMSwgbGFtYmRhMSA9IHo7XG5cbiAgICB2YXIgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCxcbiAgICAgICAgcG9sYXIgPSBhYnMoZGVsdGEgLSBwaSQzKSA8IGVwc2lsb24kMixcbiAgICAgICAgbWVyaWRpYW4gPSBwb2xhciB8fCBkZWx0YSA8IGVwc2lsb24kMjtcblxuICAgIGlmICghcG9sYXIgJiYgcGhpMSA8IHBoaTApIHogPSBwaGkwLCBwaGkwID0gcGhpMSwgcGhpMSA9IHo7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBmaXJzdCBwb2ludCBpcyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgaWYgKG1lcmlkaWFuXG4gICAgICAgID8gcG9sYXJcbiAgICAgICAgICA/IHBoaTAgKyBwaGkxID4gMCBeIHFbMV0gPCAoYWJzKHFbMF0gLSBsYW1iZGEwKSA8IGVwc2lsb24kMiA/IHBoaTAgOiBwaGkxKVxuICAgICAgICAgIDogcGhpMCA8PSBxWzFdICYmIHFbMV0gPD0gcGhpMVxuICAgICAgICA6IGRlbHRhID4gcGkkMyBeIChsYW1iZGEwIDw9IHFbMF0gJiYgcVswXSA8PSBsYW1iZGExKSkge1xuICAgICAgdmFyIHExID0gY2FydGVzaWFuU2NhbGUodSwgKC13ICsgdCkgLyB1dSk7XG4gICAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHExLCBBKTtcbiAgICAgIHJldHVybiBbcSwgc3BoZXJpY2FsKHExKV07XG4gICAgfVxuICB9XG5cbiAgLy8gR2VuZXJhdGVzIGEgNC1iaXQgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gb2YgYSBwb2ludCByZWxhdGl2ZSB0b1xuICAvLyB0aGUgc21hbGwgY2lyY2xlJ3MgYm91bmRpbmcgYm94LlxuICBmdW5jdGlvbiBjb2RlKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IHBpJDMgLSByYWRpdXMsXG4gICAgICAgIGNvZGUgPSAwO1xuICAgIGlmIChsYW1iZGEgPCAtcikgY29kZSB8PSAxOyAvLyBsZWZ0XG4gICAgZWxzZSBpZiAobGFtYmRhID4gcikgY29kZSB8PSAyOyAvLyByaWdodFxuICAgIGlmIChwaGkgPCAtcikgY29kZSB8PSA0OyAvLyBiZWxvd1xuICAgIGVsc2UgaWYgKHBoaSA+IHIpIGNvZGUgfD0gODsgLy8gYWJvdmVcbiAgICByZXR1cm4gY29kZTtcbiAgfVxuXG4gIHJldHVybiBjbGlwKHZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc21hbGxSYWRpdXMgPyBbMCwgLXJhZGl1c10gOiBbLXBpJDMsIHJhZGl1cyAtIHBpJDNdKTtcbn07XG5cbnZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbihtZXRob2RzKSB7XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiB0cmFuc2Zvcm1lcihtZXRob2RzKVxuICB9O1xufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIobWV0aG9kcykge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSBzW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgcmV0dXJuIHM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbSgpIHt9XG5cblRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm1TdHJlYW0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpOyB9LFxuICBzcGhlcmU6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5zcGhlcmUoKTsgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7IH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lRW5kKCk7IH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpOyB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpOyB9XG59O1xuXG5mdW5jdGlvbiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpIHtcbiAgdmFyIHcgPSBleHRlbnRbMV1bMF0gLSBleHRlbnRbMF1bMF0sXG4gICAgICBoID0gZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdLFxuICAgICAgY2xpcCA9IHByb2plY3Rpb24uY2xpcEV4dGVudCAmJiBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoKTtcblxuICBwcm9qZWN0aW9uXG4gICAgICAuc2NhbGUoMTUwKVxuICAgICAgLnRyYW5zbGF0ZShbMCwgMF0pO1xuXG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChudWxsKTtcblxuICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uLnN0cmVhbShib3VuZHNTdHJlYW0kMSkpO1xuXG4gIHZhciBiID0gYm91bmRzU3RyZWFtJDEucmVzdWx0KCksXG4gICAgICBrID0gTWF0aC5taW4odyAvIChiWzFdWzBdIC0gYlswXVswXSksIGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pKSxcbiAgICAgIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgeSA9ICtleHRlbnRbMF1bMV0gKyAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG5cbiAgaWYgKGNsaXAgIT0gbnVsbCkgcHJvamVjdGlvbi5jbGlwRXh0ZW50KGNsaXApO1xuXG4gIHJldHVybiBwcm9qZWN0aW9uXG4gICAgICAuc2NhbGUoayAqIDE1MClcbiAgICAgIC50cmFuc2xhdGUoW3gsIHldKTtcbn1cblxuZnVuY3Rpb24gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBbWzAsIDBdLCBzaXplXSwgb2JqZWN0KTtcbn1cblxudmFyIG1heERlcHRoID0gMTY7XG52YXIgY29zTWluRGlzdGFuY2UgPSBjb3MkMSgzMCAqIHJhZGlhbnMpOyAvLyBjb3MobWluaW11bSBhbmd1bGFyIGRpc3RhbmNlKVxuXG52YXIgcmVzYW1wbGUgPSBmdW5jdGlvbihwcm9qZWN0LCBkZWx0YTIpIHtcbiAgcmV0dXJuICtkZWx0YTIgPyByZXNhbXBsZSQxKHByb2plY3QsIGRlbHRhMikgOiByZXNhbXBsZU5vbmUocHJvamVjdCk7XG59O1xuXG5mdW5jdGlvbiByZXNhbXBsZU5vbmUocHJvamVjdCkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2FtcGxlJDEocHJvamVjdCwgZGVsdGEyKSB7XG5cbiAgZnVuY3Rpb24gcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pIHtcbiAgICB2YXIgZHggPSB4MSAtIHgwLFxuICAgICAgICBkeSA9IHkxIC0geTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgaWYgKGQyID4gNCAqIGRlbHRhMiAmJiBkZXB0aC0tKSB7XG4gICAgICB2YXIgYSA9IGEwICsgYTEsXG4gICAgICAgICAgYiA9IGIwICsgYjEsXG4gICAgICAgICAgYyA9IGMwICsgYzEsXG4gICAgICAgICAgbSA9IHNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSxcbiAgICAgICAgICBwaGkyID0gYXNpbihjIC89IG0pLFxuICAgICAgICAgIGxhbWJkYTIgPSBhYnMoYWJzKGMpIC0gMSkgPCBlcHNpbG9uJDIgfHwgYWJzKGxhbWJkYTAgLSBsYW1iZGExKSA8IGVwc2lsb24kMiA/IChsYW1iZGEwICsgbGFtYmRhMSkgLyAyIDogYXRhbjIoYiwgYSksXG4gICAgICAgICAgcCA9IHByb2plY3QobGFtYmRhMiwgcGhpMiksXG4gICAgICAgICAgeDIgPSBwWzBdLFxuICAgICAgICAgIHkyID0gcFsxXSxcbiAgICAgICAgICBkeDIgPSB4MiAtIHgwLFxuICAgICAgICAgIGR5MiA9IHkyIC0geTAsXG4gICAgICAgICAgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgaWYgKGR6ICogZHogLyBkMiA+IGRlbHRhMiAvLyBwZXJwZW5kaWN1bGFyIHByb2plY3RlZCBkaXN0YW5jZVxuICAgICAgICAgIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIDAuNSkgPiAwLjMgLy8gbWlkcG9pbnQgY2xvc2UgdG8gYW4gZW5kXG4gICAgICAgICAgfHwgYTAgKiBhMSArIGIwICogYjEgKyBjMCAqIGMxIDwgY29zTWluRGlzdGFuY2UpIHsgLy8gYW5ndWxhciBkaXN0YW5jZVxuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgbGFtYmRhMiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeDIsIHkyKTtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCBsYW1iZGEyLCBhLCBiLCBjLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGxhbWJkYTAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgbGFtYmRhMCwgeDAsIHkwLCBhMCwgYjAsIGMwOyAvLyBwcmV2aW91cyBwb2ludFxuXG4gICAgdmFyIHJlc2FtcGxlU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25TdGFydCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSByaW5nU3RhcnQ7IH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25FbmQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gbGluZVN0YXJ0OyB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIHgwID0gTmFOO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICB2YXIgYyA9IGNhcnRlc2lhbihbbGFtYmRhLCBwaGldKSwgcCA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgbGFtYmRhMCA9IGxhbWJkYSwgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZVBvaW50KGxhbWJkYTAwID0gbGFtYmRhLCBwaGkpLCB4MDAgPSB4MCwgeTAwID0geTAsIGEwMCA9IGEwLCBiMDAgPSBiMCwgYzAwID0gYzA7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgbGFtYmRhMDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICBsaW5lRW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2FtcGxlU3RyZWFtO1xuICB9O1xufVxuXG52YXIgdHJhbnNmb3JtUmFkaWFucyA9IHRyYW5zZm9ybWVyKHtcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICogcmFkaWFucywgeSAqIHJhZGlhbnMpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gcHJvamVjdGlvbihwcm9qZWN0KSB7XG4gIHJldHVybiBwcm9qZWN0aW9uTXV0YXRvcihmdW5jdGlvbigpIHsgcmV0dXJuIHByb2plY3Q7IH0pKCk7XG59XG5cbmZ1bmN0aW9uIHByb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCkge1xuICB2YXIgcHJvamVjdCxcbiAgICAgIGsgPSAxNTAsIC8vIHNjYWxlXG4gICAgICB4ID0gNDgwLCB5ID0gMjUwLCAvLyB0cmFuc2xhdGVcbiAgICAgIGR4LCBkeSwgbGFtYmRhID0gMCwgcGhpID0gMCwgLy8gY2VudGVyXG4gICAgICBkZWx0YUxhbWJkYSA9IDAsIGRlbHRhUGhpID0gMCwgZGVsdGFHYW1tYSA9IDAsIHJvdGF0ZSwgcHJvamVjdFJvdGF0ZSwgLy8gcm90YXRlXG4gICAgICB0aGV0YSA9IG51bGwsIHByZWNsaXAgPSBjbGlwQW50aW1lcmlkaWFuLCAvLyBjbGlwIGFuZ2xlXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTEsIHBvc3RjbGlwID0gaWRlbnRpdHkkNCwgLy8gY2xpcCBleHRlbnRcbiAgICAgIGRlbHRhMiA9IDAuNSwgcHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyKSwgLy8gcHJlY2lzaW9uXG4gICAgICBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtO1xuXG4gIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcbiAgICBwb2ludCA9IHByb2plY3RSb3RhdGUocG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnMpO1xuICAgIHJldHVybiBbcG9pbnRbMF0gKiBrICsgZHgsIGR5IC0gcG9pbnRbMV0gKiBrXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmVydChwb2ludCkge1xuICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZS5pbnZlcnQoKHBvaW50WzBdIC0gZHgpIC8gaywgKGR5IC0gcG9pbnRbMV0pIC8gayk7XG4gICAgcmV0dXJuIHBvaW50ICYmIFtwb2ludFswXSAqIGRlZ3JlZXMkMSwgcG9pbnRbMV0gKiBkZWdyZWVzJDFdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvamVjdFRyYW5zZm9ybSh4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBwcm9qZWN0KHgsIHkpLCBbeFswXSAqIGsgKyBkeCwgZHkgLSB4WzFdICoga107XG4gIH1cblxuICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybVJhZGlhbnMocHJlY2xpcChyb3RhdGUsIHByb2plY3RSZXNhbXBsZShwb3N0Y2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpKSk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9ICtfID8gY2xpcENpcmNsZSh0aGV0YSA9IF8gKiByYWRpYW5zLCA2ICogcmFkaWFucykgOiAodGhldGEgPSBudWxsLCBjbGlwQW50aW1lcmlkaWFuKSwgcmVzZXQoKSkgOiB0aGV0YSAqIGRlZ3JlZXMkMTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSQ0KSA6IGNsaXBFeHRlbnQoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGsgPSArXywgcmVjZW50ZXIoKSkgOiBrO1xuICB9O1xuXG4gIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArX1swXSwgeSA9ICtfWzFdLCByZWNlbnRlcigpKSA6IFt4LCB5XTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgcGhpID0gX1sxXSAlIDM2MCAqIHJhZGlhbnMsIHJlY2VudGVyKCkpIDogW2xhbWJkYSAqIGRlZ3JlZXMkMSwgcGhpICogZGVncmVlcyQxXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWx0YUxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YVBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YUdhbW1hID0gXy5sZW5ndGggPiAyID8gX1syXSAlIDM2MCAqIHJhZGlhbnMgOiAwLCByZWNlbnRlcigpKSA6IFtkZWx0YUxhbWJkYSAqIGRlZ3JlZXMkMSwgZGVsdGFQaGkgKiBkZWdyZWVzJDEsIGRlbHRhR2FtbWEgKiBkZWdyZWVzJDFdO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMiA9IF8gKiBfKSwgcmVzZXQoKSkgOiBzcXJ0KGRlbHRhMik7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRFeHRlbnQgPSBmdW5jdGlvbihleHRlbnQsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjZW50ZXIoKSB7XG4gICAgcHJvamVjdFJvdGF0ZSA9IGNvbXBvc2Uocm90YXRlID0gcm90YXRlUmFkaWFucyhkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGRlbHRhR2FtbWEpLCBwcm9qZWN0KTtcbiAgICB2YXIgY2VudGVyID0gcHJvamVjdChsYW1iZGEsIHBoaSk7XG4gICAgZHggPSB4IC0gY2VudGVyWzBdICogaztcbiAgICBkeSA9IHkgKyBjZW50ZXJbMV0gKiBrO1xuICAgIHJldHVybiByZXNldCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgcmV0dXJuIHByb2plY3Rpb247XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcHJvamVjdCA9IHByb2plY3RBdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHByb2plY3Rpb24uaW52ZXJ0ID0gcHJvamVjdC5pbnZlcnQgJiYgaW52ZXJ0O1xuICAgIHJldHVybiByZWNlbnRlcigpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb25pY1Byb2plY3Rpb24ocHJvamVjdEF0KSB7XG4gIHZhciBwaGkwID0gMCxcbiAgICAgIHBoaTEgPSBwaSQzIC8gMyxcbiAgICAgIG0gPSBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpLFxuICAgICAgcCA9IG0ocGhpMCwgcGhpMSk7XG5cbiAgcC5wYXJhbGxlbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBtKHBoaTAgPSBfWzBdICogcmFkaWFucywgcGhpMSA9IF9bMV0gKiByYWRpYW5zKSA6IFtwaGkwICogZGVncmVlcyQxLCBwaGkxICogZGVncmVlcyQxXTtcbiAgfTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gY3lsaW5kcmljYWxFcXVhbEFyZWFSYXcocGhpMCkge1xuICB2YXIgY29zUGhpMCA9IGNvcyQxKHBoaTApO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gW2xhbWJkYSAqIGNvc1BoaTAsIHNpbiQxKHBoaSkgLyBjb3NQaGkwXTtcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbeCAvIGNvc1BoaTAsIGFzaW4oeSAqIGNvc1BoaTApXTtcbiAgfTtcblxuICByZXR1cm4gZm9yd2FyZDtcbn1cblxuZnVuY3Rpb24gY29uaWNFcXVhbEFyZWFSYXcoeTAsIHkxKSB7XG4gIHZhciBzeTAgPSBzaW4kMSh5MCksIG4gPSAoc3kwICsgc2luJDEoeTEpKSAvIDI7XG5cbiAgLy8gQXJlIHRoZSBwYXJhbGxlbHMgc3ltbWV0cmljYWwgYXJvdW5kIHRoZSBFcXVhdG9yP1xuICBpZiAoYWJzKG4pIDwgZXBzaWxvbiQyKSByZXR1cm4gY3lsaW5kcmljYWxFcXVhbEFyZWFSYXcoeTApO1xuXG4gIHZhciBjID0gMSArIHN5MCAqICgyICogbiAtIHN5MCksIHIwID0gc3FydChjKSAvIG47XG5cbiAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgdmFyIHIgPSBzcXJ0KGMgLSAyICogbiAqIHNpbiQxKHkpKSAvIG47XG4gICAgcmV0dXJuIFtyICogc2luJDEoeCAqPSBuKSwgcjAgLSByICogY29zJDEoeCldO1xuICB9XG5cbiAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHIweSA9IHIwIC0geTtcbiAgICByZXR1cm4gW2F0YW4yKHgsIGFicyhyMHkpKSAvIG4gKiBzaWduKHIweSksIGFzaW4oKGMgLSAoeCAqIHggKyByMHkgKiByMHkpICogbiAqIG4pIC8gKDIgKiBuKSldO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG52YXIgY29uaWNFcXVhbEFyZWEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0VxdWFsQXJlYVJhdylcbiAgICAgIC5zY2FsZSgxNTUuNDI0KVxuICAgICAgLmNlbnRlcihbMCwgMzMuNjQ0Ml0pO1xufTtcblxudmFyIGFsYmVycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY29uaWNFcXVhbEFyZWEoKVxuICAgICAgLnBhcmFsbGVscyhbMjkuNSwgNDUuNV0pXG4gICAgICAuc2NhbGUoMTA3MClcbiAgICAgIC50cmFuc2xhdGUoWzQ4MCwgMjUwXSlcbiAgICAgIC5yb3RhdGUoWzk2LCAwXSlcbiAgICAgIC5jZW50ZXIoWy0wLjYsIDM4LjddKTtcbn07XG5cbi8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuLy8gYXMgdGhpcyB3aWxsIGF2b2lkIGVtaXR0aW5nIGludGVybGVhdmluZyBsaW5lcyBhbmQgcG9seWdvbnMuXG5mdW5jdGlvbiBtdWx0aXBsZXgoc3RyZWFtcykge1xuICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xuICByZXR1cm4ge1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLnBvaW50KHgsIHkpOyB9LFxuICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLnNwaGVyZSgpOyB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLmxpbmVTdGFydCgpOyB9LFxuICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5saW5lRW5kKCk7IH0sXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7IH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLnBvbHlnb25FbmQoKTsgfVxuICB9O1xufVxuXG4vLyBBIGNvbXBvc2l0ZSBwcm9qZWN0aW9uIGZvciB0aGUgVW5pdGVkIFN0YXRlcywgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvclxuLy8gOTYww5c1MDAuIFRoZSBwcm9qZWN0aW9uIGFsc28gd29ya3MgcXVpdGUgd2VsbCBhdCA5NjDDlzYwMCBpZiB5b3UgY2hhbmdlIHRoZVxuLy8gc2NhbGUgdG8gMTI4NSBhbmQgYWRqdXN0IHRoZSB0cmFuc2xhdGUgYWNjb3JkaW5nbHkuIFRoZSBzZXQgb2Ygc3RhbmRhcmRcbi8vIHBhcmFsbGVscyBmb3IgZWFjaCByZWdpb24gY29tZXMgZnJvbSBVU0dTLCB3aGljaCBpcyBwdWJsaXNoZWQgaGVyZTpcbi8vIGh0dHA6Ly9lZ3NjLnVzZ3MuZ292L2lzYi9wdWJzL01hcFByb2plY3Rpb25zL3Byb2plY3Rpb25zLmh0bWwjYWxiZXJzXG52YXIgYWxiZXJzVXNhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjYWNoZSxcbiAgICAgIGNhY2hlU3RyZWFtLFxuICAgICAgbG93ZXI0OCA9IGFsYmVycygpLCBsb3dlcjQ4UG9pbnQsXG4gICAgICBhbGFza2EgPSBjb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbMTU0LCAwXSkuY2VudGVyKFstMiwgNTguNV0pLnBhcmFsbGVscyhbNTUsIDY1XSksIGFsYXNrYVBvaW50LCAvLyBFUFNHOjMzMzhcbiAgICAgIGhhd2FpaSA9IGNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTcsIDBdKS5jZW50ZXIoWy0zLCAxOS45XSkucGFyYWxsZWxzKFs4LCAxOF0pLCBoYXdhaWlQb2ludCwgLy8gRVNSSToxMDIwMDdcbiAgICAgIHBvaW50LCBwb2ludFN0cmVhbSA9IHtwb2ludDogZnVuY3Rpb24oeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfX07XG5cbiAgZnVuY3Rpb24gYWxiZXJzVXNhKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgIChsb3dlcjQ4UG9pbnQucG9pbnQoeCwgeSksIHBvaW50KVxuICAgICAgICB8fCAoYWxhc2thUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KVxuICAgICAgICB8fCAoaGF3YWlpUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KTtcbiAgfVxuXG4gIGFsYmVyc1VzYS5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLFxuICAgICAgICB0ID0gbG93ZXI0OC50cmFuc2xhdGUoKSxcbiAgICAgICAgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gayxcbiAgICAgICAgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICByZXR1cm4gKHkgPj0gMC4xMjAgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuNDI1ICYmIHggPCAtMC4yMTQgPyBhbGFza2FcbiAgICAgICAgOiB5ID49IDAuMTY2ICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjIxNCAmJiB4IDwgLTAuMTE1ID8gaGF3YWlpXG4gICAgICAgIDogbG93ZXI0OCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgfTtcblxuICBhbGJlcnNVc2Euc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4KFtsb3dlcjQ4LnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGFsYXNrYS5zdHJlYW0oc3RyZWFtKSwgaGF3YWlpLnN0cmVhbShzdHJlYW0pXSk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnByZWNpc2lvbigpO1xuICAgIGxvd2VyNDgucHJlY2lzaW9uKF8pLCBhbGFza2EucHJlY2lzaW9uKF8pLCBoYXdhaWkucHJlY2lzaW9uKF8pO1xuICAgIHJldHVybiByZXNldCgpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnNjYWxlKCk7XG4gICAgbG93ZXI0OC5zY2FsZShfKSwgYWxhc2thLnNjYWxlKF8gKiAwLjM1KSwgaGF3YWlpLnNjYWxlKF8pO1xuICAgIHJldHVybiBhbGJlcnNVc2EudHJhbnNsYXRlKGxvd2VyNDgudHJhbnNsYXRlKCkpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC50cmFuc2xhdGUoKTtcbiAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG5cbiAgICBsb3dlcjQ4UG9pbnQgPSBsb3dlcjQ4XG4gICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40NTUgKiBrLCB5IC0gMC4yMzggKiBrXSwgW3ggKyAwLjQ1NSAqIGssIHkgKyAwLjIzOCAqIGtdXSlcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG5cbiAgICBhbGFza2FQb2ludCA9IGFsYXNrYVxuICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4zMDcgKiBrLCB5ICsgMC4yMDEgKiBrXSlcbiAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40MjUgKiBrICsgZXBzaWxvbiQyLCB5ICsgMC4xMjAgKiBrICsgZXBzaWxvbiQyXSwgW3ggLSAwLjIxNCAqIGsgLSBlcHNpbG9uJDIsIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uJDJdXSlcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG5cbiAgICBoYXdhaWlQb2ludCA9IGhhd2FpaVxuICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4yMDUgKiBrLCB5ICsgMC4yMTIgKiBrXSlcbiAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4yMTQgKiBrICsgZXBzaWxvbiQyLCB5ICsgMC4xNjYgKiBrICsgZXBzaWxvbiQyXSwgW3ggLSAwLjExNSAqIGsgLSBlcHNpbG9uJDIsIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uJDJdXSlcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG5cbiAgICByZXR1cm4gcmVzZXQoKTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0RXh0ZW50KGFsYmVyc1VzYSwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5maXRTaXplID0gZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFNpemUoYWxiZXJzVXNhLCBzaXplLCBvYmplY3QpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBhbGJlcnNVc2E7XG4gIH1cblxuICByZXR1cm4gYWxiZXJzVXNhLnNjYWxlKDEwNzApO1xufTtcblxuZnVuY3Rpb24gYXppbXV0aGFsUmF3KHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGN4ID0gY29zJDEoeCksXG4gICAgICAgIGN5ID0gY29zJDEoeSksXG4gICAgICAgIGsgPSBzY2FsZShjeCAqIGN5KTtcbiAgICByZXR1cm4gW1xuICAgICAgayAqIGN5ICogc2luJDEoeCksXG4gICAgICBrICogc2luJDEoeSlcbiAgICBdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF6aW11dGhhbEludmVydChhbmdsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB6ID0gc3FydCh4ICogeCArIHkgKiB5KSxcbiAgICAgICAgYyA9IGFuZ2xlKHopLFxuICAgICAgICBzYyA9IHNpbiQxKGMpLFxuICAgICAgICBjYyA9IGNvcyQxKGMpO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih4ICogc2MsIHogKiBjYyksXG4gICAgICBhc2luKHogJiYgeSAqIHNjIC8geilcbiAgICBdO1xuICB9XG59XG5cbnZhciBhemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24oY3hjeSkge1xuICByZXR1cm4gc3FydCgyIC8gKDEgKyBjeGN5KSk7XG59KTtcblxuYXppbXV0aGFsRXF1YWxBcmVhUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbih6KSB7XG4gIHJldHVybiAyICogYXNpbih6IC8gMik7XG59KTtcblxudmFyIGF6aW11dGhhbEVxdWFsQXJlYSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihhemltdXRoYWxFcXVhbEFyZWFSYXcpXG4gICAgICAuc2NhbGUoMTI0Ljc1KVxuICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbn07XG5cbnZhciBhemltdXRoYWxFcXVpZGlzdGFudFJhdyA9IGF6aW11dGhhbFJhdyhmdW5jdGlvbihjKSB7XG4gIHJldHVybiAoYyA9IGFjb3MoYykpICYmIGMgLyBzaW4kMShjKTtcbn0pO1xuXG5hemltdXRoYWxFcXVpZGlzdGFudFJhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24oeikge1xuICByZXR1cm4gejtcbn0pO1xuXG52YXIgYXppbXV0aGFsRXF1aWRpc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcpXG4gICAgICAuc2NhbGUoNzkuNDE4OClcbiAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG59O1xuXG5mdW5jdGlvbiBtZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2xhbWJkYSwgbG9nKHRhbigoaGFsZlBpJDIgKyBwaGkpIC8gMikpXTtcbn1cblxubWVyY2F0b3JSYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gW3gsIDIgKiBhdGFuKGV4cCh5KSkgLSBoYWxmUGkkMl07XG59O1xuXG52YXIgbWVyY2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG1lcmNhdG9yUHJvamVjdGlvbihtZXJjYXRvclJhdylcbiAgICAgIC5zY2FsZSg5NjEgLyB0YXUkMyk7XG59O1xuXG5mdW5jdGlvbiBtZXJjYXRvclByb2plY3Rpb24ocHJvamVjdCkge1xuICB2YXIgbSA9IHByb2plY3Rpb24ocHJvamVjdCksXG4gICAgICBjZW50ZXIgPSBtLmNlbnRlcixcbiAgICAgIHNjYWxlID0gbS5zY2FsZSxcbiAgICAgIHRyYW5zbGF0ZSA9IG0udHJhbnNsYXRlLFxuICAgICAgY2xpcEV4dGVudCA9IG0uY2xpcEV4dGVudCxcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MTsgLy8gY2xpcCBleHRlbnRcblxuICBtLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlKF8pLCByZWNsaXAoKSkgOiBzY2FsZSgpO1xuICB9O1xuXG4gIG0udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZShfKSwgcmVjbGlwKCkpIDogdHJhbnNsYXRlKCk7XG4gIH07XG5cbiAgbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyKF8pLCByZWNsaXAoKSkgOiBjZW50ZXIoKTtcbiAgfTtcblxuICBtLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKF8gPT0gbnVsbCA/IHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCA6ICh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSksIHJlY2xpcCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjbGlwKCkge1xuICAgIHZhciBrID0gcGkkMyAqIHNjYWxlKCksXG4gICAgICAgIHQgPSBtKHJvdGF0aW9uKG0ucm90YXRlKCkpLmludmVydChbMCwgMF0pKTtcbiAgICByZXR1cm4gY2xpcEV4dGVudCh4MCA9PSBudWxsXG4gICAgICAgID8gW1t0WzBdIC0gaywgdFsxXSAtIGtdLCBbdFswXSArIGssIHRbMV0gKyBrXV0gOiBwcm9qZWN0ID09PSBtZXJjYXRvclJhd1xuICAgICAgICA/IFtbTWF0aC5tYXgodFswXSAtIGssIHgwKSwgeTBdLCBbTWF0aC5taW4odFswXSArIGssIHgxKSwgeTFdXVxuICAgICAgICA6IFtbeDAsIE1hdGgubWF4KHRbMV0gLSBrLCB5MCldLCBbeDEsIE1hdGgubWluKHRbMV0gKyBrLCB5MSldXSk7XG4gIH1cblxuICByZXR1cm4gcmVjbGlwKCk7XG59XG5cbmZ1bmN0aW9uIHRhbnkoeSkge1xuICByZXR1cm4gdGFuKChoYWxmUGkkMiArIHkpIC8gMik7XG59XG5cbmZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsUmF3KHkwLCB5MSkge1xuICB2YXIgY3kwID0gY29zJDEoeTApLFxuICAgICAgbiA9IHkwID09PSB5MSA/IHNpbiQxKHkwKSA6IGxvZyhjeTAgLyBjb3MkMSh5MSkpIC8gbG9nKHRhbnkoeTEpIC8gdGFueSh5MCkpLFxuICAgICAgZiA9IGN5MCAqIHBvdyh0YW55KHkwKSwgbikgLyBuO1xuXG4gIGlmICghbikgcmV0dXJuIG1lcmNhdG9yUmF3O1xuXG4gIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgIGlmIChmID4gMCkgeyBpZiAoeSA8IC1oYWxmUGkkMiArIGVwc2lsb24kMikgeSA9IC1oYWxmUGkkMiArIGVwc2lsb24kMjsgfVxuICAgIGVsc2UgeyBpZiAoeSA+IGhhbGZQaSQyIC0gZXBzaWxvbiQyKSB5ID0gaGFsZlBpJDIgLSBlcHNpbG9uJDI7IH1cbiAgICB2YXIgciA9IGYgLyBwb3codGFueSh5KSwgbik7XG4gICAgcmV0dXJuIFtyICogc2luJDEobiAqIHgpLCBmIC0gciAqIGNvcyQxKG4gKiB4KV07XG4gIH1cblxuICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgZnkgPSBmIC0geSwgciA9IHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZnkgKiBmeSk7XG4gICAgcmV0dXJuIFthdGFuMih4LCBhYnMoZnkpKSAvIG4gKiBzaWduKGZ5KSwgMiAqIGF0YW4ocG93KGYgLyByLCAxIC8gbikpIC0gaGFsZlBpJDJdO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG52YXIgY29uaWNDb25mb3JtYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0NvbmZvcm1hbFJhdylcbiAgICAgIC5zY2FsZSgxMDkuNSlcbiAgICAgIC5wYXJhbGxlbHMoWzMwLCAzMF0pO1xufTtcblxuZnVuY3Rpb24gZXF1aXJlY3Rhbmd1bGFyUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbbGFtYmRhLCBwaGldO1xufVxuXG5lcXVpcmVjdGFuZ3VsYXJSYXcuaW52ZXJ0ID0gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuXG52YXIgZXF1aXJlY3Rhbmd1bGFyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKGVxdWlyZWN0YW5ndWxhclJhdylcbiAgICAgIC5zY2FsZSgxNTIuNjMpO1xufTtcblxuZnVuY3Rpb24gY29uaWNFcXVpZGlzdGFudFJhdyh5MCwgeTEpIHtcbiAgdmFyIGN5MCA9IGNvcyQxKHkwKSxcbiAgICAgIG4gPSB5MCA9PT0geTEgPyBzaW4kMSh5MCkgOiAoY3kwIC0gY29zJDEoeTEpKSAvICh5MSAtIHkwKSxcbiAgICAgIGcgPSBjeTAgLyBuICsgeTA7XG5cbiAgaWYgKGFicyhuKSA8IGVwc2lsb24kMikgcmV0dXJuIGVxdWlyZWN0YW5ndWxhclJhdztcblxuICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICB2YXIgZ3kgPSBnIC0geSwgbnggPSBuICogeDtcbiAgICByZXR1cm4gW2d5ICogc2luJDEobngpLCBnIC0gZ3kgKiBjb3MkMShueCldO1xuICB9XG5cbiAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGd5ID0gZyAtIHk7XG4gICAgcmV0dXJuIFthdGFuMih4LCBhYnMoZ3kpKSAvIG4gKiBzaWduKGd5KSwgZyAtIHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZ3kgKiBneSldO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG52YXIgY29uaWNFcXVpZGlzdGFudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljRXF1aWRpc3RhbnRSYXcpXG4gICAgICAuc2NhbGUoMTMxLjE1NClcbiAgICAgIC5jZW50ZXIoWzAsIDEzLjkzODldKTtcbn07XG5cbmZ1bmN0aW9uIGdub21vbmljUmF3KHgsIHkpIHtcbiAgdmFyIGN5ID0gY29zJDEoeSksIGsgPSBjb3MkMSh4KSAqIGN5O1xuICByZXR1cm4gW2N5ICogc2luJDEoeCkgLyBrLCBzaW4kMSh5KSAvIGtdO1xufVxuXG5nbm9tb25pY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXRhbik7XG5cbnZhciBnbm9tb25pYyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihnbm9tb25pY1JhdylcbiAgICAgIC5zY2FsZSgxNDQuMDQ5KVxuICAgICAgLmNsaXBBbmdsZSg2MCk7XG59O1xuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZShreCwga3ksIHR4LCB0eSkge1xuICByZXR1cm4ga3ggPT09IDEgJiYga3kgPT09IDEgJiYgdHggPT09IDAgJiYgdHkgPT09IDAgPyBpZGVudGl0eSQ0IDogdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICoga3ggKyB0eCwgeSAqIGt5ICsgdHkpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBpZGVudGl0eSQ1ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBrID0gMSwgdHggPSAwLCB0eSA9IDAsIHN4ID0gMSwgc3kgPSAxLCB0cmFuc2Zvcm0gPSBpZGVudGl0eSQ0LCAvLyBzY2FsZSwgdHJhbnNsYXRlIGFuZCByZWZsZWN0XG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTEsIGNsaXAgPSBpZGVudGl0eSQ0LCAvLyBjbGlwIGV4dGVudFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbSxcbiAgICAgIHByb2plY3Rpb247XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgcmV0dXJuIHByb2plY3Rpb247XG4gIH1cblxuICByZXR1cm4gcHJvamVjdGlvbiA9IHtcbiAgICBzdHJlYW06IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gdHJhbnNmb3JtKGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKTtcbiAgICB9LFxuICAgIGNsaXBFeHRlbnQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSQ0KSA6IGNsaXBFeHRlbnQoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICB9LFxuICAgIHNjYWxlOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZSgoayA9ICtfKSAqIHN4LCBrICogc3ksIHR4LCB0eSksIHJlc2V0KCkpIDogaztcbiAgICB9LFxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUoayAqIHN4LCBrICogc3ksIHR4ID0gK19bMF0sIHR5ID0gK19bMV0pLCByZXNldCgpKSA6IFt0eCwgdHldO1xuICAgIH0sXG4gICAgcmVmbGVjdFg6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlKGsgKiAoc3ggPSBfID8gLTEgOiAxKSwgayAqIHN5LCB0eCwgdHkpLCByZXNldCgpKSA6IHN4IDwgMDtcbiAgICB9LFxuICAgIHJlZmxlY3RZOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZShrICogc3gsIGsgKiAoc3kgPSBfID8gLTEgOiAxKSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeSA8IDA7XG4gICAgfSxcbiAgICBmaXRFeHRlbnQ6IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgICB9LFxuICAgIGZpdFNpemU6IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgICB9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBvcnRob2dyYXBoaWNSYXcoeCwgeSkge1xuICByZXR1cm4gW2NvcyQxKHkpICogc2luJDEoeCksIHNpbiQxKHkpXTtcbn1cblxub3J0aG9ncmFwaGljUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChhc2luKTtcblxudmFyIG9ydGhvZ3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihvcnRob2dyYXBoaWNSYXcpXG4gICAgICAuc2NhbGUoMjQ5LjUpXG4gICAgICAuY2xpcEFuZ2xlKDkwICsgZXBzaWxvbiQyKTtcbn07XG5cbmZ1bmN0aW9uIHN0ZXJlb2dyYXBoaWNSYXcoeCwgeSkge1xuICB2YXIgY3kgPSBjb3MkMSh5KSwgayA9IDEgKyBjb3MkMSh4KSAqIGN5O1xuICByZXR1cm4gW2N5ICogc2luJDEoeCkgLyBrLCBzaW4kMSh5KSAvIGtdO1xufVxuXG5zdGVyZW9ncmFwaGljUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbih6KSB7XG4gIHJldHVybiAyICogYXRhbih6KTtcbn0pO1xuXG52YXIgc3RlcmVvZ3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihzdGVyZW9ncmFwaGljUmF3KVxuICAgICAgLnNjYWxlKDI1MClcbiAgICAgIC5jbGlwQW5nbGUoMTQyKTtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zdmVyc2VNZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2xvZyh0YW4oKGhhbGZQaSQyICsgcGhpKSAvIDIpKSwgLWxhbWJkYV07XG59XG5cbnRyYW5zdmVyc2VNZXJjYXRvclJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiBbLXksIDIgKiBhdGFuKGV4cCh4KSkgLSBoYWxmUGkkMl07XG59O1xuXG52YXIgdHJhbnN2ZXJzZU1lcmNhdG9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciBtID0gbWVyY2F0b3JQcm9qZWN0aW9uKHRyYW5zdmVyc2VNZXJjYXRvclJhdyksXG4gICAgICBjZW50ZXIgPSBtLmNlbnRlcixcbiAgICAgIHJvdGF0ZSA9IG0ucm90YXRlO1xuXG4gIG0uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gY2VudGVyKFstX1sxXSwgX1swXV0pIDogKF8gPSBjZW50ZXIoKSwgW19bMV0sIC1fWzBdXSk7XG4gIH07XG5cbiAgbS5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByb3RhdGUoW19bMF0sIF9bMV0sIF8ubGVuZ3RoID4gMiA/IF9bMl0gKyA5MCA6IDkwXSkgOiAoXyA9IHJvdGF0ZSgpLCBbX1swXSwgX1sxXSwgX1syXSAtIDkwXSk7XG4gIH07XG5cbiAgcmV0dXJuIHJvdGF0ZShbMCwgMCwgOTBdKVxuICAgICAgLnNjYWxlKDE1OS4xNTUpO1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdFNlcGFyYXRpb24oYSwgYikge1xuICByZXR1cm4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XG59XG5cbmZ1bmN0aW9uIG1lYW5YKGNoaWxkcmVuKSB7XG4gIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UobWVhblhSZWR1Y2UsIDApIC8gY2hpbGRyZW4ubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBtZWFuWFJlZHVjZSh4LCBjKSB7XG4gIHJldHVybiB4ICsgYy54O1xufVxuXG5mdW5jdGlvbiBtYXhZKGNoaWxkcmVuKSB7XG4gIHJldHVybiAxICsgY2hpbGRyZW4ucmVkdWNlKG1heFlSZWR1Y2UsIDApO1xufVxuXG5mdW5jdGlvbiBtYXhZUmVkdWNlKHksIGMpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHksIGMueSk7XG59XG5cbmZ1bmN0aW9uIGxlYWZMZWZ0KG5vZGUpIHtcbiAgdmFyIGNoaWxkcmVuO1xuICB3aGlsZSAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSBub2RlID0gY2hpbGRyZW5bMF07XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBsZWFmUmlnaHQobm9kZSkge1xuICB2YXIgY2hpbGRyZW47XG4gIHdoaWxlIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIG5vZGUgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbnZhciBjbHVzdGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZXBhcmF0aW9uID0gZGVmYXVsdFNlcGFyYXRpb24sXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBub2RlU2l6ZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsdXN0ZXIocm9vdCkge1xuICAgIHZhciBwcmV2aW91c05vZGUsXG4gICAgICAgIHggPSAwO1xuXG4gICAgLy8gRmlyc3Qgd2FsaywgY29tcHV0aW5nIHRoZSBpbml0aWFsIHggJiB5IHZhbHVlcy5cbiAgICByb290LmVhY2hBZnRlcihmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIG5vZGUueCA9IG1lYW5YKGNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS55ID0gbWF4WShjaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnggPSBwcmV2aW91c05vZGUgPyB4ICs9IHNlcGFyYXRpb24obm9kZSwgcHJldmlvdXNOb2RlKSA6IDA7XG4gICAgICAgIG5vZGUueSA9IDA7XG4gICAgICAgIHByZXZpb3VzTm9kZSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgbGVmdCA9IGxlYWZMZWZ0KHJvb3QpLFxuICAgICAgICByaWdodCA9IGxlYWZSaWdodChyb290KSxcbiAgICAgICAgeDAgPSBsZWZ0LnggLSBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIsXG4gICAgICAgIHgxID0gcmlnaHQueCArIHNlcGFyYXRpb24ocmlnaHQsIGxlZnQpIC8gMjtcblxuICAgIC8vIFNlY29uZCB3YWxrLCBub3JtYWxpemluZyB4ICYgeSB0byB0aGUgZGVzaXJlZCBzaXplLlxuICAgIHJldHVybiByb290LmVhY2hBZnRlcihub2RlU2l6ZSA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUueCA9IChub2RlLnggLSByb290LngpICogZHg7XG4gICAgICBub2RlLnkgPSAocm9vdC55IC0gbm9kZS55KSAqIGR5O1xuICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnggPSAobm9kZS54IC0geDApIC8gKHgxIC0geDApICogZHg7XG4gICAgICBub2RlLnkgPSAoMSAtIChyb290LnkgPyBub2RlLnkgLyByb290LnkgOiAxKSkgKiBkeTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsdXN0ZXIuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzZXBhcmF0aW9uID0geCwgY2x1c3RlcikgOiBzZXBhcmF0aW9uO1xuICB9O1xuXG4gIGNsdXN0ZXIuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBjbHVzdGVyKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gIH07XG5cbiAgY2x1c3Rlci5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIGNsdXN0ZXIpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gY2x1c3Rlcjtcbn07XG5cbmZ1bmN0aW9uIGNvdW50KG5vZGUpIHtcbiAgdmFyIHN1bSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sXG4gICAgICBpID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAoIWkpIHN1bSA9IDE7XG4gIGVsc2Ugd2hpbGUgKC0taSA+PSAwKSBzdW0gKz0gY2hpbGRyZW5baV0udmFsdWU7XG4gIG5vZGUudmFsdWUgPSBzdW07XG59XG5cbnZhciBub2RlX2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2hBZnRlcihjb3VudCk7XG59O1xuXG52YXIgbm9kZV9lYWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBjdXJyZW50LCBuZXh0ID0gW25vZGVdLCBjaGlsZHJlbiwgaSwgbjtcbiAgZG8ge1xuICAgIGN1cnJlbnQgPSBuZXh0LnJldmVyc2UoKSwgbmV4dCA9IFtdO1xuICAgIHdoaWxlIChub2RlID0gY3VycmVudC5wb3AoKSkge1xuICAgICAgY2FsbGJhY2sobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbikgZm9yIChpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBuZXh0LnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAobmV4dC5sZW5ndGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBub2RlX2VhY2hCZWZvcmUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdLCBjaGlsZHJlbiwgaTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGNhbGxiYWNrKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuKSBmb3IgKGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIG5vZGVfZWFjaEFmdGVyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXSwgbmV4dCA9IFtdLCBjaGlsZHJlbiwgaSwgbjtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIG5leHQucHVzaChub2RlKSwgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbikgZm9yIChpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChub2RlID0gbmV4dC5wb3AoKSkge1xuICAgIGNhbGxiYWNrKG5vZGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIG5vZGVfc3VtID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEFmdGVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgc3VtID0gK3ZhbHVlKG5vZGUuZGF0YSkgfHwgMCxcbiAgICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuICAgICAgICBpID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlICgtLWkgPj0gMCkgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICAgIG5vZGUudmFsdWUgPSBzdW07XG4gIH0pO1xufTtcblxudmFyIG5vZGVfc29ydCA9IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIG5vZGVfcGF0aCA9IGZ1bmN0aW9uKGVuZCkge1xuICB2YXIgc3RhcnQgPSB0aGlzLFxuICAgICAgYW5jZXN0b3IgPSBsZWFzdENvbW1vbkFuY2VzdG9yKHN0YXJ0LCBlbmQpLFxuICAgICAgbm9kZXMgPSBbc3RhcnRdO1xuICB3aGlsZSAoc3RhcnQgIT09IGFuY2VzdG9yKSB7XG4gICAgc3RhcnQgPSBzdGFydC5wYXJlbnQ7XG4gICAgbm9kZXMucHVzaChzdGFydCk7XG4gIH1cbiAgdmFyIGsgPSBub2Rlcy5sZW5ndGg7XG4gIHdoaWxlIChlbmQgIT09IGFuY2VzdG9yKSB7XG4gICAgbm9kZXMuc3BsaWNlKGssIDAsIGVuZCk7XG4gICAgZW5kID0gZW5kLnBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59O1xuXG5mdW5jdGlvbiBsZWFzdENvbW1vbkFuY2VzdG9yKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiBhO1xuICB2YXIgYU5vZGVzID0gYS5hbmNlc3RvcnMoKSxcbiAgICAgIGJOb2RlcyA9IGIuYW5jZXN0b3JzKCksXG4gICAgICBjID0gbnVsbDtcbiAgYSA9IGFOb2Rlcy5wb3AoKTtcbiAgYiA9IGJOb2Rlcy5wb3AoKTtcbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBjID0gYTtcbiAgICBhID0gYU5vZGVzLnBvcCgpO1xuICAgIGIgPSBiTm9kZXMucG9wKCk7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbnZhciBub2RlX2FuY2VzdG9ycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdO1xuICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59O1xuXG52YXIgbm9kZV9kZXNjZW5kYW50cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgdGhpcy5lYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9KTtcbiAgcmV0dXJuIG5vZGVzO1xufTtcblxudmFyIG5vZGVfbGVhdmVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBsZWF2ZXMgPSBbXTtcbiAgdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGxlYXZlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsZWF2ZXM7XG59O1xuXG52YXIgbm9kZV9saW5rcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcm9vdCA9IHRoaXMsIGxpbmtzID0gW107XG4gIHJvb3QuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgIT09IHJvb3QpIHsgLy8gRG9u4oCZdCBpbmNsdWRlIHRoZSByb2904oCZcyBwYXJlbnQsIGlmIGFueS5cbiAgICAgIGxpbmtzLnB1c2goe3NvdXJjZTogbm9kZS5wYXJlbnQsIHRhcmdldDogbm9kZX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsaW5rcztcbn07XG5cbmZ1bmN0aW9uIGhpZXJhcmNoeShkYXRhLCBjaGlsZHJlbikge1xuICB2YXIgcm9vdCA9IG5ldyBOb2RlKGRhdGEpLFxuICAgICAgdmFsdWVkID0gK2RhdGEudmFsdWUgJiYgKHJvb3QudmFsdWUgPSBkYXRhLnZhbHVlKSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlcyA9IFtyb290XSxcbiAgICAgIGNoaWxkLFxuICAgICAgY2hpbGRzLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIGNoaWxkcmVuID0gZGVmYXVsdENoaWxkcmVuO1xuXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBpZiAodmFsdWVkKSBub2RlLnZhbHVlID0gK25vZGUuZGF0YS52YWx1ZTtcbiAgICBpZiAoKGNoaWxkcyA9IGNoaWxkcmVuKG5vZGUuZGF0YSkpICYmIChuID0gY2hpbGRzLmxlbmd0aCkpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBuZXcgQXJyYXkobik7XG4gICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbm9kZXMucHVzaChjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV0gPSBuZXcgTm9kZShjaGlsZHNbaV0pKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgICAgY2hpbGQuZGVwdGggPSBub2RlLmRlcHRoICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdC5lYWNoQmVmb3JlKGNvbXB1dGVIZWlnaHQpO1xufVxuXG5mdW5jdGlvbiBub2RlX2NvcHkoKSB7XG4gIHJldHVybiBoaWVyYXJjaHkodGhpcykuZWFjaEJlZm9yZShjb3B5RGF0YSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDaGlsZHJlbihkKSB7XG4gIHJldHVybiBkLmNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBjb3B5RGF0YShub2RlKSB7XG4gIG5vZGUuZGF0YSA9IG5vZGUuZGF0YS5kYXRhO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSGVpZ2h0KG5vZGUpIHtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIGRvIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICB3aGlsZSAoKG5vZGUgPSBub2RlLnBhcmVudCkgJiYgKG5vZGUuaGVpZ2h0IDwgKytoZWlnaHQpKTtcbn1cblxuZnVuY3Rpb24gTm9kZShkYXRhKSB7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuZGVwdGggPVxuICB0aGlzLmhlaWdodCA9IDA7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbn1cblxuTm9kZS5wcm90b3R5cGUgPSBoaWVyYXJjaHkucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTm9kZSxcbiAgY291bnQ6IG5vZGVfY291bnQsXG4gIGVhY2g6IG5vZGVfZWFjaCxcbiAgZWFjaEFmdGVyOiBub2RlX2VhY2hBZnRlcixcbiAgZWFjaEJlZm9yZTogbm9kZV9lYWNoQmVmb3JlLFxuICBzdW06IG5vZGVfc3VtLFxuICBzb3J0OiBub2RlX3NvcnQsXG4gIHBhdGg6IG5vZGVfcGF0aCxcbiAgYW5jZXN0b3JzOiBub2RlX2FuY2VzdG9ycyxcbiAgZGVzY2VuZGFudHM6IG5vZGVfZGVzY2VuZGFudHMsXG4gIGxlYXZlczogbm9kZV9sZWF2ZXMsXG4gIGxpbmtzOiBub2RlX2xpbmtzLFxuICBjb3B5OiBub2RlX2NvcHlcbn07XG5cbmZ1bmN0aW9uIE5vZGUkMih2YWx1ZSkge1xuICB0aGlzLl8gPSB2YWx1ZTtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxudmFyIHNodWZmbGUkMSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gIHZhciBpLFxuICAgICAgbiA9IChhcnJheSA9IGFycmF5LnNsaWNlKCkpLmxlbmd0aCxcbiAgICAgIGhlYWQgPSBudWxsLFxuICAgICAgbm9kZSA9IGhlYWQ7XG5cbiAgd2hpbGUgKG4pIHtcbiAgICB2YXIgbmV4dCA9IG5ldyBOb2RlJDIoYXJyYXlbbiAtIDFdKTtcbiAgICBpZiAobm9kZSkgbm9kZSA9IG5vZGUubmV4dCA9IG5leHQ7XG4gICAgZWxzZSBub2RlID0gaGVhZCA9IG5leHQ7XG4gICAgYXJyYXlbaV0gPSBhcnJheVstLW5dO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoZWFkOiBoZWFkLFxuICAgIHRhaWw6IG5vZGVcbiAgfTtcbn07XG5cbnZhciBlbmNsb3NlID0gZnVuY3Rpb24oY2lyY2xlcykge1xuICByZXR1cm4gZW5jbG9zZU4oc2h1ZmZsZSQxKGNpcmNsZXMpLCBbXSk7XG59O1xuXG5mdW5jdGlvbiBlbmNsb3NlcyhhLCBiKSB7XG4gIHZhciBkeCA9IGIueCAtIGEueCxcbiAgICAgIGR5ID0gYi55IC0gYS55LFxuICAgICAgZHIgPSBhLnIgLSBiLnI7XG4gIHJldHVybiBkciAqIGRyICsgMWUtNiA+IGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCBjaXJjbGUgdGhhdCBjb250YWlucyBjaXJjbGVzIEwgYW5kIGludGVyc2VjdHMgY2lyY2xlcyBCLlxuZnVuY3Rpb24gZW5jbG9zZU4oTCwgQikge1xuICB2YXIgY2lyY2xlLFxuICAgICAgbDAgPSBudWxsLFxuICAgICAgbDEgPSBMLmhlYWQsXG4gICAgICBsMixcbiAgICAgIHAxO1xuXG4gIHN3aXRjaCAoQi5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IGNpcmNsZSA9IGVuY2xvc2UxKEJbMF0pOyBicmVhaztcbiAgICBjYXNlIDI6IGNpcmNsZSA9IGVuY2xvc2UyKEJbMF0sIEJbMV0pOyBicmVhaztcbiAgICBjYXNlIDM6IGNpcmNsZSA9IGVuY2xvc2UzKEJbMF0sIEJbMV0sIEJbMl0pOyBicmVhaztcbiAgfVxuXG4gIHdoaWxlIChsMSkge1xuICAgIHAxID0gbDEuXywgbDIgPSBsMS5uZXh0O1xuICAgIGlmICghY2lyY2xlIHx8ICFlbmNsb3NlcyhjaXJjbGUsIHAxKSkge1xuXG4gICAgICAvLyBUZW1wb3JhcmlseSB0cnVuY2F0ZSBMIGJlZm9yZSBsMS5cbiAgICAgIGlmIChsMCkgTC50YWlsID0gbDAsIGwwLm5leHQgPSBudWxsO1xuICAgICAgZWxzZSBMLmhlYWQgPSBMLnRhaWwgPSBudWxsO1xuXG4gICAgICBCLnB1c2gocDEpO1xuICAgICAgY2lyY2xlID0gZW5jbG9zZU4oTCwgQik7IC8vIE5vdGU6IHJlb3JkZXJzIEwhXG4gICAgICBCLnBvcCgpO1xuXG4gICAgICAvLyBNb3ZlIGwxIHRvIHRoZSBmcm9udCBvZiBMIGFuZCByZWNvbm5lY3QgdGhlIHRydW5jYXRlZCBsaXN0IEwuXG4gICAgICBpZiAoTC5oZWFkKSBsMS5uZXh0ID0gTC5oZWFkLCBMLmhlYWQgPSBsMTtcbiAgICAgIGVsc2UgbDEubmV4dCA9IG51bGwsIEwuaGVhZCA9IEwudGFpbCA9IGwxO1xuICAgICAgbDAgPSBMLnRhaWwsIGwwLm5leHQgPSBsMjtcblxuICAgIH0gZWxzZSB7XG4gICAgICBsMCA9IGwxO1xuICAgIH1cbiAgICBsMSA9IGwyO1xuICB9XG5cbiAgTC50YWlsID0gbDA7XG4gIHJldHVybiBjaXJjbGU7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2UxKGEpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhLngsXG4gICAgeTogYS55LFxuICAgIHI6IGEuclxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlMihhLCBiKSB7XG4gIHZhciB4MSA9IGEueCwgeTEgPSBhLnksIHIxID0gYS5yLFxuICAgICAgeDIgPSBiLngsIHkyID0gYi55LCByMiA9IGIucixcbiAgICAgIHgyMSA9IHgyIC0geDEsIHkyMSA9IHkyIC0geTEsIHIyMSA9IHIyIC0gcjEsXG4gICAgICBsID0gTWF0aC5zcXJ0KHgyMSAqIHgyMSArIHkyMSAqIHkyMSk7XG4gIHJldHVybiB7XG4gICAgeDogKHgxICsgeDIgKyB4MjEgLyBsICogcjIxKSAvIDIsXG4gICAgeTogKHkxICsgeTIgKyB5MjEgLyBsICogcjIxKSAvIDIsXG4gICAgcjogKGwgKyByMSArIHIyKSAvIDJcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZTMoYSwgYiwgYykge1xuICB2YXIgeDEgPSBhLngsIHkxID0gYS55LCByMSA9IGEucixcbiAgICAgIHgyID0gYi54LCB5MiA9IGIueSwgcjIgPSBiLnIsXG4gICAgICB4MyA9IGMueCwgeTMgPSBjLnksIHIzID0gYy5yLFxuICAgICAgYTIgPSAyICogKHgxIC0geDIpLFxuICAgICAgYjIgPSAyICogKHkxIC0geTIpLFxuICAgICAgYzIgPSAyICogKHIyIC0gcjEpLFxuICAgICAgZDIgPSB4MSAqIHgxICsgeTEgKiB5MSAtIHIxICogcjEgLSB4MiAqIHgyIC0geTIgKiB5MiArIHIyICogcjIsXG4gICAgICBhMyA9IDIgKiAoeDEgLSB4MyksXG4gICAgICBiMyA9IDIgKiAoeTEgLSB5MyksXG4gICAgICBjMyA9IDIgKiAocjMgLSByMSksXG4gICAgICBkMyA9IHgxICogeDEgKyB5MSAqIHkxIC0gcjEgKiByMSAtIHgzICogeDMgLSB5MyAqIHkzICsgcjMgKiByMyxcbiAgICAgIGFiID0gYTMgKiBiMiAtIGEyICogYjMsXG4gICAgICB4YSA9IChiMiAqIGQzIC0gYjMgKiBkMikgLyBhYiAtIHgxLFxuICAgICAgeGIgPSAoYjMgKiBjMiAtIGIyICogYzMpIC8gYWIsXG4gICAgICB5YSA9IChhMyAqIGQyIC0gYTIgKiBkMykgLyBhYiAtIHkxLFxuICAgICAgeWIgPSAoYTIgKiBjMyAtIGEzICogYzIpIC8gYWIsXG4gICAgICBBID0geGIgKiB4YiArIHliICogeWIgLSAxLFxuICAgICAgQiA9IDIgKiAoeGEgKiB4YiArIHlhICogeWIgKyByMSksXG4gICAgICBDID0geGEgKiB4YSArIHlhICogeWEgLSByMSAqIHIxLFxuICAgICAgciA9ICgtQiAtIE1hdGguc3FydChCICogQiAtIDQgKiBBICogQykpIC8gKDIgKiBBKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4YSArIHhiICogciArIHgxLFxuICAgIHk6IHlhICsgeWIgKiByICsgeTEsXG4gICAgcjogclxuICB9O1xufVxuXG5mdW5jdGlvbiBwbGFjZShhLCBiLCBjKSB7XG4gIHZhciBheCA9IGEueCxcbiAgICAgIGF5ID0gYS55LFxuICAgICAgZGEgPSBiLnIgKyBjLnIsXG4gICAgICBkYiA9IGEuciArIGMucixcbiAgICAgIGR4ID0gYi54IC0gYXgsXG4gICAgICBkeSA9IGIueSAtIGF5LFxuICAgICAgZGMgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgaWYgKGRjKSB7XG4gICAgdmFyIHggPSAwLjUgKyAoKGRiICo9IGRiKSAtIChkYSAqPSBkYSkpIC8gKDIgKiBkYyksXG4gICAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgMiAqIGRhICogKGRiICsgZGMpIC0gKGRiIC09IGRjKSAqIGRiIC0gZGEgKiBkYSkpIC8gKDIgKiBkYyk7XG4gICAgYy54ID0gYXggKyB4ICogZHggKyB5ICogZHk7XG4gICAgYy55ID0gYXkgKyB4ICogZHkgLSB5ICogZHg7XG4gIH0gZWxzZSB7XG4gICAgYy54ID0gYXggKyBkYjtcbiAgICBjLnkgPSBheTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgdmFyIGR4ID0gYi54IC0gYS54LFxuICAgICAgZHkgPSBiLnkgLSBhLnksXG4gICAgICBkciA9IGEuciArIGIucjtcbiAgcmV0dXJuIGRyICogZHIgLSAxZS02ID4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIGRpc3RhbmNlMihub2RlLCB4LCB5KSB7XG4gIHZhciBhID0gbm9kZS5fLFxuICAgICAgYiA9IG5vZGUubmV4dC5fLFxuICAgICAgYWIgPSBhLnIgKyBiLnIsXG4gICAgICBkeCA9IChhLnggKiBiLnIgKyBiLnggKiBhLnIpIC8gYWIgLSB4LFxuICAgICAgZHkgPSAoYS55ICogYi5yICsgYi55ICogYS5yKSAvIGFiIC0geTtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBOb2RlJDEoY2lyY2xlKSB7XG4gIHRoaXMuXyA9IGNpcmNsZTtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhY2tFbmNsb3NlKGNpcmNsZXMpIHtcbiAgaWYgKCEobiA9IGNpcmNsZXMubGVuZ3RoKSkgcmV0dXJuIDA7XG5cbiAgdmFyIGEsIGIsIGMsIG47XG5cbiAgLy8gUGxhY2UgdGhlIGZpcnN0IGNpcmNsZS5cbiAgYSA9IGNpcmNsZXNbMF0sIGEueCA9IDAsIGEueSA9IDA7XG4gIGlmICghKG4gPiAxKSkgcmV0dXJuIGEucjtcblxuICAvLyBQbGFjZSB0aGUgc2Vjb25kIGNpcmNsZS5cbiAgYiA9IGNpcmNsZXNbMV0sIGEueCA9IC1iLnIsIGIueCA9IGEuciwgYi55ID0gMDtcbiAgaWYgKCEobiA+IDIpKSByZXR1cm4gYS5yICsgYi5yO1xuXG4gIC8vIFBsYWNlIHRoZSB0aGlyZCBjaXJjbGUuXG4gIHBsYWNlKGIsIGEsIGMgPSBjaXJjbGVzWzJdKTtcblxuICAvLyBJbml0aWFsaXplIHRoZSB3ZWlnaHRlZCBjZW50cm9pZC5cbiAgdmFyIGFhID0gYS5yICogYS5yLFxuICAgICAgYmEgPSBiLnIgKiBiLnIsXG4gICAgICBjYSA9IGMuciAqIGMucixcbiAgICAgIG9hID0gYWEgKyBiYSArIGNhLFxuICAgICAgb3ggPSBhYSAqIGEueCArIGJhICogYi54ICsgY2EgKiBjLngsXG4gICAgICBveSA9IGFhICogYS55ICsgYmEgKiBiLnkgKyBjYSAqIGMueSxcbiAgICAgIGN4LCBjeSwgaSwgaiwgaywgc2osIHNrO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIGZyb250LWNoYWluIHVzaW5nIHRoZSBmaXJzdCB0aHJlZSBjaXJjbGVzIGEsIGIgYW5kIGMuXG4gIGEgPSBuZXcgTm9kZSQxKGEpLCBiID0gbmV3IE5vZGUkMShiKSwgYyA9IG5ldyBOb2RlJDEoYyk7XG4gIGEubmV4dCA9IGMucHJldmlvdXMgPSBiO1xuICBiLm5leHQgPSBhLnByZXZpb3VzID0gYztcbiAgYy5uZXh0ID0gYi5wcmV2aW91cyA9IGE7XG5cbiAgLy8gQXR0ZW1wdCB0byBwbGFjZSBlYWNoIHJlbWFpbmluZyBjaXJjbGXigKZcbiAgcGFjazogZm9yIChpID0gMzsgaSA8IG47ICsraSkge1xuICAgIHBsYWNlKGEuXywgYi5fLCBjID0gY2lyY2xlc1tpXSksIGMgPSBuZXcgTm9kZSQxKGMpO1xuXG4gICAgLy8gRmluZCB0aGUgY2xvc2VzdCBpbnRlcnNlY3RpbmcgY2lyY2xlIG9uIHRoZSBmcm9udC1jaGFpbiwgaWYgYW55LlxuICAgIC8vIOKAnENsb3NlbmVzc+KAnSBpcyBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZSBhbG9uZyB0aGUgZnJvbnQtY2hhaW4uXG4gICAgLy8g4oCcQWhlYWTigJ0gb3Ig4oCcYmVoaW5k4oCdIGlzIGxpa2V3aXNlIGRldGVybWluZWQgYnkgbGluZWFyIGRpc3RhbmNlLlxuICAgIGogPSBiLm5leHQsIGsgPSBhLnByZXZpb3VzLCBzaiA9IGIuXy5yLCBzayA9IGEuXy5yO1xuICAgIGRvIHtcbiAgICAgIGlmIChzaiA8PSBzaykge1xuICAgICAgICBpZiAoaW50ZXJzZWN0cyhqLl8sIGMuXykpIHtcbiAgICAgICAgICBiID0gaiwgYS5uZXh0ID0gYiwgYi5wcmV2aW91cyA9IGEsIC0taTtcbiAgICAgICAgICBjb250aW51ZSBwYWNrO1xuICAgICAgICB9XG4gICAgICAgIHNqICs9IGouXy5yLCBqID0gai5uZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoay5fLCBjLl8pKSB7XG4gICAgICAgICAgYSA9IGssIGEubmV4dCA9IGIsIGIucHJldmlvdXMgPSBhLCAtLWk7XG4gICAgICAgICAgY29udGludWUgcGFjaztcbiAgICAgICAgfVxuICAgICAgICBzayArPSBrLl8uciwgayA9IGsucHJldmlvdXM7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoaiAhPT0gay5uZXh0KTtcblxuICAgIC8vIFN1Y2Nlc3MhIEluc2VydCB0aGUgbmV3IGNpcmNsZSBjIGJldHdlZW4gYSBhbmQgYi5cbiAgICBjLnByZXZpb3VzID0gYSwgYy5uZXh0ID0gYiwgYS5uZXh0ID0gYi5wcmV2aW91cyA9IGIgPSBjO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB3ZWlnaHRlZCBjZW50cm9pZC5cbiAgICBvYSArPSBjYSA9IGMuXy5yICogYy5fLnI7XG4gICAgb3ggKz0gY2EgKiBjLl8ueDtcbiAgICBveSArPSBjYSAqIGMuXy55O1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV3IGNsb3Nlc3QgY2lyY2xlIHBhaXIgdG8gdGhlIGNlbnRyb2lkLlxuICAgIGFhID0gZGlzdGFuY2UyKGEsIGN4ID0gb3ggLyBvYSwgY3kgPSBveSAvIG9hKTtcbiAgICB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSB7XG4gICAgICBpZiAoKGNhID0gZGlzdGFuY2UyKGMsIGN4LCBjeSkpIDwgYWEpIHtcbiAgICAgICAgYSA9IGMsIGFhID0gY2E7XG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBhLm5leHQ7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBlbmNsb3NpbmcgY2lyY2xlIG9mIHRoZSBmcm9udCBjaGFpbi5cbiAgYSA9IFtiLl9dLCBjID0gYjsgd2hpbGUgKChjID0gYy5uZXh0KSAhPT0gYikgYS5wdXNoKGMuXyk7IGMgPSBlbmNsb3NlKGEpO1xuXG4gIC8vIFRyYW5zbGF0ZSB0aGUgY2lyY2xlcyB0byBwdXQgdGhlIGVuY2xvc2luZyBjaXJjbGUgYXJvdW5kIHRoZSBvcmlnaW4uXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGEgPSBjaXJjbGVzW2ldLCBhLnggLT0gYy54LCBhLnkgLT0gYy55O1xuXG4gIHJldHVybiBjLnI7XG59XG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKGNpcmNsZXMpIHtcbiAgcGFja0VuY2xvc2UoY2lyY2xlcyk7XG4gIHJldHVybiBjaXJjbGVzO1xufTtcblxuZnVuY3Rpb24gb3B0aW9uYWwoZikge1xuICByZXR1cm4gZiA9PSBudWxsID8gbnVsbCA6IHJlcXVpcmVkKGYpO1xufVxuXG5mdW5jdGlvbiByZXF1aXJlZChmKSB7XG4gIGlmICh0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmO1xufVxuXG5mdW5jdGlvbiBjb25zdGFudFplcm8oKSB7XG4gIHJldHVybiAwO1xufVxuXG52YXIgY29uc3RhbnQkOCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdFJhZGl1cyQxKGQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkLnZhbHVlKTtcbn1cblxudmFyIGluZGV4JDIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJhZGl1cyA9IG51bGwsXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nID0gY29uc3RhbnRaZXJvO1xuXG4gIGZ1bmN0aW9uIHBhY2socm9vdCkge1xuICAgIHJvb3QueCA9IGR4IC8gMiwgcm9vdC55ID0gZHkgLyAyO1xuICAgIGlmIChyYWRpdXMpIHtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKHJhZGl1cykpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgMC41KSlcbiAgICAgICAgICAuZWFjaEJlZm9yZSh0cmFuc2xhdGVDaGlsZCgxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKGRlZmF1bHRSYWRpdXMkMSkpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4oY29uc3RhbnRaZXJvLCAxKSlcbiAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihwYWRkaW5nLCByb290LnIgLyBNYXRoLm1pbihkeCwgZHkpKSlcbiAgICAgICAgICAuZWFjaEJlZm9yZSh0cmFuc2xhdGVDaGlsZChNYXRoLm1pbihkeCwgZHkpIC8gKDIgKiByb290LnIpKSk7XG4gICAgfVxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgcGFjay5yYWRpdXMgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gb3B0aW9uYWwoeCksIHBhY2spIDogcmFkaXVzO1xuICB9O1xuXG4gIHBhY2suc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBwYWNrKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHBhY2sucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCQ4KCt4KSwgcGFjaykgOiBwYWRkaW5nO1xuICB9O1xuXG4gIHJldHVybiBwYWNrO1xufTtcblxuZnVuY3Rpb24gcmFkaXVzTGVhZihyYWRpdXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIG5vZGUuciA9IE1hdGgubWF4KDAsICtyYWRpdXMobm9kZSkgfHwgMCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYWNrQ2hpbGRyZW4ocGFkZGluZywgaykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHZhciBjaGlsZHJlbixcbiAgICAgICAgICBpLFxuICAgICAgICAgIG4gPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgciA9IHBhZGRpbmcobm9kZSkgKiBrIHx8IDAsXG4gICAgICAgICAgZTtcblxuICAgICAgaWYgKHIpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoaWxkcmVuW2ldLnIgKz0gcjtcbiAgICAgIGUgPSBwYWNrRW5jbG9zZShjaGlsZHJlbik7XG4gICAgICBpZiAocikgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY2hpbGRyZW5baV0uciAtPSByO1xuICAgICAgbm9kZS5yID0gZSArIHI7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVDaGlsZChrKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50O1xuICAgIG5vZGUuciAqPSBrO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIG5vZGUueCA9IHBhcmVudC54ICsgayAqIG5vZGUueDtcbiAgICAgIG5vZGUueSA9IHBhcmVudC55ICsgayAqIG5vZGUueTtcbiAgICB9XG4gIH07XG59XG5cbnZhciByb3VuZE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUueDAgPSBNYXRoLnJvdW5kKG5vZGUueDApO1xuICBub2RlLnkwID0gTWF0aC5yb3VuZChub2RlLnkwKTtcbiAgbm9kZS54MSA9IE1hdGgucm91bmQobm9kZS54MSk7XG4gIG5vZGUueTEgPSBNYXRoLnJvdW5kKG5vZGUueTEpO1xufTtcblxudmFyIHRyZWVtYXBEaWNlID0gZnVuY3Rpb24ocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICBub2RlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIGsgPSBwYXJlbnQudmFsdWUgJiYgKHgxIC0geDApIC8gcGFyZW50LnZhbHVlO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnkwID0geTAsIG5vZGUueTEgPSB5MTtcbiAgICBub2RlLngwID0geDAsIG5vZGUueDEgPSB4MCArPSBub2RlLnZhbHVlICogaztcbiAgfVxufTtcblxudmFyIHBhcnRpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgcGFkZGluZyA9IDAsXG4gICAgICByb3VuZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHBhcnRpdGlvbihyb290KSB7XG4gICAgdmFyIG4gPSByb290LmhlaWdodCArIDE7XG4gICAgcm9vdC54MCA9XG4gICAgcm9vdC55MCA9IHBhZGRpbmc7XG4gICAgcm9vdC54MSA9IGR4O1xuICAgIHJvb3QueTEgPSBkeSAvIG47XG4gICAgcm9vdC5lYWNoQmVmb3JlKHBvc2l0aW9uTm9kZShkeSwgbikpO1xuICAgIGlmIChyb3VuZCkgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUoZHksIG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdHJlZW1hcERpY2Uobm9kZSwgbm9kZS54MCwgZHkgKiAobm9kZS5kZXB0aCArIDEpIC8gbiwgbm9kZS54MSwgZHkgKiAobm9kZS5kZXB0aCArIDIpIC8gbik7XG4gICAgICB9XG4gICAgICB2YXIgeDAgPSBub2RlLngwLFxuICAgICAgICAgIHkwID0gbm9kZS55MCxcbiAgICAgICAgICB4MSA9IG5vZGUueDEgLSBwYWRkaW5nLFxuICAgICAgICAgIHkxID0gbm9kZS55MSAtIHBhZGRpbmc7XG4gICAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBub2RlLngwID0geDA7XG4gICAgICBub2RlLnkwID0geTA7XG4gICAgICBub2RlLngxID0geDE7XG4gICAgICBub2RlLnkxID0geTE7XG4gICAgfTtcbiAgfVxuXG4gIHBhcnRpdGlvbi5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEheCwgcGFydGl0aW9uKSA6IHJvdW5kO1xuICB9O1xuXG4gIHBhcnRpdGlvbi5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHBhcnRpdGlvbikgOiBbZHgsIGR5XTtcbiAgfTtcblxuICBwYXJ0aXRpb24ucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gK3gsIHBhcnRpdGlvbikgOiBwYWRkaW5nO1xuICB9O1xuXG4gIHJldHVybiBwYXJ0aXRpb247XG59O1xuXG52YXIga2V5UHJlZml4JDEgPSBcIiRcIjtcbnZhciBwcmVyb290ID0ge2RlcHRoOiAtMX07XG52YXIgYW1iaWd1b3VzID0ge307XG5cbmZ1bmN0aW9uIGRlZmF1bHRJZChkKSB7XG4gIHJldHVybiBkLmlkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyZW50SWQoZCkge1xuICByZXR1cm4gZC5wYXJlbnRJZDtcbn1cblxudmFyIHN0cmF0aWZ5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpZCA9IGRlZmF1bHRJZCxcbiAgICAgIHBhcmVudElkID0gZGVmYXVsdFBhcmVudElkO1xuXG4gIGZ1bmN0aW9uIHN0cmF0aWZ5KGRhdGEpIHtcbiAgICB2YXIgZCxcbiAgICAgICAgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICByb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBub2RlSWQsXG4gICAgICAgIG5vZGVLZXksXG4gICAgICAgIG5vZGVCeUtleSA9IHt9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZCA9IGRhdGFbaV0sIG5vZGUgPSBub2Rlc1tpXSA9IG5ldyBOb2RlKGQpO1xuICAgICAgaWYgKChub2RlSWQgPSBpZChkLCBpLCBkYXRhKSkgIT0gbnVsbCAmJiAobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgIG5vZGVLZXkgPSBrZXlQcmVmaXgkMSArIChub2RlLmlkID0gbm9kZUlkKTtcbiAgICAgICAgbm9kZUJ5S2V5W25vZGVLZXldID0gbm9kZUtleSBpbiBub2RlQnlLZXkgPyBhbWJpZ3VvdXMgOiBub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZUlkID0gcGFyZW50SWQoZGF0YVtpXSwgaSwgZGF0YSk7XG4gICAgICBpZiAobm9kZUlkID09IG51bGwgfHwgIShub2RlSWQgKz0gXCJcIikpIHtcbiAgICAgICAgaWYgKHJvb3QpIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIHJvb3RzXCIpO1xuICAgICAgICByb290ID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IG5vZGVCeUtleVtrZXlQcmVmaXgkMSArIG5vZGVJZF07XG4gICAgICAgIGlmICghcGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nOiBcIiArIG5vZGVJZCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IGFtYmlndW91cykgdGhyb3cgbmV3IEVycm9yKFwiYW1iaWd1b3VzOiBcIiArIG5vZGVJZCk7XG4gICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4pIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBlbHNlIHBhcmVudC5jaGlsZHJlbiA9IFtub2RlXTtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyb290KSB0aHJvdyBuZXcgRXJyb3IoXCJubyByb290XCIpO1xuICAgIHJvb3QucGFyZW50ID0gcHJlcm9vdDtcbiAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkgeyBub2RlLmRlcHRoID0gbm9kZS5wYXJlbnQuZGVwdGggKyAxOyAtLW47IH0pLmVhY2hCZWZvcmUoY29tcHV0ZUhlaWdodCk7XG4gICAgcm9vdC5wYXJlbnQgPSBudWxsO1xuICAgIGlmIChuID4gMCkgdGhyb3cgbmV3IEVycm9yKFwiY3ljbGVcIik7XG5cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIHN0cmF0aWZ5LmlkID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlkID0gcmVxdWlyZWQoeCksIHN0cmF0aWZ5KSA6IGlkO1xuICB9O1xuXG4gIHN0cmF0aWZ5LnBhcmVudElkID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhcmVudElkID0gcmVxdWlyZWQoeCksIHN0cmF0aWZ5KSA6IHBhcmVudElkO1xuICB9O1xuXG4gIHJldHVybiBzdHJhdGlmeTtcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXBhcmF0aW9uJDEoYSwgYikge1xuICByZXR1cm4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XG59XG5cbi8vIGZ1bmN0aW9uIHJhZGlhbFNlcGFyYXRpb24oYSwgYikge1xuLy8gICByZXR1cm4gKGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyKSAvIGEuZGVwdGg7XG4vLyB9XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byB0cmF2ZXJzZSB0aGUgbGVmdCBjb250b3VyIG9mIGEgc3VidHJlZSAob3Jcbi8vIHN1YmZvcmVzdCkuIEl0IHJldHVybnMgdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91ci4gVGhpcyBzdWNjZXNzb3IgaXNcbi8vIGVpdGhlciBnaXZlbiBieSB0aGUgbGVmdG1vc3QgY2hpbGQgb2YgdiBvciBieSB0aGUgdGhyZWFkIG9mIHYuIFRoZSBmdW5jdGlvblxuLy8gcmV0dXJucyBudWxsIGlmIGFuZCBvbmx5IGlmIHYgaXMgb24gdGhlIGhpZ2hlc3QgbGV2ZWwgb2YgaXRzIHN1YnRyZWUuXG5mdW5jdGlvbiBuZXh0TGVmdCh2KSB7XG4gIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuWzBdIDogdi50O1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHdvcmtzIGFuYWxvZ291c2x5IHRvIG5leHRMZWZ0LlxuZnVuY3Rpb24gbmV4dFJpZ2h0KHYpIHtcbiAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkcmVuID8gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gOiB2LnQ7XG59XG5cbi8vIFNoaWZ0cyB0aGUgY3VycmVudCBzdWJ0cmVlIHJvb3RlZCBhdCB3Ky4gVGhpcyBpcyBkb25lIGJ5IGluY3JlYXNpbmdcbi8vIHByZWxpbSh3KykgYW5kIG1vZCh3KykgYnkgc2hpZnQuXG5mdW5jdGlvbiBtb3ZlU3VidHJlZSh3bSwgd3AsIHNoaWZ0KSB7XG4gIHZhciBjaGFuZ2UgPSBzaGlmdCAvICh3cC5pIC0gd20uaSk7XG4gIHdwLmMgLT0gY2hhbmdlO1xuICB3cC5zICs9IHNoaWZ0O1xuICB3bS5jICs9IGNoYW5nZTtcbiAgd3AueiArPSBzaGlmdDtcbiAgd3AubSArPSBzaGlmdDtcbn1cblxuLy8gQWxsIG90aGVyIHNoaWZ0cywgYXBwbGllZCB0byB0aGUgc21hbGxlciBzdWJ0cmVlcyBiZXR3ZWVuIHctIGFuZCB3KywgYXJlXG4vLyBwZXJmb3JtZWQgYnkgdGhpcyBmdW5jdGlvbi4gVG8gcHJlcGFyZSB0aGUgc2hpZnRzLCB3ZSBoYXZlIHRvIGFkanVzdFxuLy8gY2hhbmdlKHcrKSwgc2hpZnQodyspLCBhbmQgY2hhbmdlKHctKS5cbmZ1bmN0aW9uIGV4ZWN1dGVTaGlmdHModikge1xuICB2YXIgc2hpZnQgPSAwLFxuICAgICAgY2hhbmdlID0gMCxcbiAgICAgIGNoaWxkcmVuID0gdi5jaGlsZHJlbixcbiAgICAgIGkgPSBjaGlsZHJlbi5sZW5ndGgsXG4gICAgICB3O1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICB3ID0gY2hpbGRyZW5baV07XG4gICAgdy56ICs9IHNoaWZ0O1xuICAgIHcubSArPSBzaGlmdDtcbiAgICBzaGlmdCArPSB3LnMgKyAoY2hhbmdlICs9IHcuYyk7XG4gIH1cbn1cblxuLy8gSWYgdmkt4oCZcyBhbmNlc3RvciBpcyBhIHNpYmxpbmcgb2YgdiwgcmV0dXJucyB2aS3igJlzIGFuY2VzdG9yLiBPdGhlcndpc2UsXG4vLyByZXR1cm5zIHRoZSBzcGVjaWZpZWQgKGRlZmF1bHQpIGFuY2VzdG9yLlxuZnVuY3Rpb24gbmV4dEFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpIHtcbiAgcmV0dXJuIHZpbS5hLnBhcmVudCA9PT0gdi5wYXJlbnQgPyB2aW0uYSA6IGFuY2VzdG9yO1xufVxuXG5mdW5jdGlvbiBUcmVlTm9kZShub2RlLCBpKSB7XG4gIHRoaXMuXyA9IG5vZGU7XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuQSA9IG51bGw7IC8vIGRlZmF1bHQgYW5jZXN0b3JcbiAgdGhpcy5hID0gdGhpczsgLy8gYW5jZXN0b3JcbiAgdGhpcy56ID0gMDsgLy8gcHJlbGltXG4gIHRoaXMubSA9IDA7IC8vIG1vZFxuICB0aGlzLmMgPSAwOyAvLyBjaGFuZ2VcbiAgdGhpcy5zID0gMDsgLy8gc2hpZnRcbiAgdGhpcy50ID0gbnVsbDsgLy8gdGhyZWFkXG4gIHRoaXMuaSA9IGk7IC8vIG51bWJlclxufVxuXG5UcmVlTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gdHJlZVJvb3Qocm9vdCkge1xuICB2YXIgdHJlZSA9IG5ldyBUcmVlTm9kZShyb290LCAwKSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlcyA9IFt0cmVlXSxcbiAgICAgIGNoaWxkLFxuICAgICAgY2hpbGRyZW4sXG4gICAgICBpLFxuICAgICAgbjtcblxuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgaWYgKGNoaWxkcmVuID0gbm9kZS5fLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLmNoaWxkcmVuID0gbmV3IEFycmF5KG4gPSBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldID0gbmV3IFRyZWVOb2RlKGNoaWxkcmVuW2ldLCBpKSk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgKHRyZWUucGFyZW50ID0gbmV3IFRyZWVOb2RlKG51bGwsIDApKS5jaGlsZHJlbiA9IFt0cmVlXTtcbiAgcmV0dXJuIHRyZWU7XG59XG5cbi8vIE5vZGUtbGluayB0cmVlIGRpYWdyYW0gdXNpbmcgdGhlIFJlaW5nb2xkLVRpbGZvcmQgXCJ0aWR5XCIgYWxnb3JpdGhtXG52YXIgdHJlZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VwYXJhdGlvbiA9IGRlZmF1bHRTZXBhcmF0aW9uJDEsXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBub2RlU2l6ZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gdHJlZShyb290KSB7XG4gICAgdmFyIHQgPSB0cmVlUm9vdChyb290KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGxheW91dCB1c2luZyBCdWNoaGVpbSBldCBhbC7igJlzIGFsZ29yaXRobS5cbiAgICB0LmVhY2hBZnRlcihmaXJzdFdhbGspLCB0LnBhcmVudC5tID0gLXQuejtcbiAgICB0LmVhY2hCZWZvcmUoc2Vjb25kV2Fsayk7XG5cbiAgICAvLyBJZiBhIGZpeGVkIG5vZGUgc2l6ZSBpcyBzcGVjaWZpZWQsIHNjYWxlIHggYW5kIHkuXG4gICAgaWYgKG5vZGVTaXplKSByb290LmVhY2hCZWZvcmUoc2l6ZU5vZGUpO1xuXG4gICAgLy8gSWYgYSBmaXhlZCB0cmVlIHNpemUgaXMgc3BlY2lmaWVkLCBzY2FsZSB4IGFuZCB5IGJhc2VkIG9uIHRoZSBleHRlbnQuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbGVmdC1tb3N0LCByaWdodC1tb3N0LCBhbmQgZGVwdGgtbW9zdCBub2RlcyBmb3IgZXh0ZW50cy5cbiAgICBlbHNlIHtcbiAgICAgIHZhciBsZWZ0ID0gcm9vdCxcbiAgICAgICAgICByaWdodCA9IHJvb3QsXG4gICAgICAgICAgYm90dG9tID0gcm9vdDtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnggPCBsZWZ0LngpIGxlZnQgPSBub2RlO1xuICAgICAgICBpZiAobm9kZS54ID4gcmlnaHQueCkgcmlnaHQgPSBub2RlO1xuICAgICAgICBpZiAobm9kZS5kZXB0aCA+IGJvdHRvbS5kZXB0aCkgYm90dG9tID0gbm9kZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHMgPSBsZWZ0ID09PSByaWdodCA/IDEgOiBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIsXG4gICAgICAgICAgdHggPSBzIC0gbGVmdC54LFxuICAgICAgICAgIGt4ID0gZHggLyAocmlnaHQueCArIHMgKyB0eCksXG4gICAgICAgICAga3kgPSBkeSAvIChib3R0b20uZGVwdGggfHwgMSk7XG4gICAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLnggPSAobm9kZS54ICsgdHgpICoga3g7XG4gICAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBreTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgLy8gQ29tcHV0ZXMgYSBwcmVsaW1pbmFyeSB4LWNvb3JkaW5hdGUgZm9yIHYuIEJlZm9yZSB0aGF0LCBGSVJTVCBXQUxLIGlzXG4gIC8vIGFwcGxpZWQgcmVjdXJzaXZlbHkgdG8gdGhlIGNoaWxkcmVuIG9mIHYsIGFzIHdlbGwgYXMgdGhlIGZ1bmN0aW9uXG4gIC8vIEFQUE9SVElPTi4gQWZ0ZXIgc3BhY2luZyBvdXQgdGhlIGNoaWxkcmVuIGJ5IGNhbGxpbmcgRVhFQ1VURSBTSElGVFMsIHRoZVxuICAvLyBub2RlIHYgaXMgcGxhY2VkIHRvIHRoZSBtaWRwb2ludCBvZiBpdHMgb3V0ZXJtb3N0IGNoaWxkcmVuLlxuICBmdW5jdGlvbiBmaXJzdFdhbGsodikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sXG4gICAgICAgIHNpYmxpbmdzID0gdi5wYXJlbnQuY2hpbGRyZW4sXG4gICAgICAgIHcgPSB2LmkgPyBzaWJsaW5nc1t2LmkgLSAxXSA6IG51bGw7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBleGVjdXRlU2hpZnRzKHYpO1xuICAgICAgdmFyIG1pZHBvaW50ID0gKGNoaWxkcmVuWzBdLnogKyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS56KSAvIDI7XG4gICAgICBpZiAodykge1xuICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgICAgdi5tID0gdi56IC0gbWlkcG9pbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2LnogPSBtaWRwb2ludDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHcpIHtcbiAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgIH1cbiAgICB2LnBhcmVudC5BID0gYXBwb3J0aW9uKHYsIHcsIHYucGFyZW50LkEgfHwgc2libGluZ3NbMF0pO1xuICB9XG5cbiAgLy8gQ29tcHV0ZXMgYWxsIHJlYWwgeC1jb29yZGluYXRlcyBieSBzdW1taW5nIHVwIHRoZSBtb2RpZmllcnMgcmVjdXJzaXZlbHkuXG4gIGZ1bmN0aW9uIHNlY29uZFdhbGsodikge1xuICAgIHYuXy54ID0gdi56ICsgdi5wYXJlbnQubTtcbiAgICB2Lm0gKz0gdi5wYXJlbnQubTtcbiAgfVxuXG4gIC8vIFRoZSBjb3JlIG9mIHRoZSBhbGdvcml0aG0uIEhlcmUsIGEgbmV3IHN1YnRyZWUgaXMgY29tYmluZWQgd2l0aCB0aGVcbiAgLy8gcHJldmlvdXMgc3VidHJlZXMuIFRocmVhZHMgYXJlIHVzZWQgdG8gdHJhdmVyc2UgdGhlIGluc2lkZSBhbmQgb3V0c2lkZVxuICAvLyBjb250b3VycyBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZSB1cCB0byB0aGUgaGlnaGVzdCBjb21tb24gbGV2ZWwuIFRoZVxuICAvLyB2ZXJ0aWNlcyB1c2VkIGZvciB0aGUgdHJhdmVyc2FscyBhcmUgdmkrLCB2aS0sIHZvLSwgYW5kIHZvKywgd2hlcmUgdGhlXG4gIC8vIHN1cGVyc2NyaXB0IG8gbWVhbnMgb3V0c2lkZSBhbmQgaSBtZWFucyBpbnNpZGUsIHRoZSBzdWJzY3JpcHQgLSBtZWFucyBsZWZ0XG4gIC8vIHN1YnRyZWUgYW5kICsgbWVhbnMgcmlnaHQgc3VidHJlZS4gRm9yIHN1bW1pbmcgdXAgdGhlIG1vZGlmaWVycyBhbG9uZyB0aGVcbiAgLy8gY29udG91ciwgd2UgdXNlIHJlc3BlY3RpdmUgdmFyaWFibGVzIHNpKywgc2ktLCBzby0sIGFuZCBzbysuIFdoZW5ldmVyIHR3b1xuICAvLyBub2RlcyBvZiB0aGUgaW5zaWRlIGNvbnRvdXJzIGNvbmZsaWN0LCB3ZSBjb21wdXRlIHRoZSBsZWZ0IG9uZSBvZiB0aGVcbiAgLy8gZ3JlYXRlc3QgdW5jb21tb24gYW5jZXN0b3JzIHVzaW5nIHRoZSBmdW5jdGlvbiBBTkNFU1RPUiBhbmQgY2FsbCBNT1ZFXG4gIC8vIFNVQlRSRUUgdG8gc2hpZnQgdGhlIHN1YnRyZWUgYW5kIHByZXBhcmUgdGhlIHNoaWZ0cyBvZiBzbWFsbGVyIHN1YnRyZWVzLlxuICAvLyBGaW5hbGx5LCB3ZSBhZGQgYSBuZXcgdGhyZWFkIChpZiBuZWNlc3NhcnkpLlxuICBmdW5jdGlvbiBhcHBvcnRpb24odiwgdywgYW5jZXN0b3IpIHtcbiAgICBpZiAodykge1xuICAgICAgdmFyIHZpcCA9IHYsXG4gICAgICAgICAgdm9wID0gdixcbiAgICAgICAgICB2aW0gPSB3LFxuICAgICAgICAgIHZvbSA9IHZpcC5wYXJlbnQuY2hpbGRyZW5bMF0sXG4gICAgICAgICAgc2lwID0gdmlwLm0sXG4gICAgICAgICAgc29wID0gdm9wLm0sXG4gICAgICAgICAgc2ltID0gdmltLm0sXG4gICAgICAgICAgc29tID0gdm9tLm0sXG4gICAgICAgICAgc2hpZnQ7XG4gICAgICB3aGlsZSAodmltID0gbmV4dFJpZ2h0KHZpbSksIHZpcCA9IG5leHRMZWZ0KHZpcCksIHZpbSAmJiB2aXApIHtcbiAgICAgICAgdm9tID0gbmV4dExlZnQodm9tKTtcbiAgICAgICAgdm9wID0gbmV4dFJpZ2h0KHZvcCk7XG4gICAgICAgIHZvcC5hID0gdjtcbiAgICAgICAgc2hpZnQgPSB2aW0ueiArIHNpbSAtIHZpcC56IC0gc2lwICsgc2VwYXJhdGlvbih2aW0uXywgdmlwLl8pO1xuICAgICAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICAgICAgbW92ZVN1YnRyZWUobmV4dEFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpLCB2LCBzaGlmdCk7XG4gICAgICAgICAgc2lwICs9IHNoaWZ0O1xuICAgICAgICAgIHNvcCArPSBzaGlmdDtcbiAgICAgICAgfVxuICAgICAgICBzaW0gKz0gdmltLm07XG4gICAgICAgIHNpcCArPSB2aXAubTtcbiAgICAgICAgc29tICs9IHZvbS5tO1xuICAgICAgICBzb3AgKz0gdm9wLm07XG4gICAgICB9XG4gICAgICBpZiAodmltICYmICFuZXh0UmlnaHQodm9wKSkge1xuICAgICAgICB2b3AudCA9IHZpbTtcbiAgICAgICAgdm9wLm0gKz0gc2ltIC0gc29wO1xuICAgICAgfVxuICAgICAgaWYgKHZpcCAmJiAhbmV4dExlZnQodm9tKSkge1xuICAgICAgICB2b20udCA9IHZpcDtcbiAgICAgICAgdm9tLm0gKz0gc2lwIC0gc29tO1xuICAgICAgICBhbmNlc3RvciA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbmNlc3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpemVOb2RlKG5vZGUpIHtcbiAgICBub2RlLnggKj0gZHg7XG4gICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGR5O1xuICB9XG5cbiAgdHJlZS5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNlcGFyYXRpb24gPSB4LCB0cmVlKSA6IHNlcGFyYXRpb247XG4gIH07XG5cbiAgdHJlZS5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gZmFsc2UsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWUpIDogKG5vZGVTaXplID8gbnVsbCA6IFtkeCwgZHldKTtcbiAgfTtcblxuICB0cmVlLm5vZGVTaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gdHJ1ZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgdHJlZSkgOiAobm9kZVNpemUgPyBbZHgsIGR5XSA6IG51bGwpO1xuICB9O1xuXG4gIHJldHVybiB0cmVlO1xufTtcblxudmFyIHRyZWVtYXBTbGljZSA9IGZ1bmN0aW9uKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgbm9kZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBrID0gcGFyZW50LnZhbHVlICYmICh5MSAtIHkwKSAvIHBhcmVudC52YWx1ZTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDE7XG4gICAgbm9kZS55MCA9IHkwLCBub2RlLnkxID0geTAgKz0gbm9kZS52YWx1ZSAqIGs7XG4gIH1cbn07XG5cbnZhciBwaGkgPSAoMSArIE1hdGguc3FydCg1KSkgLyAyO1xuXG5mdW5jdGlvbiBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciByb3dzID0gW10sXG4gICAgICBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIHJvdyxcbiAgICAgIG5vZGVWYWx1ZSxcbiAgICAgIGkwID0gMCxcbiAgICAgIGkxID0gMCxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBkeCwgZHksXG4gICAgICB2YWx1ZSA9IHBhcmVudC52YWx1ZSxcbiAgICAgIHN1bVZhbHVlLFxuICAgICAgbWluVmFsdWUsXG4gICAgICBtYXhWYWx1ZSxcbiAgICAgIG5ld1JhdGlvLFxuICAgICAgbWluUmF0aW8sXG4gICAgICBhbHBoYSxcbiAgICAgIGJldGE7XG5cbiAgd2hpbGUgKGkwIDwgbikge1xuICAgIGR4ID0geDEgLSB4MCwgZHkgPSB5MSAtIHkwO1xuXG4gICAgLy8gRmluZCB0aGUgbmV4dCBub24tZW1wdHkgbm9kZS5cbiAgICBkbyBzdW1WYWx1ZSA9IG5vZGVzW2kxKytdLnZhbHVlOyB3aGlsZSAoIXN1bVZhbHVlICYmIGkxIDwgbik7XG4gICAgbWluVmFsdWUgPSBtYXhWYWx1ZSA9IHN1bVZhbHVlO1xuICAgIGFscGhhID0gTWF0aC5tYXgoZHkgLyBkeCwgZHggLyBkeSkgLyAodmFsdWUgKiByYXRpbyk7XG4gICAgYmV0YSA9IHN1bVZhbHVlICogc3VtVmFsdWUgKiBhbHBoYTtcbiAgICBtaW5SYXRpbyA9IE1hdGgubWF4KG1heFZhbHVlIC8gYmV0YSwgYmV0YSAvIG1pblZhbHVlKTtcblxuICAgIC8vIEtlZXAgYWRkaW5nIG5vZGVzIHdoaWxlIHRoZSBhc3BlY3QgcmF0aW8gbWFpbnRhaW5zIG9yIGltcHJvdmVzLlxuICAgIGZvciAoOyBpMSA8IG47ICsraTEpIHtcbiAgICAgIHN1bVZhbHVlICs9IG5vZGVWYWx1ZSA9IG5vZGVzW2kxXS52YWx1ZTtcbiAgICAgIGlmIChub2RlVmFsdWUgPCBtaW5WYWx1ZSkgbWluVmFsdWUgPSBub2RlVmFsdWU7XG4gICAgICBpZiAobm9kZVZhbHVlID4gbWF4VmFsdWUpIG1heFZhbHVlID0gbm9kZVZhbHVlO1xuICAgICAgYmV0YSA9IHN1bVZhbHVlICogc3VtVmFsdWUgKiBhbHBoYTtcbiAgICAgIG5ld1JhdGlvID0gTWF0aC5tYXgobWF4VmFsdWUgLyBiZXRhLCBiZXRhIC8gbWluVmFsdWUpO1xuICAgICAgaWYgKG5ld1JhdGlvID4gbWluUmF0aW8pIHsgc3VtVmFsdWUgLT0gbm9kZVZhbHVlOyBicmVhazsgfVxuICAgICAgbWluUmF0aW8gPSBuZXdSYXRpbztcbiAgICB9XG5cbiAgICAvLyBQb3NpdGlvbiBhbmQgcmVjb3JkIHRoZSByb3cgb3JpZW50YXRpb24uXG4gICAgcm93cy5wdXNoKHJvdyA9IHt2YWx1ZTogc3VtVmFsdWUsIGRpY2U6IGR4IDwgZHksIGNoaWxkcmVuOiBub2Rlcy5zbGljZShpMCwgaTEpfSk7XG4gICAgaWYgKHJvdy5kaWNlKSB0cmVlbWFwRGljZShyb3csIHgwLCB5MCwgeDEsIHZhbHVlID8geTAgKz0gZHkgKiBzdW1WYWx1ZSAvIHZhbHVlIDogeTEpO1xuICAgIGVsc2UgdHJlZW1hcFNsaWNlKHJvdywgeDAsIHkwLCB2YWx1ZSA/IHgwICs9IGR4ICogc3VtVmFsdWUgLyB2YWx1ZSA6IHgxLCB5MSk7XG4gICAgdmFsdWUgLT0gc3VtVmFsdWUsIGkwID0gaTE7XG4gIH1cblxuICByZXR1cm4gcm93cztcbn1cblxudmFyIHNxdWFyaWZ5ID0gKChmdW5jdGlvbiBjdXN0b20ocmF0aW8pIHtcblxuICBmdW5jdGlvbiBzcXVhcmlmeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgc3F1YXJpZnlSYXRpbyhyYXRpbywgcGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG4gIH1cblxuICBzcXVhcmlmeS5yYXRpbyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gY3VzdG9tKCh4ID0gK3gpID4gMSA/IHggOiAxKTtcbiAgfTtcblxuICByZXR1cm4gc3F1YXJpZnk7XG59KSkocGhpKTtcblxudmFyIGluZGV4JDMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRpbGUgPSBzcXVhcmlmeSxcbiAgICAgIHJvdW5kID0gZmFsc2UsXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nU3RhY2sgPSBbMF0sXG4gICAgICBwYWRkaW5nSW5uZXIgPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nVG9wID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ1JpZ2h0ID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ0JvdHRvbSA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdMZWZ0ID0gY29uc3RhbnRaZXJvO1xuXG4gIGZ1bmN0aW9uIHRyZWVtYXAocm9vdCkge1xuICAgIHJvb3QueDAgPVxuICAgIHJvb3QueTAgPSAwO1xuICAgIHJvb3QueDEgPSBkeDtcbiAgICByb290LnkxID0gZHk7XG4gICAgcm9vdC5lYWNoQmVmb3JlKHBvc2l0aW9uTm9kZSk7XG4gICAgcGFkZGluZ1N0YWNrID0gWzBdO1xuICAgIGlmIChyb3VuZCkgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUobm9kZSkge1xuICAgIHZhciBwID0gcGFkZGluZ1N0YWNrW25vZGUuZGVwdGhdLFxuICAgICAgICB4MCA9IG5vZGUueDAgKyBwLFxuICAgICAgICB5MCA9IG5vZGUueTAgKyBwLFxuICAgICAgICB4MSA9IG5vZGUueDEgLSBwLFxuICAgICAgICB5MSA9IG5vZGUueTEgLSBwO1xuICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgbm9kZS54MCA9IHgwO1xuICAgIG5vZGUueTAgPSB5MDtcbiAgICBub2RlLngxID0geDE7XG4gICAgbm9kZS55MSA9IHkxO1xuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBwID0gcGFkZGluZ1N0YWNrW25vZGUuZGVwdGggKyAxXSA9IHBhZGRpbmdJbm5lcihub2RlKSAvIDI7XG4gICAgICB4MCArPSBwYWRkaW5nTGVmdChub2RlKSAtIHA7XG4gICAgICB5MCArPSBwYWRkaW5nVG9wKG5vZGUpIC0gcDtcbiAgICAgIHgxIC09IHBhZGRpbmdSaWdodChub2RlKSAtIHA7XG4gICAgICB5MSAtPSBwYWRkaW5nQm90dG9tKG5vZGUpIC0gcDtcbiAgICAgIGlmICh4MSA8IHgwKSB4MCA9IHgxID0gKHgwICsgeDEpIC8gMjtcbiAgICAgIGlmICh5MSA8IHkwKSB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIHRpbGUobm9kZSwgeDAsIHkwLCB4MSwgeTEpO1xuICAgIH1cbiAgfVxuXG4gIHRyZWVtYXAucm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIXgsIHRyZWVtYXApIDogcm91bmQ7XG4gIH07XG5cbiAgdHJlZW1hcC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWVtYXApIDogW2R4LCBkeV07XG4gIH07XG5cbiAgdHJlZW1hcC50aWxlID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpbGUgPSByZXF1aXJlZCh4KSwgdHJlZW1hcCkgOiB0aWxlO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyZWVtYXAucGFkZGluZ0lubmVyKHgpLnBhZGRpbmdPdXRlcih4KSA6IHRyZWVtYXAucGFkZGluZ0lubmVyKCk7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nSW5uZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCQ4KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmVlbWFwLnBhZGRpbmdUb3AoeCkucGFkZGluZ1JpZ2h0KHgpLnBhZGRpbmdCb3R0b20oeCkucGFkZGluZ0xlZnQoeCkgOiB0cmVlbWFwLnBhZGRpbmdUb3AoKTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdUb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ1RvcCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQkOCgreCksIHRyZWVtYXApIDogcGFkZGluZ1RvcDtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdSaWdodCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nUmlnaHQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50JDgoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdSaWdodDtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdCb3R0b20gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0JvdHRvbSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQkOCgreCksIHRyZWVtYXApIDogcGFkZGluZ0JvdHRvbTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdMZWZ0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdMZWZ0ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCQ4KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nTGVmdDtcbiAgfTtcblxuICByZXR1cm4gdHJlZW1hcDtcbn07XG5cbnZhciBiaW5hcnkgPSBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIGksIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBzdW0sIHN1bXMgPSBuZXcgQXJyYXkobiArIDEpO1xuXG4gIGZvciAoc3Vtc1swXSA9IHN1bSA9IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgc3Vtc1tpICsgMV0gPSBzdW0gKz0gbm9kZXNbaV0udmFsdWU7XG4gIH1cblxuICBwYXJ0aXRpb24oMCwgbiwgcGFyZW50LnZhbHVlLCB4MCwgeTAsIHgxLCB5MSk7XG5cbiAgZnVuY3Rpb24gcGFydGl0aW9uKGksIGosIHZhbHVlLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGlmIChpID49IGogLSAxKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgbm9kZS54MCA9IHgwLCBub2RlLnkwID0geTA7XG4gICAgICBub2RlLngxID0geDEsIG5vZGUueTEgPSB5MTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVPZmZzZXQgPSBzdW1zW2ldLFxuICAgICAgICB2YWx1ZVRhcmdldCA9ICh2YWx1ZSAvIDIpICsgdmFsdWVPZmZzZXQsXG4gICAgICAgIGsgPSBpICsgMSxcbiAgICAgICAgaGkgPSBqIC0gMTtcblxuICAgIHdoaWxlIChrIDwgaGkpIHtcbiAgICAgIHZhciBtaWQgPSBrICsgaGkgPj4+IDE7XG4gICAgICBpZiAoc3Vtc1ttaWRdIDwgdmFsdWVUYXJnZXQpIGsgPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG5cbiAgICBpZiAoKHZhbHVlVGFyZ2V0IC0gc3Vtc1trIC0gMV0pIDwgKHN1bXNba10gLSB2YWx1ZVRhcmdldCkgJiYgaSArIDEgPCBrKSAtLWs7XG5cbiAgICB2YXIgdmFsdWVMZWZ0ID0gc3Vtc1trXSAtIHZhbHVlT2Zmc2V0LFxuICAgICAgICB2YWx1ZVJpZ2h0ID0gdmFsdWUgLSB2YWx1ZUxlZnQ7XG5cbiAgICBpZiAoKHgxIC0geDApID4gKHkxIC0geTApKSB7XG4gICAgICB2YXIgeGsgPSAoeDAgKiB2YWx1ZVJpZ2h0ICsgeDEgKiB2YWx1ZUxlZnQpIC8gdmFsdWU7XG4gICAgICBwYXJ0aXRpb24oaSwgaywgdmFsdWVMZWZ0LCB4MCwgeTAsIHhrLCB5MSk7XG4gICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeGssIHkwLCB4MSwgeTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeWsgPSAoeTAgKiB2YWx1ZVJpZ2h0ICsgeTEgKiB2YWx1ZUxlZnQpIC8gdmFsdWU7XG4gICAgICBwYXJ0aXRpb24oaSwgaywgdmFsdWVMZWZ0LCB4MCwgeTAsIHgxLCB5ayk7XG4gICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeDAsIHlrLCB4MSwgeTEpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHNsaWNlRGljZSA9IGZ1bmN0aW9uKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgKHBhcmVudC5kZXB0aCAmIDEgPyB0cmVlbWFwU2xpY2UgOiB0cmVlbWFwRGljZSkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG59O1xuXG52YXIgcmVzcXVhcmlmeSA9ICgoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XG5cbiAgZnVuY3Rpb24gcmVzcXVhcmlmeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgaWYgKChyb3dzID0gcGFyZW50Ll9zcXVhcmlmeSkgJiYgKHJvd3MucmF0aW8gPT09IHJhdGlvKSkge1xuICAgICAgdmFyIHJvd3MsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaiA9IC0xLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgbSA9IHJvd3MubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gcGFyZW50LnZhbHVlO1xuXG4gICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICByb3cgPSByb3dzW2pdLCBub2RlcyA9IHJvdy5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gcm93LnZhbHVlID0gMCwgbiA9IG5vZGVzLmxlbmd0aDsgaSA8IG47ICsraSkgcm93LnZhbHVlICs9IG5vZGVzW2ldLnZhbHVlO1xuICAgICAgICBpZiAocm93LmRpY2UpIHRyZWVtYXBEaWNlKHJvdywgeDAsIHkwLCB4MSwgeTAgKz0gKHkxIC0geTApICogcm93LnZhbHVlIC8gdmFsdWUpO1xuICAgICAgICBlbHNlIHRyZWVtYXBTbGljZShyb3csIHgwLCB5MCwgeDAgKz0gKHgxIC0geDApICogcm93LnZhbHVlIC8gdmFsdWUsIHkxKTtcbiAgICAgICAgdmFsdWUgLT0gcm93LnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuX3NxdWFyaWZ5ID0gcm93cyA9IHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgcm93cy5yYXRpbyA9IHJhdGlvO1xuICAgIH1cbiAgfVxuXG4gIHJlc3F1YXJpZnkucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XG4gIH07XG5cbiAgcmV0dXJuIHJlc3F1YXJpZnk7XG59KSkocGhpKTtcblxudmFyIGFyZWEkMSA9IGZ1bmN0aW9uKHBvbHlnb24pIHtcbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBwb2x5Z29uLmxlbmd0aCxcbiAgICAgIGEsXG4gICAgICBiID0gcG9seWdvbltuIC0gMV0sXG4gICAgICBhcmVhID0gMDtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGEgPSBiO1xuICAgIGIgPSBwb2x5Z29uW2ldO1xuICAgIGFyZWEgKz0gYVsxXSAqIGJbMF0gLSBhWzBdICogYlsxXTtcbiAgfVxuXG4gIHJldHVybiBhcmVhIC8gMjtcbn07XG5cbnZhciBjZW50cm9pZCQxID0gZnVuY3Rpb24ocG9seWdvbikge1xuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IHBvbHlnb24ubGVuZ3RoLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMCxcbiAgICAgIGEsXG4gICAgICBiID0gcG9seWdvbltuIC0gMV0sXG4gICAgICBjLFxuICAgICAgayA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBhID0gYjtcbiAgICBiID0gcG9seWdvbltpXTtcbiAgICBrICs9IGMgPSBhWzBdICogYlsxXSAtIGJbMF0gKiBhWzFdO1xuICAgIHggKz0gKGFbMF0gKyBiWzBdKSAqIGM7XG4gICAgeSArPSAoYVsxXSArIGJbMV0pICogYztcbiAgfVxuXG4gIHJldHVybiBrICo9IDMsIFt4IC8gaywgeSAvIGtdO1xufTtcblxuLy8gUmV0dXJucyB0aGUgMkQgY3Jvc3MgcHJvZHVjdCBvZiBBQiBhbmQgQUMgdmVjdG9ycywgaS5lLiwgdGhlIHotY29tcG9uZW50IG9mXG4vLyB0aGUgM0QgY3Jvc3MgcHJvZHVjdCBpbiBhIHF1YWRyYW50IEkgQ2FydGVzaWFuIGNvb3JkaW5hdGUgc3lzdGVtICgreCBpc1xuLy8gcmlnaHQsICt5IGlzIHVwKS4gUmV0dXJucyBhIHBvc2l0aXZlIHZhbHVlIGlmIEFCQyBpcyBjb3VudGVyLWNsb2Nrd2lzZSxcbi8vIG5lZ2F0aXZlIGlmIGNsb2Nrd2lzZSwgYW5kIHplcm8gaWYgdGhlIHBvaW50cyBhcmUgY29sbGluZWFyLlxudmFyIGNyb3NzJDEgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIHJldHVybiAoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSAtIChiWzFdIC0gYVsxXSkgKiAoY1swXSAtIGFbMF0pO1xufTtcblxuZnVuY3Rpb24gbGV4aWNvZ3JhcGhpY09yZGVyKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdO1xufVxuXG4vLyBDb21wdXRlcyB0aGUgdXBwZXIgY29udmV4IGh1bGwgcGVyIHRoZSBtb25vdG9uZSBjaGFpbiBhbGdvcml0aG0uXG4vLyBBc3N1bWVzIHBvaW50cy5sZW5ndGggPj0gMywgaXMgc29ydGVkIGJ5IHgsIHVuaXF1ZSBpbiB5LlxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBpbmRpY2VzIGludG8gcG9pbnRzIGluIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG5mdW5jdGlvbiBjb21wdXRlVXBwZXJIdWxsSW5kZXhlcyhwb2ludHMpIHtcbiAgdmFyIG4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgaW5kZXhlcyA9IFswLCAxXSxcbiAgICAgIHNpemUgPSAyO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgbjsgKytpKSB7XG4gICAgd2hpbGUgKHNpemUgPiAxICYmIGNyb3NzJDEocG9pbnRzW2luZGV4ZXNbc2l6ZSAtIDJdXSwgcG9pbnRzW2luZGV4ZXNbc2l6ZSAtIDFdXSwgcG9pbnRzW2ldKSA8PSAwKSAtLXNpemU7XG4gICAgaW5kZXhlc1tzaXplKytdID0gaTtcbiAgfVxuXG4gIHJldHVybiBpbmRleGVzLnNsaWNlKDAsIHNpemUpOyAvLyByZW1vdmUgcG9wcGVkIHBvaW50c1xufVxuXG52YXIgaHVsbCA9IGZ1bmN0aW9uKHBvaW50cykge1xuICBpZiAoKG4gPSBwb2ludHMubGVuZ3RoKSA8IDMpIHJldHVybiBudWxsO1xuXG4gIHZhciBpLFxuICAgICAgbixcbiAgICAgIHNvcnRlZFBvaW50cyA9IG5ldyBBcnJheShuKSxcbiAgICAgIGZsaXBwZWRQb2ludHMgPSBuZXcgQXJyYXkobik7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgc29ydGVkUG9pbnRzW2ldID0gWytwb2ludHNbaV1bMF0sICtwb2ludHNbaV1bMV0sIGldO1xuICBzb3J0ZWRQb2ludHMuc29ydChsZXhpY29ncmFwaGljT3JkZXIpO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBmbGlwcGVkUG9pbnRzW2ldID0gW3NvcnRlZFBvaW50c1tpXVswXSwgLXNvcnRlZFBvaW50c1tpXVsxXV07XG5cbiAgdmFyIHVwcGVySW5kZXhlcyA9IGNvbXB1dGVVcHBlckh1bGxJbmRleGVzKHNvcnRlZFBvaW50cyksXG4gICAgICBsb3dlckluZGV4ZXMgPSBjb21wdXRlVXBwZXJIdWxsSW5kZXhlcyhmbGlwcGVkUG9pbnRzKTtcblxuICAvLyBDb25zdHJ1Y3QgdGhlIGh1bGwgcG9seWdvbiwgcmVtb3ZpbmcgcG9zc2libGUgZHVwbGljYXRlIGVuZHBvaW50cy5cbiAgdmFyIHNraXBMZWZ0ID0gbG93ZXJJbmRleGVzWzBdID09PSB1cHBlckluZGV4ZXNbMF0sXG4gICAgICBza2lwUmlnaHQgPSBsb3dlckluZGV4ZXNbbG93ZXJJbmRleGVzLmxlbmd0aCAtIDFdID09PSB1cHBlckluZGV4ZXNbdXBwZXJJbmRleGVzLmxlbmd0aCAtIDFdLFxuICAgICAgaHVsbCA9IFtdO1xuXG4gIC8vIEFkZCB1cHBlciBodWxsIGluIHJpZ2h0LXRvLWwgb3JkZXIuXG4gIC8vIFRoZW4gYWRkIGxvd2VyIGh1bGwgaW4gbGVmdC10by1yaWdodCBvcmRlci5cbiAgZm9yIChpID0gdXBwZXJJbmRleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBodWxsLnB1c2gocG9pbnRzW3NvcnRlZFBvaW50c1t1cHBlckluZGV4ZXNbaV1dWzJdXSk7XG4gIGZvciAoaSA9ICtza2lwTGVmdDsgaSA8IGxvd2VySW5kZXhlcy5sZW5ndGggLSBza2lwUmlnaHQ7ICsraSkgaHVsbC5wdXNoKHBvaW50c1tzb3J0ZWRQb2ludHNbbG93ZXJJbmRleGVzW2ldXVsyXV0pO1xuXG4gIHJldHVybiBodWxsO1xufTtcblxudmFyIGNvbnRhaW5zJDEgPSBmdW5jdGlvbihwb2x5Z29uLCBwb2ludCkge1xuICB2YXIgbiA9IHBvbHlnb24ubGVuZ3RoLFxuICAgICAgcCA9IHBvbHlnb25bbiAtIDFdLFxuICAgICAgeCA9IHBvaW50WzBdLCB5ID0gcG9pbnRbMV0sXG4gICAgICB4MCA9IHBbMF0sIHkwID0gcFsxXSxcbiAgICAgIHgxLCB5MSxcbiAgICAgIGluc2lkZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgcCA9IHBvbHlnb25baV0sIHgxID0gcFswXSwgeTEgPSBwWzFdO1xuICAgIGlmICgoKHkxID4geSkgIT09ICh5MCA+IHkpKSAmJiAoeCA8ICh4MCAtIHgxKSAqICh5IC0geTEpIC8gKHkwIC0geTEpICsgeDEpKSBpbnNpZGUgPSAhaW5zaWRlO1xuICAgIHgwID0geDEsIHkwID0geTE7XG4gIH1cblxuICByZXR1cm4gaW5zaWRlO1xufTtcblxudmFyIGxlbmd0aCQyID0gZnVuY3Rpb24ocG9seWdvbikge1xuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IHBvbHlnb24ubGVuZ3RoLFxuICAgICAgYiA9IHBvbHlnb25bbiAtIDFdLFxuICAgICAgeGEsXG4gICAgICB5YSxcbiAgICAgIHhiID0gYlswXSxcbiAgICAgIHliID0gYlsxXSxcbiAgICAgIHBlcmltZXRlciA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICB4YSA9IHhiO1xuICAgIHlhID0geWI7XG4gICAgYiA9IHBvbHlnb25baV07XG4gICAgeGIgPSBiWzBdO1xuICAgIHliID0gYlsxXTtcbiAgICB4YSAtPSB4YjtcbiAgICB5YSAtPSB5YjtcbiAgICBwZXJpbWV0ZXIgKz0gTWF0aC5zcXJ0KHhhICogeGEgKyB5YSAqIHlhKTtcbiAgfVxuXG4gIHJldHVybiBwZXJpbWV0ZXI7XG59O1xuXG52YXIgc2xpY2UkMyA9IFtdLnNsaWNlO1xuXG52YXIgbm9hYm9ydCA9IHt9O1xuXG5mdW5jdGlvbiBRdWV1ZShzaXplKSB7XG4gIHRoaXMuX3NpemUgPSBzaXplO1xuICB0aGlzLl9jYWxsID1cbiAgdGhpcy5fZXJyb3IgPSBudWxsO1xuICB0aGlzLl90YXNrcyA9IFtdO1xuICB0aGlzLl9kYXRhID0gW107XG4gIHRoaXMuX3dhaXRpbmcgPVxuICB0aGlzLl9hY3RpdmUgPVxuICB0aGlzLl9lbmRlZCA9XG4gIHRoaXMuX3N0YXJ0ID0gMDsgLy8gaW5zaWRlIGEgc3luY2hyb25vdXMgdGFzayBjYWxsYmFjaz9cbn1cblxuUXVldWUucHJvdG90eXBlID0gcXVldWUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUXVldWUsXG4gIGRlZmVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFja1wiKTtcbiAgICBpZiAodGhpcy5fY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiZGVmZXIgYWZ0ZXIgYXdhaXRcIik7XG4gICAgaWYgKHRoaXMuX2Vycm9yICE9IG51bGwpIHJldHVybiB0aGlzO1xuICAgIHZhciB0ID0gc2xpY2UkMy5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdC5wdXNoKGNhbGxiYWNrKTtcbiAgICArK3RoaXMuX3dhaXRpbmcsIHRoaXMuX3Rhc2tzLnB1c2godCk7XG4gICAgcG9rZSQxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2Vycm9yID09IG51bGwpIGFib3J0KHRoaXMsIG5ldyBFcnJvcihcImFib3J0XCIpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYXdhaXQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO1xuICAgIGlmICh0aGlzLl9jYWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBhd2FpdFwiKTtcbiAgICB0aGlzLl9jYWxsID0gZnVuY3Rpb24oZXJyb3IsIHJlc3VsdHMpIHsgY2FsbGJhY2suYXBwbHkobnVsbCwgW2Vycm9yXS5jb25jYXQocmVzdWx0cykpOyB9O1xuICAgIG1heWJlTm90aWZ5KHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhd2FpdEFsbDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7XG4gICAgaWYgKHRoaXMuX2NhbGwpIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGF3YWl0XCIpO1xuICAgIHRoaXMuX2NhbGwgPSBjYWxsYmFjaztcbiAgICBtYXliZU5vdGlmeSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuZnVuY3Rpb24gcG9rZSQxKHEpIHtcbiAgaWYgKCFxLl9zdGFydCkge1xuICAgIHRyeSB7IHN0YXJ0JDEocSk7IH0gLy8gbGV0IHRoZSBjdXJyZW50IHRhc2sgY29tcGxldGVcbiAgICBjYXRjaCAoZSkge1xuICAgICAgaWYgKHEuX3Rhc2tzW3EuX2VuZGVkICsgcS5fYWN0aXZlIC0gMV0pIGFib3J0KHEsIGUpOyAvLyB0YXNrIGVycm9yZWQgc3luY2hyb25vdXNseVxuICAgICAgZWxzZSBpZiAoIXEuX2RhdGEpIHRocm93IGU7IC8vIGF3YWl0IGNhbGxiYWNrIGVycm9yZWQgc3luY2hyb25vdXNseVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydCQxKHEpIHtcbiAgd2hpbGUgKHEuX3N0YXJ0ID0gcS5fd2FpdGluZyAmJiBxLl9hY3RpdmUgPCBxLl9zaXplKSB7XG4gICAgdmFyIGkgPSBxLl9lbmRlZCArIHEuX2FjdGl2ZSxcbiAgICAgICAgdCA9IHEuX3Rhc2tzW2ldLFxuICAgICAgICBqID0gdC5sZW5ndGggLSAxLFxuICAgICAgICBjID0gdFtqXTtcbiAgICB0W2pdID0gZW5kKHEsIGkpO1xuICAgIC0tcS5fd2FpdGluZywgKytxLl9hY3RpdmU7XG4gICAgdCA9IGMuYXBwbHkobnVsbCwgdCk7XG4gICAgaWYgKCFxLl90YXNrc1tpXSkgY29udGludWU7IC8vIHRhc2sgZmluaXNoZWQgc3luY2hyb25vdXNseVxuICAgIHEuX3Rhc2tzW2ldID0gdCB8fCBub2Fib3J0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZChxLCBpKSB7XG4gIHJldHVybiBmdW5jdGlvbihlLCByKSB7XG4gICAgaWYgKCFxLl90YXNrc1tpXSkgcmV0dXJuOyAvLyBpZ25vcmUgbXVsdGlwbGUgY2FsbGJhY2tzXG4gICAgLS1xLl9hY3RpdmUsICsrcS5fZW5kZWQ7XG4gICAgcS5fdGFza3NbaV0gPSBudWxsO1xuICAgIGlmIChxLl9lcnJvciAhPSBudWxsKSByZXR1cm47IC8vIGlnbm9yZSBzZWNvbmRhcnkgZXJyb3JzXG4gICAgaWYgKGUgIT0gbnVsbCkge1xuICAgICAgYWJvcnQocSwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHEuX2RhdGFbaV0gPSByO1xuICAgICAgaWYgKHEuX3dhaXRpbmcpIHBva2UkMShxKTtcbiAgICAgIGVsc2UgbWF5YmVOb3RpZnkocSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBhYm9ydChxLCBlKSB7XG4gIHZhciBpID0gcS5fdGFza3MubGVuZ3RoLCB0O1xuICBxLl9lcnJvciA9IGU7IC8vIGlnbm9yZSBhY3RpdmUgY2FsbGJhY2tzXG4gIHEuX2RhdGEgPSB1bmRlZmluZWQ7IC8vIGFsbG93IGdjXG4gIHEuX3dhaXRpbmcgPSBOYU47IC8vIHByZXZlbnQgc3RhcnRpbmdcblxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAodCA9IHEuX3Rhc2tzW2ldKSB7XG4gICAgICBxLl90YXNrc1tpXSA9IG51bGw7XG4gICAgICBpZiAodC5hYm9ydCkge1xuICAgICAgICB0cnkgeyB0LmFib3J0KCk7IH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBxLl9hY3RpdmUgPSBOYU47IC8vIGFsbG93IG5vdGlmaWNhdGlvblxuICBtYXliZU5vdGlmeShxKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVOb3RpZnkocSkge1xuICBpZiAoIXEuX2FjdGl2ZSAmJiBxLl9jYWxsKSB7XG4gICAgdmFyIGQgPSBxLl9kYXRhO1xuICAgIHEuX2RhdGEgPSB1bmRlZmluZWQ7IC8vIGFsbG93IGdjXG4gICAgcS5fY2FsbChxLl9lcnJvciwgZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVldWUoY29uY3VycmVuY3kpIHtcbiAgaWYgKGNvbmN1cnJlbmN5ID09IG51bGwpIGNvbmN1cnJlbmN5ID0gSW5maW5pdHk7XG4gIGVsc2UgaWYgKCEoKGNvbmN1cnJlbmN5ID0gK2NvbmN1cnJlbmN5KSA+PSAxKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjb25jdXJyZW5jeVwiKTtcbiAgcmV0dXJuIG5ldyBRdWV1ZShjb25jdXJyZW5jeSk7XG59XG5cbnZhciBkZWZhdWx0U291cmNlJDEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCk7XG59O1xuXG52YXIgdW5pZm9ybSA9ICgoZnVuY3Rpb24gc291cmNlUmFuZG9tVW5pZm9ybShzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tVW5pZm9ybShtaW4sIG1heCkge1xuICAgIG1pbiA9IG1pbiA9PSBudWxsID8gMCA6ICttaW47XG4gICAgbWF4ID0gbWF4ID09IG51bGwgPyAxIDogK21heDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgbWF4ID0gbWluLCBtaW4gPSAwO1xuICAgIGVsc2UgbWF4IC09IG1pbjtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc291cmNlKCkgKiBtYXggKyBtaW47XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbVVuaWZvcm0uc291cmNlID0gc291cmNlUmFuZG9tVW5pZm9ybTtcblxuICByZXR1cm4gcmFuZG9tVW5pZm9ybTtcbn0pKShkZWZhdWx0U291cmNlJDEpO1xuXG52YXIgbm9ybWFsID0gKChmdW5jdGlvbiBzb3VyY2VSYW5kb21Ob3JtYWwoc291cmNlKSB7XG4gIGZ1bmN0aW9uIHJhbmRvbU5vcm1hbChtdSwgc2lnbWEpIHtcbiAgICB2YXIgeCwgcjtcbiAgICBtdSA9IG11ID09IG51bGwgPyAwIDogK211O1xuICAgIHNpZ21hID0gc2lnbWEgPT0gbnVsbCA/IDEgOiArc2lnbWE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHk7XG5cbiAgICAgIC8vIElmIGF2YWlsYWJsZSwgdXNlIHRoZSBzZWNvbmQgcHJldmlvdXNseS1nZW5lcmF0ZWQgdW5pZm9ybSByYW5kb20uXG4gICAgICBpZiAoeCAhPSBudWxsKSB5ID0geCwgeCA9IG51bGw7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgZ2VuZXJhdGUgYSBuZXcgeCBhbmQgeS5cbiAgICAgIGVsc2UgZG8ge1xuICAgICAgICB4ID0gc291cmNlKCkgKiAyIC0gMTtcbiAgICAgICAgeSA9IHNvdXJjZSgpICogMiAtIDE7XG4gICAgICAgIHIgPSB4ICogeCArIHkgKiB5O1xuICAgICAgfSB3aGlsZSAoIXIgfHwgciA+IDEpO1xuXG4gICAgICByZXR1cm4gbXUgKyBzaWdtYSAqIHkgKiBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhyKSAvIHIpO1xuICAgIH07XG4gIH1cblxuICByYW5kb21Ob3JtYWwuc291cmNlID0gc291cmNlUmFuZG9tTm9ybWFsO1xuXG4gIHJldHVybiByYW5kb21Ob3JtYWw7XG59KSkoZGVmYXVsdFNvdXJjZSQxKTtcblxudmFyIGxvZ05vcm1hbCA9ICgoZnVuY3Rpb24gc291cmNlUmFuZG9tTG9nTm9ybWFsKHNvdXJjZSkge1xuICBmdW5jdGlvbiByYW5kb21Mb2dOb3JtYWwoKSB7XG4gICAgdmFyIHJhbmRvbU5vcm1hbCA9IG5vcm1hbC5zb3VyY2Uoc291cmNlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLmV4cChyYW5kb21Ob3JtYWwoKSk7XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbUxvZ05vcm1hbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21Mb2dOb3JtYWw7XG5cbiAgcmV0dXJuIHJhbmRvbUxvZ05vcm1hbDtcbn0pKShkZWZhdWx0U291cmNlJDEpO1xuXG52YXIgaXJ3aW5IYWxsID0gKChmdW5jdGlvbiBzb3VyY2VSYW5kb21JcndpbkhhbGwoc291cmNlKSB7XG4gIGZ1bmN0aW9uIHJhbmRvbUlyd2luSGFsbChuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgc3VtID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHN1bSArPSBzb3VyY2UoKTtcbiAgICAgIHJldHVybiBzdW07XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbUlyd2luSGFsbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21JcndpbkhhbGw7XG5cbiAgcmV0dXJuIHJhbmRvbUlyd2luSGFsbDtcbn0pKShkZWZhdWx0U291cmNlJDEpO1xuXG52YXIgYmF0ZXMgPSAoKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbUJhdGVzKHNvdXJjZSkge1xuICBmdW5jdGlvbiByYW5kb21CYXRlcyhuKSB7XG4gICAgdmFyIHJhbmRvbUlyd2luSGFsbCA9IGlyd2luSGFsbC5zb3VyY2Uoc291cmNlKShuKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tSXJ3aW5IYWxsKCkgLyBuO1xuICAgIH07XG4gIH1cblxuICByYW5kb21CYXRlcy5zb3VyY2UgPSBzb3VyY2VSYW5kb21CYXRlcztcblxuICByZXR1cm4gcmFuZG9tQmF0ZXM7XG59KSkoZGVmYXVsdFNvdXJjZSQxKTtcblxudmFyIGV4cG9uZW50aWFsJDEgPSAoKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbUV4cG9uZW50aWFsKHNvdXJjZSkge1xuICBmdW5jdGlvbiByYW5kb21FeHBvbmVudGlhbChsYW1iZGEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLU1hdGgubG9nKDEgLSBzb3VyY2UoKSkgLyBsYW1iZGE7XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbUV4cG9uZW50aWFsLnNvdXJjZSA9IHNvdXJjZVJhbmRvbUV4cG9uZW50aWFsO1xuXG4gIHJldHVybiByYW5kb21FeHBvbmVudGlhbDtcbn0pKShkZWZhdWx0U291cmNlJDEpO1xuXG52YXIgcmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgdmFyIHJlcXVlc3QsXG4gICAgICBldmVudCA9IGRpc3BhdGNoKFwiYmVmb3Jlc2VuZFwiLCBcInByb2dyZXNzXCIsIFwibG9hZFwiLCBcImVycm9yXCIpLFxuICAgICAgbWltZVR5cGUsXG4gICAgICBoZWFkZXJzID0gbWFwJDEoKSxcbiAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCxcbiAgICAgIHVzZXIgPSBudWxsLFxuICAgICAgcGFzc3dvcmQgPSBudWxsLFxuICAgICAgcmVzcG9uc2UsXG4gICAgICByZXNwb25zZVR5cGUsXG4gICAgICB0aW1lb3V0ID0gMDtcblxuICAvLyBJZiBJRSBkb2VzIG5vdCBzdXBwb3J0IENPUlMsIHVzZSBYRG9tYWluUmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBYRG9tYWluUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgJiYgIShcIndpdGhDcmVkZW50aWFsc1wiIGluIHhocilcbiAgICAgICYmIC9eKGh0dHAocyk/Oik/XFwvXFwvLy50ZXN0KHVybCkpIHhociA9IG5ldyBYRG9tYWluUmVxdWVzdDtcblxuICBcIm9ubG9hZFwiIGluIHhoclxuICAgICAgPyB4aHIub25sb2FkID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gcmVzcG9uZFxuICAgICAgOiB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24obykgeyB4aHIucmVhZHlTdGF0ZSA+IDMgJiYgcmVzcG9uZChvKTsgfTtcblxuICBmdW5jdGlvbiByZXNwb25kKG8pIHtcbiAgICB2YXIgc3RhdHVzID0geGhyLnN0YXR1cywgcmVzdWx0O1xuICAgIGlmICghc3RhdHVzICYmIGhhc1Jlc3BvbnNlKHhocilcbiAgICAgICAgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDBcbiAgICAgICAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlLmNhbGwocmVxdWVzdCwgeGhyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGV2ZW50LmNhbGwoXCJlcnJvclwiLCByZXF1ZXN0LCBlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHhocjtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmNhbGwoXCJsb2FkXCIsIHJlcXVlc3QsIHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbGwoXCJlcnJvclwiLCByZXF1ZXN0LCBvKTtcbiAgICB9XG4gIH1cblxuICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGUpIHtcbiAgICBldmVudC5jYWxsKFwicHJvZ3Jlc3NcIiwgcmVxdWVzdCwgZSk7XG4gIH07XG5cbiAgcmVxdWVzdCA9IHtcbiAgICBoZWFkZXI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICBuYW1lID0gKG5hbWUgKyBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gaGVhZGVycy5nZXQobmFtZSk7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkgaGVhZGVycy5yZW1vdmUobmFtZSk7XG4gICAgICBlbHNlIGhlYWRlcnMuc2V0KG5hbWUsIHZhbHVlICsgXCJcIik7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9LFxuXG4gICAgLy8gSWYgbWltZVR5cGUgaXMgbm9uLW51bGwgYW5kIG5vIEFjY2VwdCBoZWFkZXIgaXMgc2V0LCBhIGRlZmF1bHQgaXMgdXNlZC5cbiAgICBtaW1lVHlwZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1pbWVUeXBlO1xuICAgICAgbWltZVR5cGUgPSB2YWx1ZSA9PSBudWxsID8gbnVsbCA6IHZhbHVlICsgXCJcIjtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0sXG5cbiAgICAvLyBTcGVjaWZpZXMgd2hhdCB0eXBlIHRoZSByZXNwb25zZSB2YWx1ZSBzaG91bGQgdGFrZTtcbiAgICAvLyBmb3IgaW5zdGFuY2UsIGFycmF5YnVmZmVyLCBibG9iLCBkb2N1bWVudCwgb3IgdGV4dC5cbiAgICByZXNwb25zZVR5cGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByZXNwb25zZVR5cGU7XG4gICAgICByZXNwb25zZVR5cGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0sXG5cbiAgICB0aW1lb3V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGltZW91dDtcbiAgICAgIHRpbWVvdXQgPSArdmFsdWU7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9LFxuXG4gICAgdXNlcjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IHVzZXIgOiAodXNlciA9IHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWUgKyBcIlwiLCByZXF1ZXN0KTtcbiAgICB9LFxuXG4gICAgcGFzc3dvcmQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDEgPyBwYXNzd29yZCA6IChwYXNzd29yZCA9IHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWUgKyBcIlwiLCByZXF1ZXN0KTtcbiAgICB9LFxuXG4gICAgLy8gU3BlY2lmeSBob3cgdG8gY29udmVydCB0aGUgcmVzcG9uc2UgY29udGVudCB0byBhIHNwZWNpZmljIHR5cGU7XG4gICAgLy8gY2hhbmdlcyB0aGUgY2FsbGJhY2sgdmFsdWUgb24gXCJsb2FkXCIgZXZlbnRzLlxuICAgIHJlc3BvbnNlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzcG9uc2UgPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0sXG5cbiAgICAvLyBBbGlhcyBmb3Igc2VuZChcIkdFVFwiLCDigKYpLlxuICAgIGdldDogZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiByZXF1ZXN0LnNlbmQoXCJHRVRcIiwgZGF0YSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvLyBBbGlhcyBmb3Igc2VuZChcIlBPU1RcIiwg4oCmKS5cbiAgICBwb3N0OiBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHJlcXVlc3Quc2VuZChcIlBPU1RcIiwgZGF0YSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvLyBJZiBjYWxsYmFjayBpcyBub24tbnVsbCwgaXQgd2lsbCBiZSB1c2VkIGZvciBlcnJvciBhbmQgbG9hZCBldmVudHMuXG4gICAgc2VuZDogZnVuY3Rpb24obWV0aG9kLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUsIHVzZXIsIHBhc3N3b3JkKTtcbiAgICAgIGlmIChtaW1lVHlwZSAhPSBudWxsICYmICFoZWFkZXJzLmhhcyhcImFjY2VwdFwiKSkgaGVhZGVycy5zZXQoXCJhY2NlcHRcIiwgbWltZVR5cGUgKyBcIiwqLypcIik7XG4gICAgICBpZiAoeGhyLnNldFJlcXVlc3RIZWFkZXIpIGhlYWRlcnMuZWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkgeyB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7IH0pO1xuICAgICAgaWYgKG1pbWVUeXBlICE9IG51bGwgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUpIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWVUeXBlKTtcbiAgICAgIGlmIChyZXNwb25zZVR5cGUgIT0gbnVsbCkgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcbiAgICAgIGlmICh0aW1lb3V0ID4gMCkgeGhyLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgaWYgKGNhbGxiYWNrID09IG51bGwgJiYgdHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIGNhbGxiYWNrLmxlbmd0aCA9PT0gMSkgY2FsbGJhY2sgPSBmaXhDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgcmVxdWVzdC5vbihcImVycm9yXCIsIGNhbGxiYWNrKS5vbihcImxvYWRcIiwgZnVuY3Rpb24oeGhyKSB7IGNhbGxiYWNrKG51bGwsIHhocik7IH0pO1xuICAgICAgZXZlbnQuY2FsbChcImJlZm9yZXNlbmRcIiwgcmVxdWVzdCwgeGhyKTtcbiAgICAgIHhoci5zZW5kKGRhdGEgPT0gbnVsbCA/IG51bGwgOiBkYXRhKTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0sXG5cbiAgICBhYm9ydDogZnVuY3Rpb24oKSB7XG4gICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH0sXG5cbiAgICBvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBldmVudC5vbi5hcHBseShldmVudCwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gZXZlbnQgPyByZXF1ZXN0IDogdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcmVxdWVzdC5nZXQoY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG5mdW5jdGlvbiBmaXhDYWxsYmFjayhjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oZXJyb3IsIHhocikge1xuICAgIGNhbGxiYWNrKGVycm9yID09IG51bGwgPyB4aHIgOiBudWxsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFzUmVzcG9uc2UoeGhyKSB7XG4gIHZhciB0eXBlID0geGhyLnJlc3BvbnNlVHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZSAhPT0gXCJ0ZXh0XCJcbiAgICAgID8geGhyLnJlc3BvbnNlIC8vIG51bGwgb24gZXJyb3JcbiAgICAgIDogeGhyLnJlc3BvbnNlVGV4dDsgLy8gXCJcIiBvbiBlcnJvclxufVxuXG52YXIgdHlwZSQxID0gZnVuY3Rpb24oZGVmYXVsdE1pbWVUeXBlLCByZXNwb25zZSkge1xuICByZXR1cm4gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHZhciByID0gcmVxdWVzdCh1cmwpLm1pbWVUeXBlKGRlZmF1bHRNaW1lVHlwZSkucmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIGlmIChjYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2s6IFwiICsgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHIuZ2V0KGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG59O1xuXG52YXIgaHRtbCA9IHR5cGUkMShcInRleHQvaHRtbFwiLCBmdW5jdGlvbih4aHIpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHhoci5yZXNwb25zZVRleHQpO1xufSk7XG5cbnZhciBqc29uID0gdHlwZSQxKFwiYXBwbGljYXRpb24vanNvblwiLCBmdW5jdGlvbih4aHIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG59KTtcblxudmFyIHRleHQgPSB0eXBlJDEoXCJ0ZXh0L3BsYWluXCIsIGZ1bmN0aW9uKHhocikge1xuICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbn0pO1xuXG52YXIgeG1sID0gdHlwZSQxKFwiYXBwbGljYXRpb24veG1sXCIsIGZ1bmN0aW9uKHhocikge1xuICB2YXIgeG1sID0geGhyLnJlc3BvbnNlWE1MO1xuICBpZiAoIXhtbCkgdGhyb3cgbmV3IEVycm9yKFwicGFyc2UgZXJyb3JcIik7XG4gIHJldHVybiB4bWw7XG59KTtcblxudmFyIGRzdiQxID0gZnVuY3Rpb24oZGVmYXVsdE1pbWVUeXBlLCBwYXJzZSkge1xuICByZXR1cm4gZnVuY3Rpb24odXJsLCByb3csIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBjYWxsYmFjayA9IHJvdywgcm93ID0gbnVsbDtcbiAgICB2YXIgciA9IHJlcXVlc3QodXJsKS5taW1lVHlwZShkZWZhdWx0TWltZVR5cGUpO1xuICAgIHIucm93ID0gZnVuY3Rpb24oXykgeyByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHIucmVzcG9uc2UocmVzcG9uc2VPZihwYXJzZSwgcm93ID0gXykpIDogcm93OyB9O1xuICAgIHIucm93KHJvdyk7XG4gICAgcmV0dXJuIGNhbGxiYWNrID8gci5nZXQoY2FsbGJhY2spIDogcjtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHJlc3BvbnNlT2YocGFyc2UsIHJvdykge1xuICByZXR1cm4gZnVuY3Rpb24ocmVxdWVzdCQkMSkge1xuICAgIHJldHVybiBwYXJzZShyZXF1ZXN0JCQxLnJlc3BvbnNlVGV4dCwgcm93KTtcbiAgfTtcbn1cblxudmFyIGNzdiQxID0gZHN2JDEoXCJ0ZXh0L2NzdlwiLCBjc3ZQYXJzZSk7XG5cbnZhciB0c3YkMSA9IGRzdiQxKFwidGV4dC90YWItc2VwYXJhdGVkLXZhbHVlc1wiLCB0c3ZQYXJzZSk7XG5cbnZhciBhcnJheSQyID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgbWFwJDMgPSBhcnJheSQyLm1hcDtcbnZhciBzbGljZSQ0ID0gYXJyYXkkMi5zbGljZTtcblxudmFyIGltcGxpY2l0ID0ge25hbWU6IFwiaW1wbGljaXRcIn07XG5cbmZ1bmN0aW9uIG9yZGluYWwocmFuZ2UpIHtcbiAgdmFyIGluZGV4ID0gbWFwJDEoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgdW5rbm93biA9IGltcGxpY2l0O1xuXG4gIHJhbmdlID0gcmFuZ2UgPT0gbnVsbCA/IFtdIDogc2xpY2UkNC5jYWxsKHJhbmdlKTtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlWyhpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IG1hcCQxKCk7XG4gICAgdmFyIGkgPSAtMSwgbiA9IF8ubGVuZ3RoLCBkLCBrZXk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmICghaW5kZXguaGFzKGtleSA9IChkID0gX1tpXSkgKyBcIlwiKSkgaW5kZXguc2V0KGtleSwgZG9tYWluLnB1c2goZCkpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IHNsaWNlJDQuY2FsbChfKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JkaW5hbCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gYmFuZCgpIHtcbiAgdmFyIHNjYWxlID0gb3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlLFxuICAgICAgcmFuZ2UkJDEgPSBbMCwgMV0sXG4gICAgICBzdGVwLFxuICAgICAgYmFuZHdpZHRoLFxuICAgICAgcm91bmQgPSBmYWxzZSxcbiAgICAgIHBhZGRpbmdJbm5lciA9IDAsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgICAgYWxpZ24gPSAwLjU7XG5cbiAgZGVsZXRlIHNjYWxlLnVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgbiA9IGRvbWFpbigpLmxlbmd0aCxcbiAgICAgICAgcmV2ZXJzZSA9IHJhbmdlJCQxWzFdIDwgcmFuZ2UkJDFbMF0sXG4gICAgICAgIHN0YXJ0ID0gcmFuZ2UkJDFbcmV2ZXJzZSAtIDBdLFxuICAgICAgICBzdG9wID0gcmFuZ2UkJDFbMSAtIHJldmVyc2VdO1xuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDEsIG4gLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICBpZiAocm91bmQpIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgIHN0YXJ0ICs9IChzdG9wIC0gc3RhcnQgLSBzdGVwICogKG4gLSBwYWRkaW5nSW5uZXIpKSAqIGFsaWduO1xuICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kKSBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpLCBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgdmFyIHZhbHVlcyA9IHNlcXVlbmNlKG4pLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBzdGFydCArIHN0ZXAgKiBpOyB9KTtcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSQkMSA9IFsrX1swXSwgK19bMV1dLCByZXNjYWxlKCkpIDogcmFuZ2UkJDEuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiByYW5nZSQkMSA9IFsrX1swXSwgK19bMV1dLCByb3VuZCA9IHRydWUsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZHdpZHRoO1xuICB9O1xuXG4gIHNjYWxlLnN0ZXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcblxuICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEhXywgcmVzY2FsZSgpKSA6IHJvdW5kO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0lubmVyID0gcGFkZGluZ091dGVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogcGFkZGluZ0lubmVyO1xuICB9O1xuXG4gIHNjYWxlLnBhZGRpbmdJbm5lciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdPdXRlcjtcbiAgfTtcblxuICBzY2FsZS5hbGlnbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbGlnbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IGFsaWduO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYmFuZCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKCkpXG4gICAgICAgIC5yYW5nZShyYW5nZSQkMSlcbiAgICAgICAgLnJvdW5kKHJvdW5kKVxuICAgICAgICAucGFkZGluZ0lubmVyKHBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpXG4gICAgICAgIC5hbGlnbihhbGlnbik7XG4gIH07XG5cbiAgcmV0dXJuIHJlc2NhbGUoKTtcbn1cblxuZnVuY3Rpb24gcG9pbnRpc2goc2NhbGUpIHtcbiAgdmFyIGNvcHkgPSBzY2FsZS5jb3B5O1xuXG4gIHNjYWxlLnBhZGRpbmcgPSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nSW5uZXI7XG4gIGRlbGV0ZSBzY2FsZS5wYWRkaW5nT3V0ZXI7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gcG9pbnQkMSgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQoKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuXG52YXIgY29uc3RhbnQkOSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxudmFyIG51bWJlciQxID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gK3g7XG59O1xuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZUxpbmVhcihhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQkOShiKTtcbn1cblxuZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZUNsYW1wKGRlaW50ZXJwb2xhdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgZCA9IGRlaW50ZXJwb2xhdGUoYSA9ICthLCBiID0gK2IpO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiB4IDw9IGEgPyAwIDogeCA+PSBiID8gMSA6IGQoeCk7IH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlaW50ZXJwb2xhdGVDbGFtcChyZWludGVycG9sYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHIgPSByZWludGVycG9sYXRlKGEgPSArYSwgYiA9ICtiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkgeyByZXR1cm4gdCA8PSAwID8gYSA6IHQgPj0gMSA/IGIgOiByKHQpOyB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlJCQxLCBkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSB7XG4gIHZhciBkMCA9IGRvbWFpblswXSwgZDEgPSBkb21haW5bMV0sIHIwID0gcmFuZ2UkJDFbMF0sIHIxID0gcmFuZ2UkJDFbMV07XG4gIGlmIChkMSA8IGQwKSBkMCA9IGRlaW50ZXJwb2xhdGUoZDEsIGQwKSwgcjAgPSByZWludGVycG9sYXRlKHIxLCByMCk7XG4gIGVsc2UgZDAgPSBkZWludGVycG9sYXRlKGQwLCBkMSksIHIwID0gcmVpbnRlcnBvbGF0ZShyMCwgcjEpO1xuICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gcjAoZDAoeCkpOyB9O1xufVxuXG5mdW5jdGlvbiBwb2x5bWFwKGRvbWFpbiwgcmFuZ2UkJDEsIGRlaW50ZXJwb2xhdGUsIHJlaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGogPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZSQkMS5sZW5ndGgpIC0gMSxcbiAgICAgIGQgPSBuZXcgQXJyYXkoaiksXG4gICAgICByID0gbmV3IEFycmF5KGopLFxuICAgICAgaSA9IC0xO1xuXG4gIC8vIFJldmVyc2UgZGVzY2VuZGluZyBkb21haW5zLlxuICBpZiAoZG9tYWluW2pdIDwgZG9tYWluWzBdKSB7XG4gICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIHJhbmdlJCQxID0gcmFuZ2UkJDEuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIH1cblxuICB3aGlsZSAoKytpIDwgaikge1xuICAgIGRbaV0gPSBkZWludGVycG9sYXRlKGRvbWFpbltpXSwgZG9tYWluW2kgKyAxXSk7XG4gICAgcltpXSA9IHJlaW50ZXJwb2xhdGUocmFuZ2UkJDFbaV0sIHJhbmdlJCQxW2kgKyAxXSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHZhciBpID0gYmlzZWN0UmlnaHQoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvcHkoc291cmNlLCB0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldFxuICAgICAgLmRvbWFpbihzb3VyY2UuZG9tYWluKCkpXG4gICAgICAucmFuZ2Uoc291cmNlLnJhbmdlKCkpXG4gICAgICAuaW50ZXJwb2xhdGUoc291cmNlLmludGVycG9sYXRlKCkpXG4gICAgICAuY2xhbXAoc291cmNlLmNsYW1wKCkpO1xufVxuXG4vLyBkZWludGVycG9sYXRlKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyByZWludGVycG9sYXRlKGEsIGIpKHQpIHRha2VzIGEgcGFyYW1ldGVyIHQgaW4gWzAsMV0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0uXG5mdW5jdGlvbiBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUsIHJlaW50ZXJwb2xhdGUpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSQkMSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSQkMSA9IGludGVycG9sYXRlVmFsdWUsXG4gICAgICBjbGFtcCA9IGZhbHNlLFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBwaWVjZXdpc2UgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZSQkMS5sZW5ndGgpID4gMiA/IHBvbHltYXAgOiBiaW1hcDtcbiAgICBvdXRwdXQgPSBpbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiAob3V0cHV0IHx8IChvdXRwdXQgPSBwaWVjZXdpc2UoZG9tYWluLCByYW5nZSQkMSwgY2xhbXAgPyBkZWludGVycG9sYXRlQ2xhbXAoZGVpbnRlcnBvbGF0ZSkgOiBkZWludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSQkMSkpKSgreCk7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIChpbnB1dCB8fCAoaW5wdXQgPSBwaWVjZXdpc2UocmFuZ2UkJDEsIGRvbWFpbiwgZGVpbnRlcnBvbGF0ZUxpbmVhciwgY2xhbXAgPyByZWludGVycG9sYXRlQ2xhbXAocmVpbnRlcnBvbGF0ZSkgOiByZWludGVycG9sYXRlKSkpKCt5KTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gbWFwJDMuY2FsbChfLCBudW1iZXIkMSksIHJlc2NhbGUoKSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSQkMSA9IHNsaWNlJDQuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlJCQxLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UkJDEgPSBzbGljZSQ0LmNhbGwoXyksIGludGVycG9sYXRlJCQxID0gaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCByZXNjYWxlKCkpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUkJDEgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGUkJDE7XG4gIH07XG5cbiAgcmV0dXJuIHJlc2NhbGUoKTtcbn1cblxudmFyIHRpY2tGb3JtYXQgPSBmdW5jdGlvbihkb21haW4sIGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgdmFyIHN0YXJ0ID0gZG9tYWluWzBdLFxuICAgICAgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sXG4gICAgICBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KSxcbiAgICAgIHByZWNpc2lvbjtcbiAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gXCIsZlwiIDogc3BlY2lmaWVyKTtcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICByZXR1cm4gZXhwb3J0cy5mb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNhc2UgXCJcIjpcbiAgICBjYXNlIFwiZVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwiclwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25Sb3VuZChzdGVwLCBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcImVcIik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZcIjpcbiAgICBjYXNlIFwiJVwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25GaXhlZChzdGVwKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiJVwiKSAqIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV4cG9ydHMuZm9ybWF0KHNwZWNpZmllcik7XG59O1xuXG5mdW5jdGlvbiBsaW5lYXJpc2goc2NhbGUpIHtcbiAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCk7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gdGlja0Zvcm1hdChkb21haW4oKSwgY291bnQsIHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG5cbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICBpMCA9IDAsXG4gICAgICAgIGkxID0gZC5sZW5ndGggLSAxLFxuICAgICAgICBzdGFydCA9IGRbaTBdLFxuICAgICAgICBzdG9wID0gZFtpMV0sXG4gICAgICAgIHN0ZXA7XG5cbiAgICBpZiAoc3RvcCA8IHN0YXJ0KSB7XG4gICAgICBzdGVwID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IHN0ZXA7XG4gICAgICBzdGVwID0gaTAsIGkwID0gaTEsIGkxID0gc3RlcDtcbiAgICB9XG5cbiAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBzdG9wID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICBkW2kwXSA9IE1hdGguZmxvb3Ioc3RhcnQgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgZG9tYWluKGQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgZFtpMV0gPSBNYXRoLmZsb29yKHN0b3AgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gbGluZWFyJDIoKSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZUxpbmVhciwgcmVpbnRlcnBvbGF0ZSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsaW5lYXIkMigpKTtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkkNigpIHtcbiAgdmFyIGRvbWFpbiA9IFswLCAxXTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuICt4O1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gc2NhbGU7XG5cbiAgc2NhbGUuZG9tYWluID0gc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gbWFwJDMuY2FsbChfLCBudW1iZXIkMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWRlbnRpdHkkNigpLmRvbWFpbihkb21haW4pO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG52YXIgbmljZSA9IGZ1bmN0aW9uKGRvbWFpbiwgaW50ZXJ2YWwpIHtcbiAgZG9tYWluID0gZG9tYWluLnNsaWNlKCk7XG5cbiAgdmFyIGkwID0gMCxcbiAgICAgIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsXG4gICAgICB4MCA9IGRvbWFpbltpMF0sXG4gICAgICB4MSA9IGRvbWFpbltpMV0sXG4gICAgICB0O1xuXG4gIGlmICh4MSA8IHgwKSB7XG4gICAgdCA9IGkwLCBpMCA9IGkxLCBpMSA9IHQ7XG4gICAgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gIH1cblxuICBkb21haW5baTBdID0gaW50ZXJ2YWwuZmxvb3IoeDApO1xuICBkb21haW5baTFdID0gaW50ZXJ2YWwuY2VpbCh4MSk7XG4gIHJldHVybiBkb21haW47XG59O1xuXG5mdW5jdGlvbiBkZWludGVycG9sYXRlKGEsIGIpIHtcbiAgcmV0dXJuIChiID0gTWF0aC5sb2coYiAvIGEpKVxuICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4IC8gYSkgLyBiOyB9XG4gICAgICA6IGNvbnN0YW50JDkoYik7XG59XG5cbmZ1bmN0aW9uIHJlaW50ZXJwb2xhdGUkMShhLCBiKSB7XG4gIHJldHVybiBhIDwgMFxuICAgICAgPyBmdW5jdGlvbih0KSB7IHJldHVybiAtTWF0aC5wb3coLWIsIHQpICogTWF0aC5wb3coLWEsIDEgLSB0KTsgfVxuICAgICAgOiBmdW5jdGlvbih0KSB7IHJldHVybiBNYXRoLnBvdyhiLCB0KSAqIE1hdGgucG93KGEsIDEgLSB0KTsgfTtcbn1cblxuZnVuY3Rpb24gcG93MTAoeCkge1xuICByZXR1cm4gaXNGaW5pdGUoeCkgPyArKFwiMWVcIiArIHgpIDogeCA8IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gcG93cChiYXNlKSB7XG4gIHJldHVybiBiYXNlID09PSAxMCA/IHBvdzEwXG4gICAgICA6IGJhc2UgPT09IE1hdGguRSA/IE1hdGguZXhwXG4gICAgICA6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucG93KGJhc2UsIHgpOyB9O1xufVxuXG5mdW5jdGlvbiBsb2dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IE1hdGguRSA/IE1hdGgubG9nXG4gICAgICA6IGJhc2UgPT09IDEwICYmIE1hdGgubG9nMTBcbiAgICAgIHx8IGJhc2UgPT09IDIgJiYgTWF0aC5sb2cyXG4gICAgICB8fCAoYmFzZSA9IE1hdGgubG9nKGJhc2UpLCBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4KSAvIGJhc2U7IH0pO1xufVxuXG5mdW5jdGlvbiByZWZsZWN0KGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gLWYoLXgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBsb2ckMSgpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlJDEpLmRvbWFpbihbMSwgMTBdKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIGJhc2UgPSAxMCxcbiAgICAgIGxvZ3MgPSBsb2dwKDEwKSxcbiAgICAgIHBvd3MgPSBwb3dwKDEwKTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIGxvZ3MgPSBsb2dwKGJhc2UpLCBwb3dzID0gcG93cChiYXNlKTtcbiAgICBpZiAoZG9tYWluKClbMF0gPCAwKSBsb2dzID0gcmVmbGVjdChsb2dzKSwgcG93cyA9IHJlZmxlY3QocG93cyk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChiYXNlID0gK18sIHJlc2NhbGUoKSkgOiBiYXNlO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4oXyksIHJlc2NhbGUoKSkgOiBkb21haW4oKTtcbiAgfTtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKSxcbiAgICAgICAgdSA9IGRbMF0sXG4gICAgICAgIHYgPSBkW2QubGVuZ3RoIC0gMV0sXG4gICAgICAgIHI7XG5cbiAgICBpZiAociA9IHYgPCB1KSBpID0gdSwgdSA9IHYsIHYgPSBpO1xuXG4gICAgdmFyIGkgPSBsb2dzKHUpLFxuICAgICAgICBqID0gbG9ncyh2KSxcbiAgICAgICAgcCxcbiAgICAgICAgayxcbiAgICAgICAgdCxcbiAgICAgICAgbiA9IGNvdW50ID09IG51bGwgPyAxMCA6ICtjb3VudCxcbiAgICAgICAgeiA9IFtdO1xuXG4gICAgaWYgKCEoYmFzZSAlIDEpICYmIGogLSBpIDwgbikge1xuICAgICAgaSA9IE1hdGgucm91bmQoaSkgLSAxLCBqID0gTWF0aC5yb3VuZChqKSArIDE7XG4gICAgICBpZiAodSA+IDApIGZvciAoOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IDEsIHAgPSBwb3dzKGkpOyBrIDwgYmFzZTsgKytrKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSBiYXNlIC0gMSwgcCA9IHBvd3MoaSk7IGsgPj0gMTsgLS1rKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IHRpY2tzKGksIGosIE1hdGgubWluKGogLSBpLCBuKSkubWFwKHBvd3MpO1xuICAgIH1cblxuICAgIHJldHVybiByID8gei5yZXZlcnNlKCkgOiB6O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgaWYgKHNwZWNpZmllciA9PSBudWxsKSBzcGVjaWZpZXIgPSBiYXNlID09PSAxMCA/IFwiLjBlXCIgOiBcIixcIjtcbiAgICBpZiAodHlwZW9mIHNwZWNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBzcGVjaWZpZXIgPSBleHBvcnRzLmZvcm1hdChzcGVjaWZpZXIpO1xuICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHJldHVybiBzcGVjaWZpZXI7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG4gICAgdmFyIGsgPSBNYXRoLm1heCgxLCBiYXNlICogY291bnQgLyBzY2FsZS50aWNrcygpLmxlbmd0aCk7IC8vIFRPRE8gZmFzdCBlc3RpbWF0ZT9cbiAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcbiAgICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAwLjUpIGkgKj0gYmFzZTtcbiAgICAgIHJldHVybiBpIDw9IGsgPyBzcGVjaWZpZXIoZCkgOiBcIlwiO1xuICAgIH07XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb21haW4obmljZShkb21haW4oKSwge1xuICAgICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5mbG9vcihsb2dzKHgpKSk7IH0sXG4gICAgICBjZWlsOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguY2VpbChsb2dzKHgpKSk7IH1cbiAgICB9KSk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsb2ckMSgpLmJhc2UoYmFzZSkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gcmFpc2UkMSh4LCBleHBvbmVudCkge1xuICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGV4cG9uZW50KSA6IE1hdGgucG93KHgsIGV4cG9uZW50KTtcbn1cblxuZnVuY3Rpb24gcG93JDEoKSB7XG4gIHZhciBleHBvbmVudCA9IDEsXG4gICAgICBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW47XG5cbiAgZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgcmV0dXJuIChiID0gcmFpc2UkMShiLCBleHBvbmVudCkgLSAoYSA9IHJhaXNlJDEoYSwgZXhwb25lbnQpKSlcbiAgICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiAocmFpc2UkMSh4LCBleHBvbmVudCkgLSBhKSAvIGI7IH1cbiAgICAgICAgOiBjb25zdGFudCQ5KGIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVpbnRlcnBvbGF0ZShhLCBiKSB7XG4gICAgYiA9IHJhaXNlJDEoYiwgZXhwb25lbnQpIC0gKGEgPSByYWlzZSQxKGEsIGV4cG9uZW50KSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHJhaXNlJDEoYSArIGIgKiB0LCAxIC8gZXhwb25lbnQpOyB9O1xuICB9XG5cbiAgc2NhbGUuZXhwb25lbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXhwb25lbnQgPSArXywgZG9tYWluKGRvbWFpbigpKSkgOiBleHBvbmVudDtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHBvdyQxKCkuZXhwb25lbnQoZXhwb25lbnQpKTtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gc3FydCQxKCkge1xuICByZXR1cm4gcG93JDEoKS5leHBvbmVudCgwLjUpO1xufVxuXG5mdW5jdGlvbiBxdWFudGlsZSQkMSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UkJDEgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXTtcblxuICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgIHZhciBpID0gMCwgbiA9IE1hdGgubWF4KDEsIHJhbmdlJCQxLmxlbmd0aCk7XG4gICAgdGhyZXNob2xkcyA9IG5ldyBBcnJheShuIC0gMSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRocmVzaG9sZHNbaSAtIDFdID0gdGhyZXNob2xkKGRvbWFpbiwgaSAvIG4pO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICBpZiAoIWlzTmFOKHggPSAreCkpIHJldHVybiByYW5nZSQkMVtiaXNlY3RSaWdodCh0aHJlc2hvbGRzLCB4KV07XG4gIH1cblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZSQkMS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl0gOiBbXG4gICAgICBpID4gMCA/IHRocmVzaG9sZHNbaSAtIDFdIDogZG9tYWluWzBdLFxuICAgICAgaSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1tpXSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV1cbiAgICBdO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IF8ubGVuZ3RoLCBkOyBpIDwgbjsgKytpKSBpZiAoZCA9IF9baV0sIGQgIT0gbnVsbCAmJiAhaXNOYU4oZCA9ICtkKSkgZG9tYWluLnB1c2goZCk7XG4gICAgZG9tYWluLnNvcnQoYXNjZW5kaW5nKTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlJCQxID0gc2xpY2UkNC5jYWxsKF8pLCByZXNjYWxlKCkpIDogcmFuZ2UkJDEuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkcy5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpbGUkJDEoKVxuICAgICAgICAuZG9tYWluKGRvbWFpbilcbiAgICAgICAgLnJhbmdlKHJhbmdlJCQxKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXplJDEoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBuID0gMSxcbiAgICAgIGRvbWFpbiA9IFswLjVdLFxuICAgICAgcmFuZ2UkJDEgPSBbMCwgMV07XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIGlmICh4IDw9IHgpIHJldHVybiByYW5nZSQkMVtiaXNlY3RSaWdodChkb21haW4sIHgsIDAsIG4pXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICBkb21haW4gPSBuZXcgQXJyYXkobik7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRvbWFpbltpXSA9ICgoaSArIDEpICogeDEgLSAoaSAtIG4pICogeDApIC8gKG4gKyAxKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UkJDEgPSBzbGljZSQ0LmNhbGwoXykpLmxlbmd0aCAtIDEsIHJlc2NhbGUoKSkgOiByYW5nZSQkMS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlJCQxLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXVxuICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgIDogaSA+PSBuID8gW2RvbWFpbltuIC0gMV0sIHgxXVxuICAgICAgICA6IFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUkMSgpXG4gICAgICAgIC5kb21haW4oW3gwLCB4MV0pXG4gICAgICAgIC5yYW5nZShyYW5nZSQkMSk7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIHRocmVzaG9sZCQxKCkge1xuICB2YXIgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSQkMSA9IFswLCAxXSxcbiAgICAgIG4gPSAxO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICBpZiAoeCA8PSB4KSByZXR1cm4gcmFuZ2UkJDFbYmlzZWN0UmlnaHQoZG9tYWluLCB4LCAwLCBuKV07XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gc2xpY2UkNC5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UkJDEubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlJCQxID0gc2xpY2UkNC5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UkJDEubGVuZ3RoIC0gMSksIHNjYWxlKSA6IHJhbmdlJCQxLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgIHZhciBpID0gcmFuZ2UkJDEuaW5kZXhPZih5KTtcbiAgICByZXR1cm4gW2RvbWFpbltpIC0gMV0sIGRvbWFpbltpXV07XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGQkMSgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UkJDEpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxudmFyIHQwJDEgPSBuZXcgRGF0ZTtcbnZhciB0MSQxID0gbmV3IERhdGU7XG5cbmZ1bmN0aW9uIG5ld0ludGVydmFsKGZsb29yaSwgb2Zmc2V0aSwgY291bnQsIGZpZWxkKSB7XG5cbiAgZnVuY3Rpb24gaW50ZXJ2YWwoZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gIH1cblxuICBpbnRlcnZhbC5mbG9vciA9IGludGVydmFsO1xuXG4gIGludGVydmFsLmNlaWwgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gbmV3IERhdGUoZGF0ZSAtIDEpKSwgb2Zmc2V0aShkYXRlLCAxKSwgZmxvb3JpKGRhdGUpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJvdW5kID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkMCA9IGludGVydmFsKGRhdGUpLFxuICAgICAgICBkMSA9IGludGVydmFsLmNlaWwoZGF0ZSk7XG4gICAgcmV0dXJuIGRhdGUgLSBkMCA8IGQxIC0gZGF0ZSA/IGQwIDogZDE7XG4gIH07XG5cbiAgaW50ZXJ2YWwub2Zmc2V0ID0gZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIHJldHVybiBvZmZzZXRpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSksIHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmZsb29yKHN0ZXApKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgdmFyIHJhbmdlID0gW107XG4gICAgc3RhcnQgPSBpbnRlcnZhbC5jZWlsKHN0YXJ0KTtcbiAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgZG8gcmFuZ2UucHVzaChuZXcgRGF0ZSgrc3RhcnQpKTsgd2hpbGUgKG9mZnNldGkoc3RhcnQsIHN0ZXApLCBmbG9vcmkoc3RhcnQpLCBzdGFydCA8IHN0b3ApXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIGludGVydmFsLmZpbHRlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPj0gZGF0ZSkgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgaWYgKGRhdGUgPj0gZGF0ZSkgd2hpbGUgKC0tc3RlcCA+PSAwKSB3aGlsZSAob2Zmc2V0aShkYXRlLCAxKSwgIXRlc3QoZGF0ZSkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICB9KTtcbiAgfTtcblxuICBpZiAoY291bnQpIHtcbiAgICBpbnRlcnZhbC5jb3VudCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHQwJDEuc2V0VGltZSgrc3RhcnQpLCB0MSQxLnNldFRpbWUoK2VuZCk7XG4gICAgICBmbG9vcmkodDAkMSksIGZsb29yaSh0MSQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwJDEsIHQxJDEpKTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZXZlcnkgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgICBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUoc3RlcCkgfHwgIShzdGVwID4gMCkgPyBudWxsXG4gICAgICAgICAgOiAhKHN0ZXAgPiAxKSA/IGludGVydmFsXG4gICAgICAgICAgOiBpbnRlcnZhbC5maWx0ZXIoZmllbGRcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbihkKSB7IHJldHVybiBmaWVsZChkKSAlIHN0ZXAgPT09IDA7IH1cbiAgICAgICAgICAgICAgOiBmdW5jdGlvbihkKSB7IHJldHVybiBpbnRlcnZhbC5jb3VudCgwLCBkKSAlIHN0ZXAgPT09IDA7IH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaW50ZXJ2YWw7XG59XG5cbnZhciBtaWxsaXNlY29uZCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKCkge1xuICAvLyBub29wXG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxubWlsbGlzZWNvbmQuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIGsgPSBNYXRoLmZsb29yKGspO1xuICBpZiAoIWlzRmluaXRlKGspIHx8ICEoayA+IDApKSByZXR1cm4gbnVsbDtcbiAgaWYgKCEoayA+IDEpKSByZXR1cm4gbWlsbGlzZWNvbmQ7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRUaW1lKE1hdGguZmxvb3IoZGF0ZSAvIGspICogayk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogayk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGs7XG4gIH0pO1xufTtcblxudmFyIG1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kLnJhbmdlO1xuXG52YXIgZHVyYXRpb25TZWNvbmQkMSA9IDFlMztcbnZhciBkdXJhdGlvbk1pbnV0ZSQxID0gNmU0O1xudmFyIGR1cmF0aW9uSG91ciQxID0gMzZlNTtcbnZhciBkdXJhdGlvbkRheSQxID0gODY0ZTU7XG52YXIgZHVyYXRpb25XZWVrJDEgPSA2MDQ4ZTU7XG5cbnZhciBzZWNvbmQgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBkdXJhdGlvblNlY29uZCQxKSAqIGR1cmF0aW9uU2Vjb25kJDEpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25TZWNvbmQkMSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25TZWNvbmQkMTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDU2Vjb25kcygpO1xufSk7XG5cbnZhciBzZWNvbmRzID0gc2Vjb25kLnJhbmdlO1xuXG52YXIgbWludXRlID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gZHVyYXRpb25NaW51dGUkMSkgKiBkdXJhdGlvbk1pbnV0ZSQxKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlJDEpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlJDE7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbn0pO1xuXG52YXIgbWludXRlcyA9IG1pbnV0ZS5yYW5nZTtcblxudmFyIGhvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIHZhciBvZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZSQxICUgZHVyYXRpb25Ib3VyJDE7XG4gIGlmIChvZmZzZXQgPCAwKSBvZmZzZXQgKz0gZHVyYXRpb25Ib3VyJDE7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKCgrZGF0ZSAtIG9mZnNldCkgLyBkdXJhdGlvbkhvdXIkMSkgKiBkdXJhdGlvbkhvdXIkMSArIG9mZnNldCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIkMSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyJDE7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG59KTtcblxudmFyIGhvdXJzID0gaG91ci5yYW5nZTtcblxudmFyIGRheSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQgLSAoZW5kLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpKSAqIGR1cmF0aW9uTWludXRlJDEpIC8gZHVyYXRpb25EYXkkMTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbn0pO1xuXG52YXIgZGF5cyA9IGRheS5yYW5nZTtcblxuZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUkMSkgLyBkdXJhdGlvbldlZWskMTtcbiAgfSk7XG59XG5cbnZhciBzdW5kYXkgPSB3ZWVrZGF5KDApO1xudmFyIG1vbmRheSA9IHdlZWtkYXkoMSk7XG52YXIgdHVlc2RheSA9IHdlZWtkYXkoMik7XG52YXIgd2VkbmVzZGF5ID0gd2Vla2RheSgzKTtcbnZhciB0aHVyc2RheSA9IHdlZWtkYXkoNCk7XG52YXIgZnJpZGF5ID0gd2Vla2RheSg1KTtcbnZhciBzYXR1cmRheSA9IHdlZWtkYXkoNik7XG5cbnZhciBzdW5kYXlzID0gc3VuZGF5LnJhbmdlO1xudmFyIG1vbmRheXMgPSBtb25kYXkucmFuZ2U7XG52YXIgdHVlc2RheXMgPSB0dWVzZGF5LnJhbmdlO1xudmFyIHdlZG5lc2RheXMgPSB3ZWRuZXNkYXkucmFuZ2U7XG52YXIgdGh1cnNkYXlzID0gdGh1cnNkYXkucmFuZ2U7XG52YXIgZnJpZGF5cyA9IGZyaWRheS5yYW5nZTtcbnZhciBzYXR1cmRheXMgPSBzYXR1cmRheS5yYW5nZTtcblxudmFyIG1vbnRoID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldERhdGUoMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0TW9udGgoZGF0ZS5nZXRNb250aCgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0TW9udGgoKSAtIHN0YXJ0LmdldE1vbnRoKCkgKyAoZW5kLmdldEZ1bGxZZWFyKCkgLSBzdGFydC5nZXRGdWxsWWVhcigpKSAqIDEyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xufSk7XG5cbnZhciBtb250aHMgPSBtb250aC5yYW5nZTtcblxudmFyIHllYXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxueWVhci5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuICFpc0Zpbml0ZShrID0gTWF0aC5mbG9vcihrKSkgfHwgIShrID4gMCkgPyBudWxsIDogbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyBrKSAqIGspO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCAqIGspO1xuICB9KTtcbn07XG5cbnZhciB5ZWFycyA9IHllYXIucmFuZ2U7XG5cbnZhciB1dGNNaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDU2Vjb25kcygwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlJDEpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlJDE7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01pbnV0ZXMoKTtcbn0pO1xuXG52YXIgdXRjTWludXRlcyA9IHV0Y01pbnV0ZS5yYW5nZTtcblxudmFyIHV0Y0hvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDTWludXRlcygwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91ciQxKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXIkMTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKTtcbn0pO1xuXG52YXIgdXRjSG91cnMgPSB1dGNIb3VyLnJhbmdlO1xuXG52YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkRheSQxO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENEYXRlKCkgLSAxO1xufSk7XG5cbnZhciB1dGNEYXlzID0gdXRjRGF5LnJhbmdlO1xuXG5mdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uV2VlayQxO1xuICB9KTtcbn1cblxudmFyIHV0Y1N1bmRheSA9IHV0Y1dlZWtkYXkoMCk7XG52YXIgdXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcbnZhciB1dGNUdWVzZGF5ID0gdXRjV2Vla2RheSgyKTtcbnZhciB1dGNXZWRuZXNkYXkgPSB1dGNXZWVrZGF5KDMpO1xudmFyIHV0Y1RodXJzZGF5ID0gdXRjV2Vla2RheSg0KTtcbnZhciB1dGNGcmlkYXkgPSB1dGNXZWVrZGF5KDUpO1xudmFyIHV0Y1NhdHVyZGF5ID0gdXRjV2Vla2RheSg2KTtcblxudmFyIHV0Y1N1bmRheXMgPSB1dGNTdW5kYXkucmFuZ2U7XG52YXIgdXRjTW9uZGF5cyA9IHV0Y01vbmRheS5yYW5nZTtcbnZhciB1dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXkucmFuZ2U7XG52YXIgdXRjV2VkbmVzZGF5cyA9IHV0Y1dlZG5lc2RheS5yYW5nZTtcbnZhciB1dGNUaHVyc2RheXMgPSB1dGNUaHVyc2RheS5yYW5nZTtcbnZhciB1dGNGcmlkYXlzID0gdXRjRnJpZGF5LnJhbmdlO1xudmFyIHV0Y1NhdHVyZGF5cyA9IHV0Y1NhdHVyZGF5LnJhbmdlO1xuXG52YXIgdXRjTW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDRGF0ZSgxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENNb250aChkYXRlLmdldFVUQ01vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENNb250aCgpIC0gc3RhcnQuZ2V0VVRDTW9udGgoKSArIChlbmQuZ2V0VVRDRnVsbFllYXIoKSAtIHN0YXJ0LmdldFVUQ0Z1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ01vbnRoKCk7XG59KTtcblxudmFyIHV0Y01vbnRocyA9IHV0Y01vbnRoLnJhbmdlO1xuXG52YXIgdXRjWWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG51dGNZZWFyLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSAvIGspICogayk7XG4gICAgZGF0ZS5zZXRVVENNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgKyBzdGVwICogayk7XG4gIH0pO1xufTtcblxudmFyIHV0Y1llYXJzID0gdXRjWWVhci5yYW5nZTtcblxuZnVuY3Rpb24gbG9jYWxEYXRlKGQpIHtcbiAgaWYgKDAgPD0gZC55ICYmIGQueSA8IDEwMCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoLTEsIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpO1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbn1cblxuZnVuY3Rpb24gdXRjRGF0ZShkKSB7XG4gIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcihkLnkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhkLnksIGQubSwgZC5kLCBkLkgsIGQuTSwgZC5TLCBkLkwpKTtcbn1cblxuZnVuY3Rpb24gbmV3WWVhcih5KSB7XG4gIHJldHVybiB7eTogeSwgbTogMCwgZDogMSwgSDogMCwgTTogMCwgUzogMCwgTDogMH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExvY2FsZSQxKGxvY2FsZSkge1xuICB2YXIgbG9jYWxlX2RhdGVUaW1lID0gbG9jYWxlLmRhdGVUaW1lLFxuICAgICAgbG9jYWxlX2RhdGUgPSBsb2NhbGUuZGF0ZSxcbiAgICAgIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsXG4gICAgICBsb2NhbGVfcGVyaW9kcyA9IGxvY2FsZS5wZXJpb2RzLFxuICAgICAgbG9jYWxlX3dlZWtkYXlzID0gbG9jYWxlLmRheXMsXG4gICAgICBsb2NhbGVfc2hvcnRXZWVrZGF5cyA9IGxvY2FsZS5zaG9ydERheXMsXG4gICAgICBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocyxcbiAgICAgIGxvY2FsZV9zaG9ydE1vbnRocyA9IGxvY2FsZS5zaG9ydE1vbnRocztcblxuICB2YXIgcGVyaW9kUmUgPSBmb3JtYXRSZShsb2NhbGVfcGVyaW9kcyksXG4gICAgICBwZXJpb2RMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3BlcmlvZHMpLFxuICAgICAgd2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3dlZWtkYXlzKSxcbiAgICAgIHNob3J0V2Vla2RheVJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5TG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydFdlZWtkYXlzKSxcbiAgICAgIG1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfbW9udGhzKSxcbiAgICAgIG1vbnRoTG9va3VwID0gZm9ybWF0TG9va3VwKGxvY2FsZV9tb250aHMpLFxuICAgICAgc2hvcnRNb250aFJlID0gZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSxcbiAgICAgIHNob3J0TW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0TW9udGhzKTtcblxuICB2YXIgZm9ybWF0cyA9IHtcbiAgICBcImFcIjogZm9ybWF0U2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBmb3JtYXRXZWVrZGF5LFxuICAgIFwiYlwiOiBmb3JtYXRTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBmb3JtYXRNb250aCxcbiAgICBcImNcIjogbnVsbCxcbiAgICBcImRcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcImVcIjogZm9ybWF0RGF5T2ZNb250aCxcbiAgICBcIkhcIjogZm9ybWF0SG91cjI0LFxuICAgIFwiSVwiOiBmb3JtYXRIb3VyMTIsXG4gICAgXCJqXCI6IGZvcm1hdERheU9mWWVhcixcbiAgICBcIkxcIjogZm9ybWF0TWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBmb3JtYXRNb250aE51bWJlcixcbiAgICBcIk1cIjogZm9ybWF0TWludXRlcyxcbiAgICBcInBcIjogZm9ybWF0UGVyaW9kLFxuICAgIFwiU1wiOiBmb3JtYXRTZWNvbmRzLFxuICAgIFwiVVwiOiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwid1wiOiBmb3JtYXRXZWVrZGF5TnVtYmVyLFxuICAgIFwiV1wiOiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBudWxsLFxuICAgIFwiWFwiOiBudWxsLFxuICAgIFwieVwiOiBmb3JtYXRZZWFyLFxuICAgIFwiWVwiOiBmb3JtYXRGdWxsWWVhcixcbiAgICBcIlpcIjogZm9ybWF0Wm9uZSxcbiAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICB2YXIgdXRjRm9ybWF0cyA9IHtcbiAgICBcImFcIjogZm9ybWF0VVRDU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBmb3JtYXRVVENXZWVrZGF5LFxuICAgIFwiYlwiOiBmb3JtYXRVVENTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBmb3JtYXRVVENNb250aCxcbiAgICBcImNcIjogbnVsbCxcbiAgICBcImRcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICBcImVcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICBcIkhcIjogZm9ybWF0VVRDSG91cjI0LFxuICAgIFwiSVwiOiBmb3JtYXRVVENIb3VyMTIsXG4gICAgXCJqXCI6IGZvcm1hdFVUQ0RheU9mWWVhcixcbiAgICBcIkxcIjogZm9ybWF0VVRDTWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBmb3JtYXRVVENNb250aE51bWJlcixcbiAgICBcIk1cIjogZm9ybWF0VVRDTWludXRlcyxcbiAgICBcInBcIjogZm9ybWF0VVRDUGVyaW9kLFxuICAgIFwiU1wiOiBmb3JtYXRVVENTZWNvbmRzLFxuICAgIFwiVVwiOiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwid1wiOiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyLFxuICAgIFwiV1wiOiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBudWxsLFxuICAgIFwiWFwiOiBudWxsLFxuICAgIFwieVwiOiBmb3JtYXRVVENZZWFyLFxuICAgIFwiWVwiOiBmb3JtYXRVVENGdWxsWWVhcixcbiAgICBcIlpcIjogZm9ybWF0VVRDWm9uZSxcbiAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICB2YXIgcGFyc2VzID0ge1xuICAgIFwiYVwiOiBwYXJzZVNob3J0V2Vla2RheSxcbiAgICBcIkFcIjogcGFyc2VXZWVrZGF5LFxuICAgIFwiYlwiOiBwYXJzZVNob3J0TW9udGgsXG4gICAgXCJCXCI6IHBhcnNlTW9udGgsXG4gICAgXCJjXCI6IHBhcnNlTG9jYWxlRGF0ZVRpbWUsXG4gICAgXCJkXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICBcImVcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiSFwiOiBwYXJzZUhvdXIyNCxcbiAgICBcIklcIjogcGFyc2VIb3VyMjQsXG4gICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBwYXJzZU1pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogcGFyc2VNb250aE51bWJlcixcbiAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxuICAgIFwicFwiOiBwYXJzZVBlcmlvZCxcbiAgICBcIlNcIjogcGFyc2VTZWNvbmRzLFxuICAgIFwiVVwiOiBwYXJzZVdlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJ3XCI6IHBhcnNlV2Vla2RheU51bWJlcixcbiAgICBcIldcIjogcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBwYXJzZUxvY2FsZURhdGUsXG4gICAgXCJYXCI6IHBhcnNlTG9jYWxlVGltZSxcbiAgICBcInlcIjogcGFyc2VZZWFyLFxuICAgIFwiWVwiOiBwYXJzZUZ1bGxZZWFyLFxuICAgIFwiWlwiOiBwYXJzZVpvbmUsXG4gICAgXCIlXCI6IHBhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICAvLyBUaGVzZSByZWN1cnNpdmUgZGlyZWN0aXZlIGRlZmluaXRpb25zIG11c3QgYmUgZGVmZXJyZWQuXG4gIGZvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIGZvcm1hdHMpO1xuICB1dGNGb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCB1dGNGb3JtYXRzKTtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyLCBmb3JtYXRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBbXSxcbiAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBwYWQsXG4gICAgICAgICAgZm9ybWF0O1xuXG4gICAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XG5cbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChzcGVjaWZpZXIuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgIGlmICgocGFkID0gcGFkc1tjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKTtcbiAgICAgICAgICBlbHNlIHBhZCA9IGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIjtcbiAgICAgICAgICBpZiAoZm9ybWF0ID0gZm9ybWF0c1tjXSkgYyA9IGZvcm1hdChkYXRlLCBwYWQpO1xuICAgICAgICAgIHN0cmluZy5wdXNoKGMpO1xuICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBuZXdQYXJzZShzcGVjaWZpZXIsIG5ld0RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgZCA9IG5ld1llYXIoMTkwMCksXG4gICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nICs9IFwiXCIsIDApO1xuICAgICAgaWYgKGkgIT0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIFRoZSBhbS1wbSBmbGFnIGlzIDAgZm9yIEFNLCBhbmQgMSBmb3IgUE0uXG4gICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcblxuICAgICAgLy8gQ29udmVydCBkYXktb2Ytd2VlayBhbmQgd2Vlay1vZi15ZWFyIHRvIGRheS1vZi15ZWFyLlxuICAgICAgaWYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkge1xuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gXCJXXCIgaW4gZCA/IDEgOiAwO1xuICAgICAgICB2YXIgZGF5JCQxID0gXCJaXCIgaW4gZCA/IHV0Y0RhdGUobmV3WWVhcihkLnkpKS5nZXRVVENEYXkoKSA6IG5ld0RhdGUobmV3WWVhcihkLnkpKS5nZXREYXkoKTtcbiAgICAgICAgZC5tID0gMDtcbiAgICAgICAgZC5kID0gXCJXXCIgaW4gZCA/IChkLncgKyA2KSAlIDcgKyBkLlcgKiA3IC0gKGRheSQkMSArIDUpICUgNyA6IGQudyArIGQuVSAqIDcgLSAoZGF5JCQxICsgNikgJSA3O1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhIHRpbWUgem9uZSBpcyBzcGVjaWZpZWQsIGFsbCBmaWVsZHMgYXJlIGludGVycHJldGVkIGFzIFVUQyBhbmQgdGhlblxuICAgICAgLy8gb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHRpbWUgem9uZS5cbiAgICAgIGlmIChcIlpcIiBpbiBkKSB7XG4gICAgICAgIGQuSCArPSBkLlogLyAxMDAgfCAwO1xuICAgICAgICBkLk0gKz0gZC5aICUgMTAwO1xuICAgICAgICByZXR1cm4gdXRjRGF0ZShkKTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgZmllbGRzIGFyZSBpbiBsb2NhbCB0aW1lLlxuICAgICAgcmV0dXJuIG5ld0RhdGUoZCk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nLCBqKSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBuID0gc3BlY2lmaWVyLmxlbmd0aCxcbiAgICAgICAgbSA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgIGMsXG4gICAgICAgIHBhcnNlO1xuXG4gICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICBpZiAoaiA+PSBtKSByZXR1cm4gLTE7XG4gICAgICBjID0gc3BlY2lmaWVyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgIGlmIChjID09PSAzNykge1xuICAgICAgICBjID0gc3BlY2lmaWVyLmNoYXJBdChpKyspO1xuICAgICAgICBwYXJzZSA9IHBhcnNlc1tjIGluIHBhZHMgPyBzcGVjaWZpZXIuY2hhckF0KGkrKykgOiBjXTtcbiAgICAgICAgaWYgKCFwYXJzZSB8fCAoKGogPSBwYXJzZShkLCBzdHJpbmcsIGopKSA8IDApKSByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKGMgIT0gc3RyaW5nLmNoYXJDb2RlQXQoaisrKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGo7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVBlcmlvZChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHBlcmlvZFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLnAgPSBwZXJpb2RMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTaG9ydFdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBzaG9ydFdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC53ID0gc2hvcnRXZWVrZGF5TG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC53ID0gd2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNob3J0TW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBzaG9ydE1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQubSA9IHNob3J0TW9udGhMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQubSA9IG1vbnRoTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlRGF0ZVRpbWUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlVGltZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTG9jYWxlRGF0ZShkLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gcGFyc2VTcGVjaWZpZXIoZCwgbG9jYWxlX2RhdGUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZVRpbWUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV90aW1lLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0U2hvcnRXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXREYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0U2hvcnRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldE1vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQZXJpb2QoZCkge1xuICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0SG91cnMoKSA+PSAxMildO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0V2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5KGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3dlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDU2hvcnRNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydE1vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDTW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENQZXJpb2QoZCkge1xuICAgIHJldHVybiBsb2NhbGVfcGVyaW9kc1srKGQuZ2V0VVRDSG91cnMoKSA+PSAxMildO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIGZvcm1hdHMpO1xuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgcCA9IG5ld1BhcnNlKHNwZWNpZmllciArPSBcIlwiLCBsb2NhbERhdGUpO1xuICAgICAgcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICB1dGNGb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIHV0Y0Zvcm1hdHMpO1xuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgICB1dGNQYXJzZTogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgcCA9IG5ld1BhcnNlKHNwZWNpZmllciwgdXRjRGF0ZSk7XG4gICAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH07XG59XG5cbnZhciBwYWRzID0ge1wiLVwiOiBcIlwiLCBcIl9cIjogXCIgXCIsIFwiMFwiOiBcIjBcIn07XG52YXIgbnVtYmVyUmUgPSAvXlxccypcXGQrLztcbnZhciBwZXJjZW50UmUgPSAvXiUvO1xudmFyIHJlcXVvdGVSZSA9IC9bXFxcXFxcXlxcJFxcKlxcK1xcP1xcfFxcW1xcXVxcKFxcKVxcLlxce1xcfV0vZztcblxuZnVuY3Rpb24gcGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xuICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIixcbiAgICAgIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIixcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlcXVvdGUocykge1xuICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJlKG5hbWVzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TG9va3VwKG5hbWVzKSB7XG4gIHZhciBtYXAgPSB7fSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbWFwW25hbWVzW2ldLnRvTG93ZXJDYXNlKCldID0gaTtcbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5TnVtYmVyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gKGQudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gIHJldHVybiBuID8gKGQuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gIHJldHVybiBuID8gKGQuVyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnVsbFllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDQpKTtcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQueSA9ICtuWzBdICsgKCtuWzBdID4gNjggPyAxOTAwIDogMjAwMCksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2Vab25lKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IC9eKFopfChbKy1dXFxkXFxkKSg/OlxcOj8oXFxkXFxkKSk/Ly5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLlogPSBuWzFdID8gMCA6IC0oblsyXSArIChuWzNdIHx8IFwiMDBcIikpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9udGhOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZk1vbnRoKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gIHJldHVybiBuID8gKGQubSA9IDAsIGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSG91cjI0KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWludXRlcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5TID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaWxsaXNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaXRlcmFsUGVyY2VudChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBwZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXREYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyBkYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChzdW5kYXkuY291bnQoeWVhcihkKSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyKGQpIHtcbiAgcmV0dXJuIGQuZ2V0RGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKG1vbmRheS5jb3VudCh5ZWFyKGQpLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFpvbmUoZCkge1xuICB2YXIgeiA9IGQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgcmV0dXJuICh6ID4gMCA/IFwiLVwiIDogKHogKj0gLTEsIFwiK1wiKSlcbiAgICAgICsgcGFkKHogLyA2MCB8IDAsIFwiMFwiLCAyKVxuICAgICAgKyBwYWQoeiAlIDYwLCBcIjBcIiwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0RheU9mTW9udGgoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRGF0ZSgpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDSG91cjI0KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0hvdXJzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMTIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZCgxICsgdXRjRGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTW9udGhOdW1iZXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNaW51dGVzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbnV0ZXMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1NlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDU2Vjb25kcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gIHJldHVybiBwYWQodXRjU3VuZGF5LmNvdW50KHV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlcihkKSB7XG4gIHJldHVybiBkLmdldFVUQ0RheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZCh1dGNNb25kYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENGdWxsWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwMDAsIHAsIDQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENab25lKCkge1xuICByZXR1cm4gXCIrMDAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMaXRlcmFsUGVyY2VudCgpIHtcbiAgcmV0dXJuIFwiJVwiO1xufVxuXG52YXIgbG9jYWxlJDI7XG5cblxuXG5cblxuZGVmYXVsdExvY2FsZSQxKHtcbiAgZGF0ZVRpbWU6IFwiJXgsICVYXCIsXG4gIGRhdGU6IFwiJS1tLyUtZC8lWVwiLFxuICB0aW1lOiBcIiUtSTolTTolUyAlcFwiLFxuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbn0pO1xuXG5mdW5jdGlvbiBkZWZhdWx0TG9jYWxlJDEoZGVmaW5pdGlvbikge1xuICBsb2NhbGUkMiA9IGZvcm1hdExvY2FsZSQxKGRlZmluaXRpb24pO1xuICBleHBvcnRzLnRpbWVGb3JtYXQgPSBsb2NhbGUkMi5mb3JtYXQ7XG4gIGV4cG9ydHMudGltZVBhcnNlID0gbG9jYWxlJDIucGFyc2U7XG4gIGV4cG9ydHMudXRjRm9ybWF0ID0gbG9jYWxlJDIudXRjRm9ybWF0O1xuICBleHBvcnRzLnV0Y1BhcnNlID0gbG9jYWxlJDIudXRjUGFyc2U7XG4gIHJldHVybiBsb2NhbGUkMjtcbn1cblxudmFyIGlzb1NwZWNpZmllciA9IFwiJVktJW0tJWRUJUg6JU06JVMuJUxaXCI7XG5cbmZ1bmN0aW9uIGZvcm1hdElzb05hdGl2ZShkYXRlKSB7XG4gIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG59XG5cbnZhciBmb3JtYXRJc28gPSBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZ1xuICAgID8gZm9ybWF0SXNvTmF0aXZlXG4gICAgOiBleHBvcnRzLnV0Y0Zvcm1hdChpc29TcGVjaWZpZXIpO1xuXG5mdW5jdGlvbiBwYXJzZUlzb05hdGl2ZShzdHJpbmcpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcpO1xuICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBudWxsIDogZGF0ZTtcbn1cblxudmFyIHBhcnNlSXNvID0gK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpXG4gICAgPyBwYXJzZUlzb05hdGl2ZVxuICAgIDogZXhwb3J0cy51dGNQYXJzZShpc29TcGVjaWZpZXIpO1xuXG52YXIgZHVyYXRpb25TZWNvbmQgPSAxMDAwO1xudmFyIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MDtcbnZhciBkdXJhdGlvbkhvdXIgPSBkdXJhdGlvbk1pbnV0ZSAqIDYwO1xudmFyIGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQ7XG52YXIgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3O1xudmFyIGR1cmF0aW9uTW9udGggPSBkdXJhdGlvbkRheSAqIDMwO1xudmFyIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuXG5mdW5jdGlvbiBkYXRlJDEodCkge1xuICByZXR1cm4gbmV3IERhdGUodCk7XG59XG5cbmZ1bmN0aW9uIG51bWJlciQyKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBEYXRlID8gK3QgOiArbmV3IERhdGUoK3QpO1xufVxuXG5mdW5jdGlvbiBjYWxlbmRhcih5ZWFyJCQxLCBtb250aCQkMSwgd2VlaywgZGF5JCQxLCBob3VyJCQxLCBtaW51dGUkJDEsIHNlY29uZCQkMSwgbWlsbGlzZWNvbmQkJDEsIGZvcm1hdCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGVMaW5lYXIsIHJlaW50ZXJwb2xhdGUpLFxuICAgICAgaW52ZXJ0ID0gc2NhbGUuaW52ZXJ0LFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIHZhciBmb3JtYXRNaWxsaXNlY29uZCA9IGZvcm1hdChcIi4lTFwiKSxcbiAgICAgIGZvcm1hdFNlY29uZCA9IGZvcm1hdChcIjolU1wiKSxcbiAgICAgIGZvcm1hdE1pbnV0ZSA9IGZvcm1hdChcIiVJOiVNXCIpLFxuICAgICAgZm9ybWF0SG91ciA9IGZvcm1hdChcIiVJICVwXCIpLFxuICAgICAgZm9ybWF0RGF5ID0gZm9ybWF0KFwiJWEgJWRcIiksXG4gICAgICBmb3JtYXRXZWVrID0gZm9ybWF0KFwiJWIgJWRcIiksXG4gICAgICBmb3JtYXRNb250aCA9IGZvcm1hdChcIiVCXCIpLFxuICAgICAgZm9ybWF0WWVhciA9IGZvcm1hdChcIiVZXCIpO1xuXG4gIHZhciB0aWNrSW50ZXJ2YWxzID0gW1xuICAgIFtzZWNvbmQkJDEsICAxLCAgICAgIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kJCQxLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCQkMSwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQkJDEsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbbWludXRlJCQxLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSQkMSwgIDUsICA1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUkJDEsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlJCQxLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgWyAgaG91ciQkMSwgIDEsICAgICAgZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIkJDEsICAzLCAgMyAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyJCQxLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciQkMSwgMTIsIDEyICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgICBkYXkkJDEsICAxLCAgICAgIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICAgZGF5JCQxLCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgd2VlaywgIDEsICAgICAgZHVyYXRpb25XZWVrICBdLFxuICAgIFsgbW9udGgkJDEsICAxLCAgICAgIGR1cmF0aW9uTW9udGggXSxcbiAgICBbIG1vbnRoJCQxLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyAgeWVhciQkMSwgIDEsICAgICAgZHVyYXRpb25ZZWFyICBdXG4gIF07XG5cbiAgZnVuY3Rpb24gdGlja0Zvcm1hdChkYXRlKSB7XG4gICAgcmV0dXJuIChzZWNvbmQkJDEoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWlsbGlzZWNvbmRcbiAgICAgICAgOiBtaW51dGUkJDEoZGF0ZSkgPCBkYXRlID8gZm9ybWF0U2Vjb25kXG4gICAgICAgIDogaG91ciQkMShkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaW51dGVcbiAgICAgICAgOiBkYXkkJDEoZGF0ZSkgPCBkYXRlID8gZm9ybWF0SG91clxuICAgICAgICA6IG1vbnRoJCQxKGRhdGUpIDwgZGF0ZSA/ICh3ZWVrKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdERheSA6IGZvcm1hdFdlZWspXG4gICAgICAgIDogeWVhciQkMShkYXRlKSA8IGRhdGUgPyBmb3JtYXRNb250aFxuICAgICAgICA6IGZvcm1hdFllYXIpKGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGlja0ludGVydmFsKGludGVydmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKSBpbnRlcnZhbCA9IDEwO1xuXG4gICAgLy8gSWYgYSBkZXNpcmVkIHRpY2sgY291bnQgaXMgc3BlY2lmaWVkLCBwaWNrIGEgcmVhc29uYWJsZSB0aWNrIGludGVydmFsXG4gICAgLy8gYmFzZWQgb24gdGhlIGV4dGVudCBvZiB0aGUgZG9tYWluIGFuZCBhIHJvdWdoIGVzdGltYXRlIG9mIHRpY2sgc2l6ZS5cbiAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpbnRlcnZhbCBpcyBhbHJlYWR5IGEgdGltZSBpbnRlcnZhbCBhbmQgdXNlIGl0LlxuICAgIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gaW50ZXJ2YWwsXG4gICAgICAgICAgaSA9IGJpc2VjdG9yKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGlbMl07IH0pLnJpZ2h0KHRpY2tJbnRlcnZhbHMsIHRhcmdldCk7XG4gICAgICBpZiAoaSA9PT0gdGlja0ludGVydmFscy5sZW5ndGgpIHtcbiAgICAgICAgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0IC8gZHVyYXRpb25ZZWFyLCBzdG9wIC8gZHVyYXRpb25ZZWFyLCBpbnRlcnZhbCk7XG4gICAgICAgIGludGVydmFsID0geWVhciQkMTtcbiAgICAgIH0gZWxzZSBpZiAoaSkge1xuICAgICAgICBpID0gdGlja0ludGVydmFsc1t0YXJnZXQgLyB0aWNrSW50ZXJ2YWxzW2kgLSAxXVsyXSA8IHRpY2tJbnRlcnZhbHNbaV1bMl0gLyB0YXJnZXQgPyBpIC0gMSA6IGldO1xuICAgICAgICBzdGVwID0gaVsxXTtcbiAgICAgICAgaW50ZXJ2YWwgPSBpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcCA9IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBpbnRlcnZhbCk7XG4gICAgICAgIGludGVydmFsID0gbWlsbGlzZWNvbmQkJDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ZXAgPT0gbnVsbCA/IGludGVydmFsIDogaW50ZXJ2YWwuZXZlcnkoc3RlcCk7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGludmVydCh5KSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZG9tYWluKG1hcCQzLmNhbGwoXywgbnVtYmVyJDIpKSA6IGRvbWFpbigpLm1hcChkYXRlJDEpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICB0MCA9IGRbMF0sXG4gICAgICAgIHQxID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByID0gdDEgPCB0MCxcbiAgICAgICAgdDtcbiAgICBpZiAocikgdCA9IHQwLCB0MCA9IHQxLCB0MSA9IHQ7XG4gICAgdCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgdDAsIHQxLCBzdGVwKTtcbiAgICB0ID0gdCA/IHQucmFuZ2UodDAsIHQxICsgMSkgOiBbXTsgLy8gaW5jbHVzaXZlIHN0b3BcbiAgICByZXR1cm4gciA/IHQucmV2ZXJzZSgpIDogdDtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IHRpY2tGb3JtYXQgOiBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiAoaW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgc3RlcCkpXG4gICAgICAgID8gZG9tYWluKG5pY2UoZCwgaW50ZXJ2YWwpKVxuICAgICAgICA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgY2FsZW5kYXIoeWVhciQkMSwgbW9udGgkJDEsIHdlZWssIGRheSQkMSwgaG91ciQkMSwgbWludXRlJCQxLCBzZWNvbmQkJDEsIG1pbGxpc2Vjb25kJCQxLCBmb3JtYXQpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbnZhciB0aW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjYWxlbmRhcih5ZWFyLCBtb250aCwgc3VuZGF5LCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZCwgZXhwb3J0cy50aW1lRm9ybWF0KS5kb21haW4oW25ldyBEYXRlKDIwMDAsIDAsIDEpLCBuZXcgRGF0ZSgyMDAwLCAwLCAyKV0pO1xufTtcblxudmFyIHV0Y1RpbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGNhbGVuZGFyKHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNTdW5kYXksIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBleHBvcnRzLnV0Y0Zvcm1hdCkuZG9tYWluKFtEYXRlLlVUQygyMDAwLCAwLCAxKSwgRGF0ZS5VVEMoMjAwMCwgMCwgMildKTtcbn07XG5cbnZhciBjb2xvcnMgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzLm1hdGNoKC8uezZ9L2cpLm1hcChmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIFwiI1wiICsgeDtcbiAgfSk7XG59O1xuXG52YXIgY2F0ZWdvcnkxMCA9IGNvbG9ycyhcIjFmNzdiNGZmN2YwZTJjYTAyY2Q2MjcyODk0NjdiZDhjNTY0YmUzNzdjMjdmN2Y3ZmJjYmQyMjE3YmVjZlwiKTtcblxudmFyIGNhdGVnb3J5MjBiID0gY29sb3JzKFwiMzkzYjc5NTI1NGEzNmI2ZWNmOWM5ZWRlNjM3OTM5OGNhMjUyYjVjZjZiY2VkYjljOGM2ZDMxYmQ5ZTM5ZTdiYTUyZTdjYjk0ODQzYzM5YWQ0OTRhZDY2MTZiZTc5NjljN2I0MTczYTU1MTk0Y2U2ZGJkZGU5ZWQ2XCIpO1xuXG52YXIgY2F0ZWdvcnkyMGMgPSBjb2xvcnMoXCIzMTgyYmQ2YmFlZDY5ZWNhZTFjNmRiZWZlNjU1MGRmZDhkM2NmZGFlNmJmZGQwYTIzMWEzNTQ3NGM0NzZhMWQ5OWJjN2U5YzA3NTZiYjE5ZTlhYzhiY2JkZGNkYWRhZWI2MzYzNjM5Njk2OTZiZGJkYmRkOWQ5ZDlcIik7XG5cbnZhciBjYXRlZ29yeTIwID0gY29sb3JzKFwiMWY3N2I0YWVjN2U4ZmY3ZjBlZmZiYjc4MmNhMDJjOThkZjhhZDYyNzI4ZmY5ODk2OTQ2N2JkYzViMGQ1OGM1NjRiYzQ5Yzk0ZTM3N2MyZjdiNmQyN2Y3ZjdmYzdjN2M3YmNiZDIyZGJkYjhkMTdiZWNmOWVkYWU1XCIpO1xuXG52YXIgY3ViZWhlbGl4JDMgPSBjdWJlaGVsaXhMb25nKGN1YmVoZWxpeCgzMDAsIDAuNSwgMC4wKSwgY3ViZWhlbGl4KC0yNDAsIDAuNSwgMS4wKSk7XG5cbnZhciB3YXJtID0gY3ViZWhlbGl4TG9uZyhjdWJlaGVsaXgoLTEwMCwgMC43NSwgMC4zNSksIGN1YmVoZWxpeCg4MCwgMS41MCwgMC44KSk7XG5cbnZhciBjb29sID0gY3ViZWhlbGl4TG9uZyhjdWJlaGVsaXgoMjYwLCAwLjc1LCAwLjM1KSwgY3ViZWhlbGl4KDgwLCAxLjUwLCAwLjgpKTtcblxudmFyIHJhaW5ib3cgPSBjdWJlaGVsaXgoKTtcblxudmFyIHJhaW5ib3ckMSA9IGZ1bmN0aW9uKHQpIHtcbiAgaWYgKHQgPCAwIHx8IHQgPiAxKSB0IC09IE1hdGguZmxvb3IodCk7XG4gIHZhciB0cyA9IE1hdGguYWJzKHQgLSAwLjUpO1xuICByYWluYm93LmggPSAzNjAgKiB0IC0gMTAwO1xuICByYWluYm93LnMgPSAxLjUgLSAxLjUgKiB0cztcbiAgcmFpbmJvdy5sID0gMC44IC0gMC45ICogdHM7XG4gIHJldHVybiByYWluYm93ICsgXCJcIjtcbn07XG5cbmZ1bmN0aW9uIHJhbXAocmFuZ2UpIHtcbiAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgfTtcbn1cblxudmFyIHZpcmlkaXMgPSByYW1wKGNvbG9ycyhcIjQ0MDE1NDQ0MDI1NjQ1MDQ1NzQ1MDU1OTQ2MDc1YTQ2MDg1YzQ2MGE1ZDQ2MGI1ZTQ3MGQ2MDQ3MGU2MTQ3MTA2MzQ3MTE2NDQ3MTM2NTQ4MTQ2NzQ4MTY2ODQ4MTc2OTQ4MTg2YTQ4MWE2YzQ4MWI2ZDQ4MWM2ZTQ4MWQ2ZjQ4MWY3MDQ4MjA3MTQ4MjE3MzQ4MjM3NDQ4MjQ3NTQ4MjU3NjQ4MjY3NzQ4Mjg3ODQ4Mjk3OTQ3MmE3YTQ3MmM3YTQ3MmQ3YjQ3MmU3YzQ3MmY3ZDQ2MzA3ZTQ2MzI3ZTQ2MzM3ZjQ2MzQ4MDQ1MzU4MTQ1Mzc4MTQ1Mzg4MjQ0Mzk4MzQ0M2E4MzQ0M2I4NDQzM2Q4NDQzM2U4NTQyM2Y4NTQyNDA4NjQyNDE4NjQxNDI4NzQxNDQ4NzQwNDU4ODQwNDY4ODNmNDc4ODNmNDg4OTNlNDk4OTNlNGE4OTNlNGM4YTNkNGQ4YTNkNGU4YTNjNGY4YTNjNTA4YjNiNTE4YjNiNTI4YjNhNTM4YjNhNTQ4YzM5NTU4YzM5NTY4YzM4NTg4YzM4NTk4YzM3NWE4YzM3NWI4ZDM2NWM4ZDM2NWQ4ZDM1NWU4ZDM1NWY4ZDM0NjA4ZDM0NjE4ZDMzNjI4ZDMzNjM4ZDMyNjQ4ZTMyNjU4ZTMxNjY4ZTMxNjc4ZTMxNjg4ZTMwNjk4ZTMwNmE4ZTJmNmI4ZTJmNmM4ZTJlNmQ4ZTJlNmU4ZTJlNmY4ZTJkNzA4ZTJkNzE4ZTJjNzE4ZTJjNzI4ZTJjNzM4ZTJiNzQ4ZTJiNzU4ZTJhNzY4ZTJhNzc4ZTJhNzg4ZTI5Nzk4ZTI5N2E4ZTI5N2I4ZTI4N2M4ZTI4N2Q4ZTI3N2U4ZTI3N2Y4ZTI3ODA4ZTI2ODE4ZTI2ODI4ZTI2ODI4ZTI1ODM4ZTI1ODQ4ZTI1ODU4ZTI0ODY4ZTI0ODc4ZTIzODg4ZTIzODk4ZTIzOGE4ZDIyOGI4ZDIyOGM4ZDIyOGQ4ZDIxOGU4ZDIxOGY4ZDIxOTA4ZDIxOTE4YzIwOTI4YzIwOTI4YzIwOTM4YzFmOTQ4YzFmOTU4YjFmOTY4YjFmOTc4YjFmOTg4YjFmOTk4YTFmOWE4YTFlOWI4YTFlOWM4OTFlOWQ4OTFmOWU4OTFmOWY4ODFmYTA4ODFmYTE4ODFmYTE4NzFmYTI4NzIwYTM4NjIwYTQ4NjIxYTU4NTIxYTY4NTIyYTc4NTIyYTg4NDIzYTk4MzI0YWE4MzI1YWI4MjI1YWM4MjI2YWQ4MTI3YWQ4MTI4YWU4MDI5YWY3ZjJhYjA3ZjJjYjE3ZTJkYjI3ZDJlYjM3YzJmYjQ3YzMxYjU3YjMyYjY3YTM0YjY3OTM1Yjc3OTM3Yjg3ODM4Yjk3NzNhYmE3NjNiYmI3NTNkYmM3NDNmYmM3MzQwYmQ3MjQyYmU3MTQ0YmY3MDQ2YzA2ZjQ4YzE2ZTRhYzE2ZDRjYzI2YzRlYzM2YjUwYzQ2YTUyYzU2OTU0YzU2ODU2YzY2NzU4Yzc2NTVhYzg2NDVjYzg2MzVlYzk2MjYwY2E2MDYzY2I1ZjY1Y2I1ZTY3Y2M1YzY5Y2Q1YjZjY2Q1YTZlY2U1ODcwY2Y1NzczZDA1Njc1ZDA1NDc3ZDE1MzdhZDE1MTdjZDI1MDdmZDM0ZTgxZDM0ZDg0ZDQ0Yjg2ZDU0OTg5ZDU0ODhiZDY0NjhlZDY0NTkwZDc0MzkzZDc0MTk1ZDg0MDk4ZDgzZTliZDkzYzlkZDkzYmEwZGEzOWEyZGEzN2E1ZGIzNmE4ZGIzNGFhZGMzMmFkZGMzMGIwZGQyZmIyZGQyZGI1ZGUyYmI4ZGUyOWJhZGUyOGJkZGYyNmMwZGYyNWMyZGYyM2M1ZTAyMWM4ZTAyMGNhZTExZmNkZTExZGQwZTExY2QyZTIxYmQ1ZTIxYWQ4ZTIxOWRhZTMxOWRkZTMxOGRmZTMxOGUyZTQxOGU1ZTQxOWU3ZTQxOWVhZTUxYWVjZTUxYmVmZTUxY2YxZTUxZGY0ZTYxZWY2ZTYyMGY4ZTYyMWZiZTcyM2ZkZTcyNVwiKSk7XG5cbnZhciBtYWdtYSA9IHJhbXAoY29sb3JzKFwiMDAwMDA0MDEwMDA1MDEwMTA2MDEwMTA4MDIwMTA5MDIwMjBiMDIwMjBkMDMwMzBmMDMwMzEyMDQwNDE0MDUwNDE2MDYwNTE4MDYwNTFhMDcwNjFjMDgwNzFlMDkwNzIwMGEwODIyMGIwOTI0MGMwOTI2MGQwYTI5MGUwYjJiMTAwYjJkMTEwYzJmMTIwZDMxMTMwZDM0MTQwZTM2MTUwZTM4MTYwZjNiMTgwZjNkMTkxMDNmMWExMDQyMWMxMDQ0MWQxMTQ3MWUxMTQ5MjAxMTRiMjExMTRlMjIxMTUwMjQxMjUzMjUxMjU1MjcxMjU4MjkxMTVhMmExMTVjMmMxMTVmMmQxMTYxMmYxMTYzMzExMTY1MzMxMDY3MzQxMDY5MzYxMDZiMzgxMDZjMzkwZjZlM2IwZjcwM2QwZjcxM2YwZjcyNDAwZjc0NDIwZjc1NDQwZjc2NDUxMDc3NDcxMDc4NDkxMDc4NGExMDc5NGMxMTdhNGUxMTdiNGYxMjdiNTExMjdjNTIxMzdjNTQxMzdkNTYxNDdkNTcxNTdlNTkxNTdlNWExNjdlNWMxNjdmNWQxNzdmNWYxODdmNjAxODgwNjIxOTgwNjQxYTgwNjUxYTgwNjcxYjgwNjgxYzgxNmExYzgxNmIxZDgxNmQxZDgxNmUxZTgxNzAxZjgxNzIxZjgxNzMyMDgxNzUyMTgxNzYyMTgxNzgyMjgxNzkyMjgyN2IyMzgyN2MyMzgyN2UyNDgyODAyNTgyODEyNTgxODMyNjgxODQyNjgxODYyNzgxODgyNzgxODkyODgxOGIyOTgxOGMyOTgxOGUyYTgxOTAyYTgxOTEyYjgxOTMyYjgwOTQyYzgwOTYyYzgwOTgyZDgwOTkyZDgwOWIyZTdmOWMyZTdmOWUyZjdmYTAyZjdmYTEzMDdlYTMzMDdlYTUzMTdlYTYzMTdkYTgzMjdkYWEzMzdkYWIzMzdjYWQzNDdjYWUzNDdiYjAzNTdiYjIzNTdiYjMzNjdhYjUzNjdhYjczNzc5YjgzNzc5YmEzODc4YmMzOTc4YmQzOTc3YmYzYTc3YzAzYTc2YzIzYjc1YzQzYzc1YzUzYzc0YzczZDczYzgzZTczY2EzZTcyY2MzZjcxY2Q0MDcxY2Y0MDcwZDA0MTZmZDI0MjZmZDM0MzZlZDU0NDZkZDY0NTZjZDg0NTZjZDk0NjZiZGI0NzZhZGM0ODY5ZGU0OTY4ZGY0YTY4ZTA0YzY3ZTI0ZDY2ZTM0ZTY1ZTQ0ZjY0ZTU1MDY0ZTc1MjYzZTg1MzYyZTk1NDYyZWE1NjYxZWI1NzYwZWM1ODYwZWQ1YTVmZWU1YjVlZWY1ZDVlZjA1ZjVlZjE2MDVkZjI2MjVkZjI2NDVjZjM2NTVjZjQ2NzVjZjQ2OTVjZjU2YjVjZjY2YzVjZjY2ZTVjZjc3MDVjZjc3MjVjZjg3NDVjZjg3NjVjZjk3ODVkZjk3OTVkZjk3YjVkZmE3ZDVlZmE3ZjVlZmE4MTVmZmI4MzVmZmI4NTYwZmI4NzYxZmM4OTYxZmM4YTYyZmM4YzYzZmM4ZTY0ZmM5MDY1ZmQ5MjY2ZmQ5NDY3ZmQ5NjY4ZmQ5ODY5ZmQ5YTZhZmQ5YjZiZmU5ZDZjZmU5ZjZkZmVhMTZlZmVhMzZmZmVhNTcxZmVhNzcyZmVhOTczZmVhYTc0ZmVhYzc2ZmVhZTc3ZmViMDc4ZmViMjdhZmViNDdiZmViNjdjZmViNzdlZmViOTdmZmViYjgxZmViZDgyZmViZjg0ZmVjMTg1ZmVjMjg3ZmVjNDg4ZmVjNjhhZmVjODhjZmVjYThkZmVjYzhmZmVjZDkwZmVjZjkyZmVkMTk0ZmVkMzk1ZmVkNTk3ZmVkNzk5ZmVkODlhZmRkYTljZmRkYzllZmRkZWEwZmRlMGExZmRlMmEzZmRlM2E1ZmRlNWE3ZmRlN2E5ZmRlOWFhZmRlYmFjZmNlY2FlZmNlZWIwZmNmMGIyZmNmMmI0ZmNmNGI2ZmNmNmI4ZmNmN2I5ZmNmOWJiZmNmYmJkZmNmZGJmXCIpKTtcblxudmFyIGluZmVybm8gPSByYW1wKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwYTAyMDIwYzAyMDIwZTAzMDIxMDA0MDMxMjA0MDMxNDA1MDQxNzA2MDQxOTA3MDUxYjA4MDUxZDA5MDYxZjBhMDcyMjBiMDcyNDBjMDgyNjBkMDgyOTBlMDkyYjEwMDkyZDExMGEzMDEyMGEzMjE0MGIzNDE1MGIzNzE2MGIzOTE4MGMzYzE5MGMzZTFiMGM0MTFjMGM0MzFlMGM0NTFmMGM0ODIxMGM0YTIzMGM0YzI0MGM0ZjI2MGM1MTI4MGI1MzI5MGI1NTJiMGI1NzJkMGI1OTJmMGE1YjMxMGE1YzMyMGE1ZTM0MGE1ZjM2MDk2MTM4MDk2MjM5MDk2MzNiMDk2NDNkMDk2NTNlMDk2NjQwMGE2NzQyMGE2ODQ0MGE2ODQ1MGE2OTQ3MGI2YTQ5MGI2YTRhMGM2YjRjMGM2YjRkMGQ2YzRmMGQ2YzUxMGU2YzUyMGU2ZDU0MGY2ZDU1MGY2ZDU3MTA2ZTU5MTA2ZTVhMTE2ZTVjMTI2ZTVkMTI2ZTVmMTM2ZTYxMTM2ZTYyMTQ2ZTY0MTU2ZTY1MTU2ZTY3MTY2ZTY5MTY2ZTZhMTc2ZTZjMTg2ZTZkMTg2ZTZmMTk2ZTcxMTk2ZTcyMWE2ZTc0MWE2ZTc1MWI2ZTc3MWM2ZDc4MWM2ZDdhMWQ2ZDdjMWQ2ZDdkMWU2ZDdmMWU2YzgwMWY2YzgyMjA2Yzg0MjA2Yjg1MjE2Yjg3MjE2Yjg4MjI2YThhMjI2YThjMjM2OThkMjM2OThmMjQ2OTkwMjU2ODkyMjU2ODkzMjY2Nzk1MjY2Nzk3Mjc2Njk4Mjc2NjlhMjg2NTliMjk2NDlkMjk2NDlmMmE2M2EwMmE2M2EyMmI2MmEzMmM2MWE1MmM2MGE2MmQ2MGE4MmU1ZmE5MmU1ZWFiMmY1ZWFkMzA1ZGFlMzA1Y2IwMzE1YmIxMzI1YWIzMzI1YWI0MzM1OWI2MzQ1OGI3MzU1N2I5MzU1NmJhMzY1NWJjMzc1NGJkMzg1M2JmMzk1MmMwM2E1MWMxM2E1MGMzM2I0ZmM0M2M0ZWM2M2Q0ZGM3M2U0Y2M4M2Y0YmNhNDA0YWNiNDE0OWNjNDI0OGNlNDM0N2NmNDQ0NmQwNDU0NWQyNDY0NGQzNDc0M2Q0NDg0MmQ1NGE0MWQ3NGIzZmQ4NGMzZWQ5NGQzZGRhNGUzY2RiNTAzYmRkNTEzYWRlNTIzOGRmNTMzN2UwNTUzNmUxNTYzNWUyNTczNGUzNTkzM2U0NWEzMWU1NWMzMGU2NWQyZmU3NWUyZWU4NjAyZGU5NjEyYmVhNjMyYWViNjQyOWViNjYyOGVjNjcyNmVkNjkyNWVlNmEyNGVmNmMyM2VmNmUyMWYwNmYyMGYxNzExZmYxNzMxZGYyNzQxY2YzNzYxYmYzNzgxOWY0NzkxOGY1N2IxN2Y1N2QxNWY2N2UxNGY2ODAxM2Y3ODIxMmY3ODQxMGY4ODUwZmY4ODcwZWY4ODkwY2Y5OGIwYmY5OGMwYWY5OGUwOWZhOTAwOGZhOTIwN2ZhOTQwN2ZiOTYwNmZiOTcwNmZiOTkwNmZiOWIwNmZiOWQwN2ZjOWYwN2ZjYTEwOGZjYTMwOWZjYTUwYWZjYTYwY2ZjYTgwZGZjYWEwZmZjYWMxMWZjYWUxMmZjYjAxNGZjYjIxNmZjYjQxOGZiYjYxYWZiYjgxZGZiYmExZmZiYmMyMWZiYmUyM2ZhYzAyNmZhYzIyOGZhYzQyYWZhYzYyZGY5YzcyZmY5YzkzMmY5Y2IzNWY4Y2QzN2Y4Y2YzYWY3ZDEzZGY3ZDM0MGY2ZDU0M2Y2ZDc0NmY1ZDk0OWY1ZGI0Y2Y0ZGQ0ZmY0ZGY1M2Y0ZTE1NmYzZTM1YWYzZTU1ZGYyZTY2MWYyZTg2NWYyZWE2OWYxZWM2ZGYxZWQ3MWYxZWY3NWYxZjE3OWYyZjI3ZGYyZjQ4MmYzZjU4NmYzZjY4YWY0Zjg4ZWY1Zjk5MmY2ZmE5NmY4ZmI5YWY5ZmM5ZGZhZmRhMWZjZmZhNFwiKSk7XG5cbnZhciBwbGFzbWEgPSByYW1wKGNvbG9ycyhcIjBkMDg4NzEwMDc4ODEzMDc4OTE2MDc4YTE5MDY4YzFiMDY4ZDFkMDY4ZTIwMDY4ZjIyMDY5MDI0MDY5MTI2MDU5MTI4MDU5MjJhMDU5MzJjMDU5NDJlMDU5NTJmMDU5NjMxMDU5NzMzMDU5NzM1MDQ5ODM3MDQ5OTM4MDQ5YTNhMDQ5YTNjMDQ5YjNlMDQ5YzNmMDQ5YzQxMDQ5ZDQzMDM5ZTQ0MDM5ZTQ2MDM5ZjQ4MDM5ZjQ5MDNhMDRiMDNhMTRjMDJhMTRlMDJhMjUwMDJhMjUxMDJhMzUzMDJhMzU1MDJhNDU2MDFhNDU4MDFhNDU5MDFhNTViMDFhNTVjMDFhNjVlMDFhNjYwMDFhNjYxMDBhNzYzMDBhNzY0MDBhNzY2MDBhNzY3MDBhODY5MDBhODZhMDBhODZjMDBhODZlMDBhODZmMDBhODcxMDBhODcyMDFhODc0MDFhODc1MDFhODc3MDFhODc4MDFhODdhMDJhODdiMDJhODdkMDNhODdlMDNhODgwMDRhODgxMDRhNzgzMDVhNzg0MDVhNzg2MDZhNjg3MDdhNjg4MDhhNjhhMDlhNThiMGFhNThkMGJhNThlMGNhNDhmMGRhNDkxMGVhMzkyMGZhMzk0MTBhMjk1MTFhMTk2MTNhMTk4MTRhMDk5MTU5ZjlhMTY5ZjljMTc5ZTlkMTg5ZDllMTk5ZGEwMWE5Y2ExMWI5YmEyMWQ5YWEzMWU5YWE1MWY5OWE2MjA5OGE3MjE5N2E4MjI5NmFhMjM5NWFiMjQ5NGFjMjY5NGFkMjc5M2FlMjg5MmIwMjk5MWIxMmE5MGIyMmI4ZmIzMmM4ZWI0MmU4ZGI1MmY4Y2I2MzA4YmI3MzE4YWI4MzI4OWJhMzM4OGJiMzQ4OGJjMzU4N2JkMzc4NmJlMzg4NWJmMzk4NGMwM2E4M2MxM2I4MmMyM2M4MWMzM2Q4MGM0M2U3ZmM1NDA3ZWM2NDE3ZGM3NDI3Y2M4NDM3YmM5NDQ3YWNhNDU3YWNiNDY3OWNjNDc3OGNjNDk3N2NkNGE3NmNlNGI3NWNmNGM3NGQwNGQ3M2QxNGU3MmQyNGY3MWQzNTE3MWQ0NTI3MGQ1NTM2ZmQ1NTQ2ZWQ2NTU2ZGQ3NTY2Y2Q4NTc2YmQ5NTg2YWRhNWE2YWRhNWI2OWRiNWM2OGRjNWQ2N2RkNWU2NmRlNWY2NWRlNjE2NGRmNjI2M2UwNjM2M2UxNjQ2MmUyNjU2MWUyNjY2MGUzNjg1ZmU0Njk1ZWU1NmE1ZGU1NmI1ZGU2NmM1Y2U3NmU1YmU3NmY1YWU4NzA1OWU5NzE1OGU5NzI1N2VhNzQ1N2ViNzU1NmViNzY1NWVjNzc1NGVkNzk1M2VkN2E1MmVlN2I1MWVmN2M1MWVmN2U1MGYwN2Y0ZmYwODA0ZWYxODE0ZGYxODM0Y2YyODQ0YmYzODU0YmYzODc0YWY0ODg0OWY0ODk0OGY1OGI0N2Y1OGM0NmY2OGQ0NWY2OGY0NGY3OTA0NGY3OTE0M2Y3OTM0MmY4OTQ0MWY4OTU0MGY5OTczZmY5OTgzZWY5OWEzZWZhOWIzZGZhOWMzY2ZhOWUzYmZiOWYzYWZiYTEzOWZiYTIzOGZjYTMzOGZjYTUzN2ZjYTYzNmZjYTgzNWZjYTkzNGZkYWIzM2ZkYWMzM2ZkYWUzMmZkYWYzMWZkYjEzMGZkYjIyZmZkYjQyZmZkYjUyZWZlYjcyZGZlYjgyY2ZlYmEyY2ZlYmIyYmZlYmQyYWZlYmUyYWZlYzAyOWZkYzIyOWZkYzMyOGZkYzUyN2ZkYzYyN2ZkYzgyN2ZkY2EyNmZkY2IyNmZjY2QyNWZjY2UyNWZjZDAyNWZjZDIyNWZiZDMyNGZiZDUyNGZiZDcyNGZhZDgyNGZhZGEyNGY5ZGMyNGY5ZGQyNWY4ZGYyNWY4ZTEyNWY3ZTIyNWY3ZTQyNWY2ZTYyNmY2ZTgyNmY1ZTkyNmY1ZWIyN2Y0ZWQyN2YzZWUyN2YzZjAyN2YyZjIyN2YxZjQyNmYxZjUyNWYwZjcyNGYwZjkyMVwiKSk7XG5cbmZ1bmN0aW9uIHNlcXVlbnRpYWwoaW50ZXJwb2xhdG9yKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB4MSA9IDEsXG4gICAgICBjbGFtcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICB2YXIgdCA9ICh4IC0geDApIC8gKHgxIC0geDApO1xuICAgIHJldHVybiBpbnRlcnBvbGF0b3IoY2xhbXAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0KSkgOiB0KTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9ICtfWzBdLCB4MSA9ICtfWzFdLCBzY2FsZSkgOiBbeDAsIHgxXTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9ICEhXywgc2NhbGUpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGludGVycG9sYXRvciA9IF8sIHNjYWxlKSA6IGludGVycG9sYXRvcjtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNlcXVlbnRpYWwoaW50ZXJwb2xhdG9yKS5kb21haW4oW3gwLCB4MV0pLmNsYW1wKGNsYW1wKTtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxudmFyIGNvbnN0YW50JDEwID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24gY29uc3RhbnQoKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuXG52YXIgYWJzJDEgPSBNYXRoLmFicztcbnZhciBhdGFuMiQxID0gTWF0aC5hdGFuMjtcbnZhciBjb3MkMiA9IE1hdGguY29zO1xudmFyIG1heCQyID0gTWF0aC5tYXg7XG52YXIgbWluJDEgPSBNYXRoLm1pbjtcbnZhciBzaW4kMiA9IE1hdGguc2luO1xudmFyIHNxcnQkMiA9IE1hdGguc3FydDtcblxudmFyIGVwc2lsb24kMyA9IDFlLTEyO1xudmFyIHBpJDQgPSBNYXRoLlBJO1xudmFyIGhhbGZQaSQzID0gcGkkNCAvIDI7XG52YXIgdGF1JDQgPSAyICogcGkkNDtcblxuZnVuY3Rpb24gYWNvcyQxKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpJDQgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmZ1bmN0aW9uIGFzaW4kMSh4KSB7XG4gIHJldHVybiB4ID49IDEgPyBoYWxmUGkkMyA6IHggPD0gLTEgPyAtaGFsZlBpJDMgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmZ1bmN0aW9uIGFyY0lubmVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY091dGVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY1N0YXJ0QW5nbGUoZCkge1xuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNFbmRBbmdsZShkKSB7XG4gIHJldHVybiBkLmVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNQYWRBbmdsZShkKSB7XG4gIHJldHVybiBkICYmIGQucGFkQW5nbGU7IC8vIE5vdGU6IG9wdGlvbmFsIVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciB4MTAgPSB4MSAtIHgwLCB5MTAgPSB5MSAtIHkwLFxuICAgICAgeDMyID0geDMgLSB4MiwgeTMyID0geTMgLSB5MixcbiAgICAgIHQgPSAoeDMyICogKHkwIC0geTIpIC0geTMyICogKHgwIC0geDIpKSAvICh5MzIgKiB4MTAgLSB4MzIgKiB5MTApO1xuICByZXR1cm4gW3gwICsgdCAqIHgxMCwgeTAgKyB0ICogeTEwXTtcbn1cblxuLy8gQ29tcHV0ZSBwZXJwZW5kaWN1bGFyIG9mZnNldCBsaW5lIG9mIGxlbmd0aCByYy5cbi8vIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vQ2lyY2xlLUxpbmVJbnRlcnNlY3Rpb24uaHRtbFxuZnVuY3Rpb24gY29ybmVyVGFuZ2VudHMoeDAsIHkwLCB4MSwgeTEsIHIxLCByYywgY3cpIHtcbiAgdmFyIHgwMSA9IHgwIC0geDEsXG4gICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBzcXJ0JDIoeDAxICogeDAxICsgeTAxICogeTAxKSxcbiAgICAgIG94ID0gbG8gKiB5MDEsXG4gICAgICBveSA9IC1sbyAqIHgwMSxcbiAgICAgIHgxMSA9IHgwICsgb3gsXG4gICAgICB5MTEgPSB5MCArIG95LFxuICAgICAgeDEwID0geDEgKyBveCxcbiAgICAgIHkxMCA9IHkxICsgb3ksXG4gICAgICB4MDAgPSAoeDExICsgeDEwKSAvIDIsXG4gICAgICB5MDAgPSAoeTExICsgeTEwKSAvIDIsXG4gICAgICBkeCA9IHgxMCAtIHgxMSxcbiAgICAgIGR5ID0geTEwIC0geTExLFxuICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSxcbiAgICAgIHIgPSByMSAtIHJjLFxuICAgICAgRCA9IHgxMSAqIHkxMCAtIHgxMCAqIHkxMSxcbiAgICAgIGQgPSAoZHkgPCAwID8gLTEgOiAxKSAqIHNxcnQkMihtYXgkMigwLCByICogciAqIGQyIC0gRCAqIEQpKSxcbiAgICAgIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTAgPSAoLUQgKiBkeCAtIGR5ICogZCkgLyBkMixcbiAgICAgIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMixcbiAgICAgIGR4MCA9IGN4MCAtIHgwMCxcbiAgICAgIGR5MCA9IGN5MCAtIHkwMCxcbiAgICAgIGR4MSA9IGN4MSAtIHgwMCxcbiAgICAgIGR5MSA9IGN5MSAtIHkwMDtcblxuICAvLyBQaWNrIHRoZSBjbG9zZXIgb2YgdGhlIHR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAvLyBUT0RPIElzIHRoZXJlIGEgZmFzdGVyIHdheSB0byBkZXRlcm1pbmUgd2hpY2ggaW50ZXJzZWN0aW9uIHRvIHVzZT9cbiAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG5cbiAgcmV0dXJuIHtcbiAgICBjeDogY3gwLFxuICAgIGN5OiBjeTAsXG4gICAgeDAxOiAtb3gsXG4gICAgeTAxOiAtb3ksXG4gICAgeDExOiBjeDAgKiAocjEgLyByIC0gMSksXG4gICAgeTExOiBjeTAgKiAocjEgLyByIC0gMSlcbiAgfTtcbn1cblxudmFyIGFyYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5uZXJSYWRpdXMgPSBhcmNJbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzID0gYXJjT3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb25zdGFudCQxMCgwKSxcbiAgICAgIHBhZFJhZGl1cyA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gYXJjU3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gYXJjRW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IGFyY1BhZEFuZ2xlLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJjKCkge1xuICAgIHZhciBidWZmZXIsXG4gICAgICAgIHIsXG4gICAgICAgIHIwID0gK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIxID0gK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpJDMsXG4gICAgICAgIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSQzLFxuICAgICAgICBkYSA9IGFicyQxKGExIC0gYTApLFxuICAgICAgICBjdyA9IGExID4gYTA7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3V0ZXIgcmFkaXVzIGlzIGFsd2F5cyBsYXJnZXIgdGhhbiB0aGUgaW5uZXIgcmFkaXVzLlxuICAgIGlmIChyMSA8IHIwKSByID0gcjEsIHIxID0gcjAsIHIwID0gcjtcblxuICAgIC8vIElzIGl0IGEgcG9pbnQ/XG4gICAgaWYgKCEocjEgPiBlcHNpbG9uJDMpKSBjb250ZXh0Lm1vdmVUbygwLCAwKTtcblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY2xlIG9yIGFubnVsdXM/XG4gICAgZWxzZSBpZiAoZGEgPiB0YXUkNCAtIGVwc2lsb24kMykge1xuICAgICAgY29udGV4dC5tb3ZlVG8ocjEgKiBjb3MkMihhMCksIHIxICogc2luJDIoYTApKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMCwgYTEsICFjdyk7XG4gICAgICBpZiAocjAgPiBlcHNpbG9uJDMpIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocjAgKiBjb3MkMihhMSksIHIwICogc2luJDIoYTEpKTtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExLCBhMCwgY3cpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY3VsYXIgb3IgYW5udWxhciBzZWN0b3I/XG4gICAgZWxzZSB7XG4gICAgICB2YXIgYTAxID0gYTAsXG4gICAgICAgICAgYTExID0gYTEsXG4gICAgICAgICAgYTAwID0gYTAsXG4gICAgICAgICAgYTEwID0gYTEsXG4gICAgICAgICAgZGEwID0gZGEsXG4gICAgICAgICAgZGExID0gZGEsXG4gICAgICAgICAgYXAgPSBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC8gMixcbiAgICAgICAgICBycCA9IChhcCA+IGVwc2lsb24kMykgJiYgKHBhZFJhZGl1cyA/ICtwYWRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHNxcnQkMihyMCAqIHIwICsgcjEgKiByMSkpLFxuICAgICAgICAgIHJjID0gbWluJDEoYWJzJDEocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLFxuICAgICAgICAgIHJjMCA9IHJjLFxuICAgICAgICAgIHJjMSA9IHJjLFxuICAgICAgICAgIHQwLFxuICAgICAgICAgIHQxO1xuXG4gICAgICAvLyBBcHBseSBwYWRkaW5nPyBOb3RlIHRoYXQgc2luY2UgcjEg4omlIHIwLCBkYTEg4omlIGRhMC5cbiAgICAgIGlmIChycCA+IGVwc2lsb24kMykge1xuICAgICAgICB2YXIgcDAgPSBhc2luJDEocnAgLyByMCAqIHNpbiQyKGFwKSksXG4gICAgICAgICAgICBwMSA9IGFzaW4kMShycCAvIHIxICogc2luJDIoYXApKTtcbiAgICAgICAgaWYgKChkYTAgLT0gcDAgKiAyKSA+IGVwc2lsb24kMykgcDAgKj0gKGN3ID8gMSA6IC0xKSwgYTAwICs9IHAwLCBhMTAgLT0gcDA7XG4gICAgICAgIGVsc2UgZGEwID0gMCwgYTAwID0gYTEwID0gKGEwICsgYTEpIC8gMjtcbiAgICAgICAgaWYgKChkYTEgLT0gcDEgKiAyKSA+IGVwc2lsb24kMykgcDEgKj0gKGN3ID8gMSA6IC0xKSwgYTAxICs9IHAxLCBhMTEgLT0gcDE7XG4gICAgICAgIGVsc2UgZGExID0gMCwgYTAxID0gYTExID0gKGEwICsgYTEpIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHgwMSA9IHIxICogY29zJDIoYTAxKSxcbiAgICAgICAgICB5MDEgPSByMSAqIHNpbiQyKGEwMSksXG4gICAgICAgICAgeDEwID0gcjAgKiBjb3MkMihhMTApLFxuICAgICAgICAgIHkxMCA9IHIwICogc2luJDIoYTEwKTtcblxuICAgICAgLy8gQXBwbHkgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgaWYgKHJjID4gZXBzaWxvbiQzKSB7XG4gICAgICAgIHZhciB4MTEgPSByMSAqIGNvcyQyKGExMSksXG4gICAgICAgICAgICB5MTEgPSByMSAqIHNpbiQyKGExMSksXG4gICAgICAgICAgICB4MDAgPSByMCAqIGNvcyQyKGEwMCksXG4gICAgICAgICAgICB5MDAgPSByMCAqIHNpbiQyKGEwMCk7XG5cbiAgICAgICAgLy8gUmVzdHJpY3QgdGhlIGNvcm5lciByYWRpdXMgYWNjb3JkaW5nIHRvIHRoZSBzZWN0b3IgYW5nbGUuXG4gICAgICAgIGlmIChkYSA8IHBpJDQpIHtcbiAgICAgICAgICB2YXIgb2MgPSBkYTAgPiBlcHNpbG9uJDMgPyBpbnRlcnNlY3QoeDAxLCB5MDEsIHgwMCwgeTAwLCB4MTEsIHkxMSwgeDEwLCB5MTApIDogW3gxMCwgeTEwXSxcbiAgICAgICAgICAgICAgYXggPSB4MDEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYXkgPSB5MDEgLSBvY1sxXSxcbiAgICAgICAgICAgICAgYnggPSB4MTEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYnkgPSB5MTEgLSBvY1sxXSxcbiAgICAgICAgICAgICAga2MgPSAxIC8gc2luJDIoYWNvcyQxKChheCAqIGJ4ICsgYXkgKiBieSkgLyAoc3FydCQyKGF4ICogYXggKyBheSAqIGF5KSAqIHNxcnQkMihieCAqIGJ4ICsgYnkgKiBieSkpKSAvIDIpLFxuICAgICAgICAgICAgICBsYyA9IHNxcnQkMihvY1swXSAqIG9jWzBdICsgb2NbMV0gKiBvY1sxXSk7XG4gICAgICAgICAgcmMwID0gbWluJDEocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKTtcbiAgICAgICAgICByYzEgPSBtaW4kMShyYywgKHIxIC0gbGMpIC8gKGtjICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElzIHRoZSBzZWN0b3IgY29sbGFwc2VkIHRvIGEgbGluZT9cbiAgICAgIGlmICghKGRhMSA+IGVwc2lsb24kMykpIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBvdXRlciByaW5nIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMxID4gZXBzaWxvbiQzKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMSA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIkMSh0MC55MDEsIHQwLngwMSksIGF0YW4yJDEodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIkMSh0MC55MDEsIHQwLngwMSksIGF0YW4yJDEodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhdGFuMiQxKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yJDEodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMSwgYXRhbjIkMSh0MS55MTEsIHQxLngxMSksIGF0YW4yJDEodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpO1xuXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgLy8gT3IgcGVyaGFwcyBpdOKAmXMgYW4gYW5udWxhciBzZWN0b3IgY29sbGFwc2VkIGR1ZSB0byBwYWRkaW5nP1xuICAgICAgaWYgKCEocjAgPiBlcHNpbG9uJDMpIHx8ICEoZGEwID4gZXBzaWxvbiQzKSkgY29udGV4dC5saW5lVG8oeDEwLCB5MTApO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIGlubmVyIHJpbmcgKG9yIHBvaW50KSBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGVsc2UgaWYgKHJjMCA+IGVwc2lsb24kMykge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIkMSh0MC55MDEsIHQwLngwMSksIGF0YW4yJDEodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIkMSh0MC55MDEsIHQwLngwMSksIGF0YW4yJDEodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhdGFuMiQxKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yJDEodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBhdGFuMiQxKHQxLnkxMSwgdDEueDExKSwgYXRhbjIkMSh0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIGlubmVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExMCwgYTAwLCBjdyk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSAoK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyLFxuICAgICAgICBhID0gKCtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKyArZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgLyAyIC0gcGkkNCAvIDI7XG4gICAgcmV0dXJuIFtjb3MkMihhKSAqIHIsIHNpbiQyKGEpICogcl07XG4gIH07XG5cbiAgYXJjLmlubmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlubmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCgrXyksIGFyYykgOiBpbm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3V0ZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDEwKCtfKSwgYXJjKSA6IG91dGVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29ybmVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCgrXyksIGFyYykgOiBjb3JuZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnBhZFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRSYWRpdXMgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCgrXyksIGFyYykgOiBwYWRSYWRpdXM7XG4gIH07XG5cbiAgYXJjLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoK18pLCBhcmMpIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICBhcmMuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDEwKCtfKSwgYXJjKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5wYWRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoK18pLCBhcmMpIDogcGFkQW5nbGU7XG4gIH07XG5cbiAgYXJjLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIGFyYykgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmM7XG59O1xuXG5mdW5jdGlvbiBMaW5lYXIoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG52YXIgY3VydmVMaW5lYXIgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyKGNvbnRleHQpO1xufTtcblxuZnVuY3Rpb24geCQzKHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmZ1bmN0aW9uIHkkMyhwKSB7XG4gIHJldHVybiBwWzFdO1xufVxuXG52YXIgbGluZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCQkMSA9IHgkMyxcbiAgICAgIHkkJDEgPSB5JDMsXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQkMTAodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgZWxzZSBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSBvdXRwdXQucG9pbnQoK3gkJDEoZCwgaSwgZGF0YSksICt5JCQxKGQsIGksIGRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgbGluZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDEwKCtfKSwgbGluZSkgOiB4JCQxO1xuICB9O1xuXG4gIGxpbmUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCgrXyksIGxpbmUpIDogeSQkMTtcbiAgfTtcblxuICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoISFfKSwgbGluZSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGxpbmUuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgbGluZSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBsaW5lLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGxpbmUpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gbGluZTtcbn07XG5cbnZhciBhcmVhJDIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHgwID0geCQzLFxuICAgICAgeDEgPSBudWxsLFxuICAgICAgeTAgPSBjb25zdGFudCQxMCgwKSxcbiAgICAgIHkxID0geSQzLFxuICAgICAgZGVmaW5lZCA9IGNvbnN0YW50JDEwKHRydWUpLFxuICAgICAgY29udGV4dCA9IG51bGwsXG4gICAgICBjdXJ2ZSA9IGN1cnZlTGluZWFyLFxuICAgICAgb3V0cHV0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBhcmVhKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXIsXG4gICAgICAgIHgweiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgeTB6ID0gbmV3IEFycmF5KG4pO1xuXG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgb3V0cHV0ID0gY3VydmUoYnVmZmVyID0gcGF0aCgpKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkge1xuICAgICAgICAgIGogPSBpO1xuICAgICAgICAgIG91dHB1dC5hcmVhU3RhcnQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChrID0gaSAtIDE7IGsgPj0gajsgLS1rKSB7XG4gICAgICAgICAgICBvdXRwdXQucG9pbnQoeDB6W2tdLCB5MHpba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5hcmVhRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkge1xuICAgICAgICB4MHpbaV0gPSAreDAoZCwgaSwgZGF0YSksIHkweltpXSA9ICt5MChkLCBpLCBkYXRhKTtcbiAgICAgICAgb3V0cHV0LnBvaW50KHgxID8gK3gxKGQsIGksIGRhdGEpIDogeDB6W2ldLCB5MSA/ICt5MShkLCBpLCBkYXRhKSA6IHkweltpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWFsaW5lKCkge1xuICAgIHJldHVybiBsaW5lKCkuZGVmaW5lZChkZWZpbmVkKS5jdXJ2ZShjdXJ2ZSkuY29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGFyZWEueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoK18pLCB4MSA9IG51bGwsIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoK18pLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCgrXyksIGFyZWEpIDogeDE7XG4gIH07XG5cbiAgYXJlYS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCgrXyksIHkxID0gbnVsbCwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCgrXyksIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDEwKCtfKSwgYXJlYSkgOiB5MTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMCA9XG4gIGFyZWEubGluZVkwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5saW5lWTEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkxKTtcbiAgfTtcblxuICBhcmVhLmxpbmVYMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDEpLnkoeTApO1xuICB9O1xuXG4gIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCghIV8pLCBhcmVhKSA6IGRlZmluZWQ7XG4gIH07XG5cbiAgYXJlYS5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBhcmVhKSA6IGN1cnZlO1xuICB9O1xuXG4gIGFyZWEuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChfID09IG51bGwgPyBjb250ZXh0ID0gb3V0cHV0ID0gbnVsbCA6IG91dHB1dCA9IGN1cnZlKGNvbnRleHQgPSBfKSwgYXJlYSkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBhcmVhO1xufTtcblxudmFyIGRlc2NlbmRpbmckMSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufTtcblxudmFyIGlkZW50aXR5JDcgPSBmdW5jdGlvbihkKSB7XG4gIHJldHVybiBkO1xufTtcblxudmFyIHBpZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSBpZGVudGl0eSQ3LFxuICAgICAgc29ydFZhbHVlcyA9IGRlc2NlbmRpbmckMSxcbiAgICAgIHNvcnQgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGNvbnN0YW50JDEwKDApLFxuICAgICAgZW5kQW5nbGUgPSBjb25zdGFudCQxMCh0YXUkNCksXG4gICAgICBwYWRBbmdsZSA9IGNvbnN0YW50JDEwKDApO1xuXG4gIGZ1bmN0aW9uIHBpZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgc3VtID0gMCxcbiAgICAgICAgaW5kZXggPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGFyY3MgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIGEwID0gK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgZGEgPSBNYXRoLm1pbih0YXUkNCwgTWF0aC5tYXgoLXRhdSQ0LCBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gYTApKSxcbiAgICAgICAgYTEsXG4gICAgICAgIHAgPSBNYXRoLm1pbihNYXRoLmFicyhkYSkgLyBuLCBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgcGEgPSBwICogKGRhIDwgMCA/IC0xIDogMSksXG4gICAgICAgIHY7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHYgPSBhcmNzW2luZGV4W2ldID0gaV0gPSArdmFsdWUoZGF0YVtpXSwgaSwgZGF0YSkpID4gMCkge1xuICAgICAgICBzdW0gKz0gdjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcHRpb25hbGx5IHNvcnQgdGhlIGFyY3MgYnkgcHJldmlvdXNseS1jb21wdXRlZCB2YWx1ZXMgb3IgYnkgZGF0YS5cbiAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKSBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIHNvcnRWYWx1ZXMoYXJjc1tpXSwgYXJjc1tqXSk7IH0pO1xuICAgIGVsc2UgaWYgKHNvcnQgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0KGRhdGFbaV0sIGRhdGFbal0pOyB9KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGFyY3MhIFRoZXkgYXJlIHN0b3JlZCBpbiB0aGUgb3JpZ2luYWwgZGF0YSdzIG9yZGVyLlxuICAgIGZvciAoaSA9IDAsIGsgPSBzdW0gPyAoZGEgLSBuICogcGEpIC8gc3VtIDogMDsgaSA8IG47ICsraSwgYTAgPSBhMSkge1xuICAgICAgaiA9IGluZGV4W2ldLCB2ID0gYXJjc1tqXSwgYTEgPSBhMCArICh2ID4gMCA/IHYgKiBrIDogMCkgKyBwYSwgYXJjc1tqXSA9IHtcbiAgICAgICAgZGF0YTogZGF0YVtqXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiB2LFxuICAgICAgICBzdGFydEFuZ2xlOiBhMCxcbiAgICAgICAgZW5kQW5nbGU6IGExLFxuICAgICAgICBwYWRBbmdsZTogcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJjcztcbiAgfVxuXG4gIHBpZS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoK18pLCBwaWUpIDogdmFsdWU7XG4gIH07XG5cbiAgcGllLnNvcnRWYWx1ZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydFZhbHVlcyA9IF8sIHNvcnQgPSBudWxsLCBwaWUpIDogc29ydFZhbHVlcztcbiAgfTtcblxuICBwaWUuc29ydCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0ID0gXywgc29ydFZhbHVlcyA9IG51bGwsIHBpZSkgOiBzb3J0O1xuICB9O1xuXG4gIHBpZS5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDEwKCtfKSwgcGllKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgcGllLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCgrXyksIHBpZSkgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBwaWUucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDEwKCtfKSwgcGllKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIHJldHVybiBwaWU7XG59O1xuXG52YXIgY3VydmVSYWRpYWxMaW5lYXIgPSBjdXJ2ZVJhZGlhbChjdXJ2ZUxpbmVhcik7XG5cbmZ1bmN0aW9uIFJhZGlhbChjdXJ2ZSkge1xuICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xufVxuXG5SYWRpYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFTdGFydCgpO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5hcmVhRW5kKCk7XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmxpbmVFbmQoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB0aGlzLl9jdXJ2ZS5wb2ludChyICogTWF0aC5zaW4oYSksIHIgKiAtTWF0aC5jb3MoYSkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjdXJ2ZVJhZGlhbChjdXJ2ZSkge1xuXG4gIGZ1bmN0aW9uIHJhZGlhbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBSYWRpYWwoY3VydmUoY29udGV4dCkpO1xuICB9XG5cbiAgcmFkaWFsLl9jdXJ2ZSA9IGN1cnZlO1xuXG4gIHJldHVybiByYWRpYWw7XG59XG5cbmZ1bmN0aW9uIHJhZGlhbExpbmUobCkge1xuICB2YXIgYyA9IGwuY3VydmU7XG5cbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG5cbiAgbC5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gbDtcbn1cblxudmFyIHJhZGlhbExpbmUkMSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcmFkaWFsTGluZShsaW5lKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpKTtcbn07XG5cbnZhciByYWRpYWxBcmVhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhID0gYXJlYSQyKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpLFxuICAgICAgYyA9IGEuY3VydmUsXG4gICAgICB4MCA9IGEubGluZVgwLFxuICAgICAgeDEgPSBhLmxpbmVYMSxcbiAgICAgIHkwID0gYS5saW5lWTAsXG4gICAgICB5MSA9IGEubGluZVkxO1xuXG4gIGEuYW5nbGUgPSBhLngsIGRlbGV0ZSBhLng7XG4gIGEuc3RhcnRBbmdsZSA9IGEueDAsIGRlbGV0ZSBhLngwO1xuICBhLmVuZEFuZ2xlID0gYS54MSwgZGVsZXRlIGEueDE7XG4gIGEucmFkaXVzID0gYS55LCBkZWxldGUgYS55O1xuICBhLmlubmVyUmFkaXVzID0gYS55MCwgZGVsZXRlIGEueTA7XG4gIGEub3V0ZXJSYWRpdXMgPSBhLnkxLCBkZWxldGUgYS55MTtcbiAgYS5saW5lU3RhcnRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFkaWFsTGluZSh4MCgpKTsgfSwgZGVsZXRlIGEubGluZVgwO1xuICBhLmxpbmVFbmRBbmdsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFkaWFsTGluZSh4MSgpKTsgfSwgZGVsZXRlIGEubGluZVgxO1xuICBhLmxpbmVJbm5lclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFkaWFsTGluZSh5MCgpKTsgfSwgZGVsZXRlIGEubGluZVkwO1xuICBhLmxpbmVPdXRlclJhZGl1cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmFkaWFsTGluZSh5MSgpKTsgfSwgZGVsZXRlIGEubGluZVkxO1xuXG4gIGEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XG4gIH07XG5cbiAgcmV0dXJuIGE7XG59O1xuXG52YXIgc2xpY2UkNSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxudmFyIHJhZGlhbFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gWyh5ID0gK3kpICogTWF0aC5jb3MoeCAtPSBNYXRoLlBJIC8gMiksIHkgKiBNYXRoLnNpbih4KV07XG59O1xuXG5mdW5jdGlvbiBsaW5rU291cmNlKGQpIHtcbiAgcmV0dXJuIGQuc291cmNlO1xufVxuXG5mdW5jdGlvbiBsaW5rVGFyZ2V0KGQpIHtcbiAgcmV0dXJuIGQudGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBsaW5rJDIoY3VydmUpIHtcbiAgdmFyIHNvdXJjZSA9IGxpbmtTb3VyY2UsXG4gICAgICB0YXJnZXQgPSBsaW5rVGFyZ2V0LFxuICAgICAgeCQkMSA9IHgkMyxcbiAgICAgIHkkJDEgPSB5JDMsXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBsaW5rKCkge1xuICAgIHZhciBidWZmZXIsIGFyZ3YgPSBzbGljZSQ1LmNhbGwoYXJndW1lbnRzKSwgcyA9IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd2KSwgdCA9IHRhcmdldC5hcHBseSh0aGlzLCBhcmd2KTtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG4gICAgY3VydmUoY29udGV4dCwgK3gkJDEuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSBzLCBhcmd2KSksICt5JCQxLmFwcGx5KHRoaXMsIGFyZ3YpLCAreCQkMS5hcHBseSh0aGlzLCAoYXJndlswXSA9IHQsIGFyZ3YpKSwgK3kkJDEuYXBwbHkodGhpcywgYXJndikpO1xuICAgIGlmIChidWZmZXIpIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgbGluay5zb3VyY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc291cmNlID0gXywgbGluaykgOiBzb3VyY2U7XG4gIH07XG5cbiAgbGluay50YXJnZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFyZ2V0ID0gXywgbGluaykgOiB0YXJnZXQ7XG4gIH07XG5cbiAgbGluay54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDEwKCtfKSwgbGluaykgOiB4JCQxO1xuICB9O1xuXG4gIGxpbmsueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMCgrXyksIGxpbmspIDogeSQkMTtcbiAgfTtcblxuICBsaW5rLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIGxpbmspIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gY3VydmVIb3Jpem9udGFsKGNvbnRleHQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCA9ICh4MCArIHgxKSAvIDIsIHkwLCB4MCwgeTEsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlVmVydGljYWwoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgwLCB5MCA9ICh5MCArIHkxKSAvIDIsIHgxLCB5MCwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gY3VydmVSYWRpYWwkMShjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgcDAgPSByYWRpYWxQb2ludCh4MCwgeTApLFxuICAgICAgcDEgPSByYWRpYWxQb2ludCh4MCwgeTAgPSAoeTAgKyB5MSkgLyAyKSxcbiAgICAgIHAyID0gcmFkaWFsUG9pbnQoeDEsIHkwKSxcbiAgICAgIHAzID0gcmFkaWFsUG9pbnQoeDEsIHkxKTtcbiAgY29udGV4dC5tb3ZlVG8ocDBbMF0sIHAwWzFdKTtcbiAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHAxWzBdLCBwMVsxXSwgcDJbMF0sIHAyWzFdLCBwM1swXSwgcDNbMV0pO1xufVxuXG5mdW5jdGlvbiBsaW5rSG9yaXpvbnRhbCgpIHtcbiAgcmV0dXJuIGxpbmskMihjdXJ2ZUhvcml6b250YWwpO1xufVxuXG5mdW5jdGlvbiBsaW5rVmVydGljYWwoKSB7XG4gIHJldHVybiBsaW5rJDIoY3VydmVWZXJ0aWNhbCk7XG59XG5cbmZ1bmN0aW9uIGxpbmtSYWRpYWwoKSB7XG4gIHZhciBsID0gbGluayQyKGN1cnZlUmFkaWFsJDEpO1xuICBsLmFuZ2xlID0gbC54LCBkZWxldGUgbC54O1xuICBsLnJhZGl1cyA9IGwueSwgZGVsZXRlIGwueTtcbiAgcmV0dXJuIGw7XG59XG5cbnZhciBjaXJjbGUkMiA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBwaSQ0KTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUkNCk7XG4gIH1cbn07XG5cbnZhciBjcm9zcyQyID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICBjb250ZXh0Lm1vdmVUbygtMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtMyAqIHIsIHIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbnZhciB0YW4zMCA9IE1hdGguc3FydCgxIC8gMyk7XG52YXIgdGFuMzBfMiA9IHRhbjMwICogMjtcblxudmFyIGRpYW1vbmQgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgeSA9IE1hdGguc3FydChzaXplIC8gdGFuMzBfMiksXG4gICAgICAgIHggPSB5ICogdGFuMzA7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXkpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIDApO1xuICAgIGNvbnRleHQubGluZVRvKDAsIHkpO1xuICAgIGNvbnRleHQubGluZVRvKC14LCAwKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuXG52YXIga2EgPSAwLjg5MDgxMzA5MTUyOTI4NTIyODEwO1xudmFyIGtyID0gTWF0aC5zaW4ocGkkNCAvIDEwKSAvIE1hdGguc2luKDcgKiBwaSQ0IC8gMTApO1xudmFyIGt4ID0gTWF0aC5zaW4odGF1JDQgLyAxMCkgKiBrcjtcbnZhciBreSA9IC1NYXRoLmNvcyh0YXUkNCAvIDEwKSAqIGtyO1xuXG52YXIgc3RhciA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXG4gICAgICAgIHggPSBreCAqIHIsXG4gICAgICAgIHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgYSA9IHRhdSQ0ICogaSAvIDUsXG4gICAgICAgICAgYyA9IE1hdGguY29zKGEpLFxuICAgICAgICAgIHMgPSBNYXRoLnNpbihhKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMgKiByLCAtYyAqIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8oYyAqIHggLSBzICogeSwgcyAqIHggKyBjICogeSk7XG4gICAgfVxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbnZhciBzcXVhcmUgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgdyA9IE1hdGguc3FydChzaXplKSxcbiAgICAgICAgeCA9IC13IC8gMjtcbiAgICBjb250ZXh0LnJlY3QoeCwgeCwgdywgdyk7XG4gIH1cbn07XG5cbnZhciBzcXJ0MyA9IE1hdGguc3FydCgzKTtcblxudmFyIHRyaWFuZ2xlID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSAtTWF0aC5zcXJ0KHNpemUgLyAoc3FydDMgKiAzKSk7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgeSAqIDIpO1xuICAgIGNvbnRleHQubGluZVRvKC1zcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyhzcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuXG52YXIgYyA9IC0wLjU7XG52YXIgcyA9IE1hdGguc3FydCgzKSAvIDI7XG52YXIgayA9IDEgLyBNYXRoLnNxcnQoMTIpO1xudmFyIGEgPSAoayAvIDIgKyAxKSAqIDM7XG5cbnZhciB3eWUgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gYSksXG4gICAgICAgIHgwID0gciAvIDIsXG4gICAgICAgIHkwID0gciAqIGssXG4gICAgICAgIHgxID0geDAsXG4gICAgICAgIHkxID0gciAqIGsgKyByLFxuICAgICAgICB4MiA9IC14MSxcbiAgICAgICAgeTIgPSB5MTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgLSBzICogeTAsIHMgKiB4MCArIGMgKiB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxIC0gcyAqIHkxLCBzICogeDEgKyBjICogeTEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiAtIHMgKiB5MiwgcyAqIHgyICsgYyAqIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgKyBzICogeTAsIGMgKiB5MCAtIHMgKiB4MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxICsgcyAqIHkxLCBjICogeTEgLSBzICogeDEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiArIHMgKiB5MiwgYyAqIHkyIC0gcyAqIHgyKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuXG52YXIgc3ltYm9scyA9IFtcbiAgY2lyY2xlJDIsXG4gIGNyb3NzJDIsXG4gIGRpYW1vbmQsXG4gIHNxdWFyZSxcbiAgc3RhcixcbiAgdHJpYW5nbGUsXG4gIHd5ZVxuXTtcblxudmFyIHN5bWJvbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGNvbnN0YW50JDEwKGNpcmNsZSQyKSxcbiAgICAgIHNpemUgPSBjb25zdGFudCQxMCg2NCksXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBzeW1ib2woKSB7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoKCk7XG4gICAgdHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmRyYXcoY29udGV4dCwgK3NpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0eXBlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMChfKSwgc3ltYm9sKSA6IHR5cGU7XG4gIH07XG5cbiAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2l6ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoK18pLCBzeW1ib2wpIDogc2l6ZTtcbiAgfTtcblxuICBzeW1ib2wuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8sIHN5bWJvbCkgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgbm9vcCQyID0gZnVuY3Rpb24oKSB7fTtcblxuZnVuY3Rpb24gcG9pbnQkMih0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICAoMiAqIHRoYXQuX3gwICsgdGhhdC5feDEpIC8gMyxcbiAgICAoMiAqIHRoYXQuX3kwICsgdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyAyICogdGhhdC5feDEpIC8gMyxcbiAgICAodGhhdC5feTAgKyAyICogdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyA0ICogdGhhdC5feDEgKyB4KSAvIDYsXG4gICAgKHRoYXQuX3kwICsgNCAqIHRoYXQuX3kxICsgeSkgLyA2XG4gICk7XG59XG5cbmZ1bmN0aW9uIEJhc2lzKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAzOiBwb2ludCQyKHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IC8vIHByb2NlZWRcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9jb250ZXh0LmxpbmVUbygoNSAqIHRoaXMuX3gwICsgdGhpcy5feDEpIC8gNiwgKDUgKiB0aGlzLl95MCArIHRoaXMuX3kxKSAvIDYpOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQyKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxudmFyIGJhc2lzJDIgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXMoY29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBCYXNpc0Nsb3NlZChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpc0Nsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCQyLFxuICBhcmVhRW5kOiBub29wJDIsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDIgKyAyICogdGhpcy5feDMpIC8gMywgKHRoaXMuX3kyICsgMiAqIHRoaXMuX3kzKSAvIDMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbygodGhpcy5feDMgKyAyICogdGhpcy5feDIpIC8gMywgKHRoaXMuX3kzICsgMiAqIHRoaXMuX3kyKSAvIDMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gyID0geCwgdGhpcy5feTIgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHk7IHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIHgpIC8gNiwgKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgeSkgLyA2KTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCQyKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxudmFyIGJhc2lzQ2xvc2VkJDEgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNDbG9zZWQoY29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBCYXNpc09wZW4oY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdmFyIHgwID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCB5MCA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNjsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgwLCB5MCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4MCwgeTApOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQyKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxudmFyIGJhc2lzT3BlbiA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc09wZW4oY29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBCdW5kbGUoY29udGV4dCwgYmV0YSkge1xuICB0aGlzLl9iYXNpcyA9IG5ldyBCYXNpcyhjb250ZXh0KTtcbiAgdGhpcy5fYmV0YSA9IGJldGE7XG59XG5cbkJ1bmRsZS5wcm90b3R5cGUgPSB7XG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgICB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgaiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIGlmIChqID4gMCkge1xuICAgICAgdmFyIHgwID0geFswXSxcbiAgICAgICAgICB5MCA9IHlbMF0sXG4gICAgICAgICAgZHggPSB4W2pdIC0geDAsXG4gICAgICAgICAgZHkgPSB5W2pdIC0geTAsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIHQ7XG5cbiAgICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgICB0ID0gaSAvIGo7XG4gICAgICAgIHRoaXMuX2Jhc2lzLnBvaW50KFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB4W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh4MCArIHQgKiBkeCksXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG52YXIgYnVuZGxlID0gKChmdW5jdGlvbiBjdXN0b20oYmV0YSkge1xuXG4gIGZ1bmN0aW9uIGJ1bmRsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGJldGEgPT09IDEgPyBuZXcgQmFzaXMoY29udGV4dCkgOiBuZXcgQnVuZGxlKGNvbnRleHQsIGJldGEpO1xuICB9XG5cbiAgYnVuZGxlLmJldGEgPSBmdW5jdGlvbihiZXRhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYmV0YSk7XG4gIH07XG5cbiAgcmV0dXJuIGJ1bmRsZTtcbn0pKSgwLjg1KTtcblxuZnVuY3Rpb24gcG9pbnQkMyh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICB0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksXG4gICAgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLFxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxuICAgIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLFxuICAgIHRoYXQuX3gyLFxuICAgIHRoYXQuX3kyXG4gICk7XG59XG5cbmZ1bmN0aW9uIENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQkMyh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gxID0geCwgdGhpcy5feTEgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQzKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhcmRpbmFsID0gKChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSkoMCk7XG5cbmZ1bmN0aW9uIENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AkMixcbiAgYXJlYUVuZDogbm9vcCQyLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQkMyh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbnZhciBjYXJkaW5hbENsb3NlZCA9ICgoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkpKDApO1xuXG5mdW5jdGlvbiBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbikge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xufVxuXG5DYXJkaW5hbE9wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gyLCB0aGlzLl95MikgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQzKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhcmRpbmFsT3BlbiA9ICgoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKSgwKTtcblxuZnVuY3Rpb24gcG9pbnQkNCh0aGF0LCB4LCB5KSB7XG4gIHZhciB4MSA9IHRoYXQuX3gxLFxuICAgICAgeTEgPSB0aGF0Ll95MSxcbiAgICAgIHgyID0gdGhhdC5feDIsXG4gICAgICB5MiA9IHRoYXQuX3kyO1xuXG4gIGlmICh0aGF0Ll9sMDFfYSA+IGVwc2lsb24kMykge1xuICAgIHZhciBhID0gMiAqIHRoYXQuX2wwMV8yYSArIDMgKiB0aGF0Ll9sMDFfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBuID0gMyAqIHRoYXQuX2wwMV9hICogKHRoYXQuX2wwMV9hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgxID0gKHgxICogYSAtIHRoYXQuX3gwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feDIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgICB5MSA9ICh5MSAqIGEgLSB0aGF0Ll95MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3kyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gIH1cblxuICBpZiAodGhhdC5fbDIzX2EgPiBlcHNpbG9uJDMpIHtcbiAgICB2YXIgYiA9IDIgKiB0aGF0Ll9sMjNfMmEgKyAzICogdGhhdC5fbDIzX2EgKiB0aGF0Ll9sMTJfYSArIHRoYXQuX2wxMl8yYSxcbiAgICAgICAgbSA9IDMgKiB0aGF0Ll9sMjNfYSAqICh0aGF0Ll9sMjNfYSArIHRoYXQuX2wxMl9hKTtcbiAgICB4MiA9ICh4MiAqIGIgKyB0aGF0Ll94MSAqIHRoYXQuX2wyM18yYSAtIHggKiB0aGF0Ll9sMTJfMmEpIC8gbTtcbiAgICB5MiA9ICh5MiAqIGIgKyB0aGF0Ll95MSAqIHRoYXQuX2wyM18yYSAtIHkgKiB0aGF0Ll9sMTJfMmEpIC8gbTtcbiAgfVxuXG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgdGhhdC5feDIsIHRoYXQuX3kyKTtcbn1cblxuZnVuY3Rpb24gQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbS5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQ0KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSwgdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhO1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gIH1cbn07XG5cbnZhciBjYXRtdWxsUm9tID0gKChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWwoY29udGV4dCwgMCk7XG4gIH1cblxuICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gIH07XG5cbiAgcmV0dXJuIGNhdG11bGxSb207XG59KSkoMC41KTtcblxuZnVuY3Rpb24gQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbUNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCQyLFxuICBhcmVhRW5kOiBub29wJDIsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhdG11bGxSb21DbG9zZWQgPSAoKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKSgwLjUpO1xuXG5mdW5jdGlvbiBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbU9wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhdG11bGxSb21PcGVuID0gKChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKSgwLjUpO1xuXG5mdW5jdGlvbiBMaW5lYXJDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wJDIsXG4gIGFyZWFFbmQ6IG5vb3AkMixcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBpZiAodGhpcy5fcG9pbnQpIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGVsc2UgdGhpcy5fcG9pbnQgPSAxLCB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgfVxufTtcblxudmFyIGxpbmVhckNsb3NlZCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXJDbG9zZWQoY29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBzaWduJDEoeCkge1xuICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgc2xvcGVzIG9mIHRoZSB0YW5nZW50cyAoSGVybWl0ZS10eXBlIGludGVycG9sYXRpb24pIGJhc2VkIG9uXG4vLyB0aGUgZm9sbG93aW5nIHBhcGVyOiBTdGVmZmVuLCBNLiAxOTkwLiBBIFNpbXBsZSBNZXRob2QgZm9yIE1vbm90b25pY1xuLy8gSW50ZXJwb2xhdGlvbiBpbiBPbmUgRGltZW5zaW9uLiBBc3Ryb25vbXkgYW5kIEFzdHJvcGh5c2ljcywgVm9sLiAyMzksIE5PLlxuLy8gTk9WKElJKSwgUC4gNDQzLCAxOTkwLlxuZnVuY3Rpb24gc2xvcGUzKHRoYXQsIHgyLCB5Mikge1xuICB2YXIgaDAgPSB0aGF0Ll94MSAtIHRoYXQuX3gwLFxuICAgICAgaDEgPSB4MiAtIHRoYXQuX3gxLFxuICAgICAgczAgPSAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyAoaDAgfHwgaDEgPCAwICYmIC0wKSxcbiAgICAgIHMxID0gKHkyIC0gdGhhdC5feTEpIC8gKGgxIHx8IGgwIDwgMCAmJiAtMCksXG4gICAgICBwID0gKHMwICogaDEgKyBzMSAqIGgwKSAvIChoMCArIGgxKTtcbiAgcmV0dXJuIChzaWduJDEoczApICsgc2lnbiQxKHMxKSkgKiBNYXRoLm1pbihNYXRoLmFicyhzMCksIE1hdGguYWJzKHMxKSwgMC41ICogTWF0aC5hYnMocCkpIHx8IDA7XG59XG5cbi8vIENhbGN1bGF0ZSBhIG9uZS1zaWRlZCBzbG9wZS5cbmZ1bmN0aW9uIHNsb3BlMih0aGF0LCB0KSB7XG4gIHZhciBoID0gdGhhdC5feDEgLSB0aGF0Ll94MDtcbiAgcmV0dXJuIGggPyAoMyAqICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIGggLSB0KSAvIDIgOiB0O1xufVxuXG4vLyBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfSGVybWl0ZV9zcGxpbmUjUmVwcmVzZW50YXRpb25zXG4vLyBcInlvdSBjYW4gZXhwcmVzcyBjdWJpYyBIZXJtaXRlIGludGVycG9sYXRpb24gaW4gdGVybXMgb2YgY3ViaWMgQsOpemllciBjdXJ2ZXNcbi8vIHdpdGggcmVzcGVjdCB0byB0aGUgZm91ciB2YWx1ZXMgcDAsIHAwICsgbTAgLyAzLCBwMSAtIG0xIC8gMywgcDFcIi5cbmZ1bmN0aW9uIHBvaW50JDUodGhhdCwgdDAsIHQxKSB7XG4gIHZhciB4MCA9IHRoYXQuX3gwLFxuICAgICAgeTAgPSB0aGF0Ll95MCxcbiAgICAgIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgZHggPSAoeDEgLSB4MCkgLyAzO1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDAgKyBkeCwgeTAgKyBkeCAqIHQwLCB4MSAtIGR4LCB5MSAtIGR4ICogdDEsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5Nb25vdG9uZVgucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPVxuICAgIHRoaXMuX3QwID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQkNSh0aGlzLCB0aGlzLl90MCwgc2xvcGUyKHRoaXMsIHRoaXMuX3QwKSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB0MSA9IE5hTjtcblxuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh4ID09PSB0aGlzLl94MSAmJiB5ID09PSB0aGlzLl95MSkgcmV0dXJuOyAvLyBJZ25vcmUgY29pbmNpZGVudCBwb2ludHMuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyBwb2ludCQ1KHRoaXMsIHNsb3BlMih0aGlzLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSksIHQxKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCQ1KHRoaXMsIHRoaXMuX3QwLCB0MSA9IHNsb3BlMyh0aGlzLCB4LCB5KSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gICAgdGhpcy5fdDAgPSB0MTtcbiAgfVxufTtcblxuZnVuY3Rpb24gTW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IG5ldyBSZWZsZWN0Q29udGV4dChjb250ZXh0KTtcbn1cblxuKE1vbm90b25lWS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vbm90b25lWC5wcm90b3R5cGUpKS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgTW9ub3RvbmVYLnByb3RvdHlwZS5wb2ludC5jYWxsKHRoaXMsIHksIHgpO1xufTtcblxuZnVuY3Rpb24gUmVmbGVjdENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUmVmbGVjdENvbnRleHQucHJvdG90eXBlID0ge1xuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5tb3ZlVG8oeSwgeCk7IH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7IHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7IH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLl9jb250ZXh0LmxpbmVUbyh5LCB4KTsgfSxcbiAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHsgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHkxLCB4MSwgeTIsIHgyLCB5LCB4KTsgfVxufTtcblxuZnVuY3Rpb24gbW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBNb25vdG9uZVgoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIG1vbm90b25lWShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVZKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBOYXR1cmFsKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk5hdHVyYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3ggPSBbXTtcbiAgICB0aGlzLl95ID0gW107XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gdGhpcy5feCxcbiAgICAgICAgeSA9IHRoaXMuX3ksXG4gICAgICAgIG4gPSB4Lmxlbmd0aDtcblxuICAgIGlmIChuKSB7XG4gICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeFswXSwgeVswXSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4WzBdLCB5WzBdKTtcbiAgICAgIGlmIChuID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHhbMV0sIHlbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHB4ID0gY29udHJvbFBvaW50cyh4KSxcbiAgICAgICAgICAgIHB5ID0gY29udHJvbFBvaW50cyh5KTtcbiAgICAgICAgZm9yICh2YXIgaTAgPSAwLCBpMSA9IDE7IGkxIDwgbjsgKytpMCwgKytpMSkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhweFswXVtpMF0sIHB5WzBdW2kwXSwgcHhbMV1baTBdLCBweVsxXVtpMF0sIHhbaTFdLCB5W2kxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiBuID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgdGhpcy5feS5wdXNoKCt5KTtcbiAgfVxufTtcblxuLy8gU2VlIGh0dHBzOi8vd3d3LnBhcnRpY2xlaW5jZWxsLmNvbS8yMDEyL2Jlemllci1zcGxpbmVzLyBmb3IgZGVyaXZhdGlvbi5cbmZ1bmN0aW9uIGNvbnRyb2xQb2ludHMoeCkge1xuICB2YXIgaSxcbiAgICAgIG4gPSB4Lmxlbmd0aCAtIDEsXG4gICAgICBtLFxuICAgICAgYSA9IG5ldyBBcnJheShuKSxcbiAgICAgIGIgPSBuZXcgQXJyYXkobiksXG4gICAgICByID0gbmV3IEFycmF5KG4pO1xuICBhWzBdID0gMCwgYlswXSA9IDIsIHJbMF0gPSB4WzBdICsgMiAqIHhbMV07XG4gIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgKytpKSBhW2ldID0gMSwgYltpXSA9IDQsIHJbaV0gPSA0ICogeFtpXSArIDIgKiB4W2kgKyAxXTtcbiAgYVtuIC0gMV0gPSAyLCBiW24gLSAxXSA9IDcsIHJbbiAtIDFdID0gOCAqIHhbbiAtIDFdICsgeFtuXTtcbiAgZm9yIChpID0gMTsgaSA8IG47ICsraSkgbSA9IGFbaV0gLyBiW2kgLSAxXSwgYltpXSAtPSBtLCByW2ldIC09IG0gKiByW2kgLSAxXTtcbiAgYVtuIC0gMV0gPSByW24gLSAxXSAvIGJbbiAtIDFdO1xuICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIGFbaV0gPSAocltpXSAtIGFbaSArIDFdKSAvIGJbaV07XG4gIGJbbiAtIDFdID0gKHhbbl0gKyBhW24gLSAxXSkgLyAyO1xuICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7ICsraSkgYltpXSA9IDIgKiB4W2kgKyAxXSAtIGFbaSArIDFdO1xuICByZXR1cm4gW2EsIGJdO1xufVxuXG52YXIgbmF0dXJhbCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBOYXR1cmFsKGNvbnRleHQpO1xufTtcblxuZnVuY3Rpb24gU3RlcChjb250ZXh0LCB0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl90ID0gdDtcbn1cblxuU3RlcC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IHRoaXMuX3kgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoMCA8IHRoaXMuX3QgJiYgdGhpcy5fdCA8IDEgJiYgdGhpcy5fcG9pbnQgPT09IDIpIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBpZiAodGhpcy5fbGluZSA+PSAwKSB0aGlzLl90ID0gMSAtIHRoaXMuX3QsIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX3QgPD0gMCkge1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gsIHkpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB4MSA9IHRoaXMuX3ggKiAoMSAtIHRoaXMuX3QpICsgeCAqIHRoaXMuX3Q7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHRoaXMuX3kpO1xuICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgxLCB5KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5feCA9IHgsIHRoaXMuX3kgPSB5O1xuICB9XG59O1xuXG52YXIgc3RlcCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDAuNSk7XG59O1xuXG5mdW5jdGlvbiBzdGVwQmVmb3JlKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDApO1xufVxuXG5mdW5jdGlvbiBzdGVwQWZ0ZXIoY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMSk7XG59XG5cbnZhciBub25lJDEgPSBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAxKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpID0gMSwgaiwgczAsIHMxID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMxLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHMwID0gczEsIHMxID0gc2VyaWVzW29yZGVyW2ldXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBzMVtqXVsxXSArPSBzMVtqXVswXSA9IGlzTmFOKHMwW2pdWzFdKSA/IHMwW2pdWzBdIDogczBbal1bMV07XG4gICAgfVxuICB9XG59O1xuXG52YXIgbm9uZSQyID0gZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aCwgbyA9IG5ldyBBcnJheShuKTtcbiAgd2hpbGUgKC0tbiA+PSAwKSBvW25dID0gbjtcbiAgcmV0dXJuIG87XG59O1xuXG5mdW5jdGlvbiBzdGFja1ZhbHVlKGQsIGtleSkge1xuICByZXR1cm4gZFtrZXldO1xufVxuXG52YXIgc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGtleXMgPSBjb25zdGFudCQxMChbXSksXG4gICAgICBvcmRlciA9IG5vbmUkMixcbiAgICAgIG9mZnNldCA9IG5vbmUkMSxcbiAgICAgIHZhbHVlID0gc3RhY2tWYWx1ZTtcblxuICBmdW5jdGlvbiBzdGFjayhkYXRhKSB7XG4gICAgdmFyIGt6ID0ga2V5cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICBpLFxuICAgICAgICBtID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIG4gPSBrei5sZW5ndGgsXG4gICAgICAgIHN6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBvejtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGZvciAodmFyIGtpID0ga3pbaV0sIHNpID0gc3pbaV0gPSBuZXcgQXJyYXkobSksIGogPSAwLCBzaWo7IGogPCBtOyArK2opIHtcbiAgICAgICAgc2lbal0gPSBzaWogPSBbMCwgK3ZhbHVlKGRhdGFbal0sIGtpLCBqLCBkYXRhKV07XG4gICAgICAgIHNpai5kYXRhID0gZGF0YVtqXTtcbiAgICAgIH1cbiAgICAgIHNpLmtleSA9IGtpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG96ID0gb3JkZXIoc3opOyBpIDwgbjsgKytpKSB7XG4gICAgICBzeltveltpXV0uaW5kZXggPSBpO1xuICAgIH1cblxuICAgIG9mZnNldChzeiwgb3opO1xuICAgIHJldHVybiBzejtcbiAgfVxuXG4gIHN0YWNrLmtleXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoa2V5cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoc2xpY2UkNS5jYWxsKF8pKSwgc3RhY2spIDoga2V5cztcbiAgfTtcblxuICBzdGFjay52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoK18pLCBzdGFjaykgOiB2YWx1ZTtcbiAgfTtcblxuICBzdGFjay5vcmRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvcmRlciA9IF8gPT0gbnVsbCA/IG5vbmUkMiA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTAoc2xpY2UkNS5jYWxsKF8pKSwgc3RhY2spIDogb3JkZXI7XG4gIH07XG5cbiAgc3RhY2sub2Zmc2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9mZnNldCA9IF8gPT0gbnVsbCA/IG5vbmUkMSA6IF8sIHN0YWNrKSA6IG9mZnNldDtcbiAgfTtcblxuICByZXR1cm4gc3RhY2s7XG59O1xuXG52YXIgZXhwYW5kID0gZnVuY3Rpb24oc2VyaWVzLCBvcmRlcikge1xuICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpIHJldHVybjtcbiAgZm9yICh2YXIgaSwgbiwgaiA9IDAsIG0gPSBzZXJpZXNbMF0ubGVuZ3RoLCB5OyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh5ID0gaSA9IDA7IGkgPCBuOyArK2kpIHkgKz0gc2VyaWVzW2ldW2pdWzFdIHx8IDA7XG4gICAgaWYgKHkpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHNlcmllc1tpXVtqXVsxXSAvPSB5O1xuICB9XG4gIG5vbmUkMShzZXJpZXMsIG9yZGVyKTtcbn07XG5cbnZhciBkaXZlcmdpbmcgPSBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAxKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpLCBqID0gMCwgZCwgZHksIHlwLCB5biwgbiwgbSA9IHNlcmllc1tvcmRlclswXV0ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh5cCA9IHluID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgoZHkgPSAoZCA9IHNlcmllc1tvcmRlcltpXV1bal0pWzFdIC0gZFswXSkgPj0gMCkge1xuICAgICAgICBkWzBdID0geXAsIGRbMV0gPSB5cCArPSBkeTtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPCAwKSB7XG4gICAgICAgIGRbMV0gPSB5biwgZFswXSA9IHluICs9IGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFswXSA9IHlwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNpbGhvdWV0dGUgPSBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSkgcmV0dXJuO1xuICBmb3IgKHZhciBqID0gMCwgczAgPSBzZXJpZXNbb3JkZXJbMF1dLCBuLCBtID0gczAubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIHMwW2pdWzFdICs9IHMwW2pdWzBdID0gLXkgLyAyO1xuICB9XG4gIG5vbmUkMShzZXJpZXMsIG9yZGVyKTtcbn07XG5cbnZhciB3aWdnbGUgPSBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSB8fCAhKChtID0gKHMwID0gc2VyaWVzW29yZGVyWzBdXSkubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIHkgPSAwLCBqID0gMSwgczAsIG0sIG47IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBpID0gMCwgczEgPSAwLCBzMiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBzaSA9IHNlcmllc1tvcmRlcltpXV0sXG4gICAgICAgICAgc2lqMCA9IHNpW2pdWzFdIHx8IDAsXG4gICAgICAgICAgc2lqMSA9IHNpW2ogLSAxXVsxXSB8fCAwLFxuICAgICAgICAgIHMzID0gKHNpajAgLSBzaWoxKSAvIDI7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGk7ICsraykge1xuICAgICAgICB2YXIgc2sgPSBzZXJpZXNbb3JkZXJba11dLFxuICAgICAgICAgICAgc2tqMCA9IHNrW2pdWzFdIHx8IDAsXG4gICAgICAgICAgICBza2oxID0gc2tbaiAtIDFdWzFdIHx8IDA7XG4gICAgICAgIHMzICs9IHNrajAgLSBza2oxO1xuICAgICAgfVxuICAgICAgczEgKz0gc2lqMCwgczIgKz0gczMgKiBzaWowO1xuICAgIH1cbiAgICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgICBpZiAoczEpIHkgLT0gczIgLyBzMTtcbiAgfVxuICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgbm9uZSQxKHNlcmllcywgb3JkZXIpO1xufTtcblxudmFyIGFzY2VuZGluZyQyID0gZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBzdW1zID0gc2VyaWVzLm1hcChzdW0kMik7XG4gIHJldHVybiBub25lJDIoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHN1bXNbYV0gLSBzdW1zW2JdOyB9KTtcbn07XG5cbmZ1bmN0aW9uIHN1bSQyKHNlcmllcykge1xuICB2YXIgcyA9IDAsIGkgPSAtMSwgbiA9IHNlcmllcy5sZW5ndGgsIHY7XG4gIHdoaWxlICgrK2kgPCBuKSBpZiAodiA9ICtzZXJpZXNbaV1bMV0pIHMgKz0gdjtcbiAgcmV0dXJuIHM7XG59XG5cbnZhciBkZXNjZW5kaW5nJDIgPSBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIGFzY2VuZGluZyQyKHNlcmllcykucmV2ZXJzZSgpO1xufTtcblxudmFyIGluc2lkZU91dCA9IGZ1bmN0aW9uKHNlcmllcykge1xuICB2YXIgbiA9IHNlcmllcy5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHN1bXMgPSBzZXJpZXMubWFwKHN1bSQyKSxcbiAgICAgIG9yZGVyID0gbm9uZSQyKHNlcmllcykuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzdW1zW2JdIC0gc3Vtc1thXTsgfSksXG4gICAgICB0b3AgPSAwLFxuICAgICAgYm90dG9tID0gMCxcbiAgICAgIHRvcHMgPSBbXSxcbiAgICAgIGJvdHRvbXMgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaiA9IG9yZGVyW2ldO1xuICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgIHRvcCArPSBzdW1zW2pdO1xuICAgICAgdG9wcy5wdXNoKGopO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3R0b20gKz0gc3Vtc1tqXTtcbiAgICAgIGJvdHRvbXMucHVzaChqKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm90dG9tcy5yZXZlcnNlKCkuY29uY2F0KHRvcHMpO1xufTtcblxudmFyIHJldmVyc2UgPSBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIG5vbmUkMihzZXJpZXMpLnJldmVyc2UoKTtcbn07XG5cbnZhciBjb25zdGFudCQxMSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxuZnVuY3Rpb24geCQ0KGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmZ1bmN0aW9uIHkkNChkKSB7XG4gIHJldHVybiBkWzFdO1xufVxuXG5mdW5jdGlvbiBSZWRCbGFja1RyZWUoKSB7XG4gIHRoaXMuXyA9IG51bGw7IC8vIHJvb3Qgbm9kZVxufVxuXG5mdW5jdGlvbiBSZWRCbGFja05vZGUobm9kZSkge1xuICBub2RlLlUgPSAvLyBwYXJlbnQgbm9kZVxuICBub2RlLkMgPSAvLyBjb2xvciAtIHRydWUgZm9yIHJlZCwgZmFsc2UgZm9yIGJsYWNrXG4gIG5vZGUuTCA9IC8vIGxlZnQgbm9kZVxuICBub2RlLlIgPSAvLyByaWdodCBub2RlXG4gIG5vZGUuUCA9IC8vIHByZXZpb3VzIG5vZGVcbiAgbm9kZS5OID0gbnVsbDsgLy8gbmV4dCBub2RlXG59XG5cblJlZEJsYWNrVHJlZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSZWRCbGFja1RyZWUsXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbihhZnRlciwgbm9kZSkge1xuICAgIHZhciBwYXJlbnQsIGdyYW5kcGEsIHVuY2xlO1xuXG4gICAgaWYgKGFmdGVyKSB7XG4gICAgICBub2RlLlAgPSBhZnRlcjtcbiAgICAgIG5vZGUuTiA9IGFmdGVyLk47XG4gICAgICBpZiAoYWZ0ZXIuTikgYWZ0ZXIuTi5QID0gbm9kZTtcbiAgICAgIGFmdGVyLk4gPSBub2RlO1xuICAgICAgaWYgKGFmdGVyLlIpIHtcbiAgICAgICAgYWZ0ZXIgPSBhZnRlci5SO1xuICAgICAgICB3aGlsZSAoYWZ0ZXIuTCkgYWZ0ZXIgPSBhZnRlci5MO1xuICAgICAgICBhZnRlci5MID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyLlIgPSBub2RlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLl8pIHtcbiAgICAgIGFmdGVyID0gUmVkQmxhY2tGaXJzdCh0aGlzLl8pO1xuICAgICAgbm9kZS5QID0gbnVsbDtcbiAgICAgIG5vZGUuTiA9IGFmdGVyO1xuICAgICAgYWZ0ZXIuUCA9IGFmdGVyLkwgPSBub2RlO1xuICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuUCA9IG5vZGUuTiA9IG51bGw7XG4gICAgICB0aGlzLl8gPSBub2RlO1xuICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5MID0gbm9kZS5SID0gbnVsbDtcbiAgICBub2RlLlUgPSBwYXJlbnQ7XG4gICAgbm9kZS5DID0gdHJ1ZTtcblxuICAgIGFmdGVyID0gbm9kZTtcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5DKSB7XG4gICAgICBncmFuZHBhID0gcGFyZW50LlU7XG4gICAgICBpZiAocGFyZW50ID09PSBncmFuZHBhLkwpIHtcbiAgICAgICAgdW5jbGUgPSBncmFuZHBhLlI7XG4gICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XG4gICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFmdGVyID09PSBwYXJlbnQuUikge1xuICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bmNsZSA9IGdyYW5kcGEuTDtcbiAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5MKSB7XG4gICAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgZ3JhbmRwYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgfVxuICAgIHRoaXMuXy5DID0gZmFsc2U7XG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUuTikgbm9kZS5OLlAgPSBub2RlLlA7XG4gICAgaWYgKG5vZGUuUCkgbm9kZS5QLk4gPSBub2RlLk47XG4gICAgbm9kZS5OID0gbm9kZS5QID0gbnVsbDtcblxuICAgIHZhciBwYXJlbnQgPSBub2RlLlUsXG4gICAgICAgIHNpYmxpbmcsXG4gICAgICAgIGxlZnQgPSBub2RlLkwsXG4gICAgICAgIHJpZ2h0ID0gbm9kZS5SLFxuICAgICAgICBuZXh0LFxuICAgICAgICByZWQ7XG5cbiAgICBpZiAoIWxlZnQpIG5leHQgPSByaWdodDtcbiAgICBlbHNlIGlmICghcmlnaHQpIG5leHQgPSBsZWZ0O1xuICAgIGVsc2UgbmV4dCA9IFJlZEJsYWNrRmlyc3QocmlnaHQpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5MID09PSBub2RlKSBwYXJlbnQuTCA9IG5leHQ7XG4gICAgICBlbHNlIHBhcmVudC5SID0gbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fID0gbmV4dDtcbiAgICB9XG5cbiAgICBpZiAobGVmdCAmJiByaWdodCkge1xuICAgICAgcmVkID0gbmV4dC5DO1xuICAgICAgbmV4dC5DID0gbm9kZS5DO1xuICAgICAgbmV4dC5MID0gbGVmdDtcbiAgICAgIGxlZnQuVSA9IG5leHQ7XG4gICAgICBpZiAobmV4dCAhPT0gcmlnaHQpIHtcbiAgICAgICAgcGFyZW50ID0gbmV4dC5VO1xuICAgICAgICBuZXh0LlUgPSBub2RlLlU7XG4gICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICAgIHBhcmVudC5MID0gbm9kZTtcbiAgICAgICAgbmV4dC5SID0gcmlnaHQ7XG4gICAgICAgIHJpZ2h0LlUgPSBuZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dC5VID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQgPSBuZXh0O1xuICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWQgPSBub2RlLkM7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICBpZiAobm9kZSkgbm9kZS5VID0gcGFyZW50O1xuICAgIGlmIChyZWQpIHJldHVybjtcbiAgICBpZiAobm9kZSAmJiBub2RlLkMpIHsgbm9kZS5DID0gZmFsc2U7IHJldHVybjsgfVxuXG4gICAgZG8ge1xuICAgICAgaWYgKG5vZGUgPT09IHRoaXMuXykgYnJlYWs7XG4gICAgICBpZiAobm9kZSA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICBpZiAoc2libGluZy5DKSB7XG4gICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQylcbiAgICAgICAgICAgIHx8IChzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpKSB7XG4gICAgICAgICAgaWYgKCFzaWJsaW5nLlIgfHwgIXNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgc2libGluZyk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQylcbiAgICAgICAgICB8fCAoc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSkge1xuICAgICAgICAgIGlmICghc2libGluZy5MIHx8ICFzaWJsaW5nLkwuQykge1xuICAgICAgICAgICAgc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgc2libGluZyk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuXztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuVTtcbiAgICB9IHdoaWxlICghbm9kZS5DKTtcblxuICAgIGlmIChub2RlKSBub2RlLkMgPSBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUmVkQmxhY2tSb3RhdGVMZWZ0KHRyZWUsIG5vZGUpIHtcbiAgdmFyIHAgPSBub2RlLFxuICAgICAgcSA9IG5vZGUuUixcbiAgICAgIHBhcmVudCA9IHAuVTtcblxuICBpZiAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5MID09PSBwKSBwYXJlbnQuTCA9IHE7XG4gICAgZWxzZSBwYXJlbnQuUiA9IHE7XG4gIH0gZWxzZSB7XG4gICAgdHJlZS5fID0gcTtcbiAgfVxuXG4gIHEuVSA9IHBhcmVudDtcbiAgcC5VID0gcTtcbiAgcC5SID0gcS5MO1xuICBpZiAocC5SKSBwLlIuVSA9IHA7XG4gIHEuTCA9IHA7XG59XG5cbmZ1bmN0aW9uIFJlZEJsYWNrUm90YXRlUmlnaHQodHJlZSwgbm9kZSkge1xuICB2YXIgcCA9IG5vZGUsXG4gICAgICBxID0gbm9kZS5MLFxuICAgICAgcGFyZW50ID0gcC5VO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LkwgPT09IHApIHBhcmVudC5MID0gcTtcbiAgICBlbHNlIHBhcmVudC5SID0gcTtcbiAgfSBlbHNlIHtcbiAgICB0cmVlLl8gPSBxO1xuICB9XG5cbiAgcS5VID0gcGFyZW50O1xuICBwLlUgPSBxO1xuICBwLkwgPSBxLlI7XG4gIGlmIChwLkwpIHAuTC5VID0gcDtcbiAgcS5SID0gcDtcbn1cblxuZnVuY3Rpb24gUmVkQmxhY2tGaXJzdChub2RlKSB7XG4gIHdoaWxlIChub2RlLkwpIG5vZGUgPSBub2RlLkw7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFZGdlKGxlZnQsIHJpZ2h0LCB2MCwgdjEpIHtcbiAgdmFyIGVkZ2UgPSBbbnVsbCwgbnVsbF0sXG4gICAgICBpbmRleCA9IGVkZ2VzLnB1c2goZWRnZSkgLSAxO1xuICBlZGdlLmxlZnQgPSBsZWZ0O1xuICBlZGdlLnJpZ2h0ID0gcmlnaHQ7XG4gIGlmICh2MCkgc2V0RWRnZUVuZChlZGdlLCBsZWZ0LCByaWdodCwgdjApO1xuICBpZiAodjEpIHNldEVkZ2VFbmQoZWRnZSwgcmlnaHQsIGxlZnQsIHYxKTtcbiAgY2VsbHNbbGVmdC5pbmRleF0uaGFsZmVkZ2VzLnB1c2goaW5kZXgpO1xuICBjZWxsc1tyaWdodC5pbmRleF0uaGFsZmVkZ2VzLnB1c2goaW5kZXgpO1xuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQm9yZGVyRWRnZShsZWZ0LCB2MCwgdjEpIHtcbiAgdmFyIGVkZ2UgPSBbdjAsIHYxXTtcbiAgZWRnZS5sZWZ0ID0gbGVmdDtcbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmZ1bmN0aW9uIHNldEVkZ2VFbmQoZWRnZSwgbGVmdCwgcmlnaHQsIHZlcnRleCkge1xuICBpZiAoIWVkZ2VbMF0gJiYgIWVkZ2VbMV0pIHtcbiAgICBlZGdlWzBdID0gdmVydGV4O1xuICAgIGVkZ2UubGVmdCA9IGxlZnQ7XG4gICAgZWRnZS5yaWdodCA9IHJpZ2h0O1xuICB9IGVsc2UgaWYgKGVkZ2UubGVmdCA9PT0gcmlnaHQpIHtcbiAgICBlZGdlWzFdID0gdmVydGV4O1xuICB9IGVsc2Uge1xuICAgIGVkZ2VbMF0gPSB2ZXJ0ZXg7XG4gIH1cbn1cblxuLy8gTGlhbmfigJNCYXJza3kgbGluZSBjbGlwcGluZy5cbmZ1bmN0aW9uIGNsaXBFZGdlKGVkZ2UsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBhID0gZWRnZVswXSxcbiAgICAgIGIgPSBlZGdlWzFdLFxuICAgICAgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgdDAgPSAwLFxuICAgICAgdDEgPSAxLFxuICAgICAgZHggPSBieCAtIGF4LFxuICAgICAgZHkgPSBieSAtIGF5LFxuICAgICAgcjtcblxuICByID0geDAgLSBheDtcbiAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHgxIC0gYXg7XG4gIGlmICghZHggJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIHIgPSB5MCAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geTEgLSBheTtcbiAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgaWYgKCEodDAgPiAwKSAmJiAhKHQxIDwgMSkpIHJldHVybiB0cnVlOyAvLyBUT0RPIEJldHRlciBjaGVjaz9cblxuICBpZiAodDAgPiAwKSBlZGdlWzBdID0gW2F4ICsgdDAgKiBkeCwgYXkgKyB0MCAqIGR5XTtcbiAgaWYgKHQxIDwgMSkgZWRnZVsxXSA9IFtheCArIHQxICogZHgsIGF5ICsgdDEgKiBkeV07XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25uZWN0RWRnZShlZGdlLCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgdjEgPSBlZGdlWzFdO1xuICBpZiAodjEpIHJldHVybiB0cnVlO1xuXG4gIHZhciB2MCA9IGVkZ2VbMF0sXG4gICAgICBsZWZ0ID0gZWRnZS5sZWZ0LFxuICAgICAgcmlnaHQgPSBlZGdlLnJpZ2h0LFxuICAgICAgbHggPSBsZWZ0WzBdLFxuICAgICAgbHkgPSBsZWZ0WzFdLFxuICAgICAgcnggPSByaWdodFswXSxcbiAgICAgIHJ5ID0gcmlnaHRbMV0sXG4gICAgICBmeCA9IChseCArIHJ4KSAvIDIsXG4gICAgICBmeSA9IChseSArIHJ5KSAvIDIsXG4gICAgICBmbSxcbiAgICAgIGZiO1xuXG4gIGlmIChyeSA9PT0gbHkpIHtcbiAgICBpZiAoZnggPCB4MCB8fCBmeCA+PSB4MSkgcmV0dXJuO1xuICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICBpZiAoIXYwKSB2MCA9IFtmeCwgeTBdO1xuICAgICAgZWxzZSBpZiAodjBbMV0gPj0geTEpIHJldHVybjtcbiAgICAgIHYxID0gW2Z4LCB5MV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdjApIHYwID0gW2Z4LCB5MV07XG4gICAgICBlbHNlIGlmICh2MFsxXSA8IHkwKSByZXR1cm47XG4gICAgICB2MSA9IFtmeCwgeTBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmbSA9IChseCAtIHJ4KSAvIChyeSAtIGx5KTtcbiAgICBmYiA9IGZ5IC0gZm0gKiBmeDtcbiAgICBpZiAoZm0gPCAtMSB8fCBmbSA+IDEpIHtcbiAgICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICAgIGlmICghdjApIHYwID0gWyh5MCAtIGZiKSAvIGZtLCB5MF07XG4gICAgICAgIGVsc2UgaWYgKHYwWzFdID49IHkxKSByZXR1cm47XG4gICAgICAgIHYxID0gWyh5MSAtIGZiKSAvIGZtLCB5MV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXYwKSB2MCA9IFsoeTEgLSBmYikgLyBmbSwgeTFdO1xuICAgICAgICBlbHNlIGlmICh2MFsxXSA8IHkwKSByZXR1cm47XG4gICAgICAgIHYxID0gWyh5MCAtIGZiKSAvIGZtLCB5MF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChseSA8IHJ5KSB7XG4gICAgICAgIGlmICghdjApIHYwID0gW3gwLCBmbSAqIHgwICsgZmJdO1xuICAgICAgICBlbHNlIGlmICh2MFswXSA+PSB4MSkgcmV0dXJuO1xuICAgICAgICB2MSA9IFt4MSwgZm0gKiB4MSArIGZiXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdjApIHYwID0gW3gxLCBmbSAqIHgxICsgZmJdO1xuICAgICAgICBlbHNlIGlmICh2MFswXSA8IHgwKSByZXR1cm47XG4gICAgICAgIHYxID0gW3gwLCBmbSAqIHgwICsgZmJdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVkZ2VbMF0gPSB2MDtcbiAgZWRnZVsxXSA9IHYxO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2xpcEVkZ2VzKHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBpID0gZWRnZXMubGVuZ3RoLFxuICAgICAgZWRnZTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKCFjb25uZWN0RWRnZShlZGdlID0gZWRnZXNbaV0sIHgwLCB5MCwgeDEsIHkxKVxuICAgICAgICB8fCAhY2xpcEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpXG4gICAgICAgIHx8ICEoTWF0aC5hYnMoZWRnZVswXVswXSAtIGVkZ2VbMV1bMF0pID4gZXBzaWxvbiQ0XG4gICAgICAgICAgICB8fCBNYXRoLmFicyhlZGdlWzBdWzFdIC0gZWRnZVsxXVsxXSkgPiBlcHNpbG9uJDQpKSB7XG4gICAgICBkZWxldGUgZWRnZXNbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNlbGwoc2l0ZSkge1xuICByZXR1cm4gY2VsbHNbc2l0ZS5pbmRleF0gPSB7XG4gICAgc2l0ZTogc2l0ZSxcbiAgICBoYWxmZWRnZXM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNlbGxIYWxmZWRnZUFuZ2xlKGNlbGwsIGVkZ2UpIHtcbiAgdmFyIHNpdGUgPSBjZWxsLnNpdGUsXG4gICAgICB2YSA9IGVkZ2UubGVmdCxcbiAgICAgIHZiID0gZWRnZS5yaWdodDtcbiAgaWYgKHNpdGUgPT09IHZiKSB2YiA9IHZhLCB2YSA9IHNpdGU7XG4gIGlmICh2YikgcmV0dXJuIE1hdGguYXRhbjIodmJbMV0gLSB2YVsxXSwgdmJbMF0gLSB2YVswXSk7XG4gIGlmIChzaXRlID09PSB2YSkgdmEgPSBlZGdlWzFdLCB2YiA9IGVkZ2VbMF07XG4gIGVsc2UgdmEgPSBlZGdlWzBdLCB2YiA9IGVkZ2VbMV07XG4gIHJldHVybiBNYXRoLmF0YW4yKHZhWzBdIC0gdmJbMF0sIHZiWzFdIC0gdmFbMV0pO1xufVxuXG5mdW5jdGlvbiBjZWxsSGFsZmVkZ2VTdGFydChjZWxsLCBlZGdlKSB7XG4gIHJldHVybiBlZGdlWysoZWRnZS5sZWZ0ICE9PSBjZWxsLnNpdGUpXTtcbn1cblxuZnVuY3Rpb24gY2VsbEhhbGZlZGdlRW5kKGNlbGwsIGVkZ2UpIHtcbiAgcmV0dXJuIGVkZ2VbKyhlZGdlLmxlZnQgPT09IGNlbGwuc2l0ZSldO1xufVxuXG5mdW5jdGlvbiBzb3J0Q2VsbEhhbGZlZGdlcygpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBjZWxscy5sZW5ndGgsIGNlbGwsIGhhbGZlZGdlcywgaiwgbTsgaSA8IG47ICsraSkge1xuICAgIGlmICgoY2VsbCA9IGNlbGxzW2ldKSAmJiAobSA9IChoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcykubGVuZ3RoKSkge1xuICAgICAgdmFyIGluZGV4ID0gbmV3IEFycmF5KG0pLFxuICAgICAgICAgIGFycmF5ID0gbmV3IEFycmF5KG0pO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgaW5kZXhbal0gPSBqLCBhcnJheVtqXSA9IGNlbGxIYWxmZWRnZUFuZ2xlKGNlbGwsIGVkZ2VzW2hhbGZlZGdlc1tqXV0pO1xuICAgICAgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBhcnJheVtqXSAtIGFycmF5W2ldOyB9KTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIGFycmF5W2pdID0gaGFsZmVkZ2VzW2luZGV4W2pdXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIGhhbGZlZGdlc1tqXSA9IGFycmF5W2pdO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGlwQ2VsbHMoeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5DZWxscyA9IGNlbGxzLmxlbmd0aCxcbiAgICAgIGlDZWxsLFxuICAgICAgY2VsbCxcbiAgICAgIHNpdGUsXG4gICAgICBpSGFsZmVkZ2UsXG4gICAgICBoYWxmZWRnZXMsXG4gICAgICBuSGFsZmVkZ2VzLFxuICAgICAgc3RhcnQsXG4gICAgICBzdGFydFgsXG4gICAgICBzdGFydFksXG4gICAgICBlbmQsXG4gICAgICBlbmRYLFxuICAgICAgZW5kWSxcbiAgICAgIGNvdmVyID0gdHJ1ZTtcblxuICBmb3IgKGlDZWxsID0gMDsgaUNlbGwgPCBuQ2VsbHM7ICsraUNlbGwpIHtcbiAgICBpZiAoY2VsbCA9IGNlbGxzW2lDZWxsXSkge1xuICAgICAgc2l0ZSA9IGNlbGwuc2l0ZTtcbiAgICAgIGhhbGZlZGdlcyA9IGNlbGwuaGFsZmVkZ2VzO1xuICAgICAgaUhhbGZlZGdlID0gaGFsZmVkZ2VzLmxlbmd0aDtcblxuICAgICAgLy8gUmVtb3ZlIGFueSBkYW5nbGluZyBjbGlwcGVkIGVkZ2VzLlxuICAgICAgd2hpbGUgKGlIYWxmZWRnZS0tKSB7XG4gICAgICAgIGlmICghZWRnZXNbaGFsZmVkZ2VzW2lIYWxmZWRnZV1dKSB7XG4gICAgICAgICAgaGFsZmVkZ2VzLnNwbGljZShpSGFsZmVkZ2UsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEluc2VydCBhbnkgYm9yZGVyIGVkZ2VzIGFzIG5lY2Vzc2FyeS5cbiAgICAgIGlIYWxmZWRnZSA9IDAsIG5IYWxmZWRnZXMgPSBoYWxmZWRnZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGlIYWxmZWRnZSA8IG5IYWxmZWRnZXMpIHtcbiAgICAgICAgZW5kID0gY2VsbEhhbGZlZGdlRW5kKGNlbGwsIGVkZ2VzW2hhbGZlZGdlc1tpSGFsZmVkZ2VdXSksIGVuZFggPSBlbmRbMF0sIGVuZFkgPSBlbmRbMV07XG4gICAgICAgIHN0YXJ0ID0gY2VsbEhhbGZlZGdlU3RhcnQoY2VsbCwgZWRnZXNbaGFsZmVkZ2VzWysraUhhbGZlZGdlICUgbkhhbGZlZGdlc11dKSwgc3RhcnRYID0gc3RhcnRbMF0sIHN0YXJ0WSA9IHN0YXJ0WzFdO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZW5kWCAtIHN0YXJ0WCkgPiBlcHNpbG9uJDQgfHwgTWF0aC5hYnMoZW5kWSAtIHN0YXJ0WSkgPiBlcHNpbG9uJDQpIHtcbiAgICAgICAgICBoYWxmZWRnZXMuc3BsaWNlKGlIYWxmZWRnZSwgMCwgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIGVuZCxcbiAgICAgICAgICAgICAgTWF0aC5hYnMoZW5kWCAtIHgwKSA8IGVwc2lsb24kNCAmJiB5MSAtIGVuZFkgPiBlcHNpbG9uJDQgPyBbeDAsIE1hdGguYWJzKHN0YXJ0WCAtIHgwKSA8IGVwc2lsb24kNCA/IHN0YXJ0WSA6IHkxXVxuICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFkgLSB5MSkgPCBlcHNpbG9uJDQgJiYgeDEgLSBlbmRYID4gZXBzaWxvbiQ0ID8gW01hdGguYWJzKHN0YXJ0WSAtIHkxKSA8IGVwc2lsb24kNCA/IHN0YXJ0WCA6IHgxLCB5MV1cbiAgICAgICAgICAgICAgOiBNYXRoLmFicyhlbmRYIC0geDEpIDwgZXBzaWxvbiQ0ICYmIGVuZFkgLSB5MCA+IGVwc2lsb24kNCA/IFt4MSwgTWF0aC5hYnMoc3RhcnRYIC0geDEpIDwgZXBzaWxvbiQ0ID8gc3RhcnRZIDogeTBdXG4gICAgICAgICAgICAgIDogTWF0aC5hYnMoZW5kWSAtIHkwKSA8IGVwc2lsb24kNCAmJiBlbmRYIC0geDAgPiBlcHNpbG9uJDQgPyBbTWF0aC5hYnMoc3RhcnRZIC0geTApIDwgZXBzaWxvbiQ0ID8gc3RhcnRYIDogeDAsIHkwXVxuICAgICAgICAgICAgICA6IG51bGwpKSAtIDEpO1xuICAgICAgICAgICsrbkhhbGZlZGdlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobkhhbGZlZGdlcykgY292ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlbuKAmXQgYW55IGVkZ2VzLCBoYXZlIHRoZSBjbG9zZXN0IHNpdGUgY292ZXIgdGhlIGV4dGVudC5cbiAgLy8gSXQgZG9lc27igJl0IG1hdHRlciB3aGljaCBjb3JuZXIgb2YgdGhlIGV4dGVudCB3ZSBtZWFzdXJlIVxuICBpZiAoY292ZXIpIHtcbiAgICB2YXIgZHgsIGR5LCBkMiwgZGMgPSBJbmZpbml0eTtcblxuICAgIGZvciAoaUNlbGwgPSAwLCBjb3ZlciA9IG51bGw7IGlDZWxsIDwgbkNlbGxzOyArK2lDZWxsKSB7XG4gICAgICBpZiAoY2VsbCA9IGNlbGxzW2lDZWxsXSkge1xuICAgICAgICBzaXRlID0gY2VsbC5zaXRlO1xuICAgICAgICBkeCA9IHNpdGVbMF0gLSB4MDtcbiAgICAgICAgZHkgPSBzaXRlWzFdIC0geTA7XG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkMiA8IGRjKSBkYyA9IGQyLCBjb3ZlciA9IGNlbGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvdmVyKSB7XG4gICAgICB2YXIgdjAwID0gW3gwLCB5MF0sIHYwMSA9IFt4MCwgeTFdLCB2MTEgPSBbeDEsIHkxXSwgdjEwID0gW3gxLCB5MF07XG4gICAgICBjb3Zlci5oYWxmZWRnZXMucHVzaChcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUgPSBjb3Zlci5zaXRlLCB2MDAsIHYwMSkpIC0gMSxcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIHYwMSwgdjExKSkgLSAxLFxuICAgICAgICBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgdjExLCB2MTApKSAtIDEsXG4gICAgICAgIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCB2MTAsIHYwMCkpIC0gMVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBMYXN0bHkgZGVsZXRlIGFueSBjZWxscyB3aXRoIG5vIGVkZ2VzOyB0aGVzZSB3ZXJlIGVudGlyZWx5IGNsaXBwZWQuXG4gIGZvciAoaUNlbGwgPSAwOyBpQ2VsbCA8IG5DZWxsczsgKytpQ2VsbCkge1xuICAgIGlmIChjZWxsID0gY2VsbHNbaUNlbGxdKSB7XG4gICAgICBpZiAoIWNlbGwuaGFsZmVkZ2VzLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgY2VsbHNbaUNlbGxdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgY2lyY2xlUG9vbCA9IFtdO1xuXG52YXIgZmlyc3RDaXJjbGU7XG5cbmZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgUmVkQmxhY2tOb2RlKHRoaXMpO1xuICB0aGlzLnggPVxuICB0aGlzLnkgPVxuICB0aGlzLmFyYyA9XG4gIHRoaXMuc2l0ZSA9XG4gIHRoaXMuY3kgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hDaXJjbGUoYXJjKSB7XG4gIHZhciBsQXJjID0gYXJjLlAsXG4gICAgICByQXJjID0gYXJjLk47XG5cbiAgaWYgKCFsQXJjIHx8ICFyQXJjKSByZXR1cm47XG5cbiAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLFxuICAgICAgY1NpdGUgPSBhcmMuc2l0ZSxcbiAgICAgIHJTaXRlID0gckFyYy5zaXRlO1xuXG4gIGlmIChsU2l0ZSA9PT0gclNpdGUpIHJldHVybjtcblxuICB2YXIgYnggPSBjU2l0ZVswXSxcbiAgICAgIGJ5ID0gY1NpdGVbMV0sXG4gICAgICBheCA9IGxTaXRlWzBdIC0gYngsXG4gICAgICBheSA9IGxTaXRlWzFdIC0gYnksXG4gICAgICBjeCA9IHJTaXRlWzBdIC0gYngsXG4gICAgICBjeSA9IHJTaXRlWzFdIC0gYnk7XG5cbiAgdmFyIGQgPSAyICogKGF4ICogY3kgLSBheSAqIGN4KTtcbiAgaWYgKGQgPj0gLWVwc2lsb24yJDIpIHJldHVybjtcblxuICB2YXIgaGEgPSBheCAqIGF4ICsgYXkgKiBheSxcbiAgICAgIGhjID0gY3ggKiBjeCArIGN5ICogY3ksXG4gICAgICB4ID0gKGN5ICogaGEgLSBheSAqIGhjKSAvIGQsXG4gICAgICB5ID0gKGF4ICogaGMgLSBjeCAqIGhhKSAvIGQ7XG5cbiAgdmFyIGNpcmNsZSA9IGNpcmNsZVBvb2wucG9wKCkgfHwgbmV3IENpcmNsZTtcbiAgY2lyY2xlLmFyYyA9IGFyYztcbiAgY2lyY2xlLnNpdGUgPSBjU2l0ZTtcbiAgY2lyY2xlLnggPSB4ICsgYng7XG4gIGNpcmNsZS55ID0gKGNpcmNsZS5jeSA9IHkgKyBieSkgKyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7IC8vIHkgYm90dG9tXG5cbiAgYXJjLmNpcmNsZSA9IGNpcmNsZTtcblxuICB2YXIgYmVmb3JlID0gbnVsbCxcbiAgICAgIG5vZGUgPSBjaXJjbGVzLl87XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAoY2lyY2xlLnkgPCBub2RlLnkgfHwgKGNpcmNsZS55ID09PSBub2RlLnkgJiYgY2lyY2xlLnggPD0gbm9kZS54KSkge1xuICAgICAgaWYgKG5vZGUuTCkgbm9kZSA9IG5vZGUuTDtcbiAgICAgIGVsc2UgeyBiZWZvcmUgPSBub2RlLlA7IGJyZWFrOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChub2RlLlIpIG5vZGUgPSBub2RlLlI7XG4gICAgICBlbHNlIHsgYmVmb3JlID0gbm9kZTsgYnJlYWs7IH1cbiAgICB9XG4gIH1cblxuICBjaXJjbGVzLmluc2VydChiZWZvcmUsIGNpcmNsZSk7XG4gIGlmICghYmVmb3JlKSBmaXJzdENpcmNsZSA9IGNpcmNsZTtcbn1cblxuZnVuY3Rpb24gZGV0YWNoQ2lyY2xlKGFyYykge1xuICB2YXIgY2lyY2xlID0gYXJjLmNpcmNsZTtcbiAgaWYgKGNpcmNsZSkge1xuICAgIGlmICghY2lyY2xlLlApIGZpcnN0Q2lyY2xlID0gY2lyY2xlLk47XG4gICAgY2lyY2xlcy5yZW1vdmUoY2lyY2xlKTtcbiAgICBjaXJjbGVQb29sLnB1c2goY2lyY2xlKTtcbiAgICBSZWRCbGFja05vZGUoY2lyY2xlKTtcbiAgICBhcmMuY2lyY2xlID0gbnVsbDtcbiAgfVxufVxuXG52YXIgYmVhY2hQb29sID0gW107XG5cbmZ1bmN0aW9uIEJlYWNoKCkge1xuICBSZWRCbGFja05vZGUodGhpcyk7XG4gIHRoaXMuZWRnZSA9XG4gIHRoaXMuc2l0ZSA9XG4gIHRoaXMuY2lyY2xlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmVhY2goc2l0ZSkge1xuICB2YXIgYmVhY2ggPSBiZWFjaFBvb2wucG9wKCkgfHwgbmV3IEJlYWNoO1xuICBiZWFjaC5zaXRlID0gc2l0ZTtcbiAgcmV0dXJuIGJlYWNoO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hCZWFjaChiZWFjaCkge1xuICBkZXRhY2hDaXJjbGUoYmVhY2gpO1xuICBiZWFjaGVzLnJlbW92ZShiZWFjaCk7XG4gIGJlYWNoUG9vbC5wdXNoKGJlYWNoKTtcbiAgUmVkQmxhY2tOb2RlKGJlYWNoKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQmVhY2goYmVhY2gpIHtcbiAgdmFyIGNpcmNsZSA9IGJlYWNoLmNpcmNsZSxcbiAgICAgIHggPSBjaXJjbGUueCxcbiAgICAgIHkgPSBjaXJjbGUuY3ksXG4gICAgICB2ZXJ0ZXggPSBbeCwgeV0sXG4gICAgICBwcmV2aW91cyA9IGJlYWNoLlAsXG4gICAgICBuZXh0ID0gYmVhY2guTixcbiAgICAgIGRpc2FwcGVhcmluZyA9IFtiZWFjaF07XG5cbiAgZGV0YWNoQmVhY2goYmVhY2gpO1xuXG4gIHZhciBsQXJjID0gcHJldmlvdXM7XG4gIHdoaWxlIChsQXJjLmNpcmNsZVxuICAgICAgJiYgTWF0aC5hYnMoeCAtIGxBcmMuY2lyY2xlLngpIDwgZXBzaWxvbiQ0XG4gICAgICAmJiBNYXRoLmFicyh5IC0gbEFyYy5jaXJjbGUuY3kpIDwgZXBzaWxvbiQ0KSB7XG4gICAgcHJldmlvdXMgPSBsQXJjLlA7XG4gICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgZGV0YWNoQmVhY2gobEFyYyk7XG4gICAgbEFyYyA9IHByZXZpb3VzO1xuICB9XG5cbiAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gIGRldGFjaENpcmNsZShsQXJjKTtcblxuICB2YXIgckFyYyA9IG5leHQ7XG4gIHdoaWxlIChyQXJjLmNpcmNsZVxuICAgICAgJiYgTWF0aC5hYnMoeCAtIHJBcmMuY2lyY2xlLngpIDwgZXBzaWxvbiQ0XG4gICAgICAmJiBNYXRoLmFicyh5IC0gckFyYy5jaXJjbGUuY3kpIDwgZXBzaWxvbiQ0KSB7XG4gICAgbmV4dCA9IHJBcmMuTjtcbiAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICBkZXRhY2hCZWFjaChyQXJjKTtcbiAgICByQXJjID0gbmV4dDtcbiAgfVxuXG4gIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICBkZXRhY2hDaXJjbGUockFyYyk7XG5cbiAgdmFyIG5BcmNzID0gZGlzYXBwZWFyaW5nLmxlbmd0aCxcbiAgICAgIGlBcmM7XG4gIGZvciAoaUFyYyA9IDE7IGlBcmMgPCBuQXJjczsgKytpQXJjKSB7XG4gICAgckFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjXTtcbiAgICBsQXJjID0gZGlzYXBwZWFyaW5nW2lBcmMgLSAxXTtcbiAgICBzZXRFZGdlRW5kKHJBcmMuZWRnZSwgbEFyYy5zaXRlLCByQXJjLnNpdGUsIHZlcnRleCk7XG4gIH1cblxuICBsQXJjID0gZGlzYXBwZWFyaW5nWzBdO1xuICByQXJjID0gZGlzYXBwZWFyaW5nW25BcmNzIC0gMV07XG4gIHJBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobEFyYy5zaXRlLCByQXJjLnNpdGUsIG51bGwsIHZlcnRleCk7XG5cbiAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xuICBhdHRhY2hDaXJjbGUockFyYyk7XG59XG5cbmZ1bmN0aW9uIGFkZEJlYWNoKHNpdGUpIHtcbiAgdmFyIHggPSBzaXRlWzBdLFxuICAgICAgZGlyZWN0cml4ID0gc2l0ZVsxXSxcbiAgICAgIGxBcmMsXG4gICAgICByQXJjLFxuICAgICAgZHhsLFxuICAgICAgZHhyLFxuICAgICAgbm9kZSA9IGJlYWNoZXMuXztcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGR4bCA9IGxlZnRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCkgLSB4O1xuICAgIGlmIChkeGwgPiBlcHNpbG9uJDQpIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xuICAgICAgZHhyID0geCAtIHJpZ2h0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpO1xuICAgICAgaWYgKGR4ciA+IGVwc2lsb24kNCkge1xuICAgICAgICBpZiAoIW5vZGUuUikge1xuICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLlI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZHhsID4gLWVwc2lsb24kNCkge1xuICAgICAgICAgIGxBcmMgPSBub2RlLlA7XG4gICAgICAgICAgckFyYyA9IG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoZHhyID4gLWVwc2lsb24kNCkge1xuICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgIHJBcmMgPSBub2RlLk47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbEFyYyA9IHJBcmMgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNlbGwoc2l0ZSk7XG4gIHZhciBuZXdBcmMgPSBjcmVhdGVCZWFjaChzaXRlKTtcbiAgYmVhY2hlcy5pbnNlcnQobEFyYywgbmV3QXJjKTtcblxuICBpZiAoIWxBcmMgJiYgIXJBcmMpIHJldHVybjtcblxuICBpZiAobEFyYyA9PT0gckFyYykge1xuICAgIGRldGFjaENpcmNsZShsQXJjKTtcbiAgICByQXJjID0gY3JlYXRlQmVhY2gobEFyYy5zaXRlKTtcbiAgICBiZWFjaGVzLmluc2VydChuZXdBcmMsIHJBcmMpO1xuICAgIG5ld0FyYy5lZGdlID0gckFyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICBhdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghckFyYykgeyAvLyAmJiBsQXJjXG4gICAgbmV3QXJjLmVkZ2UgPSBjcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVsc2UgbEFyYyAhPT0gckFyY1xuICBkZXRhY2hDaXJjbGUobEFyYyk7XG4gIGRldGFjaENpcmNsZShyQXJjKTtcblxuICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsXG4gICAgICBheCA9IGxTaXRlWzBdLFxuICAgICAgYXkgPSBsU2l0ZVsxXSxcbiAgICAgIGJ4ID0gc2l0ZVswXSAtIGF4LFxuICAgICAgYnkgPSBzaXRlWzFdIC0gYXksXG4gICAgICByU2l0ZSA9IHJBcmMuc2l0ZSxcbiAgICAgIGN4ID0gclNpdGVbMF0gLSBheCxcbiAgICAgIGN5ID0gclNpdGVbMV0gLSBheSxcbiAgICAgIGQgPSAyICogKGJ4ICogY3kgLSBieSAqIGN4KSxcbiAgICAgIGhiID0gYnggKiBieCArIGJ5ICogYnksXG4gICAgICBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LFxuICAgICAgdmVydGV4ID0gWyhjeSAqIGhiIC0gYnkgKiBoYykgLyBkICsgYXgsIChieCAqIGhjIC0gY3ggKiBoYikgLyBkICsgYXldO1xuXG4gIHNldEVkZ2VFbmQockFyYy5lZGdlLCBsU2l0ZSwgclNpdGUsIHZlcnRleCk7XG4gIG5ld0FyYy5lZGdlID0gY3JlYXRlRWRnZShsU2l0ZSwgc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgckFyYy5lZGdlID0gY3JlYXRlRWRnZShzaXRlLCByU2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xuICBhdHRhY2hDaXJjbGUockFyYyk7XG59XG5cbmZ1bmN0aW9uIGxlZnRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gIHZhciBzaXRlID0gYXJjLnNpdGUsXG4gICAgICByZm9jeCA9IHNpdGVbMF0sXG4gICAgICByZm9jeSA9IHNpdGVbMV0sXG4gICAgICBwYnkyID0gcmZvY3kgLSBkaXJlY3RyaXg7XG5cbiAgaWYgKCFwYnkyKSByZXR1cm4gcmZvY3g7XG5cbiAgdmFyIGxBcmMgPSBhcmMuUDtcbiAgaWYgKCFsQXJjKSByZXR1cm4gLUluZmluaXR5O1xuXG4gIHNpdGUgPSBsQXJjLnNpdGU7XG4gIHZhciBsZm9jeCA9IHNpdGVbMF0sXG4gICAgICBsZm9jeSA9IHNpdGVbMV0sXG4gICAgICBwbGJ5MiA9IGxmb2N5IC0gZGlyZWN0cml4O1xuXG4gIGlmICghcGxieTIpIHJldHVybiBsZm9jeDtcblxuICB2YXIgaGwgPSBsZm9jeCAtIHJmb2N4LFxuICAgICAgYWJ5MiA9IDEgLyBwYnkyIC0gMSAvIHBsYnkyLFxuICAgICAgYiA9IGhsIC8gcGxieTI7XG5cbiAgaWYgKGFieTIpIHJldHVybiAoLWIgKyBNYXRoLnNxcnQoYiAqIGIgLSAyICogYWJ5MiAqIChobCAqIGhsIC8gKC0yICogcGxieTIpIC0gbGZvY3kgKyBwbGJ5MiAvIDIgKyByZm9jeSAtIHBieTIgLyAyKSkpIC8gYWJ5MiArIHJmb2N4O1xuXG4gIHJldHVybiAocmZvY3ggKyBsZm9jeCkgLyAyO1xufVxuXG5mdW5jdGlvbiByaWdodEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgdmFyIHJBcmMgPSBhcmMuTjtcbiAgaWYgKHJBcmMpIHJldHVybiBsZWZ0QnJlYWtQb2ludChyQXJjLCBkaXJlY3RyaXgpO1xuICB2YXIgc2l0ZSA9IGFyYy5zaXRlO1xuICByZXR1cm4gc2l0ZVsxXSA9PT0gZGlyZWN0cml4ID8gc2l0ZVswXSA6IEluZmluaXR5O1xufVxuXG52YXIgZXBzaWxvbiQ0ID0gMWUtNjtcbnZhciBlcHNpbG9uMiQyID0gMWUtMTI7XG52YXIgYmVhY2hlcztcbnZhciBjZWxscztcbnZhciBjaXJjbGVzO1xudmFyIGVkZ2VzO1xuXG5mdW5jdGlvbiB0cmlhbmdsZUFyZWEoYSwgYiwgYykge1xuICByZXR1cm4gKGFbMF0gLSBjWzBdKSAqIChiWzFdIC0gYVsxXSkgLSAoYVswXSAtIGJbMF0pICogKGNbMV0gLSBhWzFdKTtcbn1cblxuZnVuY3Rpb24gbGV4aWNvZ3JhcGhpYyhhLCBiKSB7XG4gIHJldHVybiBiWzFdIC0gYVsxXVxuICAgICAgfHwgYlswXSAtIGFbMF07XG59XG5cbmZ1bmN0aW9uIERpYWdyYW0oc2l0ZXMsIGV4dGVudCkge1xuICB2YXIgc2l0ZSA9IHNpdGVzLnNvcnQobGV4aWNvZ3JhcGhpYykucG9wKCksXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNpcmNsZTtcblxuICBlZGdlcyA9IFtdO1xuICBjZWxscyA9IG5ldyBBcnJheShzaXRlcy5sZW5ndGgpO1xuICBiZWFjaGVzID0gbmV3IFJlZEJsYWNrVHJlZTtcbiAgY2lyY2xlcyA9IG5ldyBSZWRCbGFja1RyZWU7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjaXJjbGUgPSBmaXJzdENpcmNsZTtcbiAgICBpZiAoc2l0ZSAmJiAoIWNpcmNsZSB8fCBzaXRlWzFdIDwgY2lyY2xlLnkgfHwgKHNpdGVbMV0gPT09IGNpcmNsZS55ICYmIHNpdGVbMF0gPCBjaXJjbGUueCkpKSB7XG4gICAgICBpZiAoc2l0ZVswXSAhPT0geCB8fCBzaXRlWzFdICE9PSB5KSB7XG4gICAgICAgIGFkZEJlYWNoKHNpdGUpO1xuICAgICAgICB4ID0gc2l0ZVswXSwgeSA9IHNpdGVbMV07XG4gICAgICB9XG4gICAgICBzaXRlID0gc2l0ZXMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChjaXJjbGUpIHtcbiAgICAgIHJlbW92ZUJlYWNoKGNpcmNsZS5hcmMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzb3J0Q2VsbEhhbGZlZGdlcygpO1xuXG4gIGlmIChleHRlbnQpIHtcbiAgICB2YXIgeDAgPSArZXh0ZW50WzBdWzBdLFxuICAgICAgICB5MCA9ICtleHRlbnRbMF1bMV0sXG4gICAgICAgIHgxID0gK2V4dGVudFsxXVswXSxcbiAgICAgICAgeTEgPSArZXh0ZW50WzFdWzFdO1xuICAgIGNsaXBFZGdlcyh4MCwgeTAsIHgxLCB5MSk7XG4gICAgY2xpcENlbGxzKHgwLCB5MCwgeDEsIHkxKTtcbiAgfVxuXG4gIHRoaXMuZWRnZXMgPSBlZGdlcztcbiAgdGhpcy5jZWxscyA9IGNlbGxzO1xuXG4gIGJlYWNoZXMgPVxuICBjaXJjbGVzID1cbiAgZWRnZXMgPVxuICBjZWxscyA9IG51bGw7XG59XG5cbkRpYWdyYW0ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlhZ3JhbSxcblxuICBwb2x5Z29uczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcztcblxuICAgIHJldHVybiB0aGlzLmNlbGxzLm1hcChmdW5jdGlvbihjZWxsKSB7XG4gICAgICB2YXIgcG9seWdvbiA9IGNlbGwuaGFsZmVkZ2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBjZWxsSGFsZmVkZ2VTdGFydChjZWxsLCBlZGdlc1tpXSk7IH0pO1xuICAgICAgcG9seWdvbi5kYXRhID0gY2VsbC5zaXRlLmRhdGE7XG4gICAgICByZXR1cm4gcG9seWdvbjtcbiAgICB9KTtcbiAgfSxcblxuICB0cmlhbmdsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmlhbmdsZXMgPSBbXSxcbiAgICAgICAgZWRnZXMgPSB0aGlzLmVkZ2VzO1xuXG4gICAgdGhpcy5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGkpIHtcbiAgICAgIGlmICghKG0gPSAoaGFsZmVkZ2VzID0gY2VsbC5oYWxmZWRnZXMpLmxlbmd0aCkpIHJldHVybjtcbiAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlLFxuICAgICAgICAgIGhhbGZlZGdlcyxcbiAgICAgICAgICBqID0gLTEsXG4gICAgICAgICAgbSxcbiAgICAgICAgICBzMCxcbiAgICAgICAgICBlMSA9IGVkZ2VzW2hhbGZlZGdlc1ttIC0gMV1dLFxuICAgICAgICAgIHMxID0gZTEubGVmdCA9PT0gc2l0ZSA/IGUxLnJpZ2h0IDogZTEubGVmdDtcblxuICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgZTEgPSBlZGdlc1toYWxmZWRnZXNbal1dO1xuICAgICAgICBzMSA9IGUxLmxlZnQgPT09IHNpdGUgPyBlMS5yaWdodCA6IGUxLmxlZnQ7XG4gICAgICAgIGlmIChzMCAmJiBzMSAmJiBpIDwgczAuaW5kZXggJiYgaSA8IHMxLmluZGV4ICYmIHRyaWFuZ2xlQXJlYShzaXRlLCBzMCwgczEpIDwgMCkge1xuICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKFtzaXRlLmRhdGEsIHMwLmRhdGEsIHMxLmRhdGFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbiAgfSxcblxuICBsaW5rczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRnZXMuZmlsdGVyKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLnJpZ2h0O1xuICAgIH0pLm1hcChmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IGVkZ2UubGVmdC5kYXRhLFxuICAgICAgICB0YXJnZXQ6IGVkZ2UucmlnaHQuZGF0YVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSxcblxuICBmaW5kOiBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsIGkwLCBpMSA9IHRoYXQuX2ZvdW5kIHx8IDAsIG4gPSB0aGF0LmNlbGxzLmxlbmd0aCwgY2VsbDtcblxuICAgIC8vIFVzZSB0aGUgcHJldmlvdXNseS1mb3VuZCBjZWxsLCBvciBzdGFydCB3aXRoIGFuIGFyYml0cmFyeSBvbmUuXG4gICAgd2hpbGUgKCEoY2VsbCA9IHRoYXQuY2VsbHNbaTFdKSkgaWYgKCsraTEgPj0gbikgcmV0dXJuIG51bGw7XG4gICAgdmFyIGR4ID0geCAtIGNlbGwuc2l0ZVswXSwgZHkgPSB5IC0gY2VsbC5zaXRlWzFdLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuXG4gICAgLy8gVHJhdmVyc2UgdGhlIGhhbGYtZWRnZXMgdG8gZmluZCBhIGNsb3NlciBjZWxsLCBpZiBhbnkuXG4gICAgZG8ge1xuICAgICAgY2VsbCA9IHRoYXQuY2VsbHNbaTAgPSBpMV0sIGkxID0gbnVsbDtcbiAgICAgIGNlbGwuaGFsZmVkZ2VzLmZvckVhY2goZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZWRnZSA9IHRoYXQuZWRnZXNbZV0sIHYgPSBlZGdlLmxlZnQ7XG4gICAgICAgIGlmICgodiA9PT0gY2VsbC5zaXRlIHx8ICF2KSAmJiAhKHYgPSBlZGdlLnJpZ2h0KSkgcmV0dXJuO1xuICAgICAgICB2YXIgdnggPSB4IC0gdlswXSwgdnkgPSB5IC0gdlsxXSwgdjIgPSB2eCAqIHZ4ICsgdnkgKiB2eTtcbiAgICAgICAgaWYgKHYyIDwgZDIpIGQyID0gdjIsIGkxID0gdi5pbmRleDtcbiAgICAgIH0pO1xuICAgIH0gd2hpbGUgKGkxICE9PSBudWxsKTtcblxuICAgIHRoYXQuX2ZvdW5kID0gaTA7XG5cbiAgICByZXR1cm4gcmFkaXVzID09IG51bGwgfHwgZDIgPD0gcmFkaXVzICogcmFkaXVzID8gY2VsbC5zaXRlIDogbnVsbDtcbiAgfVxufTtcblxudmFyIHZvcm9ub2kgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHgkJDEgPSB4JDQsXG4gICAgICB5JCQxID0geSQ0LFxuICAgICAgZXh0ZW50ID0gbnVsbDtcblxuICBmdW5jdGlvbiB2b3Jvbm9pKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IERpYWdyYW0oZGF0YS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgdmFyIHMgPSBbTWF0aC5yb3VuZCh4JCQxKGQsIGksIGRhdGEpIC8gZXBzaWxvbiQ0KSAqIGVwc2lsb24kNCwgTWF0aC5yb3VuZCh5JCQxKGQsIGksIGRhdGEpIC8gZXBzaWxvbiQ0KSAqIGVwc2lsb24kNF07XG4gICAgICBzLmluZGV4ID0gaTtcbiAgICAgIHMuZGF0YSA9IGQ7XG4gICAgICByZXR1cm4gcztcbiAgICB9KSwgZXh0ZW50KTtcbiAgfVxuXG4gIHZvcm9ub2kucG9seWdvbnMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHZvcm9ub2koZGF0YSkucG9seWdvbnMoKTtcbiAgfTtcblxuICB2b3Jvbm9pLmxpbmtzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiB2b3Jvbm9pKGRhdGEpLmxpbmtzKCk7XG4gIH07XG5cbiAgdm9yb25vaS50cmlhbmdsZXMgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHZvcm9ub2koZGF0YSkudHJpYW5nbGVzKCk7XG4gIH07XG5cbiAgdm9yb25vaS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDExKCtfKSwgdm9yb25vaSkgOiB4JCQxO1xuICB9O1xuXG4gIHZvcm9ub2kueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCQxMSgrXyksIHZvcm9ub2kpIDogeSQkMTtcbiAgfTtcblxuICB2b3Jvbm9pLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSBfID09IG51bGwgPyBudWxsIDogW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0sIHZvcm9ub2kpIDogZXh0ZW50ICYmIFtbZXh0ZW50WzBdWzBdLCBleHRlbnRbMF1bMV1dLCBbZXh0ZW50WzFdWzBdLCBleHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB2b3Jvbm9pLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gXyA9PSBudWxsID8gbnVsbCA6IFtbMCwgMF0sIFsrX1swXSwgK19bMV1dXSwgdm9yb25vaSkgOiBleHRlbnQgJiYgW2V4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSwgZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdXTtcbiAgfTtcblxuICByZXR1cm4gdm9yb25vaTtcbn07XG5cbnZhciBjb25zdGFudCQxMiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxuZnVuY3Rpb24gWm9vbUV2ZW50KHRhcmdldCwgdHlwZSwgdHJhbnNmb3JtKSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKGssIHgsIHkpIHtcbiAgdGhpcy5rID0gaztcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybSxcbiAgc2NhbGU6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gayA9PT0gMSA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuayAqIGssIHRoaXMueCwgdGhpcy55KTtcbiAgfSxcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHggPT09IDAgJiB5ID09PSAwID8gdGhpcyA6IG5ldyBUcmFuc2Zvcm0odGhpcy5rLCB0aGlzLnggKyB0aGlzLmsgKiB4LCB0aGlzLnkgKyB0aGlzLmsgKiB5KTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIFtwb2ludFswXSAqIHRoaXMuayArIHRoaXMueCwgcG9pbnRbMV0gKiB0aGlzLmsgKyB0aGlzLnldO1xuICB9LFxuICBhcHBseVg6IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCAqIHRoaXMuayArIHRoaXMueDtcbiAgfSxcbiAgYXBwbHlZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkgKiB0aGlzLmsgKyB0aGlzLnk7XG4gIH0sXG4gIGludmVydDogZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICByZXR1cm4gWyhsb2NhdGlvblswXSAtIHRoaXMueCkgLyB0aGlzLmssIChsb2NhdGlvblsxXSAtIHRoaXMueSkgLyB0aGlzLmtdO1xuICB9LFxuICBpbnZlcnRYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuICh4IC0gdGhpcy54KSAvIHRoaXMuaztcbiAgfSxcbiAgaW52ZXJ0WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiAoeSAtIHRoaXMueSkgLyB0aGlzLms7XG4gIH0sXG4gIHJlc2NhbGVYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHguY29weSgpLmRvbWFpbih4LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WCwgdGhpcykubWFwKHguaW52ZXJ0LCB4KSk7XG4gIH0sXG4gIHJlc2NhbGVZOiBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIHkuY29weSgpLmRvbWFpbih5LnJhbmdlKCkubWFwKHRoaXMuaW52ZXJ0WSwgdGhpcykubWFwKHkuaW52ZXJ0LCB5KSk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiKSBzY2FsZShcIiArIHRoaXMuayArIFwiKVwiO1xuICB9XG59O1xuXG52YXIgaWRlbnRpdHkkOCA9IG5ldyBUcmFuc2Zvcm0oMSwgMCwgMCk7XG5cbnRyYW5zZm9ybSQxLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX196b29tIHx8IGlkZW50aXR5JDg7XG59XG5cbmZ1bmN0aW9uIG5vcHJvcGFnYXRpb24kMigpIHtcbiAgZXhwb3J0cy5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxudmFyIG5vZXZlbnQkMiA9IGZ1bmN0aW9uKCkge1xuICBleHBvcnRzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV4cG9ydHMuZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59O1xuXG4vLyBJZ25vcmUgcmlnaHQtY2xpY2ssIHNpbmNlIHRoYXQgc2hvdWxkIG9wZW4gdGhlIGNvbnRleHQgbWVudS5cbmZ1bmN0aW9uIGRlZmF1bHRGaWx0ZXIkMigpIHtcbiAgcmV0dXJuICFleHBvcnRzLmV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCQxKCkge1xuICB2YXIgZSA9IHRoaXMsIHcsIGg7XG4gIGlmIChlIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIGUgPSBlLm93bmVyU1ZHRWxlbWVudCB8fCBlO1xuICAgIHcgPSBlLndpZHRoLmJhc2VWYWwudmFsdWU7XG4gICAgaCA9IGUuaGVpZ2h0LmJhc2VWYWwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdyA9IGUuY2xpZW50V2lkdGg7XG4gICAgaCA9IGUuY2xpZW50SGVpZ2h0O1xuICB9XG4gIHJldHVybiBbWzAsIDBdLCBbdywgaF1dO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VHJhbnNmb3JtKCkge1xuICByZXR1cm4gdGhpcy5fX3pvb20gfHwgaWRlbnRpdHkkODtcbn1cblxudmFyIHpvb20gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIkMixcbiAgICAgIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQkMSxcbiAgICAgIGswID0gMCxcbiAgICAgIGsxID0gSW5maW5pdHksXG4gICAgICB4MCA9IC1rMSxcbiAgICAgIHgxID0gazEsXG4gICAgICB5MCA9IHgwLFxuICAgICAgeTEgPSB4MSxcbiAgICAgIGR1cmF0aW9uID0gMjUwLFxuICAgICAgaW50ZXJwb2xhdGUkJDEgPSBpbnRlcnBvbGF0ZVpvb20sXG4gICAgICBnZXN0dXJlcyA9IFtdLFxuICAgICAgbGlzdGVuZXJzID0gZGlzcGF0Y2goXCJzdGFydFwiLCBcInpvb21cIiwgXCJlbmRcIiksXG4gICAgICB0b3VjaHN0YXJ0aW5nLFxuICAgICAgdG91Y2hlbmRpbmcsXG4gICAgICB0b3VjaERlbGF5ID0gNTAwLFxuICAgICAgd2hlZWxEZWxheSA9IDE1MCxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiB6b29tKHNlbGVjdGlvbiQkMSkge1xuICAgIHNlbGVjdGlvbiQkMVxuICAgICAgICAub24oXCJ3aGVlbC56b29tXCIsIHdoZWVsZWQpXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi56b29tXCIsIG1vdXNlZG93bmVkKVxuICAgICAgICAub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpXG4gICAgICAgIC5vbihcInRvdWNoc3RhcnQuem9vbVwiLCB0b3VjaHN0YXJ0ZWQpXG4gICAgICAgIC5vbihcInRvdWNobW92ZS56b29tXCIsIHRvdWNobW92ZWQpXG4gICAgICAgIC5vbihcInRvdWNoZW5kLnpvb20gdG91Y2hjYW5jZWwuem9vbVwiLCB0b3VjaGVuZGVkKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKTtcbiAgfVxuXG4gIHpvb20udHJhbnNmb3JtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdHJhbnNmb3JtKSB7XG4gICAgdmFyIHNlbGVjdGlvbiQkMSA9IGNvbGxlY3Rpb24uc2VsZWN0aW9uID8gY29sbGVjdGlvbi5zZWxlY3Rpb24oKSA6IGNvbGxlY3Rpb247XG4gICAgc2VsZWN0aW9uJCQxLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pO1xuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24kJDEpIHtcbiAgICAgIHNjaGVkdWxlKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbiQkMS5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAuem9vbShudWxsLCB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRyYW5zZm9ybSlcbiAgICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24kJDEsIGspIHtcbiAgICB6b29tLnNjYWxlVG8oc2VsZWN0aW9uJCQxLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrMCA9IHRoaXMuX196b29tLmssXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBrMCAqIGsxO1xuICAgIH0pO1xuICB9O1xuXG4gIHpvb20uc2NhbGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiQkMSwgaykge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiQkMSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBjZW50cm9pZChlKSxcbiAgICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24kJDEsIHgsIHkpIHtcbiAgICB6b29tLnRyYW5zZm9ybShzZWxlY3Rpb24kJDEsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbih0aGlzLl9fem9vbS50cmFuc2xhdGUoXG4gICAgICAgIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB4LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8geS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogeVxuICAgICAgKSwgZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSwgaykge1xuICAgIGsgPSBNYXRoLm1heChrMCwgTWF0aC5taW4oazEsIGspKTtcbiAgICByZXR1cm4gayA9PT0gdHJhbnNmb3JtLmsgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKGssIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0ueSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtLCBwMCwgcDEpIHtcbiAgICB2YXIgeCA9IHAwWzBdIC0gcDFbMF0gKiB0cmFuc2Zvcm0uaywgeSA9IHAwWzFdIC0gcDFbMV0gKiB0cmFuc2Zvcm0uaztcbiAgICByZXR1cm4geCA9PT0gdHJhbnNmb3JtLnggJiYgeSA9PT0gdHJhbnNmb3JtLnkgPyB0cmFuc2Zvcm0gOiBuZXcgVHJhbnNmb3JtKHRyYW5zZm9ybS5rLCB4LCB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cmFpbih0cmFuc2Zvcm0sIGV4dGVudCkge1xuICAgIHZhciBkeDAgPSB0cmFuc2Zvcm0uaW52ZXJ0WChleHRlbnRbMF1bMF0pIC0geDAsXG4gICAgICAgIGR4MSA9IHRyYW5zZm9ybS5pbnZlcnRYKGV4dGVudFsxXVswXSkgLSB4MSxcbiAgICAgICAgZHkwID0gdHJhbnNmb3JtLmludmVydFkoZXh0ZW50WzBdWzFdKSAtIHkwLFxuICAgICAgICBkeTEgPSB0cmFuc2Zvcm0uaW52ZXJ0WShleHRlbnRbMV1bMV0pIC0geTE7XG4gICAgcmV0dXJuIHRyYW5zZm9ybS50cmFuc2xhdGUoXG4gICAgICBkeDEgPiBkeDAgPyAoZHgwICsgZHgxKSAvIDIgOiBNYXRoLm1pbigwLCBkeDApIHx8IE1hdGgubWF4KDAsIGR4MSksXG4gICAgICBkeTEgPiBkeTAgPyAoZHkwICsgZHkxKSAvIDIgOiBNYXRoLm1pbigwLCBkeTApIHx8IE1hdGgubWF4KDAsIGR5MSlcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY2VudHJvaWQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIFsoK2V4dGVudFswXVswXSArICtleHRlbnRbMV1bMF0pIC8gMiwgKCtleHRlbnRbMF1bMV0gKyArZXh0ZW50WzFdWzFdKSAvIDJdO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGUodHJhbnNpdGlvbiQkMSwgdHJhbnNmb3JtLCBjZW50ZXIpIHtcbiAgICB0cmFuc2l0aW9uJCQxXG4gICAgICAgIC5vbihcInN0YXJ0Lnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5zdGFydCgpOyB9KVxuICAgICAgICAub24oXCJpbnRlcnJ1cHQuem9vbSBlbmQuem9vbVwiLCBmdW5jdGlvbigpIHsgZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLmVuZCgpOyB9KVxuICAgICAgICAudHdlZW4oXCJ6b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgZyA9IGdlc3R1cmUodGhhdCwgYXJncyksXG4gICAgICAgICAgICAgIGUgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyksXG4gICAgICAgICAgICAgIHAgPSBjZW50ZXIgfHwgY2VudHJvaWQoZSksXG4gICAgICAgICAgICAgIHcgPSBNYXRoLm1heChlWzFdWzBdIC0gZVswXVswXSwgZVsxXVsxXSAtIGVbMF1bMV0pLFxuICAgICAgICAgICAgICBhID0gdGhhdC5fX3pvb20sXG4gICAgICAgICAgICAgIGIgPSB0eXBlb2YgdHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0uYXBwbHkodGhhdCwgYXJncykgOiB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgIGkgPSBpbnRlcnBvbGF0ZSQkMShhLmludmVydChwKS5jb25jYXQodyAvIGEuayksIGIuaW52ZXJ0KHApLmNvbmNhdCh3IC8gYi5rKSk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgIGlmICh0ID09PSAxKSB0ID0gYjsgLy8gQXZvaWQgcm91bmRpbmcgZXJyb3Igb24gZW5kLlxuICAgICAgICAgICAgZWxzZSB7IHZhciBsID0gaSh0KSwgayA9IHcgLyBsWzJdOyB0ID0gbmV3IFRyYW5zZm9ybShrLCBwWzBdIC0gbFswXSAqIGssIHBbMV0gLSBsWzFdICogayk7IH1cbiAgICAgICAgICAgIGcuem9vbShudWxsLCB0KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlc3R1cmUodGhhdCwgYXJncykge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gZ2VzdHVyZXMubGVuZ3RoLCBnOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKGcgPSBnZXN0dXJlc1tpXSkudGhhdCA9PT0gdGhhdCkge1xuICAgICAgICByZXR1cm4gZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHZXN0dXJlKHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gR2VzdHVyZSh0aGF0LCBhcmdzKSB7XG4gICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgdGhpcy5leHRlbnQgPSBleHRlbnQuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cblxuICBHZXN0dXJlLnByb3RvdHlwZSA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKyt0aGlzLmFjdGl2ZSA9PT0gMSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gZ2VzdHVyZXMucHVzaCh0aGlzKSAtIDE7XG4gICAgICAgIHRoaXMuZW1pdChcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbihrZXksIHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRoaXMubW91c2UgJiYga2V5ICE9PSBcIm1vdXNlXCIpIHRoaXMubW91c2VbMV0gPSB0cmFuc2Zvcm0uaW52ZXJ0KHRoaXMubW91c2VbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gwICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMFsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDBbMF0pO1xuICAgICAgaWYgKHRoaXMudG91Y2gxICYmIGtleSAhPT0gXCJ0b3VjaFwiKSB0aGlzLnRvdWNoMVsxXSA9IHRyYW5zZm9ybS5pbnZlcnQodGhpcy50b3VjaDFbMF0pO1xuICAgICAgdGhpcy50aGF0Ll9fem9vbSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuZW1pdChcInpvb21cIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICBnZXN0dXJlcy5zcGxpY2UodGhpcy5pbmRleCwgMSk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBjdXN0b21FdmVudChuZXcgWm9vbUV2ZW50KHpvb20sIHR5cGUsIHRoaXMudGhhdC5fX3pvb20pLCBsaXN0ZW5lcnMuYXBwbHksIGxpc3RlbmVycywgW3R5cGUsIHRoaXMudGhhdCwgdGhpcy5hcmdzXSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHdoZWVsZWQoKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB0ID0gdGhpcy5fX3pvb20sXG4gICAgICAgIGsgPSBNYXRoLm1heChrMCwgTWF0aC5taW4oazEsIHQuayAqIE1hdGgucG93KDIsIC1leHBvcnRzLmV2ZW50LmRlbHRhWSAqIChleHBvcnRzLmV2ZW50LmRlbHRhTW9kZSA/IDEyMCA6IDEpIC8gNTAwKSkpLFxuICAgICAgICBwID0gbW91c2UodGhpcyk7XG5cbiAgICAvLyBJZiB0aGUgbW91c2UgaXMgaW4gdGhlIHNhbWUgbG9jYXRpb24gYXMgYmVmb3JlLCByZXVzZSBpdC5cbiAgICAvLyBJZiB0aGVyZSB3ZXJlIHJlY2VudCB3aGVlbCBldmVudHMsIHJlc2V0IHRoZSB3aGVlbCBpZGxlIHRpbWVvdXQuXG4gICAgaWYgKGcud2hlZWwpIHtcbiAgICAgIGlmIChnLm1vdXNlWzBdWzBdICE9PSBwWzBdIHx8IGcubW91c2VbMF1bMV0gIT09IHBbMV0pIHtcbiAgICAgICAgZy5tb3VzZVsxXSA9IHQuaW52ZXJ0KGcubW91c2VbMF0gPSBwKTtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dChnLndoZWVsKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGlzIHdoZWVsIGV2ZW50IHdvbuKAmXQgdHJpZ2dlciBhIHRyYW5zZm9ybSBjaGFuZ2UsIGlnbm9yZSBpdC5cbiAgICBlbHNlIGlmICh0LmsgPT09IGspIHJldHVybjtcblxuICAgIC8vIE90aGVyd2lzZSwgY2FwdHVyZSB0aGUgbW91c2UgcG9pbnQgYW5kIGxvY2F0aW9uIGF0IHRoZSBzdGFydC5cbiAgICBlbHNlIHtcbiAgICAgIGcubW91c2UgPSBbcCwgdC5pbnZlcnQocCldO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cblxuICAgIG5vZXZlbnQkMigpO1xuICAgIGcud2hlZWwgPSBzZXRUaW1lb3V0KHdoZWVsaWRsZWQsIHdoZWVsRGVsYXkpO1xuICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoc2NhbGUodCwgayksIGcubW91c2VbMF0sIGcubW91c2VbMV0pLCBnLmV4dGVudCkpO1xuXG4gICAgZnVuY3Rpb24gd2hlZWxpZGxlZCgpIHtcbiAgICAgIGcud2hlZWwgPSBudWxsO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZCgpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHYgPSBzZWxlY3QoZXhwb3J0cy5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS56b29tXCIsIG1vdXNlbW92ZWQsIHRydWUpLm9uKFwibW91c2V1cC56b29tXCIsIG1vdXNldXBwZWQsIHRydWUpLFxuICAgICAgICBwID0gbW91c2UodGhpcyksXG4gICAgICAgIHgwID0gZXhwb3J0cy5ldmVudC5jbGllbnRYLFxuICAgICAgICB5MCA9IGV4cG9ydHMuZXZlbnQuY2xpZW50WTtcblxuICAgIGRyYWdEaXNhYmxlKGV4cG9ydHMuZXZlbnQudmlldyk7XG4gICAgbm9wcm9wYWdhdGlvbiQyKCk7XG4gICAgZy5tb3VzZSA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCldO1xuICAgIGludGVycnVwdCh0aGlzKTtcbiAgICBnLnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmVkKCkge1xuICAgICAgbm9ldmVudCQyKCk7XG4gICAgICBpZiAoIWcubW92ZWQpIHtcbiAgICAgICAgdmFyIGR4ID0gZXhwb3J0cy5ldmVudC5jbGllbnRYIC0geDAsIGR5ID0gZXhwb3J0cy5ldmVudC5jbGllbnRZIC0geTA7XG4gICAgICAgIGcubW92ZWQgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgICAgfVxuICAgICAgZy56b29tKFwibW91c2VcIiwgY29uc3RyYWluKHRyYW5zbGF0ZShnLnRoYXQuX196b29tLCBnLm1vdXNlWzBdID0gbW91c2UoZy50aGF0KSwgZy5tb3VzZVsxXSksIGcuZXh0ZW50KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XG4gICAgICB5ZXNkcmFnKGV4cG9ydHMuZXZlbnQudmlldywgZy5tb3ZlZCk7XG4gICAgICBub2V2ZW50JDIoKTtcbiAgICAgIGcuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGJsY2xpY2tlZCgpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgIHAwID0gbW91c2UodGhpcyksXG4gICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgazEgPSB0MC5rICogKGV4cG9ydHMuZXZlbnQuc2hpZnRLZXkgPyAwLjUgOiAyKSxcbiAgICAgICAgdDEgPSBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIG5vZXZlbnQkMigpO1xuICAgIGlmIChkdXJhdGlvbiA+IDApIHNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoc2NoZWR1bGUsIHQxLCBwMCk7XG4gICAgZWxzZSBzZWxlY3QodGhpcykuY2FsbCh6b29tLnRyYW5zZm9ybSwgdDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hzdGFydGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgdG91Y2hlcyQkMSA9IGV4cG9ydHMuZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIHN0YXJ0ZWQsXG4gICAgICAgIG4gPSB0b3VjaGVzJCQxLmxlbmd0aCwgaSwgdCwgcDtcblxuICAgIG5vcHJvcGFnYXRpb24kMigpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzJCQxW2ldLCBwID0gdG91Y2godGhpcywgdG91Y2hlcyQkMSwgdC5pZGVudGlmaWVyKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSkgZy50b3VjaDEgPSBwO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgYSBkYmx0YXAsIHJlcm91dGUgdG8gdGhlIChvcHRpb25hbCkgZGJsY2xpY2suem9vbSBoYW5kbGVyLlxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB7XG4gICAgICB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuICAgICAgaWYgKCFnLnRvdWNoMSkge1xuICAgICAgICBnLmVuZCgpO1xuICAgICAgICBwID0gc2VsZWN0KHRoaXMpLm9uKFwiZGJsY2xpY2suem9vbVwiKTtcbiAgICAgICAgaWYgKHApIHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydGVkKSB7XG4gICAgICB0b3VjaHN0YXJ0aW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hzdGFydGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgICAgaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoKSB7XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHRvdWNoZXMkJDEgPSBleHBvcnRzLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcyQkMS5sZW5ndGgsIGksIHQsIHAsIGw7XG5cbiAgICBub2V2ZW50JDIoKTtcbiAgICBpZiAodG91Y2hzdGFydGluZykgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlcyQkMVtpXSwgcCA9IHRvdWNoKHRoaXMsIHRvdWNoZXMkJDEsIHQuaWRlbnRpZmllcik7XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDBbMF0gPSBwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDFbMF0gPSBwO1xuICAgIH1cbiAgICB0ID0gZy50aGF0Ll9fem9vbTtcbiAgICBpZiAoZy50b3VjaDEpIHtcbiAgICAgIHZhciBwMCA9IGcudG91Y2gwWzBdLCBsMCA9IGcudG91Y2gwWzFdLFxuICAgICAgICAgIHAxID0gZy50b3VjaDFbMF0sIGwxID0gZy50b3VjaDFbMV0sXG4gICAgICAgICAgZHAgPSAoZHAgPSBwMVswXSAtIHAwWzBdKSAqIGRwICsgKGRwID0gcDFbMV0gLSBwMFsxXSkgKiBkcCxcbiAgICAgICAgICBkbCA9IChkbCA9IGwxWzBdIC0gbDBbMF0pICogZGwgKyAoZGwgPSBsMVsxXSAtIGwwWzFdKSAqIGRsO1xuICAgICAgdCA9IHNjYWxlKHQsIE1hdGguc3FydChkcCAvIGRsKSk7XG4gICAgICBwID0gWyhwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDJdO1xuICAgICAgbCA9IFsobDBbMF0gKyBsMVswXSkgLyAyLCAobDBbMV0gKyBsMVsxXSkgLyAyXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZy50b3VjaDApIHAgPSBnLnRvdWNoMFswXSwgbCA9IGcudG91Y2gwWzFdO1xuICAgIGVsc2UgcmV0dXJuO1xuICAgIGcuem9vbShcInRvdWNoXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUodCwgcCwgbCksIGcuZXh0ZW50KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaGVuZGVkKCkge1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB0b3VjaGVzJCQxID0gZXhwb3J0cy5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMkJDEubGVuZ3RoLCBpLCB0O1xuXG4gICAgbm9wcm9wYWdhdGlvbiQyKCk7XG4gICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgIHRvdWNoZW5kaW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hlbmRpbmcgPSBudWxsOyB9LCB0b3VjaERlbGF5KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlcyQkMVtpXTtcbiAgICAgIGlmIChnLnRvdWNoMCAmJiBnLnRvdWNoMFsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDA7XG4gICAgICBlbHNlIGlmIChnLnRvdWNoMSAmJiBnLnRvdWNoMVsyXSA9PT0gdC5pZGVudGlmaWVyKSBkZWxldGUgZy50b3VjaDE7XG4gICAgfVxuICAgIGlmIChnLnRvdWNoMSAmJiAhZy50b3VjaDApIGcudG91Y2gwID0gZy50b3VjaDEsIGRlbGV0ZSBnLnRvdWNoMTtcbiAgICBpZiAoZy50b3VjaDApIGcudG91Y2gwWzFdID0gdGhpcy5fX3pvb20uaW52ZXJ0KGcudG91Y2gwWzBdKTtcbiAgICBlbHNlIGcuZW5kKCk7XG4gIH1cblxuICB6b29tLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50JDEyKCEhXyksIHpvb20pIDogZmlsdGVyO1xuICB9O1xuXG4gIHpvb20uZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQkMTIoW1srX1swXVswXSwgK19bMF1bMV1dLCBbK19bMV1bMF0sICtfWzFdWzFdXV0pLCB6b29tKSA6IGV4dGVudDtcbiAgfTtcblxuICB6b29tLnNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGswID0gK19bMF0sIGsxID0gK19bMV0sIHpvb20pIDogW2swLCBrMV07XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXVswXSwgeDEgPSArX1sxXVswXSwgeTAgPSArX1swXVsxXSwgeTEgPSArX1sxXVsxXSwgem9vbSkgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcblxuICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR1cmF0aW9uID0gK18sIHpvb20pIDogZHVyYXRpb247XG4gIH07XG5cbiAgem9vbS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSQkMSA9IF8sIHpvb20pIDogaW50ZXJwb2xhdGUkJDE7XG4gIH07XG5cbiAgem9vbS5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyB6b29tIDogdmFsdWU7XG4gIH07XG5cbiAgem9vbS5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCB6b29tKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG4gICAgXG4gIHJldHVybiB6b29tO1xufTtcblxuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmV4cG9ydHMuYmlzZWN0ID0gYmlzZWN0UmlnaHQ7XG5leHBvcnRzLmJpc2VjdFJpZ2h0ID0gYmlzZWN0UmlnaHQ7XG5leHBvcnRzLmJpc2VjdExlZnQgPSBiaXNlY3RMZWZ0O1xuZXhwb3J0cy5hc2NlbmRpbmcgPSBhc2NlbmRpbmc7XG5leHBvcnRzLmJpc2VjdG9yID0gYmlzZWN0b3I7XG5leHBvcnRzLmNyb3NzID0gY3Jvc3M7XG5leHBvcnRzLmRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nO1xuZXhwb3J0cy5kZXZpYXRpb24gPSBkZXZpYXRpb247XG5leHBvcnRzLmV4dGVudCA9IGV4dGVudDtcbmV4cG9ydHMuaGlzdG9ncmFtID0gaGlzdG9ncmFtO1xuZXhwb3J0cy50aHJlc2hvbGRGcmVlZG1hbkRpYWNvbmlzID0gZnJlZWRtYW5EaWFjb25pcztcbmV4cG9ydHMudGhyZXNob2xkU2NvdHQgPSBzY290dDtcbmV4cG9ydHMudGhyZXNob2xkU3R1cmdlcyA9IHN0dXJnZXM7XG5leHBvcnRzLm1heCA9IG1heDtcbmV4cG9ydHMubWVhbiA9IG1lYW47XG5leHBvcnRzLm1lZGlhbiA9IG1lZGlhbjtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMubWluID0gbWluO1xuZXhwb3J0cy5wYWlycyA9IHBhaXJzO1xuZXhwb3J0cy5wZXJtdXRlID0gcGVybXV0ZTtcbmV4cG9ydHMucXVhbnRpbGUgPSB0aHJlc2hvbGQ7XG5leHBvcnRzLnJhbmdlID0gc2VxdWVuY2U7XG5leHBvcnRzLnNjYW4gPSBzY2FuO1xuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbmV4cG9ydHMuc3VtID0gc3VtO1xuZXhwb3J0cy50aWNrcyA9IHRpY2tzO1xuZXhwb3J0cy50aWNrSW5jcmVtZW50ID0gdGlja0luY3JlbWVudDtcbmV4cG9ydHMudGlja1N0ZXAgPSB0aWNrU3RlcDtcbmV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuZXhwb3J0cy52YXJpYW5jZSA9IHZhcmlhbmNlO1xuZXhwb3J0cy56aXAgPSB6aXA7XG5leHBvcnRzLmF4aXNUb3AgPSBheGlzVG9wO1xuZXhwb3J0cy5heGlzUmlnaHQgPSBheGlzUmlnaHQ7XG5leHBvcnRzLmF4aXNCb3R0b20gPSBheGlzQm90dG9tO1xuZXhwb3J0cy5heGlzTGVmdCA9IGF4aXNMZWZ0O1xuZXhwb3J0cy5icnVzaCA9IGJydXNoO1xuZXhwb3J0cy5icnVzaFggPSBicnVzaFg7XG5leHBvcnRzLmJydXNoWSA9IGJydXNoWTtcbmV4cG9ydHMuYnJ1c2hTZWxlY3Rpb24gPSBicnVzaFNlbGVjdGlvbjtcbmV4cG9ydHMuY2hvcmQgPSBjaG9yZDtcbmV4cG9ydHMucmliYm9uID0gcmliYm9uO1xuZXhwb3J0cy5uZXN0ID0gbmVzdDtcbmV4cG9ydHMuc2V0ID0gc2V0JDI7XG5leHBvcnRzLm1hcCA9IG1hcCQxO1xuZXhwb3J0cy5rZXlzID0ga2V5cztcbmV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuZXhwb3J0cy5lbnRyaWVzID0gZW50cmllcztcbmV4cG9ydHMuY29sb3IgPSBjb2xvcjtcbmV4cG9ydHMucmdiID0gcmdiO1xuZXhwb3J0cy5oc2wgPSBoc2w7XG5leHBvcnRzLmxhYiA9IGxhYjtcbmV4cG9ydHMuaGNsID0gaGNsO1xuZXhwb3J0cy5jdWJlaGVsaXggPSBjdWJlaGVsaXg7XG5leHBvcnRzLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5leHBvcnRzLmRyYWcgPSBkcmFnO1xuZXhwb3J0cy5kcmFnRGlzYWJsZSA9IGRyYWdEaXNhYmxlO1xuZXhwb3J0cy5kcmFnRW5hYmxlID0geWVzZHJhZztcbmV4cG9ydHMuZHN2Rm9ybWF0ID0gZHN2O1xuZXhwb3J0cy5jc3ZQYXJzZSA9IGNzdlBhcnNlO1xuZXhwb3J0cy5jc3ZQYXJzZVJvd3MgPSBjc3ZQYXJzZVJvd3M7XG5leHBvcnRzLmNzdkZvcm1hdCA9IGNzdkZvcm1hdDtcbmV4cG9ydHMuY3N2Rm9ybWF0Um93cyA9IGNzdkZvcm1hdFJvd3M7XG5leHBvcnRzLnRzdlBhcnNlID0gdHN2UGFyc2U7XG5leHBvcnRzLnRzdlBhcnNlUm93cyA9IHRzdlBhcnNlUm93cztcbmV4cG9ydHMudHN2Rm9ybWF0ID0gdHN2Rm9ybWF0O1xuZXhwb3J0cy50c3ZGb3JtYXRSb3dzID0gdHN2Rm9ybWF0Um93cztcbmV4cG9ydHMuZWFzZUxpbmVhciA9IGxpbmVhciQxO1xuZXhwb3J0cy5lYXNlUXVhZCA9IHF1YWRJbk91dDtcbmV4cG9ydHMuZWFzZVF1YWRJbiA9IHF1YWRJbjtcbmV4cG9ydHMuZWFzZVF1YWRPdXQgPSBxdWFkT3V0O1xuZXhwb3J0cy5lYXNlUXVhZEluT3V0ID0gcXVhZEluT3V0O1xuZXhwb3J0cy5lYXNlQ3ViaWMgPSBjdWJpY0luT3V0O1xuZXhwb3J0cy5lYXNlQ3ViaWNJbiA9IGN1YmljSW47XG5leHBvcnRzLmVhc2VDdWJpY091dCA9IGN1YmljT3V0O1xuZXhwb3J0cy5lYXNlQ3ViaWNJbk91dCA9IGN1YmljSW5PdXQ7XG5leHBvcnRzLmVhc2VQb2x5ID0gcG9seUluT3V0O1xuZXhwb3J0cy5lYXNlUG9seUluID0gcG9seUluO1xuZXhwb3J0cy5lYXNlUG9seU91dCA9IHBvbHlPdXQ7XG5leHBvcnRzLmVhc2VQb2x5SW5PdXQgPSBwb2x5SW5PdXQ7XG5leHBvcnRzLmVhc2VTaW4gPSBzaW5Jbk91dDtcbmV4cG9ydHMuZWFzZVNpbkluID0gc2luSW47XG5leHBvcnRzLmVhc2VTaW5PdXQgPSBzaW5PdXQ7XG5leHBvcnRzLmVhc2VTaW5Jbk91dCA9IHNpbkluT3V0O1xuZXhwb3J0cy5lYXNlRXhwID0gZXhwSW5PdXQ7XG5leHBvcnRzLmVhc2VFeHBJbiA9IGV4cEluO1xuZXhwb3J0cy5lYXNlRXhwT3V0ID0gZXhwT3V0O1xuZXhwb3J0cy5lYXNlRXhwSW5PdXQgPSBleHBJbk91dDtcbmV4cG9ydHMuZWFzZUNpcmNsZSA9IGNpcmNsZUluT3V0O1xuZXhwb3J0cy5lYXNlQ2lyY2xlSW4gPSBjaXJjbGVJbjtcbmV4cG9ydHMuZWFzZUNpcmNsZU91dCA9IGNpcmNsZU91dDtcbmV4cG9ydHMuZWFzZUNpcmNsZUluT3V0ID0gY2lyY2xlSW5PdXQ7XG5leHBvcnRzLmVhc2VCb3VuY2UgPSBib3VuY2VPdXQ7XG5leHBvcnRzLmVhc2VCb3VuY2VJbiA9IGJvdW5jZUluO1xuZXhwb3J0cy5lYXNlQm91bmNlT3V0ID0gYm91bmNlT3V0O1xuZXhwb3J0cy5lYXNlQm91bmNlSW5PdXQgPSBib3VuY2VJbk91dDtcbmV4cG9ydHMuZWFzZUJhY2sgPSBiYWNrSW5PdXQ7XG5leHBvcnRzLmVhc2VCYWNrSW4gPSBiYWNrSW47XG5leHBvcnRzLmVhc2VCYWNrT3V0ID0gYmFja091dDtcbmV4cG9ydHMuZWFzZUJhY2tJbk91dCA9IGJhY2tJbk91dDtcbmV4cG9ydHMuZWFzZUVsYXN0aWMgPSBlbGFzdGljT3V0O1xuZXhwb3J0cy5lYXNlRWxhc3RpY0luID0gZWxhc3RpY0luO1xuZXhwb3J0cy5lYXNlRWxhc3RpY091dCA9IGVsYXN0aWNPdXQ7XG5leHBvcnRzLmVhc2VFbGFzdGljSW5PdXQgPSBlbGFzdGljSW5PdXQ7XG5leHBvcnRzLmZvcmNlQ2VudGVyID0gY2VudGVyJDE7XG5leHBvcnRzLmZvcmNlQ29sbGlkZSA9IGNvbGxpZGU7XG5leHBvcnRzLmZvcmNlTGluayA9IGxpbms7XG5leHBvcnRzLmZvcmNlTWFueUJvZHkgPSBtYW55Qm9keTtcbmV4cG9ydHMuZm9yY2VTaW11bGF0aW9uID0gc2ltdWxhdGlvbjtcbmV4cG9ydHMuZm9yY2VYID0geCQyO1xuZXhwb3J0cy5mb3JjZVkgPSB5JDI7XG5leHBvcnRzLmZvcm1hdERlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuZXhwb3J0cy5mb3JtYXRMb2NhbGUgPSBmb3JtYXRMb2NhbGU7XG5leHBvcnRzLmZvcm1hdFNwZWNpZmllciA9IGZvcm1hdFNwZWNpZmllcjtcbmV4cG9ydHMucHJlY2lzaW9uRml4ZWQgPSBwcmVjaXNpb25GaXhlZDtcbmV4cG9ydHMucHJlY2lzaW9uUHJlZml4ID0gcHJlY2lzaW9uUHJlZml4O1xuZXhwb3J0cy5wcmVjaXNpb25Sb3VuZCA9IHByZWNpc2lvblJvdW5kO1xuZXhwb3J0cy5nZW9BcmVhID0gYXJlYTtcbmV4cG9ydHMuZ2VvQm91bmRzID0gYm91bmRzO1xuZXhwb3J0cy5nZW9DZW50cm9pZCA9IGNlbnRyb2lkO1xuZXhwb3J0cy5nZW9DaXJjbGUgPSBjaXJjbGU7XG5leHBvcnRzLmdlb0NsaXBFeHRlbnQgPSBleHRlbnQkMTtcbmV4cG9ydHMuZ2VvQ29udGFpbnMgPSBjb250YWlucztcbmV4cG9ydHMuZ2VvRGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuZ2VvR3JhdGljdWxlID0gZ3JhdGljdWxlO1xuZXhwb3J0cy5nZW9HcmF0aWN1bGUxMCA9IGdyYXRpY3VsZTEwO1xuZXhwb3J0cy5nZW9JbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlJDE7XG5leHBvcnRzLmdlb0xlbmd0aCA9IGxlbmd0aCQxO1xuZXhwb3J0cy5nZW9QYXRoID0gaW5kZXgkMTtcbmV4cG9ydHMuZ2VvQWxiZXJzID0gYWxiZXJzO1xuZXhwb3J0cy5nZW9BbGJlcnNVc2EgPSBhbGJlcnNVc2E7XG5leHBvcnRzLmdlb0F6aW11dGhhbEVxdWFsQXJlYSA9IGF6aW11dGhhbEVxdWFsQXJlYTtcbmV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1YWxBcmVhUmF3ID0gYXppbXV0aGFsRXF1YWxBcmVhUmF3O1xuZXhwb3J0cy5nZW9BemltdXRoYWxFcXVpZGlzdGFudCA9IGF6aW11dGhhbEVxdWlkaXN0YW50O1xuZXhwb3J0cy5nZW9BemltdXRoYWxFcXVpZGlzdGFudFJhdyA9IGF6aW11dGhhbEVxdWlkaXN0YW50UmF3O1xuZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbCA9IGNvbmljQ29uZm9ybWFsO1xuZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbFJhdyA9IGNvbmljQ29uZm9ybWFsUmF3O1xuZXhwb3J0cy5nZW9Db25pY0VxdWFsQXJlYSA9IGNvbmljRXF1YWxBcmVhO1xuZXhwb3J0cy5nZW9Db25pY0VxdWFsQXJlYVJhdyA9IGNvbmljRXF1YWxBcmVhUmF3O1xuZXhwb3J0cy5nZW9Db25pY0VxdWlkaXN0YW50ID0gY29uaWNFcXVpZGlzdGFudDtcbmV4cG9ydHMuZ2VvQ29uaWNFcXVpZGlzdGFudFJhdyA9IGNvbmljRXF1aWRpc3RhbnRSYXc7XG5leHBvcnRzLmdlb0VxdWlyZWN0YW5ndWxhciA9IGVxdWlyZWN0YW5ndWxhcjtcbmV4cG9ydHMuZ2VvRXF1aXJlY3Rhbmd1bGFyUmF3ID0gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuZXhwb3J0cy5nZW9Hbm9tb25pYyA9IGdub21vbmljO1xuZXhwb3J0cy5nZW9Hbm9tb25pY1JhdyA9IGdub21vbmljUmF3O1xuZXhwb3J0cy5nZW9JZGVudGl0eSA9IGlkZW50aXR5JDU7XG5leHBvcnRzLmdlb1Byb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuZXhwb3J0cy5nZW9Qcm9qZWN0aW9uTXV0YXRvciA9IHByb2plY3Rpb25NdXRhdG9yO1xuZXhwb3J0cy5nZW9NZXJjYXRvciA9IG1lcmNhdG9yO1xuZXhwb3J0cy5nZW9NZXJjYXRvclJhdyA9IG1lcmNhdG9yUmF3O1xuZXhwb3J0cy5nZW9PcnRob2dyYXBoaWMgPSBvcnRob2dyYXBoaWM7XG5leHBvcnRzLmdlb09ydGhvZ3JhcGhpY1JhdyA9IG9ydGhvZ3JhcGhpY1JhdztcbmV4cG9ydHMuZ2VvU3RlcmVvZ3JhcGhpYyA9IHN0ZXJlb2dyYXBoaWM7XG5leHBvcnRzLmdlb1N0ZXJlb2dyYXBoaWNSYXcgPSBzdGVyZW9ncmFwaGljUmF3O1xuZXhwb3J0cy5nZW9UcmFuc3ZlcnNlTWVyY2F0b3IgPSB0cmFuc3ZlcnNlTWVyY2F0b3I7XG5leHBvcnRzLmdlb1RyYW5zdmVyc2VNZXJjYXRvclJhdyA9IHRyYW5zdmVyc2VNZXJjYXRvclJhdztcbmV4cG9ydHMuZ2VvUm90YXRpb24gPSByb3RhdGlvbjtcbmV4cG9ydHMuZ2VvU3RyZWFtID0gZ2VvU3RyZWFtO1xuZXhwb3J0cy5nZW9UcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5leHBvcnRzLmNsdXN0ZXIgPSBjbHVzdGVyO1xuZXhwb3J0cy5oaWVyYXJjaHkgPSBoaWVyYXJjaHk7XG5leHBvcnRzLnBhY2sgPSBpbmRleCQyO1xuZXhwb3J0cy5wYWNrU2libGluZ3MgPSBzaWJsaW5ncztcbmV4cG9ydHMucGFja0VuY2xvc2UgPSBlbmNsb3NlO1xuZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG5leHBvcnRzLnN0cmF0aWZ5ID0gc3RyYXRpZnk7XG5leHBvcnRzLnRyZWUgPSB0cmVlO1xuZXhwb3J0cy50cmVlbWFwID0gaW5kZXgkMztcbmV4cG9ydHMudHJlZW1hcEJpbmFyeSA9IGJpbmFyeTtcbmV4cG9ydHMudHJlZW1hcERpY2UgPSB0cmVlbWFwRGljZTtcbmV4cG9ydHMudHJlZW1hcFNsaWNlID0gdHJlZW1hcFNsaWNlO1xuZXhwb3J0cy50cmVlbWFwU2xpY2VEaWNlID0gc2xpY2VEaWNlO1xuZXhwb3J0cy50cmVlbWFwU3F1YXJpZnkgPSBzcXVhcmlmeTtcbmV4cG9ydHMudHJlZW1hcFJlc3F1YXJpZnkgPSByZXNxdWFyaWZ5O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlVmFsdWU7XG5leHBvcnRzLmludGVycG9sYXRlQXJyYXkgPSBhcnJheSQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJhc2lzID0gYmFzaXMkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZCA9IGJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZURhdGUgPSBkYXRlO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU51bWJlciA9IHJlaW50ZXJwb2xhdGU7XG5leHBvcnRzLmludGVycG9sYXRlT2JqZWN0ID0gb2JqZWN0O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJvdW5kID0gaW50ZXJwb2xhdGVSb3VuZDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVTdHJpbmcgPSBpbnRlcnBvbGF0ZVN0cmluZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVUcmFuc2Zvcm1TdmcgPSBpbnRlcnBvbGF0ZVRyYW5zZm9ybVN2ZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVab29tID0gaW50ZXJwb2xhdGVab29tO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYiA9IGludGVycG9sYXRlUmdiO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJnYkJhc2lzID0gcmdiQmFzaXM7XG5leHBvcnRzLmludGVycG9sYXRlUmdiQmFzaXNDbG9zZWQgPSByZ2JCYXNpc0Nsb3NlZDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIc2wgPSBoc2wkMjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIc2xMb25nID0gaHNsTG9uZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVMYWIgPSBsYWIkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIY2wgPSBoY2wkMjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVIY2xMb25nID0gaGNsTG9uZztcbmV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXggPSBjdWJlaGVsaXgkMjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nID0gY3ViZWhlbGl4TG9uZztcbmV4cG9ydHMucXVhbnRpemUgPSBxdWFudGl6ZTtcbmV4cG9ydHMucGF0aCA9IHBhdGg7XG5leHBvcnRzLnBvbHlnb25BcmVhID0gYXJlYSQxO1xuZXhwb3J0cy5wb2x5Z29uQ2VudHJvaWQgPSBjZW50cm9pZCQxO1xuZXhwb3J0cy5wb2x5Z29uSHVsbCA9IGh1bGw7XG5leHBvcnRzLnBvbHlnb25Db250YWlucyA9IGNvbnRhaW5zJDE7XG5leHBvcnRzLnBvbHlnb25MZW5ndGggPSBsZW5ndGgkMjtcbmV4cG9ydHMucXVhZHRyZWUgPSBxdWFkdHJlZTtcbmV4cG9ydHMucXVldWUgPSBxdWV1ZTtcbmV4cG9ydHMucmFuZG9tVW5pZm9ybSA9IHVuaWZvcm07XG5leHBvcnRzLnJhbmRvbU5vcm1hbCA9IG5vcm1hbDtcbmV4cG9ydHMucmFuZG9tTG9nTm9ybWFsID0gbG9nTm9ybWFsO1xuZXhwb3J0cy5yYW5kb21CYXRlcyA9IGJhdGVzO1xuZXhwb3J0cy5yYW5kb21JcndpbkhhbGwgPSBpcndpbkhhbGw7XG5leHBvcnRzLnJhbmRvbUV4cG9uZW50aWFsID0gZXhwb25lbnRpYWwkMTtcbmV4cG9ydHMucmVxdWVzdCA9IHJlcXVlc3Q7XG5leHBvcnRzLmh0bWwgPSBodG1sO1xuZXhwb3J0cy5qc29uID0ganNvbjtcbmV4cG9ydHMudGV4dCA9IHRleHQ7XG5leHBvcnRzLnhtbCA9IHhtbDtcbmV4cG9ydHMuY3N2ID0gY3N2JDE7XG5leHBvcnRzLnRzdiA9IHRzdiQxO1xuZXhwb3J0cy5zY2FsZUJhbmQgPSBiYW5kO1xuZXhwb3J0cy5zY2FsZVBvaW50ID0gcG9pbnQkMTtcbmV4cG9ydHMuc2NhbGVJZGVudGl0eSA9IGlkZW50aXR5JDY7XG5leHBvcnRzLnNjYWxlTGluZWFyID0gbGluZWFyJDI7XG5leHBvcnRzLnNjYWxlTG9nID0gbG9nJDE7XG5leHBvcnRzLnNjYWxlT3JkaW5hbCA9IG9yZGluYWw7XG5leHBvcnRzLnNjYWxlSW1wbGljaXQgPSBpbXBsaWNpdDtcbmV4cG9ydHMuc2NhbGVQb3cgPSBwb3ckMTtcbmV4cG9ydHMuc2NhbGVTcXJ0ID0gc3FydCQxO1xuZXhwb3J0cy5zY2FsZVF1YW50aWxlID0gcXVhbnRpbGUkJDE7XG5leHBvcnRzLnNjYWxlUXVhbnRpemUgPSBxdWFudGl6ZSQxO1xuZXhwb3J0cy5zY2FsZVRocmVzaG9sZCA9IHRocmVzaG9sZCQxO1xuZXhwb3J0cy5zY2FsZVRpbWUgPSB0aW1lO1xuZXhwb3J0cy5zY2FsZVV0YyA9IHV0Y1RpbWU7XG5leHBvcnRzLnNjaGVtZUNhdGVnb3J5MTAgPSBjYXRlZ29yeTEwO1xuZXhwb3J0cy5zY2hlbWVDYXRlZ29yeTIwYiA9IGNhdGVnb3J5MjBiO1xuZXhwb3J0cy5zY2hlbWVDYXRlZ29yeTIwYyA9IGNhdGVnb3J5MjBjO1xuZXhwb3J0cy5zY2hlbWVDYXRlZ29yeTIwID0gY2F0ZWdvcnkyMDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhEZWZhdWx0ID0gY3ViZWhlbGl4JDM7XG5leHBvcnRzLmludGVycG9sYXRlUmFpbmJvdyA9IHJhaW5ib3ckMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVXYXJtID0gd2FybTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVDb29sID0gY29vbDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVWaXJpZGlzID0gdmlyaWRpcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVNYWdtYSA9IG1hZ21hO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUluZmVybm8gPSBpbmZlcm5vO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVBsYXNtYSA9IHBsYXNtYTtcbmV4cG9ydHMuc2NhbGVTZXF1ZW50aWFsID0gc2VxdWVudGlhbDtcbmV4cG9ydHMuY3JlYXRvciA9IGNyZWF0b3I7XG5leHBvcnRzLmxvY2FsID0gbG9jYWwkMTtcbmV4cG9ydHMubWF0Y2hlciA9IG1hdGNoZXIkMTtcbmV4cG9ydHMubW91c2UgPSBtb3VzZTtcbmV4cG9ydHMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuZXhwb3J0cy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcbmV4cG9ydHMuc2VsZWN0ID0gc2VsZWN0O1xuZXhwb3J0cy5zZWxlY3RBbGwgPSBzZWxlY3RBbGw7XG5leHBvcnRzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbmV4cG9ydHMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbmV4cG9ydHMuc2VsZWN0b3JBbGwgPSBzZWxlY3RvckFsbDtcbmV4cG9ydHMuc3R5bGUgPSBzdHlsZVZhbHVlO1xuZXhwb3J0cy50b3VjaCA9IHRvdWNoO1xuZXhwb3J0cy50b3VjaGVzID0gdG91Y2hlcztcbmV4cG9ydHMud2luZG93ID0gZGVmYXVsdFZpZXc7XG5leHBvcnRzLmN1c3RvbUV2ZW50ID0gY3VzdG9tRXZlbnQ7XG5leHBvcnRzLmFyYyA9IGFyYztcbmV4cG9ydHMuYXJlYSA9IGFyZWEkMjtcbmV4cG9ydHMubGluZSA9IGxpbmU7XG5leHBvcnRzLnBpZSA9IHBpZTtcbmV4cG9ydHMucmFkaWFsQXJlYSA9IHJhZGlhbEFyZWE7XG5leHBvcnRzLnJhZGlhbExpbmUgPSByYWRpYWxMaW5lJDE7XG5leHBvcnRzLmxpbmtIb3Jpem9udGFsID0gbGlua0hvcml6b250YWw7XG5leHBvcnRzLmxpbmtWZXJ0aWNhbCA9IGxpbmtWZXJ0aWNhbDtcbmV4cG9ydHMubGlua1JhZGlhbCA9IGxpbmtSYWRpYWw7XG5leHBvcnRzLnN5bWJvbCA9IHN5bWJvbDtcbmV4cG9ydHMuc3ltYm9scyA9IHN5bWJvbHM7XG5leHBvcnRzLnN5bWJvbENpcmNsZSA9IGNpcmNsZSQyO1xuZXhwb3J0cy5zeW1ib2xDcm9zcyA9IGNyb3NzJDI7XG5leHBvcnRzLnN5bWJvbERpYW1vbmQgPSBkaWFtb25kO1xuZXhwb3J0cy5zeW1ib2xTcXVhcmUgPSBzcXVhcmU7XG5leHBvcnRzLnN5bWJvbFN0YXIgPSBzdGFyO1xuZXhwb3J0cy5zeW1ib2xUcmlhbmdsZSA9IHRyaWFuZ2xlO1xuZXhwb3J0cy5zeW1ib2xXeWUgPSB3eWU7XG5leHBvcnRzLmN1cnZlQmFzaXNDbG9zZWQgPSBiYXNpc0Nsb3NlZCQxO1xuZXhwb3J0cy5jdXJ2ZUJhc2lzT3BlbiA9IGJhc2lzT3BlbjtcbmV4cG9ydHMuY3VydmVCYXNpcyA9IGJhc2lzJDI7XG5leHBvcnRzLmN1cnZlQnVuZGxlID0gYnVuZGxlO1xuZXhwb3J0cy5jdXJ2ZUNhcmRpbmFsQ2xvc2VkID0gY2FyZGluYWxDbG9zZWQ7XG5leHBvcnRzLmN1cnZlQ2FyZGluYWxPcGVuID0gY2FyZGluYWxPcGVuO1xuZXhwb3J0cy5jdXJ2ZUNhcmRpbmFsID0gY2FyZGluYWw7XG5leHBvcnRzLmN1cnZlQ2F0bXVsbFJvbUNsb3NlZCA9IGNhdG11bGxSb21DbG9zZWQ7XG5leHBvcnRzLmN1cnZlQ2F0bXVsbFJvbU9wZW4gPSBjYXRtdWxsUm9tT3BlbjtcbmV4cG9ydHMuY3VydmVDYXRtdWxsUm9tID0gY2F0bXVsbFJvbTtcbmV4cG9ydHMuY3VydmVMaW5lYXJDbG9zZWQgPSBsaW5lYXJDbG9zZWQ7XG5leHBvcnRzLmN1cnZlTGluZWFyID0gY3VydmVMaW5lYXI7XG5leHBvcnRzLmN1cnZlTW9ub3RvbmVYID0gbW9ub3RvbmVYO1xuZXhwb3J0cy5jdXJ2ZU1vbm90b25lWSA9IG1vbm90b25lWTtcbmV4cG9ydHMuY3VydmVOYXR1cmFsID0gbmF0dXJhbDtcbmV4cG9ydHMuY3VydmVTdGVwID0gc3RlcDtcbmV4cG9ydHMuY3VydmVTdGVwQWZ0ZXIgPSBzdGVwQWZ0ZXI7XG5leHBvcnRzLmN1cnZlU3RlcEJlZm9yZSA9IHN0ZXBCZWZvcmU7XG5leHBvcnRzLnN0YWNrID0gc3RhY2s7XG5leHBvcnRzLnN0YWNrT2Zmc2V0RXhwYW5kID0gZXhwYW5kO1xuZXhwb3J0cy5zdGFja09mZnNldERpdmVyZ2luZyA9IGRpdmVyZ2luZztcbmV4cG9ydHMuc3RhY2tPZmZzZXROb25lID0gbm9uZSQxO1xuZXhwb3J0cy5zdGFja09mZnNldFNpbGhvdWV0dGUgPSBzaWxob3VldHRlO1xuZXhwb3J0cy5zdGFja09mZnNldFdpZ2dsZSA9IHdpZ2dsZTtcbmV4cG9ydHMuc3RhY2tPcmRlckFzY2VuZGluZyA9IGFzY2VuZGluZyQyO1xuZXhwb3J0cy5zdGFja09yZGVyRGVzY2VuZGluZyA9IGRlc2NlbmRpbmckMjtcbmV4cG9ydHMuc3RhY2tPcmRlckluc2lkZU91dCA9IGluc2lkZU91dDtcbmV4cG9ydHMuc3RhY2tPcmRlck5vbmUgPSBub25lJDI7XG5leHBvcnRzLnN0YWNrT3JkZXJSZXZlcnNlID0gcmV2ZXJzZTtcbmV4cG9ydHMudGltZUludGVydmFsID0gbmV3SW50ZXJ2YWw7XG5leHBvcnRzLnRpbWVNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuZXhwb3J0cy50aW1lTWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuZXhwb3J0cy51dGNNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuZXhwb3J0cy51dGNNaWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XG5leHBvcnRzLnRpbWVTZWNvbmQgPSBzZWNvbmQ7XG5leHBvcnRzLnRpbWVTZWNvbmRzID0gc2Vjb25kcztcbmV4cG9ydHMudXRjU2Vjb25kID0gc2Vjb25kO1xuZXhwb3J0cy51dGNTZWNvbmRzID0gc2Vjb25kcztcbmV4cG9ydHMudGltZU1pbnV0ZSA9IG1pbnV0ZTtcbmV4cG9ydHMudGltZU1pbnV0ZXMgPSBtaW51dGVzO1xuZXhwb3J0cy50aW1lSG91ciA9IGhvdXI7XG5leHBvcnRzLnRpbWVIb3VycyA9IGhvdXJzO1xuZXhwb3J0cy50aW1lRGF5ID0gZGF5O1xuZXhwb3J0cy50aW1lRGF5cyA9IGRheXM7XG5leHBvcnRzLnRpbWVXZWVrID0gc3VuZGF5O1xuZXhwb3J0cy50aW1lV2Vla3MgPSBzdW5kYXlzO1xuZXhwb3J0cy50aW1lU3VuZGF5ID0gc3VuZGF5O1xuZXhwb3J0cy50aW1lU3VuZGF5cyA9IHN1bmRheXM7XG5leHBvcnRzLnRpbWVNb25kYXkgPSBtb25kYXk7XG5leHBvcnRzLnRpbWVNb25kYXlzID0gbW9uZGF5cztcbmV4cG9ydHMudGltZVR1ZXNkYXkgPSB0dWVzZGF5O1xuZXhwb3J0cy50aW1lVHVlc2RheXMgPSB0dWVzZGF5cztcbmV4cG9ydHMudGltZVdlZG5lc2RheSA9IHdlZG5lc2RheTtcbmV4cG9ydHMudGltZVdlZG5lc2RheXMgPSB3ZWRuZXNkYXlzO1xuZXhwb3J0cy50aW1lVGh1cnNkYXkgPSB0aHVyc2RheTtcbmV4cG9ydHMudGltZVRodXJzZGF5cyA9IHRodXJzZGF5cztcbmV4cG9ydHMudGltZUZyaWRheSA9IGZyaWRheTtcbmV4cG9ydHMudGltZUZyaWRheXMgPSBmcmlkYXlzO1xuZXhwb3J0cy50aW1lU2F0dXJkYXkgPSBzYXR1cmRheTtcbmV4cG9ydHMudGltZVNhdHVyZGF5cyA9IHNhdHVyZGF5cztcbmV4cG9ydHMudGltZU1vbnRoID0gbW9udGg7XG5leHBvcnRzLnRpbWVNb250aHMgPSBtb250aHM7XG5leHBvcnRzLnRpbWVZZWFyID0geWVhcjtcbmV4cG9ydHMudGltZVllYXJzID0geWVhcnM7XG5leHBvcnRzLnV0Y01pbnV0ZSA9IHV0Y01pbnV0ZTtcbmV4cG9ydHMudXRjTWludXRlcyA9IHV0Y01pbnV0ZXM7XG5leHBvcnRzLnV0Y0hvdXIgPSB1dGNIb3VyO1xuZXhwb3J0cy51dGNIb3VycyA9IHV0Y0hvdXJzO1xuZXhwb3J0cy51dGNEYXkgPSB1dGNEYXk7XG5leHBvcnRzLnV0Y0RheXMgPSB1dGNEYXlzO1xuZXhwb3J0cy51dGNXZWVrID0gdXRjU3VuZGF5O1xuZXhwb3J0cy51dGNXZWVrcyA9IHV0Y1N1bmRheXM7XG5leHBvcnRzLnV0Y1N1bmRheSA9IHV0Y1N1bmRheTtcbmV4cG9ydHMudXRjU3VuZGF5cyA9IHV0Y1N1bmRheXM7XG5leHBvcnRzLnV0Y01vbmRheSA9IHV0Y01vbmRheTtcbmV4cG9ydHMudXRjTW9uZGF5cyA9IHV0Y01vbmRheXM7XG5leHBvcnRzLnV0Y1R1ZXNkYXkgPSB1dGNUdWVzZGF5O1xuZXhwb3J0cy51dGNUdWVzZGF5cyA9IHV0Y1R1ZXNkYXlzO1xuZXhwb3J0cy51dGNXZWRuZXNkYXkgPSB1dGNXZWRuZXNkYXk7XG5leHBvcnRzLnV0Y1dlZG5lc2RheXMgPSB1dGNXZWRuZXNkYXlzO1xuZXhwb3J0cy51dGNUaHVyc2RheSA9IHV0Y1RodXJzZGF5O1xuZXhwb3J0cy51dGNUaHVyc2RheXMgPSB1dGNUaHVyc2RheXM7XG5leHBvcnRzLnV0Y0ZyaWRheSA9IHV0Y0ZyaWRheTtcbmV4cG9ydHMudXRjRnJpZGF5cyA9IHV0Y0ZyaWRheXM7XG5leHBvcnRzLnV0Y1NhdHVyZGF5ID0gdXRjU2F0dXJkYXk7XG5leHBvcnRzLnV0Y1NhdHVyZGF5cyA9IHV0Y1NhdHVyZGF5cztcbmV4cG9ydHMudXRjTW9udGggPSB1dGNNb250aDtcbmV4cG9ydHMudXRjTW9udGhzID0gdXRjTW9udGhzO1xuZXhwb3J0cy51dGNZZWFyID0gdXRjWWVhcjtcbmV4cG9ydHMudXRjWWVhcnMgPSB1dGNZZWFycztcbmV4cG9ydHMudGltZUZvcm1hdERlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlJDE7XG5leHBvcnRzLnRpbWVGb3JtYXRMb2NhbGUgPSBmb3JtYXRMb2NhbGUkMTtcbmV4cG9ydHMuaXNvRm9ybWF0ID0gZm9ybWF0SXNvO1xuZXhwb3J0cy5pc29QYXJzZSA9IHBhcnNlSXNvO1xuZXhwb3J0cy5ub3cgPSBub3c7XG5leHBvcnRzLnRpbWVyID0gdGltZXI7XG5leHBvcnRzLnRpbWVyRmx1c2ggPSB0aW1lckZsdXNoO1xuZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dCQxO1xuZXhwb3J0cy5pbnRlcnZhbCA9IGludGVydmFsJDE7XG5leHBvcnRzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuZXhwb3J0cy5hY3RpdmUgPSBhY3RpdmU7XG5leHBvcnRzLmludGVycnVwdCA9IGludGVycnVwdDtcbmV4cG9ydHMudm9yb25vaSA9IHZvcm9ub2k7XG5leHBvcnRzLnpvb20gPSB6b29tO1xuZXhwb3J0cy56b29tVHJhbnNmb3JtID0gdHJhbnNmb3JtJDE7XG5leHBvcnRzLnpvb21JZGVudGl0eSA9IGlkZW50aXR5JDg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kMy9idWlsZC9kMy5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgc3R1ZHlEYXRhID0gW1xyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIkF1c3RyYWxpYVwiLFxyXG4gICAgXCJyZWdpb25cIjogXCJPQ1wiLFxyXG4gICAgXCJjb2RlXCI6IFwiQVVTXCIsXHJcbiAgICBcIlBvcHVsYXRpb25cIjogW1sxOTc1LDEyOTI1MTc5XSxbMTk3NiwxMzEwNDcxN10sWzE5NzcsMTMyNzQ0ODddLFsxOTc4LDEzNDQ1MTYwXSxbMTk3OSwxMzYyNDUwNF0sWzE5ODAsMTM4MTU2MjNdLFsxOTgxLDE0MDE2NTg5XSxbMTk4MiwxNDIyNDA3M10sWzE5ODMsMTQ0MzI1NzJdLFsxOTg0LDE0NjM4MzI3XSxbMTk4NSwxNDg0MDIyNF0sWzE5ODYsMTUwNDA0NDhdLFsxOTg3LDE1MjQyMzkwXSxbMTk4OCwxNTQ1MDg1OF0sWzE5ODksMTU2NjkxMTddLFsxOTkwLDE1ODk4MDM4XSxbMTk5MSwxNjEzNTg5N10sWzE5OTIsMTYzODAxMjBdLFsxOTkzLDE2NjI2OTQxXSxbMTk5NCwxNjg3MzMzNV0sWzE5OTUsMTcxMTkxMDhdLFsxOTk2LDE3MzY0MzE2XSxbMTk5NywxNzYwNjU0NV0sWzE5OTgsMTc4NDI5NDRdLFsxOTk5LDE4MDcxNzU4XSxbMjAwMCwxODI5MTEwOF1dLFxyXG4gICAgXCJBcmFibGUgQXJlYVwiOiBbWzE5NzQsMF0sWzE5NzUsNDEyODNdLFsxOTc2LDQwNzg3XSxbMTk3Nyw0MDM4N10sWzE5NzgsNDIyODddLFsxOTc5LDQyMzg3XSxbMTk4MCw0MjIzM10sWzE5ODEsNDEyNDFdLFsxOTgyLDQyNjcwXSxbMTk4Myw0NDA4N10sWzE5ODQsNDQxODZdLFsxOTg1LDQzMTcxXSxbMTk4Niw0NjUzMV0sWzE5ODcsNDQ5NzVdLFsxOTg4LDQ3MjM5XSxbMTk4OSw0NzMxMF0sWzE5OTAsNDY5NzVdLFsxOTkxLDQ3MTA2XSxbMTk5Miw0NzIyM10sWzE5OTMsNDc4NzddLFsxOTk0LDQ4MDgxXSxbMTk5NSw0NTg3NF0sWzE5OTYsNDczNzhdLFsxOTk3LDQ2NDg2XSxbMTk5OCw1MjEwMF0sWzE5OTksNDYzNDhdLFsyMDAwLDUyMjIxXV0sXHJcbiAgICBcIkVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsNTc5NzRdLFsxOTc2LDYwODg4XSxbMTk3Nyw2NDc3Ml0sWzE5NzgsNjk3NDNdLFsxOTc5LDczOTMzXSxbMTk4MCw3NjU5Nl0sWzE5ODEsODI2MDddLFsxOTgyLDg2Mjk1XSxbMTk4Myw5MTIzMl0sWzE5ODQsOTYxMzVdLFsxOTg1LDEwMTQ4MF0sWzE5ODYsMTA1MzI5XSxbMTk4NywxMDYyODddLFsxOTg4LDExMjk0N10sWzE5ODksMTIwOTk2XSxbMTk5MCwxMjYyMTFdLFsxOTkxLDEzMTUyM10sWzE5OTIsMTM5MDE3XSxbMTk5MywxNDc3ODhdLFsxOTk0LDE1NTA3N10sWzE5OTUsMTU2ODUxXSxbMTk5NiwxNTk3NjFdLFsxOTk3LDE2Mzc0N10sWzE5OTgsMTY3NTEzXSxbMTk5OSwxNzMzODRdLFsyMDAwLDE3NzY3Ml1dLFxyXG4gICAgXCJHRFAgUGVyIENhcGl0YVwiOiBbWzE5NzUsMzc5OF0sWzE5NzYsNDMyNV0sWzE5NzcsNDg1Ml0sWzE5NzgsNTM3OV0sWzE5NzksNTkwNl0sWzE5ODAsNjQzM10sWzE5ODEsNjg2MF0sWzE5ODIsNzU3N10sWzE5ODMsODM3N10sWzE5ODQsOTI1OV0sWzE5ODUsMTA0MjldLFsxOTg2LDEwNDkwXSxbMTk4NywxMTM1MV0sWzE5ODgsMTIzMjddLFsxOTg5LDEzMDY0XSxbMTk5MCwxMzM4OF0sWzE5OTEsMTQzMzRdLFsxOTkyLDE1MjUyXSxbMTk5MywxNjIxNV0sWzE5OTQsMTY3MDNdLFsxOTk1LDE3MDA0XSxbMTk5NiwxNzcxNF0sWzE5OTcsMTg1OTVdLFsxOTk4LDE5NjI0XSxbMTk5OSwyMDc1M10sWzIwMDAsMjE2MDJdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5IChXb21lbilcIjogW1sxOTc1LDczLjc2XSxbMTk3Niw3NC4xMl0sWzE5NzcsNzQuNDhdLFsxOTc4LDc0Ljg0XSxbMTk3OSw3NS4yXSxbMTk4MCw3NS41Nl0sWzE5ODEsNzUuOTJdLFsxOTgyLDc2LjI4XSxbMTk4Myw3Ni42NF0sWzE5ODQsNzddLFsxOTg1LDc3LjM0XSxbMTk4Niw3Ny42OF0sWzE5ODcsNzguMDJdLFsxOTg4LDc4LjM2XSxbMTk4OSw3OC43XSxbMTk5MCw3OC44NF0sWzE5OTEsNzguOThdLFsxOTkyLDc5LjEyXSxbMTk5Myw3OS4yNl0sWzE5OTQsNzkuNF0sWzE5OTUsNzkuNjRdLFsxOTk2LDc5Ljg4XSxbMTk5Nyw4MC4xMl0sWzE5OTgsODAuMzZdLFsxOTk5LDgwLjZdLFsyMDAwLDgwLjgzXV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiOiBbWzE5NzUsNjcuMDRdLFsxOTc2LDY3LjM4XSxbMTk3Nyw2Ny43Ml0sWzE5NzgsNjguMDZdLFsxOTc5LDY4LjRdLFsxOTgwLDY4Ljc0XSxbMTk4MSw2OS4wOF0sWzE5ODIsNjkuNDJdLFsxOTgzLDY5Ljc1XSxbMTk4NCw3MC4xXSxbMTk4NSw3MC40Nl0sWzE5ODYsNzAuODJdLFsxOTg3LDcxLjE4XSxbMTk4OCw3MS41NF0sWzE5ODksNzEuOV0sWzE5OTAsNzIuMTJdLFsxOTkxLDcyLjM0XSxbMTk5Miw3Mi41Nl0sWzE5OTMsNzIuNzhdLFsxOTk0LDczXSxbMTk5NSw3My4zNF0sWzE5OTYsNzMuNjhdLFsxOTk3LDc0LjAyXSxbMTk5OCw3NC4zNl0sWzE5OTksNzQuN10sWzIwMDAsNzUuMDRdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5XCI6IFtbMTk3NSw3MC4yNl0sWzE5NzYsNzAuNjJdLFsxOTc3LDcwLjk4XSxbMTk3OCw3MS4zNF0sWzE5NzksNzEuN10sWzE5ODAsNzIuMDZdLFsxOTgxLDcyLjQyXSxbMTk4Miw3Mi43OF0sWzE5ODMsNzMuMTRdLFsxOTg0LDczLjVdLFsxOTg1LDczLjg0XSxbMTk4Niw3NC4xOF0sWzE5ODcsNzQuNTJdLFsxOTg4LDc0Ljg2XSxbMTk4OSw3NS4yXSxbMTk5MCw3NS4zOF0sWzE5OTEsNzUuNTZdLFsxOTkyLDc1Ljc0XSxbMTk5Myw3NS45Ml0sWzE5OTQsNzYuMV0sWzE5OTUsNzYuMzldLFsxOTk2LDc2LjY5XSxbMTk5Nyw3N10sWzE5OTgsNzcuM10sWzE5OTksNzcuNl0sWzIwMDAsNzcuODldXSxcclxuICAgIFwiSW5mYW50IE1vcnRhbGl0eVwiOiBbWzE5NzUsMTkuMzNdLFsxOTc2LDE4LjY1XSxbMTk3NywxNy45NV0sWzE5NzgsMTcuMjldLFsxOTc5LDE2LjZdLFsxOTgwLDE1LjldLFsxOTgxLDE1LjI0XSxbMTk4MiwxNC41NV0sWzE5ODMsMTMuODVdLFsxOTg0LDEzLjE5XSxbMTk4NSwxMi41XSxbMTk4NiwxMl0sWzE5ODcsMTEuNV0sWzE5ODgsMTFdLFsxOTg5LDEwLjVdLFsxOTkwLDEwXSxbMTk5MSw5LjcyXSxbMTk5Miw5LjQ0XSxbMTk5Myw5LjE2XSxbMTk5NCw4Ljg3XSxbMTk5NSw4LjZdLFsxOTk2LDguMl0sWzE5OTcsNy44XSxbMTk5OCw3LjM5XSxbMTk5OSw3XSxbMjAwMCw2LjZdXSxcclxuICAgIFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiOiBbWzE5NzUsMF0sWzE5NzYsMF0sWzE5NzcsMF0sWzE5NzgsMF0sWzE5NzksMF0sWzE5ODAsMF0sWzE5ODEsMF0sWzE5ODIsMF0sWzE5ODMsMF0sWzE5ODQsMF0sWzE5ODUsMF0sWzE5ODYsMF0sWzE5ODcsMF0sWzE5ODgsMi4wM10sWzE5ODksNC4xOV0sWzE5OTAsNi4xNl0sWzE5OTEsOC4yXSxbMTk5MiwxMC4zXSxbMTk5MywxMy4xXSxbMTk5NCwxNV0sWzE5OTUsMTZdLFsxOTk2LDE4LjRdLFsxOTk3LDIwLjhdLFsxOTk4LDI0XSxbMTk5OSwyNy42XSxbMjAwMCwyOC45XV0sXHJcbiAgICBcIkluZGV4ZWQgUG9wdWxhdGlvblwiOiBbWzE5NzUsMC4wMTA1NDUzMTUzNzg0NDI0MTRdLFsxOTc2LDAuMDEwNjkxNzk1NzM1MzAzNjA3XSxbMTk3NywwLjAxMDgzMDMwNjYzNjUyOTY2OV0sWzE5NzgsMC4wMTA5Njk1NTQyNzE4MzAxMDhdLFsxOTc5LDAuMDExMTE1ODc2MzQ5MTY3MDE3XSxbMTk4MCwwLjAxMTI3MTgwNTM0MDkyODk1MV0sWzE5ODEsMC4wMTE0MzU3NjgyNDIzNTkxMDJdLFsxOTgyLDAuMDExNjA1MDQ5MDA5NDU1NjkyXSxbMTk4MywwLjAxMTc3NTE1Nzg4ODQ5NjM1M10sWzE5ODQsMC4wMTE5NDMwMjgwMDk3Mjk1OTldLFsxOTg1LDAuMDEyMTA3NzUwNDg5NzAxNTVdLFsxOTg2LDAuMDEyMjcxMTA4MDEyNzQ1MDA0XSxbMTk4NywwLjAxMjQzNTg2NzIwNzAzOTU5OV0sWzE5ODgsMC4wMTI2MDU5NTA3OTM5OTEzMjVdLFsxOTg5LDAuMDEyNzg0MDIyNjAxNjc2NDIzXSxbMTk5MCwwLjAxMjk3MDc5MzI1NjIwNjVdLFsxOTkxLDAuMDEzMTY0ODU2MTkxMDg3Mzk3XSxbMTk5MiwwLjAxMzM2NDExMTM0NzA2MzkxXSxbMTk5MywwLjAxMzU2NTQ4NjE0MzI2NzcwMV0sWzE5OTQsMC4wMTM3NjY1MTI1NjEzNDMzXSxbMTk5NSwwLjAxMzk2NzAzMjMyMTc2NjQxOF0sWzE5OTYsMC4wMTQxNjcwOTExMTM0NzE5MDNdLFsxOTk3LDAuMDE0MzY0NzE5NDE3MDE4Mzk1XSxbMTk5OCwwLjAxNDU1NzU5MTE3NjA5Nzk3MV0sWzE5OTksMC4wMTQ3NDQyNzQ1MzIxMjc1NDJdLFsyMDAwLDAuMDE0OTIzMjM2NDU4MTY4MjgyXV0sXHJcbiAgICBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwwLjAxNTcxNjI0MzM4MDI5MDg1Ml0sWzE5NzYsMC4wMTY1MDYyMDMyNDUyMzMyXSxbMTk3NywwLjAxNzU1OTEyMTYxMDE3MzUxM10sWzE5NzgsMC4wMTg5MDY3MTYxNDk4NTM4MTRdLFsxOTc5LDAuMDIwMDQyNTg4NDMzMzUwMTg2XSxbMTk4MCwwLjAyMDc2NDUwNDM5Nzc3NzU5NV0sWzE5ODEsMC4wMjIzOTQwMzM4MjQwNTM2NTZdLFsxOTgyLDAuMDIzMzkzODE4MzA2NTIwMTVdLFsxOTgzLDAuMDI0NzMyMTk1NzQ0MTM4NjddLFsxOTg0LDAuMDI2MDYxMzU2MDc5Njk1NF0sWzE5ODUsMC4wMjc1MTAzMzg3NDIwNTUzMzNdLFsxOTg2LDAuMDI4NTUzNzY4OTEzNjk2NzVdLFsxOTg3LDAuMDI4ODEzNDc0MzE4ODQ5MzhdLFsxOTg4LDAuMDMwNjE4OTQxOTU4MDEwNjc4XSxbMTk4OSwwLjAzMjgwMDk1NTMyNTUxOTU4XSxbMTk5MCwwLjAzNDIxNDY5NjEyNzA1NTA0XSxbMTk5MSwwLjAzNTY1NDczMjc3ODU5MDNdLFsxOTkyLDAuMDM3Njg2MjkwNTA5NTAyNDI0XSxbMTk5MywwLjA0MDA2NDAzMTc1MDIwNTY5XSxbMTk5NCwwLjA0MjA0MDAxNTc3NzUxXSxbMTk5NSwwLjA0MjUyMDkzMTYzMjE0NTQ2XSxbMTk5NiwwLjA0MzMwOTgwNzEzMjEzOTM1NF0sWzE5OTcsMC4wNDQzOTAzNzY4MDMyNjUwMjZdLFsxOTk4LDAuMDQ1NDExMzA2NDAyMjI2Ml0sWzE5OTksMC4wNDcwMDI4ODMwNTUzMDY2OF0sWzIwMDAsMC4wNDgxNjUzMjIyODAwMzk5Nl1dLFxyXG4gICAgXCJJbmRleGVkIEdEUFwiOiBbWzE5NzUsMC4xMzA1ODcyNjQ0NzUzMTI4OF0sWzE5NzYsMC4xNDg3MDcxOTI5NTgzMjc2XSxbMTk3NywwLjE2NjgyNzEyMTQ0MTM0MjMyXSxbMTk3OCwwLjE4NDk0NzA0OTkyNDM1NzA0XSxbMTk3OSwwLjIwMzA2Njk3ODQwNzM3MTc2XSxbMTk4MCwwLjIyMTE4NjkwNjg5MDM4NjQ4XSxbMTk4MSwwLjIzNTg2ODUxODc3MzIwODY0XSxbMTk4MiwwLjI2MDUyMTI0ODc5NjU4OTE3XSxbMTk4MywwLjI4ODAyNzc4MTU5ODEyOTUzXSxbMTk4NCwwLjMxODM1MzczNDAxMTgyNzhdLFsxOTg1LDAuMzU4NTgyMDM4MjM0MDgwNl0sWzE5ODYsMC4zNjA2Nzk0MTEzNjAxOTgwNF0sWzE5ODcsMC4zOTAyODMzMTcyODc4NTU4N10sWzE5ODgsMC40MjM4NDEyODczMDU3MzUxXSxbMTk4OSwwLjQ0OTE4MTY4MDY0OTE1NDE1XSxbMTk5MCwwLjQ2MDMyMTgyNjQzMzc3OF0sWzE5OTEsMC40OTI4NDgzMDE0NzE1OTk1XSxbMTk5MiwwLjUyNDQxMjA0Nzg2MTM2NzFdLFsxOTkzLDAuNTU3NTIzMDM2NzIxMjIxM10sWzE5OTQsMC41NzQzMDIwMjE3MzAxNjA5XSxbMTk5NSwwLjU4NDY1MTM1NDY5Njc0MDVdLFsxOTk2LDAuNjA5MDYzNDAyNTU4MTA3NV0sWzE5OTcsMC42MzkzNTQ5NzE4MDU4MDM5XSxbMTk5OCwwLjY3NDczNTI0OTYyMTc4NTJdLFsxOTk5LDAuNzEzNTUzODQ0MDM3OTU5XSxbMjAwMCwwLjc0Mjc0NTE1MTk3MzU5MzddXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiQ2hpbmFcIixcclxuICAgIFwicmVnaW9uXCI6IFwiQVNcIixcclxuICAgIFwiY29kZVwiOiBcIkNITlwiLFxyXG4gICAgXCJQb3B1bGF0aW9uXCI6IFtbMTk3NSw4NTE0MTA2MjRdLFsxOTc2LDg3MTgyNTUzOF0sWzE5NzcsODkxNTg3Mjg3XSxbMTk3OCw5MTAzMjgzMzBdLFsxOTc5LDkyNzgwNzYyNF0sWzE5ODAsOTQzODc3NDQxXSxbMTk4MSw5NTg2MzU2OTZdLFsxOTgyLDk3MjQxMjQ5N10sWzE5ODMsOTg1Njk1NTIyXSxbMTk4NCw5OTg4NzcwOTNdLFsxOTg1LDEwMTE5NzYzMzddLFsxOTg2LDEwMjQ5ODcwMTZdLFsxOTg3LDEwMzgyNDA2MTFdLFsxOTg4LDEwNTIxMzIyODJdLFsxOTg5LDEwNjY5MDYwNjBdLFsxOTkwLDEwODI3NTkwNTVdLFsxOTkxLDEwOTk1MzIwOTVdLFsxOTkyLDExMTY2NjUzMDVdLFsxOTkzLDExMzMzNjg1NDhdLFsxOTk0LDExNDkwNjg5NzhdLFsxOTk1LDExNjM1NTAxOTFdLFsxOTk2LDExNzY5NjM0MjldLFsxOTk3LDExODk1NTA2NzVdLFsxOTk4LDEyMDE3MTE3NjhdLFsxOTk5LDEyMTM3MzE2NTVdLFsyMDAwLDEyMjU2Nzk3MDFdXSxcclxuICAgIFwiQXJhYmxlIEFyZWFcIjogW1sxOTc1LDEwMjE2NV0sWzE5NzYsMTAxNzgxXSxbMTk3NywxMDEzODhdLFsxOTc4LDEwMjAyOV0sWzE5NzksMTAwNjM3XSxbMTk4MCwxMDA1OTBdLFsxOTgxLDEwMDUzMl0sWzE5ODIsMTAwMzE2XSxbMTk4MywxMDA0MjNdLFsxOTg0LDEwMDIxOV0sWzE5ODUsMTAwOTA4XSxbMTk4NiwxMDExOTldLFsxOTg3LDExNDkwMl0sWzE5ODgsMTE1OTAwXSxbMTk4OSwxMjU4OTZdLFsxOTkwLDEyNjk5Nl0sWzE5OTEsMTI4Nzk0XSxbMTk5MiwxMjk3MDNdLFsxOTkzLDEzMTAwMl0sWzE5OTQsMTMxMzk3XSxbMTk5NSwxMzEzOTFdLFsxOTk2LDEzMTc4M10sWzE5OTcsMTMyNzgyXSxbMTk5OCwxMzM0NzldLFsxOTk5LDEzNDcwMF0sWzIwMDAsMTM1MDc5XV0sXHJcbiAgICBcIkVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsMTM4NDAwXSxbMTk3NiwxNTI0MDBdLFsxOTc3LDE2NjgwMF0sWzE5NzgsMTY4ODAwXSxbMTk3OSwxOTU4MDBdLFsxOTgwLDIwMzEwMF0sWzE5ODEsMjIzNDAwXSxbMTk4MiwyNTY1NTBdLFsxOTgzLDI4MjIwMl0sWzE5ODQsMzAwOTI4XSxbMTk4NSwzMDk1MDddLFsxOTg2LDMyODAxMF0sWzE5ODcsMzUxODcwXSxbMTk4OCwzNzc3NjBdLFsxOTg5LDQxMTc3MF0sWzE5OTAsNDUwNzAwXSxbMTk5MSw0OTg1MjBdLFsxOTkyLDU0NjY4MF0sWzE5OTMsNTg2NTMwXSxbMTk5NCw2MjMwNDBdLFsxOTk1LDY4MDQwMF0sWzE5OTYsNzU5NDIwXSxbMTk5Nyw4NDM4NDJdLFsxOTk4LDkyNjAzN10sWzE5OTksMTAwMjM0MF0sWzIwMDAsMTA3NzcyMl1dLFxyXG4gICAgXCJHRFAgUGVyIENhcGl0YVwiOiBbWzE5NzUsMjA2XSxbMTk3NiwyMTFdLFsxOTc3LDIxNl0sWzE5NzgsMjIxXSxbMTk3OSwyMjZdLFsxOTgwLDIzMV0sWzE5ODEsMjYxXSxbMTk4MiwzMDhdLFsxOTgzLDM1NV0sWzE5ODQsNDEyXSxbMTk4NSw0NjhdLFsxOTg2LDUzMl0sWzE5ODcsNjAzXSxbMTk4OCw3MTFdLFsxOTg5LDgyM10sWzE5OTAsOTA0XSxbMTk5MSwxMDIxXSxbMTk5MiwxMTU3XSxbMTk5MywxMjI5XSxbMTk5NCwxMzAzXSxbMTk5NSwxNDU0XSxbMTk5NiwxNjgwXSxbMTk5NywxOTQ0XSxbMTk5OCwyMjE3XSxbMTk5OSwyNTE4XSxbMjAwMCwyNzg5XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoV29tZW4pXCI6IFtbMTk3NSw2MS45OF0sWzE5NzYsNjIuNDZdLFsxOTc3LDYyLjk0XSxbMTk3OCw2My40Ml0sWzE5NzksNjMuOV0sWzE5ODAsNjQuMzhdLFsxOTgxLDY0Ljg2XSxbMTk4Miw2NS4zNF0sWzE5ODMsNjUuODJdLFsxOTg0LDY2LjNdLFsxOTg1LDY2LjQyXSxbMTk4Niw2Ni41NF0sWzE5ODcsNjYuNjZdLFsxOTg4LDY2Ljc4XSxbMTk4OSw2Ni45XSxbMTk5MCw2Ny4yOF0sWzE5OTEsNjcuNjZdLFsxOTkyLDY4LjA0XSxbMTk5Myw2OC40Ml0sWzE5OTQsNjguOF0sWzE5OTUsNjkuMV0sWzE5OTYsNjkuMzldLFsxOTk3LDY5LjddLFsxOTk4LDcwXSxbMTk5OSw3MC4zXSxbMjAwMCw3MC42XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiOiBbWzE5NzUsNjAuOV0sWzE5NzYsNjEuM10sWzE5NzcsNjEuN10sWzE5NzgsNjIuMV0sWzE5NzksNjIuNV0sWzE5ODAsNjIuOV0sWzE5ODEsNjMuM10sWzE5ODIsNjMuN10sWzE5ODMsNjQuMV0sWzE5ODQsNjQuNV0sWzE5ODUsNjQuNDZdLFsxOTg2LDY0LjQyXSxbMTk4Nyw2NC4zOF0sWzE5ODgsNjQuMzRdLFsxOTg5LDY0LjNdLFsxOTkwLDY0LjY0XSxbMTk5MSw2NC45OF0sWzE5OTIsNjUuMzJdLFsxOTkzLDY1LjY2XSxbMTk5NCw2Nl0sWzE5OTUsNjYuMjhdLFsxOTk2LDY2LjU2XSxbMTk5Nyw2Ni44NF0sWzE5OTgsNjcuMTJdLFsxOTk5LDY3LjRdLFsyMDAwLDY3LjY4XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeVwiOiBbWzE5NzUsNjEuNTJdLFsxOTc2LDYxLjk0XSxbMTk3Nyw2Mi4zNl0sWzE5NzgsNjIuNzhdLFsxOTc5LDYzLjJdLFsxOTgwLDYzLjYyXSxbMTk4MSw2NC4wNF0sWzE5ODIsNjQuNDZdLFsxOTgzLDY0Ljg4XSxbMTk4NCw2NS4zXSxbMTk4NSw2NS4zNF0sWzE5ODYsNjUuMzhdLFsxOTg3LDY1LjQyXSxbMTk4OCw2NS40Nl0sWzE5ODksNjUuNV0sWzE5OTAsNjUuODZdLFsxOTkxLDY2LjIyXSxbMTk5Miw2Ni41OF0sWzE5OTMsNjYuOTRdLFsxOTk0LDY3LjNdLFsxOTk1LDY3LjU4XSxbMTk5Niw2Ny44Nl0sWzE5OTcsNjguMTRdLFsxOTk4LDY4LjQyXSxbMTk5OSw2OC43XSxbMjAwMCw2OC45OF1dLFxyXG4gICAgXCJJbmZhbnQgTW9ydGFsaXR5XCI6IFtbMTk3NSw2Ny4xNl0sWzE5NzYsNjUuNjVdLFsxOTc3LDY0LjFdLFsxOTc4LDYyLjY0XSxbMTk3OSw2MS4xXSxbMTk4MCw1OS41NV0sWzE5ODEsNTguMDldLFsxOTgyLDU2LjU1XSxbMTk4Myw1NV0sWzE5ODQsNTMuNTRdLFsxOTg1LDUyXSxbMTk4Niw0OS4xNl0sWzE5ODcsNDYuMzJdLFsxOTg4LDQzLjQ4XSxbMTk4OSw0MC42NF0sWzE5OTAsMzcuOF0sWzE5OTEsMzYuNTFdLFsxOTkyLDM1LjIzXSxbMTk5MywzMy45Nl0sWzE5OTQsMzIuNjhdLFsxOTk1LDMxLjRdLFsxOTk2LDMxLjA5XSxbMTk5NywzMC43OV0sWzE5OTgsMzAuNV0sWzE5OTksMzAuMl0sWzIwMDAsMjkuOV1dLFxyXG4gICAgXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCI6IFtbMTk3NSwwXSxbMTk3NiwwXSxbMTk3NywwXSxbMTk3OCwwXSxbMTk3OSwwXSxbMTk4MCwwXSxbMTk4MSwwXSxbMTk4MiwwXSxbMTk4MywwXSxbMTk4NCwwXSxbMTk4NSwwXSxbMTk4NiwwXSxbMTk4NywwXSxbMTk4OCwwXSxbMTk4OSwwXSxbMTk5MCwwXSxbMTk5MSwwXSxbMTk5MiwwXSxbMTk5MywwXSxbMTk5NCwwXSxbMTk5NSwwLjFdLFsxOTk2LDAuMV0sWzE5OTcsMC4xXSxbMTk5OCwwLjJdLFsxOTk5LDAuMl0sWzIwMDAsMC40XV0sXHJcbiAgICBcIkluZGV4ZWQgUG9wdWxhdGlvblwiOiBbWzE5NzUsMC42OTQ2NDM2NTIyNTcwNzUzXSxbMTk3NiwwLjcxMTI5OTY0NjQ2NDQ4ODVdLFsxOTc3LDAuNzI3NDIyNzQwNDM3NDcwOV0sWzE5NzgsMC43NDI3MTMwNjcwOTAyNzQxXSxbMTk3OSwwLjc1Njk3Mzk2NTc0NTcyMTRdLFsxOTgwLDAuNzcwMDg0OTA4OTkzNjkxNV0sWzE5ODEsMC43ODIxMjU3ODMxMjA4ODczXSxbMTk4MiwwLjc5MzM2NTkxNDYwNzczNDldLFsxOTgzLDAuODA0MjAzMTg3MTc1MDgwOF0sWzE5ODQsMC44MTQ5NTc2ODYwNzgyMTYzXSxbMTk4NSwwLjgyNTY0NTAxNjUzNjAxMjZdLFsxOTg2LDAuODM2MjYwMDg5MTI3NDc3NV0sWzE5ODcsMC44NDcwNzMzNTA1Mjc4MTQ2XSxbMTk4OCwwLjg1ODQwNzIwMTQ0MjI2MzJdLFsxOTg5LDAuODcwNDYwNzQwMzc5MDIzM10sWzE5OTAsMC44ODMzOTQ3ODQyMzAwMTE1XSxbMTk5MSwwLjg5NzA3OTQ2ODcyNDkyMV0sWzE5OTIsMC45MTEwNTgwMDY0OTk1MzAxXSxbMTk5MywwLjkyNDY4NTc0NTQ0ODI3MTldLFsxOTk0LDAuOTM3NDk1MzE1NTA3MzkxM10sWzE5OTUsMC45NDkzMTAxNTgzMTUxNjk4XSxbMTk5NiwwLjk2MDI1MzY2ODI2MjM5MDZdLFsxOTk3LDAuOTcwNTIzMjcyOTQ3NjM2MV0sWzE5OTgsMC45ODA0NDUxOTA1NDk4MjddLFsxOTk5LDAuOTkwMjUxOTAxODcxMDU4M10sWzIwMDAsMV1dLFxyXG4gICAgXCJJbmRleGVkIEVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsMC4wMzc1MTkwMjcyMTYyMDQ3NV0sWzE5NzYsMC4wNDEzMTQzMDQ1MzU3NjMwMzRdLFsxOTc3LDAuMDQ1MjE4MDE4MzUwMTY1ODRdLFsxOTc4LDAuMDQ1NzYwMjAwODI0Mzg4NDU0XSxbMTk3OSwwLjA1MzA3OTY2NDIyNjM5MzcxNV0sWzE5ODAsMC4wNTUwNTg2MzAyNTczMDYyNV0sWzE5ODEsMC4wNjA1NjE3ODIzNzA2NjU3Nl0sWzE5ODIsMC4wNjk1NDg0NTY4ODA5MDU1NV0sWzE5ODMsMC4wNzY1MDI0ODkyOTUyODQ3OF0sWzE5ODQsMC4wODE1Nzg5NDM4MDE0MzEwOV0sWzE5ODUsMC4wODM5MDQ2MzU1MjQ2MDg5OV0sWzE5ODYsMC4wODg5MjA2MzY2ODQ4Nzk0OF0sWzE5ODcsMC4wOTUzODg4NzM2MDIzNTUyM10sWzE5ODgsMC4xMDI0MDc0MjU3MzExNjY5Nl0sWzE5ODksMC4xMTE2MjcyMzg3MDUzMjI0N10sWzE5OTAsMC4xMjIxODA4MjA1NjYwNjU2XSxbMTk5MSwwLjEzNTE0NDQwMzUyNDcyODI2XSxbMTk5MiwwLjE0ODIwMDE1NzUwNDAwODc1XSxbMTk5MywwLjE1OTAwMzE0MzMwMjg5NDNdLFsxOTk0LDAuMTY4OTAwNjg0MzY5ODI4MDhdLFsxOTk1LDAuMTg0NDUwNDc3NzMwNTMyNl0sWzE5OTYsMC4yMDU4NzIxMDcyODcwNjhdLFsxOTk3LDAuMjI4NzU4MTcxNzA2NDc4NjZdLFsxOTk4LDAuMjUxMDQwNTE1OTQwODQyNV0sWzE5OTksMC4yNzE3MjU1OTA2MDYxNDY0XSxbMjAwMCwwLjI5MjE2MDk5MDI0MjA3MDkzXV0sXHJcbiAgICBcIkluZGV4ZWQgR0RQXCI6IFtbMTk3NSwwLjAwNzA4MjkzMjE5NjM5NjY0NF0sWzE5NzYsMC4wMDcyNTQ4NDgwMjY0MDYyNzJdLFsxOTc3LDAuMDA3NDI2NzYzODU2NDE1ODk4Nl0sWzE5NzgsMC4wMDc1OTg2Nzk2ODY0MjU1MjZdLFsxOTc5LDAuMDA3NzcwNTk1NTE2NDM1MTUzXSxbMTk4MCwwLjAwNzk0MjUxMTM0NjQ0NDc4XSxbMTk4MSwwLjAwODk3NDAwNjMyNjUwMjU0NV0sWzE5ODIsMC4wMTA1OTAwMTUxMjg1OTMwNF0sWzE5ODMsMC4wMTIyMDYwMjM5MzA2ODM1MzddLFsxOTg0LDAuMDE0MTY1ODY0MzkyNzkzMjg4XSxbMTk4NSwwLjAxNjA5MTMyMTY4ODkwMTExNV0sWzE5ODYsMC4wMTgyOTE4NDQzMTMwMjQzNDRdLFsxOTg3LDAuMDIwNzMzMDQ5MDk5MTYxMDVdLFsxOTg4LDAuMDI0NDQ2NDMxMDI3MzY5XSxbMTk4OSwwLjAyODI5NzM0NTYxOTU4NDY1Ml0sWzE5OTAsMC4wMzEwODIzODIwNjU3NDA2MTNdLFsxOTkxLDAuMDM1MTA1MjEyNDg3OTY1ODk0XSxbMTk5MiwwLjAzOTc4MTMyMzA2NDIyNzc1NV0sWzE5OTMsMC4wNDIyNTY5MTEwMTYzNjYzOV0sWzE5OTQsMC4wNDQ4MDEyNjUzMDA1MDg4N10sWzE5OTUsMC4wNDk5OTMxMjMzNjY3OTk2MV0sWzE5OTYsMC4wNTc3NjM3MTg4ODMyMzQ3N10sWzE5OTcsMC4wNjY4NDA4NzQ3MDc3NDMxXSxbMTk5OCwwLjA3NjIyNzQ3OTAyNjI2ODc0XSxbMTk5OSwwLjA4NjU3NjgxMTk5Mjg0ODMxXSxbMjAwMCwwLjA5NTg5NDY0OTk3OTM3MDFdXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiRGVubWFya1wiLFxyXG4gICAgXCJyZWdpb25cIjogXCJFVVwiLFxyXG4gICAgXCJjb2RlXCI6IFwiRE5LXCIsXHJcbiAgICBcIlBvcHVsYXRpb25cIjogW1sxOTc1LDQ5NTkxODldLFsxOTc2LDQ5ODc4MjZdLFsxOTc3LDUwMTQzNjRdLFsxOTc4LDUwMzg0NjZdLFsxOTc5LDUwNTk4NjRdLFsxOTgwLDUwNzg2NjBdLFsxOTgxLDUwOTQ4NDRdLFsxOTgyLDUxMDc5NThdLFsxOTgzLDUxMTc0MzNdLFsxOTg0LDUxMjMwMjldLFsxOTg1LDUxMjQ1OTddLFsxOTg2LDUxMjI3NjRdLFsxOTg3LDUxMTkwNTVdLFsxOTg4LDUxMTU1MDJdLFsxOTg5LDUxMTM2NzhdLFsxOTkwLDUxMTQxMDVdLFsxOTkxLDUxMTY3MzddLFsxOTkyLDUxMjE4NTNdLFsxOTkzLDUxMjk1NzZdLFsxOTk0LDUxMzk5NDddLFsxOTk1LDUxNTMxMzddLFsxOTk2LDUxNjkxMDZdLFsxOTk3LDUxODczNDhdLFsxOTk4LDUyMDcxMzldLFsxOTk5LDUyMjc4NjFdLFsyMDAwLDUyNDkzMzddXSxcclxuICAgIFwiQXJhYmxlIEFyZWFcIjogW1sxOTc1LDI2NjJdLFsxOTc2LDI2NjZdLFsxOTc3LDI2NjhdLFsxOTc4LDI2NTVdLFsxOTc5LDI2NjBdLFsxOTgwLDI2NjddLFsxOTgxLDI2NDhdLFsxOTgyLDI2NTNdLFsxOTgzLDI2NTZdLFsxOTg0LDI2NTNdLFsxOTg1LDI2NTFdLFsxOTg2LDI2NDRdLFsxOTg3LDI2MTBdLFsxOTg4LDI2MjddLFsxOTg5LDI2MTRdLFsxOTkwLDI2MDRdLFsxOTkxLDI1ODhdLFsxOTkyLDI1NzBdLFsxOTkzLDI1NTVdLFsxOTk0LDI1NzFdLFsxOTk1LDI1NThdLFsxOTk2LDI1NDhdLFsxOTk3LDI1NDJdLFsxOTk4LDIzNzRdLFsxOTk5LDIzMjhdLFsyMDAwLDIzMzFdXSxcclxuICAgIFwiRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwxNjY2NF0sWzE5NzYsMTgzMDZdLFsxOTc3LDE4ODk2XSxbMTk3OCwxODY3M10sWzE5NzksMTk1ODddLFsxOTgwLDIxNzU4XSxbMTk4MSwyMzA2NV0sWzE5ODIsMjQ0NzVdLFsxOTgzLDI1NTk2XSxbMTk4NCwyNTkxNl0sWzE5ODUsMjUzMjhdLFsxOTg2LDI1ODA2XSxbMTk4NywyNjQ3NF0sWzE5ODgsMjc1NTJdLFsxOTg5LDI5NTk5XSxbMTk5MCwzMDk3MF0sWzE5OTEsMzIwNTBdLFsxOTkyLDMyNDUyXSxbMTk5MywzMjYxNF0sWzE5OTQsMzMzMzZdLFsxOTk1LDM0Mzg2XSxbMTk5NiwzNDY0MV0sWzE5OTcsMzYwMzVdLFsxOTk4LDM2NDc1XSxbMTk5OSwzNzI2MF0sWzIwMDAsMzk0NjJdXSxcclxuICAgIFwiR0RQIFBlciBDYXBpdGFcIjogW1sxOTc1LDM1MzVdLFsxOTc2LDQzNTVdLFsxOTc3LDUxNzVdLFsxOTc4LDU5OTVdLFsxOTc5LDY4MTVdLFsxOTgwLDc2MzVdLFsxOTgxLDgxNTZdLFsxOTgyLDg4NTBdLFsxOTgzLDk5NTNdLFsxOTg0LDEwODc0XSxbMTk4NSwxMTc1M10sWzE5ODYsMTI5MThdLFsxOTg3LDEzNjQ1XSxbMTk4OCwxNDczOF0sWzE5ODksMTU3NDNdLFsxOTkwLDE2NjcyXSxbMTk5MSwxNzA1Ml0sWzE5OTIsMTc4NjBdLFsxOTkzLDE4NjE1XSxbMTk5NCwxOTU0Nl0sWzE5OTUsMjA0MTZdLFsxOTk2LDIwODI4XSxbMTk5NywyMTA2OV0sWzE5OTgsMjI1OTJdLFsxOTk5LDIzNDg3XSxbMjAwMCwyNDM5NF1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKFdvbWVuKVwiOiBbWzE5NzUsNzUuNjhdLFsxOTc2LDc1Ljg2XSxbMTk3Nyw3Ni4wNF0sWzE5NzgsNzYuMjJdLFsxOTc5LDc2LjRdLFsxOTgwLDc2LjU4XSxbMTk4MSw3Ni43Nl0sWzE5ODIsNzYuOTRdLFsxOTgzLDc3LjEyXSxbMTk4NCw3Ny4zXSxbMTk4NSw3Ny4zNl0sWzE5ODYsNzcuNDJdLFsxOTg3LDc3LjQ3XSxbMTk4OCw3Ny41M10sWzE5ODksNzcuNl0sWzE5OTAsNzcuNjZdLFsxOTkxLDc3LjcyXSxbMTk5Miw3Ny43OF0sWzE5OTMsNzcuODRdLFsxOTk0LDc3LjldLFsxOTk1LDc3Ljg4XSxbMTk5Niw3Ny44Nl0sWzE5OTcsNzcuODRdLFsxOTk4LDc3LjgyXSxbMTk5OSw3Ny44XSxbMjAwMCw3Ny43OF1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKE1lbilcIjogW1sxOTc1LDcwLjU4XSxbMTk3Niw3MC42Nl0sWzE5NzcsNzAuNzRdLFsxOTc4LDcwLjgyXSxbMTk3OSw3MC45XSxbMTk4MCw3MC45OF0sWzE5ODEsNzEuMDZdLFsxOTgyLDcxLjE0XSxbMTk4Myw3MS4yMl0sWzE5ODQsNzEuM10sWzE5ODUsNzEuMzZdLFsxOTg2LDcxLjQyXSxbMTk4Nyw3MS40N10sWzE5ODgsNzEuNTNdLFsxOTg5LDcxLjZdLFsxOTkwLDcxLjY5XSxbMTk5MSw3MS44XSxbMTk5Miw3MS44OV0sWzE5OTMsNzJdLFsxOTk0LDcyLjFdLFsxOTk1LDcyLjE3XSxbMTk5Niw3Mi4yNV0sWzE5OTcsNzIuMzRdLFsxOTk4LDcyLjQyXSxbMTk5OSw3Mi41XSxbMjAwMCw3Mi41OF1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3lcIjogW1sxOTc1LDczLjExXSxbMTk3Niw3My4yNF0sWzE5NzcsNzMuMzVdLFsxOTc4LDczLjQ3XSxbMTk3OSw3My42XSxbMTk4MCw3My43Ml0sWzE5ODEsNzMuODRdLFsxOTgyLDczLjk2XSxbMTk4Myw3NC4wOF0sWzE5ODQsNzQuMl0sWzE5ODUsNzQuMjhdLFsxOTg2LDc0LjM2XSxbMTk4Nyw3NC40NF0sWzE5ODgsNzQuNTJdLFsxOTg5LDc0LjZdLFsxOTkwLDc0LjY2XSxbMTk5MSw3NC43Ml0sWzE5OTIsNzQuNzhdLFsxOTkzLDc0Ljg0XSxbMTk5NCw3NC45XSxbMTk5NSw3NC45Nl0sWzE5OTYsNzUuMDJdLFsxOTk3LDc1LjA4XSxbMTk5OCw3NS4xNF0sWzE5OTksNzUuMl0sWzIwMDAsNzUuMjZdXSxcclxuICAgIFwiSW5mYW50IE1vcnRhbGl0eVwiOiBbWzE5NzUsMTMuODZdLFsxOTc2LDEzLjRdLFsxOTc3LDEyLjkyXSxbMTk3OCwxMi40N10sWzE5NzksMTJdLFsxOTgwLDExLjUyXSxbMTk4MSwxMS4wN10sWzE5ODIsMTAuNl0sWzE5ODMsMTAuMTJdLFsxOTg0LDkuNjddLFsxOTg1LDkuMl0sWzE5ODYsOC45NV0sWzE5ODcsOC43MV0sWzE5ODgsOC40OF0sWzE5ODksOC4yNF0sWzE5OTAsOF0sWzE5OTEsOF0sWzE5OTIsOF0sWzE5OTMsOF0sWzE5OTQsOF0sWzE5OTUsOF0sWzE5OTYsNy43XSxbMTk5Nyw3LjRdLFsxOTk4LDcuMV0sWzE5OTksNi44XSxbMjAwMCw2LjVdXSxcclxuICAgIFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiOiBbWzE5NzUsMF0sWzE5NzYsMF0sWzE5NzcsMF0sWzE5NzgsMF0sWzE5NzksMF0sWzE5ODAsMF0sWzE5ODEsMF0sWzE5ODIsMF0sWzE5ODMsMF0sWzE5ODQsMF0sWzE5ODUsMF0sWzE5ODYsMF0sWzE5ODcsMF0sWzE5ODgsMF0sWzE5ODksMF0sWzE5OTAsMC45NV0sWzE5OTEsMy4zOF0sWzE5OTIsNS44XSxbMTk5Myw3LjhdLFsxOTk0LDExLjVdLFsxOTk1LDEzLjRdLFsxOTk2LDE1LjVdLFsxOTk3LDE3LjldLFsxOTk4LDE5LjJdLFsxOTk5LDI2LjhdLFsyMDAwLDMwLjVdXSxcclxuICAgIFwiSW5kZXhlZCBQb3B1bGF0aW9uXCI6IFtbMTk3NSwwLjAwNDA0NjA3MjU1NTQ1OTU3N10sWzE5NzYsMC4wMDQwNjk0MzY3MzQ1MTYwMTFdLFsxOTc3LDAuMDA0MDkxMDg4Mzk0Mzg5NTg3NV0sWzE5NzgsMC4wMDQxMTA3NTI1ODU1OTc0MDJdLFsxOTc5LDAuMDA0MTI4MjEwNjUzOTUxMjY0XSxbMTk4MCwwLjAwNDE0MzU0NTgxODU4MjUwMV0sWzE5ODEsMC4wMDQxNTY3NDk5MjA3NTI3NDZdLFsxOTgyLDAuMDA0MTY3NDQ5MjkwMjQ0ODc0XSxbMTk4MywwLjAwNDE3NTE3OTY5NDg0NTkwNV0sWzE5ODQsMC4wMDQxNzk3NDUzMjQ4MzUwNzNdLFsxOTg1LDAuMDA0MTgxMDI0NjE1MDEwNzM3XSxbMTk4NiwwLjAwNDE3OTUyOTExODI2ODM5NV0sWzE5ODcsMC4wMDQxNzY1MDMwNDIyMDg3NDFdLFsxOTg4LDAuMDA0MTczNjA0MjQyNDY3NTg0XSxbMTk4OSwwLjAwNDE3MjExNjA4ODU4OTc3MV0sWzE5OTAsMC4wMDQxNzI0NjQ0NjY3MTc5NjVdLFsxOTkxLDAuMDA0MTc0NjExODQ2NjU1Njg2NV0sWzE5OTIsMC4wMDQxNzg3ODU4NTcyMDMzMjVdLFsxOTkzLDAuMDA0MTg1MDg2ODUwODQyNzcxXSxbMTk5NCwwLjAwNDE5MzU0ODI3ODQwMTMyNV0sWzE5OTUsMC4wMDQyMDQzMDk2NTQzMDUwMjc1XSxbMTk5NiwwLjAwNDIxNzMzODM0MzYwMDQyMl0sWzE5OTcsMC4wMDQyMzIyMjE1MTQxMjYyMjZdLFsxOTk4LDAuMDA0MjQ4MzY4NDczMjI0OF0sWzE5OTksMC4wMDQyNjUyNzUwMTA4NjUxNzZdLFsyMDAwLDAuMDA0MjgyNzk2NzE3Mzc4Mjg3XV0sXHJcbiAgICBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwwLjAwNDUxNzQ2NDM3NTIyMjgwM10sWzE5NzYsMC4wMDQ5NjI1OTYxODY1NTk1NjhdLFsxOTc3LDAuMDA1MTIyNTQwMDE2NDU1MjM4XSxbMTk3OCwwLjAwNTA2MjA4NjY3MDU3OTQxN10sWzE5NzksMC4wMDUzMDk4NjQwNjEyOTkxNTFdLFsxOTgwLDAuMDA1ODk4NDAzMTM3MDY3Nzk1NV0sWzE5ODEsMC4wMDYyNTI3MTkzODM5NzIyNzNdLFsxOTgyLDAuMDA2NjM0OTU4MDI4Mjk5MjE0XSxbMTk4MywwLjAwNjkzODg1MTMwNTEwMDk4OF0sWzE5ODQsMC4wMDcwMjU2MDA1MDA5NzY2MDY1XSxbMTk4NSwwLjAwNjg2NjE5ODg1MzU1NTE1OF0sWzE5ODYsMC4wMDY5OTU3ODA0NjQ4OTQzNjNdLFsxOTg3LDAuMDA3MTc2ODY5NDExMjg0NzE1XSxbMTk4OCwwLjAwNzQ2OTEwNTc2NDg5MDcwM10sWzE5ODksMC4wMDgwMjQwMjk1MjcyNTc1NDddLFsxOTkwLDAuMDA4Mzk1Njk1NjEzMzM3MTQ3XSxbMTk5MSwwLjAwODY4ODQ3NDE0OTQxNzM1N10sWzE5OTIsMC4wMDg3OTc0NTI4MjY3MzYxMDJdLFsxOTkzLDAuMDA4ODQxMzY5NjA3MTQ4MTM0XSxbMTk5NCwwLjAwOTAzNzA5NzQ4MDM0MjQ5Nl0sWzE5OTUsMC4wMDkzMjE3NDMyNzkzMDkzNjhdLFsxOTk2LDAuMDA5MzkwODcxNTQ0NzcyNzUyXSxbMTk5NywwLjAwOTc2ODc3MjcyOTMwNTkxMV0sWzE5OTgsMC4wMDk4ODgwNTI4NzM2MzQ4ODZdLFsxOTk5LDAuMDEwMTAwODU5NDk0NzY3MjYyXSxbMjAwMCwwLjAxMDY5NzgwMjM5ODg4NjM1N11dLFxyXG4gICAgXCJJbmRleGVkIEdEUFwiOiBbWzE5NzUsMC4xMjE1NDQ0OTE4MTY4MDY0OV0sWzE5NzYsMC4xNDk3Mzg2ODc5MzgzODUzOF0sWzE5NzcsMC4xNzc5MzI4ODQwNTk5NjQyNF0sWzE5NzgsMC4yMDYxMjcwODAxODE1NDMxXSxbMTk3OSwwLjIzNDMyMTI3NjMwMzEyMl0sWzE5ODAsMC4yNjI1MTU0NzI0MjQ3MDA4Nl0sWzE5ODEsMC4yODA0MjkxMDE5MTE3MDRdLFsxOTgyLDAuMzA0MjkxMDE5MTE3MDQwM10sWzE5ODMsMC4zNDIyMTU2NTEyMTcxNjQxXSxbMTk4NCwwLjM3Mzg4MjU0NzEwNDkzNzRdLFsxOTg1LDAuNDA0MTA1MzUwMDIwNjI5OV0sWzE5ODYsMC40NDQxNjE3Mzg0MTI4NzMwNF0sWzE5ODcsMC40NjkxNTgzMDAwOTYyNzI4NV0sWzE5ODgsMC41MDY3MzkxMDA1MzYzNzc0XSxbMTk4OSwwLjU0MTI5NDE4MjM2ODMxMjVdLFsxOTkwLDAuNTczMjM2MTQzNTg0MTAxMl0sWzE5OTEsMC41ODYzMDE3NDY2NjQ4MzI5XSxbMTk5MiwwLjYxNDA4MzM0NDc5NDM4ODZdLFsxOTkzLDAuNjQwMDQyNjM1MTI1ODQyNF0sWzE5OTQsMC42NzIwNTMzNjI2NzM2MzVdLFsxOTk1LDAuNzAxOTY2NzE3MDk1MzEwMV0sWzE5OTYsMC43MTYxMzI1ODE0ODgxMDM0XSxbMTk5NywwLjcyNDQxODkyNDQ5NDU2NzVdLFsxOTk4LDAuNzc2Nzg0NDg2MzE1NDk5OV0sWzE5OTksMC44MDc1NTc0MTk4ODcyMjMyXSxbMjAwMCwwLjgzODc0Mjk1MTQ1MDk2OTZdXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiR2FtYmlhXCIsXHJcbiAgICBcInJlZ2lvblwiOiBcIkFGXCIsXHJcbiAgICBcImNvZGVcIjogXCJHTUJcIixcclxuICAgIFwiUG9wdWxhdGlvblwiOiBbWzE5NzUsNDk3NDU1XSxbMTk3Niw1MTQ1MTBdLFsxOTc3LDUzMjQ5NF0sWzE5NzgsNTUxMDM2XSxbMTk3OSw1Njk4ODNdLFsxOTgwLDU4OTAxM10sWzE5ODEsNjA4NTYzXSxbMTk4Miw2Mjg2MjddLFsxOTgzLDY0OTM1Ml0sWzE5ODQsNjcwODg0XSxbMTk4NSw2OTMyMDhdLFsxOTg2LDcxNjQwMV0sWzE5ODcsNzQwODA3XSxbMTk4OCw3NjY4NjFdLFsxOTg5LDc5NDg3MF0sWzE5OTAsODI0OTg5XSxbMTk5MSw4NTcxMjJdLFsxOTkyLDg5MTAwMF0sWzE5OTMsOTI2MjE4XSxbMTk5NCw5NjI0NzNdLFsxOTk1LDk5OTYzNV0sWzE5OTYsMTAzNzc2M10sWzE5OTcsMTA3Njk2N10sWzE5OTgsMTExNzQzMV0sWzE5OTksMTE1OTI1NV0sWzIwMDAsMTIwMjQyMF1dLFxyXG4gICAgXCJBcmFibGUgQXJlYVwiOiBbWzE5NzUsMTMzXSxbMTk3NiwxMzhdLFsxOTc3LDE0M10sWzE5NzgsMTcwXSxbMTk3OSwxNjRdLFsxOTgwLDE2M10sWzE5ODEsMTcwXSxbMTk4MiwxNzddLFsxOTgzLDE2Nl0sWzE5ODQsMTU5XSxbMTk4NSwxODFdLFsxOTg2LDIwMl0sWzE5ODcsMTgzXSxbMTk4OCwxNjldLFsxOTg5LDE2OV0sWzE5OTAsMTc3XSxbMTk5MSwxODRdLFsxOTkyLDE5OV0sWzE5OTMsMTgxXSxbMTk5NCwxODddLFsxOTk1LDE5Nl0sWzE5OTYsMTYyXSxbMTk5NywxNjFdLFsxOTk4LDE4MF0sWzE5OTksMTg1XSxbMjAwMCwxOTBdXSxcclxuICAgIFwiRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwxM10sWzE5NzYsMTZdLFsxOTc3LDE4XSxbMTk3OCwyNl0sWzE5NzksMjddLFsxOTgwLDI4XSxbMTk4MSwzMV0sWzE5ODIsMzldLFsxOTgzLDQxXSxbMTk4NCw0NV0sWzE5ODUsNDVdLFsxOTg2LDQ0XSxbMTk4Nyw0NV0sWzE5ODgsNDddLFsxOTg5LDQ4XSxbMTk5MCw1M10sWzE5OTEsNThdLFsxOTkyLDY1XSxbMTk5Myw2MV0sWzE5OTQsNzBdLFsxOTk1LDcwXSxbMTk5Niw3MV0sWzE5OTcsNzNdLFsxOTk4LDczXSxbMTk5OSw3NF0sWzIwMDAsNzZdXSxcclxuICAgIFwiR0RQIFBlciBDYXBpdGFcIjogW1sxOTc1LDQwMF0sWzE5NzYsNDUyXSxbMTk3Nyw1MDRdLFsxOTc4LDU1Nl0sWzE5NzksNjA4XSxbMTk4MCw2NjBdLFsxOTgxLDcwMV0sWzE5ODIsNzg1XSxbMTk4Myw4MjBdLFsxOTg0LDkyNF0sWzE5ODUsMTAxMF0sWzE5ODYsMTA0M10sWzE5ODcsMTIwNl0sWzE5ODgsMTE2NF0sWzE5ODksMTE5N10sWzE5OTAsMTM5OF0sWzE5OTEsMTE2OF0sWzE5OTIsMTIyMl0sWzE5OTMsMTQwMV0sWzE5OTQsMTQ4NF0sWzE5OTUsMTQ2OV0sWzE5OTYsMTQ1Nl0sWzE5OTcsMTQ3OF0sWzE5OTgsMTQ2M10sWzE5OTksMTQ1Ml0sWzIwMDAsMTQ2N11dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKFdvbWVuKVwiOiBbWzE5NzUsMzUuODNdLFsxOTc2LDM2LjU4XSxbMTk3NywzNy4zMV0sWzE5NzgsMzguMDVdLFsxOTc5LDM4LjhdLFsxOTgwLDM5LjU0XSxbMTk4MSw0MC4yOF0sWzE5ODIsNDEuMDFdLFsxOTgzLDQxLjc2XSxbMTk4NCw0Mi41XSxbMTk4NSw0My4yOF0sWzE5ODYsNDQuMDZdLFsxOTg3LDQ0LjgzXSxbMTk4OCw0NS42Ml0sWzE5ODksNDYuNF0sWzE5OTAsNDcuMThdLFsxOTkxLDQ3Ljk2XSxbMTk5Miw0OC43M10sWzE5OTMsNDkuNTFdLFsxOTk0LDUwLjNdLFsxOTk1LDUxXSxbMTk5Niw1MS42OV0sWzE5OTcsNTIuNF0sWzE5OTgsNTMuMDldLFsxOTk5LDUzLjhdLFsyMDAwLDU0LjVdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5IChNZW4pXCI6IFtbMTk3NSwzNS4wN10sWzE5NzYsMzUuNzVdLFsxOTc3LDM2LjQ0XSxbMTk3OCwzNy4xMl0sWzE5NzksMzcuOF0sWzE5ODAsMzguNDhdLFsxOTgxLDM5LjE2XSxbMTk4MiwzOS44NF0sWzE5ODMsNDAuNTJdLFsxOTg0LDQxLjJdLFsxOTg1LDQxLjkyXSxbMTk4Niw0Mi42NF0sWzE5ODcsNDMuMzZdLFsxOTg4LDQ0LjA4XSxbMTk4OSw0NC44XSxbMTk5MCw0NS41XSxbMTk5MSw0Ni4xOV0sWzE5OTIsNDYuOV0sWzE5OTMsNDcuNTldLFsxOTk0LDQ4LjNdLFsxOTk1LDQ4Ljk2XSxbMTk5Niw0OS42Ml0sWzE5OTcsNTAuMjhdLFsxOTk4LDUwLjk0XSxbMTk5OSw1MS42XSxbMjAwMCw1Mi4yNl1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3lcIjogW1sxOTc1LDM1LjVdLFsxOTc2LDM2LjE5XSxbMTk3NywzNi45XSxbMTk3OCwzNy41OV0sWzE5NzksMzguM10sWzE5ODAsMzldLFsxOTgxLDM5LjY5XSxbMTk4Miw0MC40XSxbMTk4Myw0MS4wOV0sWzE5ODQsNDEuOF0sWzE5ODUsNDIuNTVdLFsxOTg2LDQzLjMyXSxbMTk4Nyw0NC4wOF0sWzE5ODgsNDQuODRdLFsxOTg5LDQ1LjZdLFsxOTkwLDQ2LjM0XSxbMTk5MSw0Ny4wOF0sWzE5OTIsNDcuODJdLFsxOTkzLDQ4LjU1XSxbMTk5NCw0OS4zXSxbMTk5NSw0OS45Nl0sWzE5OTYsNTAuNjJdLFsxOTk3LDUxLjI4XSxbMTk5OCw1MS45NF0sWzE5OTksNTIuNl0sWzIwMDAsNTMuMjZdXSxcclxuICAgIFwiSW5mYW50IE1vcnRhbGl0eVwiOiBbWzE5NzUsMTg0LjE0XSxbMTk3NiwxNzkuMV0sWzE5NzcsMTczLjk2XSxbMTk3OCwxNjkuMTNdLFsxOTc5LDE2NF0sWzE5ODAsMTU4Ljg2XSxbMTk4MSwxNTQuMDNdLFsxOTgyLDE0OC45XSxbMTk4MywxNDMuNzZdLFsxOTg0LDEzOC45M10sWzE5ODUsMTMzLjhdLFsxOTg2LDEyOS4xXSxbMTk4NywxMjQuNF0sWzE5ODgsMTE5LjddLFsxOTg5LDExNV0sWzE5OTAsMTEwLjNdLFsxOTkxLDEwNy42Ml0sWzE5OTIsMTA0Ljk0XSxbMTk5MywxMDIuMjZdLFsxOTk0LDk5LjU4XSxbMTk5NSw5Ni45XSxbMTk5Niw5NS40OF0sWzE5OTcsOTQuMDZdLFsxOTk4LDkyLjY0XSxbMTk5OSw5MS4yMl0sWzIwMDAsODkuOF1dLFxyXG4gICAgXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCI6IFtbMTk3NSwwXSxbMTk3NiwwXSxbMTk3NywwXSxbMTk3OCwwXSxbMTk3OSwwXSxbMTk4MCwwXSxbMTk4MSwwXSxbMTk4MiwwXSxbMTk4MywwXSxbMTk4NCwwXSxbMTk4NSwwXSxbMTk4NiwwXSxbMTk4NywwXSxbMTk4OCwwXSxbMTk4OSwwXSxbMTk5MCwwXSxbMTk5MSwwXSxbMTk5MiwwXSxbMTk5MywwXSxbMTk5NCwwXSxbMTk5NSwwXSxbMTk5NiwwXSxbMTk5NywwXSxbMTk5OCwwXSxbMTk5OSwwLjFdLFsyMDAwLDAuMl1dLFxyXG4gICAgXCJJbmRleGVkIFBvcHVsYXRpb25cIjogW1sxOTc1LDAuMDAwNDA1ODYwNTE5MzQ2MjM2Nl0sWzE5NzYsMC4wMDA0MTk3NzUyNDc2MjgwOTEzN10sWzE5NzcsMC4wMDA0MzQ0NDc5MjI3MDQwNzM1NF0sWzE5NzgsMC4wMDA0NDk1NzU4NTUzODA4MzQxXSxbMTk3OSwwLjAwMDQ2NDk1MjYyOTU3NzczMzRdLFsxOTgwLDAuMDAwNDgwNTYwMjk2MDcwMzY3OV0sWzE5ODEsMC4wMDA0OTY1MTA2Mjk1NzQzNDA5XSxbMTk4MiwwLjAwMDUxMjg4MDMyMjIzMDI4NTVdLFsxOTgzLDAuMDAwNTI5Nzg5MzA3NDkyMTddLFsxOTg0LDAuMDAwNTQ3MzU2NzAyOTQwMTI2NF0sWzE5ODUsMC4wMDA1NjU1NzAyNzA0NjY2MDddLFsxOTg2LDAuMDAwNTg0NDkyODMyMzU3MDIzN10sWzE5ODcsMC4wMDA2MDQ0MDUwNDkyMTExMzk3XSxbMTk4OCwwLjAwMDYyNTY2MTgyNjE0Nzg0MTJdLFsxOTg5LDAuMDAwNjQ4NTEzNjM2NDM0OTRdLFsxOTkwLDAuMDAwNjczMDg2OTQwNTE3MDk2OV0sWzE5OTEsMC4wMDA2OTkzMDM0MTQ1MDYwMDU2XSxbMTk5MiwwLjAwMDcyNjk0MzU4ODMzOTY0MjRdLFsxOTkzLDAuMDAwNzU1Njc3MDMzMTE0MjE2NV0sWzE5OTQsMC4wMDA3ODUyNTY1MzkwNTcyNjIzXSxbMTk5NSwwLjAwMDgxNTU3NjA0MjU3MDAzMl0sWzE5OTYsMC4wMDA4NDY2ODM2ODAyMDg4ODAzXSxbMTk5NywwLjAwMDg3ODY2OTE5ODA5NTgyNDZdLFsxOTk4LDAuMDAwOTExNjgyNzE3MDE2Nzg0NV0sWzE5OTksMC4wMDA5NDU4MDU4MjQzNTU0MTJdLFsyMDAwLDAuMDAwOTgxMDIzMDE4NTA4ODEzNV1dLFxyXG4gICAgXCJJbmRleGVkIEVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsMC4wMDAwMDM1MjQxODYwODI0NDY5Nzc4XSxbMTk3NiwwLjAwMDAwNDMzNzQ1OTc5Mzc4MDg5Nl0sWzE5NzcsMC4wMDAwMDQ4Nzk2NDIyNjgwMDM1MDhdLFsxOTc4LDAuMDAwMDA3MDQ4MzcyMTY0ODkzOTU1Nl0sWzE5NzksMC4wMDAwMDczMTk0NjM0MDIwMDUyNjJdLFsxOTgwLDAuMDAwMDA3NTkwNTU0NjM5MTE2NTY4XSxbMTk4MSwwLjAwMDAwODQwMzgyODM1MDQ1MDQ4Nl0sWzE5ODIsMC4wMDAwMTA1NzI1NTgyNDczNDA5MzNdLFsxOTgzLDAuMDAwMDExMTE0NzQwNzIxNTYzNTQ2XSxbMTk4NCwwLjAwMDAxMjE5OTEwNTY3MDAwODc3XSxbMTk4NSwwLjAwMDAxMjE5OTEwNTY3MDAwODc3XSxbMTk4NiwwLjAwMDAxMTkyODAxNDQzMjg5NzQ2M10sWzE5ODcsMC4wMDAwMTIxOTkxMDU2NzAwMDg3N10sWzE5ODgsMC4wMDAwMTI3NDEyODgxNDQyMzEzODFdLFsxOTg5LDAuMDAwMDEzMDEyMzc5MzgxMzQyNjg4XSxbMTk5MCwwLjAwMDAxNDM2NzgzNTU2Njg5OTIxOF0sWzE5OTEsMC4wMDAwMTU3MjMyOTE3NTI0NTU3NDddLFsxOTkyLDAuMDAwMDE3NjIwOTMwNDEyMjM0ODldLFsxOTkzLDAuMDAwMDE2NTM2NTY1NDYzNzg5NjY2XSxbMTk5NCwwLjAwMDAxODk3NjM4NjU5Nzc5MTQyXSxbMTk5NSwwLjAwMDAxODk3NjM4NjU5Nzc5MTQyXSxbMTk5NiwwLjAwMDAxOTI0NzQ3NzgzNDkwMjcyNl0sWzE5OTcsMC4wMDAwMTk3ODk2NjAzMDkxMjUzMzddLFsxOTk4LDAuMDAwMDE5Nzg5NjYwMzA5MTI1MzM3XSxbMTk5OSwwLjAwMDAyMDA2MDc1MTU0NjIzNjY0Ml0sWzIwMDAsMC4wMDAwMjA2MDI5MzQwMjA0NTkyNTZdXSxcclxuICAgIFwiSW5kZXhlZCBHRFBcIjogW1sxOTc1LDAuMDEzNzUzMjY2NDAwNzcwMTgzXSxbMTk3NiwwLjAxNTU0MTE5MTAzMjg3MDMwN10sWzE5NzcsMC4wMTczMjkxMTU2NjQ5NzA0MzJdLFsxOTc4LDAuMDE5MTE3MDQwMjk3MDcwNTU0XSxbMTk3OSwwLjAyMDkwNDk2NDkyOTE3MDY4XSxbMTk4MCwwLjAyMjY5Mjg4OTU2MTI3MDhdLFsxOTgxLDAuMDI0MTAyNTk5MzY3MzQ5NzQ3XSxbMTk4MiwwLjAyNjk5MDc4NTMxMTUxMTQ4M10sWzE5ODMsMC4wMjgxOTQxOTYxMjE1Nzg4NzddLFsxOTg0LDAuMDMxNzcwMDQ1Mzg1Nzc5MTJdLFsxOTg1LDAuMDM0NzI2OTk3NjYxOTQ0NzFdLFsxOTg2LDAuMDM1ODYxNjQyMTQwMDA4MjU0XSxbMTk4NywwLjA0MTQ2NjA5ODE5ODMyMjFdLFsxOTg4LDAuMDQwMDIyMDA1MjI2MjQxMjNdLFsxOTg5LDAuMDQxMTU2NjQ5NzA0MzA0NzddLFsxOTkwLDAuMDQ4MDY3NjY2MDcwNjkxNzldLFsxOTkxLDAuMDQwMTU5NTM3ODkwMjQ4OTNdLFsxOTkyLDAuMDQyMDE2MjI4ODU0MzUyOTFdLFsxOTkzLDAuMDQ4MTcwODE1NTY4Njk3NTddLFsxOTk0LDAuMDUxMDI0NjE4MzQ2ODU3MzhdLFsxOTk1LDAuMDUwNTA4ODcwODU2ODI4NDk0XSxbMTk5NiwwLjA1MDA2MTg4OTY5ODgwMzQ2NV0sWzE5OTcsMC4wNTA4MTgzMTkzNTA4NDU4MjVdLFsxOTk4LDAuMDUwMzAyNTcxODYwODE2OTRdLFsxOTk5LDAuMDQ5OTI0MzU3MDM0Nzk1NzY2XSxbMjAwMCwwLjA1MDQ0MDEwNDUyNDgyNDY1XV1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIkh1bmdhcnlcIixcclxuICAgIFwicmVnaW9uXCI6IFwiRVVcIixcclxuICAgIFwiY29kZVwiOiBcIkhVTlwiLFxyXG4gICAgXCJQb3B1bGF0aW9uXCI6IFtbMTk3NSwxMDM3NTA3N10sWzE5NzYsMTA0MTI3NDddLFsxOTc3LDEwNDUwODAzXSxbMTk3OCwxMDQ5MDM4MF0sWzE5NzksMTA1MzE4MjBdLFsxOTgwLDEwNTc1OTc0XSxbMTk4MSwxMDYyMTIxNl0sWzE5ODIsMTA2NjI0MTZdLFsxOTgzLDEwNjkyNzQ1XSxbMTk4NCwxMDcwNzQ3Ml0sWzE5ODUsMTA3MDUxNDddLFsxOTg2LDEwNjg3NjgwXSxbMTk4NywxMDY1Nzk3NF0sWzE5ODgsMTA2MjA1MTddLFsxOTg5LDEwNTc5MDkzXSxbMTk5MCwxMDUzMzc4N10sWzE5OTEsMTA0ODQ5OTRdLFsxOTkyLDEwNDM3MTkyXSxbMTk5MywxMDM5NTkwMF0sWzE5OTQsMTAzNjQ4NDBdLFsxOTk1LDEwMzQ2Mzk0XSxbMTk5NiwxMDMzOTE0OV0sWzE5OTcsMTAzMzgyNTJdLFsxOTk4LDEwMzM2NTgxXSxbMTk5OSwxMDMyODk2N10sWzIwMDAsMTAzMTM4MzBdXSxcclxuICAgIFwiQXJhYmxlIEFyZWFcIjogW1sxOTc1LDU1NzhdLFsxOTc2LDU1NjVdLFsxOTc3LDU1NTVdLFsxOTc4LDU1MDNdLFsxOTc5LDU0OTVdLFsxOTgwLDU0NzFdLFsxOTgxLDU0MjJdLFsxOTgyLDUzODhdLFsxOTgzLDUzNTRdLFsxOTg0LDUzMzNdLFsxOTg1LDUzMTddLFsxOTg2LDUyOTldLFsxOTg3LDUyOTJdLFsxOTg4LDUyODldLFsxOTg5LDUyOTNdLFsxOTkwLDUyODldLFsxOTkxLDUyODldLFsxOTkyLDUyODddLFsxOTkzLDUyODddLFsxOTk0LDUyODhdLFsxOTk1LDUyODddLFsxOTk2LDQ5NzJdLFsxOTk3LDQ5NzNdLFsxOTk4LDQ5NzRdLFsxOTk5LDUwMzFdLFsyMDAwLDUwMzZdXSxcclxuICAgIFwiRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwxOTM0MF0sWzE5NzYsMjA3MTNdLFsxOTc3LDIyMzA1XSxbMTk3OCwyMzY0NF0sWzE5NzksMjQ1OTZdLFsxOTgwLDI2MTY2XSxbMTk4MSwyNzg0NV0sWzE5ODIsMzAwOTVdLFsxOTgzLDMwNjQ1XSxbMTk4NCwzMTI2Ml0sWzE5ODUsMzIyMDNdLFsxOTg2LDMzNTE2XSxbMTk4NywzNDg2Nl0sWzE5ODgsMzY1NzJdLFsxOTg5LDM3NjA0XSxbMTk5MCwzODU3OV0sWzE5OTEsNDAzNjJdLFsxOTkyLDQwNTI1XSxbMTk5Myw0MDY3Ml0sWzE5OTQsMzk1MzhdLFsxOTk1LDM3MzQyXSxbMTk5NiwzNTE1NV0sWzE5OTcsMzUzODhdLFsxOTk4LDM1NTQ4XSxbMTk5OSwzNjQyMl0sWzIwMDAsMzcyODhdXSxcclxuICAgIFwiR0RQIFBlciBDYXBpdGFcIjogW1sxOTc1LDIxMDJdLFsxOTc2LDIzNjZdLFsxOTc3LDI2MzBdLFsxOTc4LDI4OTRdLFsxOTc5LDMxNThdLFsxOTgwLDM0MjJdLFsxOTgxLDM5MTFdLFsxOTgyLDQxNzBdLFsxOTgzLDQ4NjhdLFsxOTg0LDUyNzRdLFsxOTg1LDYwNTZdLFsxOTg2LDY2OTZdLFsxOTg3LDY5NDVdLFsxOTg4LDc0NjddLFsxOTg5LDc3MDhdLFsxOTkwLDgwMzJdLFsxOTkxLDg2MDZdLFsxOTkyLDg5MjJdLFsxOTkzLDk0NjNdLFsxOTk0LDk0NzBdLFsxOTk1LDg2MDVdLFsxOTk2LDg0NzddLFsxOTk3LDg2MDRdLFsxOTk4LDkwODZdLFsxOTk5LDk0NjJdLFsyMDAwLDk4NDRdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5IChXb21lbilcIjogW1sxOTc1LDcxLjg5XSxbMTk3Niw3Ml0sWzE5NzcsNzIuMV0sWzE5NzgsNzIuMl0sWzE5NzksNzIuM10sWzE5ODAsNzIuMzldLFsxOTgxLDcyLjVdLFsxOTgyLDcyLjZdLFsxOTgzLDcyLjddLFsxOTg0LDcyLjhdLFsxOTg1LDcyLjg0XSxbMTk4Niw3Mi44OF0sWzE5ODcsNzIuOTJdLFsxOTg4LDcyLjk2XSxbMTk4OSw3M10sWzE5OTAsNzMuMTJdLFsxOTkxLDczLjI0XSxbMTk5Miw3My4zNl0sWzE5OTMsNzMuNDddLFsxOTk0LDczLjZdLFsxOTk1LDczLjY2XSxbMTk5Niw3My43Ml0sWzE5OTcsNzMuNzhdLFsxOTk4LDczLjg0XSxbMTk5OSw3My45XSxbMjAwMCw3My45Nl1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKE1lbilcIjogW1sxOTc1LDY2LjY2XSxbMTk3Niw2Ni42Ml0sWzE5NzcsNjYuNThdLFsxOTc4LDY2LjU0XSxbMTk3OSw2Ni41XSxbMTk4MCw2Ni40Nl0sWzE5ODEsNjYuNDJdLFsxOTgyLDY2LjM4XSxbMTk4Myw2Ni4zNF0sWzE5ODQsNjYuM10sWzE5ODUsNjYuMV0sWzE5ODYsNjUuODldLFsxOTg3LDY1LjddLFsxOTg4LDY1LjVdLFsxOTg5LDY1LjNdLFsxOTkwLDY1LjM0XSxbMTk5MSw2NS4zOF0sWzE5OTIsNjUuNDJdLFsxOTkzLDY1LjQ2XSxbMTk5NCw2NS41XSxbMTk5NSw2NS4zNl0sWzE5OTYsNjUuMjJdLFsxOTk3LDY1LjA4XSxbMTk5OCw2NC45NF0sWzE5OTksNjQuOF0sWzIwMDAsNjQuNjZdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5XCI6IFtbMTk3NSw2OS4yMV0sWzE5NzYsNjkuMjRdLFsxOTc3LDY5LjI1XSxbMTk3OCw2OS4yOF0sWzE5NzksNjkuM10sWzE5ODAsNjkuMzJdLFsxOTgxLDY5LjM0XSxbMTk4Miw2OS4zNl0sWzE5ODMsNjkuMzhdLFsxOTg0LDY5LjRdLFsxOTg1LDY5LjM0XSxbMTk4Niw2OS4yOF0sWzE5ODcsNjkuMjJdLFsxOTg4LDY5LjE2XSxbMTk4OSw2OS4xXSxbMTk5MCw2OS4xN10sWzE5OTEsNjkuMjVdLFsxOTkyLDY5LjM0XSxbMTk5Myw2OS40Ml0sWzE5OTQsNjkuNV0sWzE5OTUsNjkuNV0sWzE5OTYsNjkuNV0sWzE5OTcsNjkuNV0sWzE5OTgsNjkuNV0sWzE5OTksNjkuNV0sWzIwMDAsNjkuNV1dLFxyXG4gICAgXCJJbmZhbnQgTW9ydGFsaXR5XCI6IFtbMTk3NSwzOS4wM10sWzE5NzYsMzcuOF0sWzE5NzcsMzYuNTRdLFsxOTc4LDM1LjM1XSxbMTk3OSwzNC4xXSxbMTk4MCwzMi44NF0sWzE5ODEsMzEuNjVdLFsxOTgyLDMwLjRdLFsxOTgzLDI5LjE0XSxbMTk4NCwyNy45NV0sWzE5ODUsMjYuN10sWzE5ODYsMjUuNDNdLFsxOTg3LDI0LjE4XSxbMTk4OCwyMi45MV0sWzE5ODksMjEuNjVdLFsxOTkwLDIwLjRdLFsxOTkxLDE5Ljc0XSxbMTk5MiwxOS4wOF0sWzE5OTMsMTguNDJdLFsxOTk0LDE3Ljc2XSxbMTk5NSwxNy4xXSxbMTk5NiwxNi4zNF0sWzE5OTcsMTUuNThdLFsxOTk4LDE0LjgyXSxbMTk5OSwxNC4wNl0sWzIwMDAsMTMuM11dLFxyXG4gICAgXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCI6IFtbMTk3NSwwXSxbMTk3NiwwXSxbMTk3NywwXSxbMTk3OCwwXSxbMTk3OSwwXSxbMTk4MCwwXSxbMTk4MSwwXSxbMTk4MiwwXSxbMTk4MywwXSxbMTk4NCwwXSxbMTk4NSwwXSxbMTk4NiwwXSxbMTk4NywwXSxbMTk4OCwwXSxbMTk4OSwwXSxbMTk5MCwwLjEyXSxbMTk5MSwwLjQyXSxbMTk5MiwwLjhdLFsxOTkzLDAuOV0sWzE5OTQsMV0sWzE5OTUsMS4yXSxbMTk5NiwxLjldLFsxOTk3LDIuN10sWzE5OTgsMy40XSxbMTk5OSwzLjldLFsyMDAwLDQuNF1dLFxyXG4gICAgXCJJbmRleGVkIFBvcHVsYXRpb25cIjogW1sxOTc1LDAuMDA4NDY0NzUzODc2MTg0MTY3XSxbMTk3NiwwLjAwODQ5NTQ4Nzg0MzYwNTg4OF0sWzE5NzcsMC4wMDg1MjY1MzY3MzgzMjg1MDddLFsxOTc4LDAuMDA4NTU4ODI2NTc3MTU2NDc0XSxbMTk3OSwwLjAwODU5MjYzNjM4ODk0MTg3OF0sWzE5ODAsMC4wMDg2Mjg2NjA0ODIzMTk1OTddLFsxOTgxLDAuMDA4NjY1NTcyMjQ2NDMxNDUxXSxbMTk4MiwwLjAwODY5OTE4NjI0ODQ5NjA5MV0sWzE5ODMsMC4wMDg3MjM5MzA4ODYwODM5MTZdLFsxOTg0LDAuMDA4NzM1OTQ2MjYwMDc0MzUyXSxbMTk4NSwwLjAwODczNDA0OTM1MzQwNDQ0Ml0sWzE5ODYsMC4wMDg3MTk3OTg0ODUxMDE5NF0sWzE5ODcsMC4wMDg2OTU1NjIxMzY5MTQyNjddLFsxOTg4LDAuMDA4NjY1MDAxOTUwNjE5NzI0XSxbMTk4OSwwLjAwODYzMTIwNTE5MjgxNTcwNF0sWzE5OTAsMC4wMDg1OTQyNDEyMTI3NzgzMTNdLFsxOTkxLDAuMDA4NTU0NDMyMjgwNjcyOTc1XSxbMTk5MiwwLjAwODUxNTQzMTg3OTUzOTYyOV0sWzE5OTMsMC4wMDg0ODE3NDI4MTcwODIwM10sWzE5OTQsMC4wMDg0NTY0MDE3NzU3MTk3MDhdLFsxOTk1LDAuMDA4NDQxMzUyMTY2OTMxMjUzXSxbMTk5NiwwLjAwODQzNTQ0MTE2MDk4NTY2Ml0sWzE5OTcsMC4wMDg0MzQ3MDkzMjIxNTQzMDRdLFsxOTk4LDAuMDA4NDMzMzQ1OTk2OTczNDc4XSxbMTk5OSwwLjAwODQyNzEzMzkzMzU4MjIxM10sWzIwMDAsMC4wMDg0MTQ3ODQwNTEzMTg4MDNdXSxcclxuICAgIFwiSW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb25cIjogW1sxOTc1LDAuMDA1MjQyOTA0NTI1NzMyNjU3NV0sWzE5NzYsMC4wMDU2MTUxMTI3OTQyODY0ODFdLFsxOTc3LDAuMDA2MDQ2NjkwMDQzNzY3NjhdLFsxOTc4LDAuMDA2NDA5NjgxMjEwMjU5NzE5XSxbMTk3OSwwLjAwNjY2Nzc2MDA2Nzk4OTY4MjVdLFsxOTgwLDAuMDA3MDkzMzczMzEwMjU0NDMyXSxbMTk4MSwwLjAwNzU0ODUzNTQ5NzM2NDMxNl0sWzE5ODIsMC4wMDgxNTg0OTA3ODA4NjQ3NTRdLFsxOTgzLDAuMDA4MzA3NTkwOTYxMjc1OTcyXSxbMTk4NCwwLjAwODQ3NDg1NDI1NDU3MzY0N10sWzE5ODUsMC4wMDg3Mjk5NTExMDg2OTUzODddLFsxOTg2LDAuMDA5MDg1ODkzOTAzMDIyNTMxXSxbMTk4NywwLjAwOTQ1MTg2NzA3MzEyMjc5NV0sWzE5ODgsMC4wMDk5MTQzNDg3MjM2MzQ2ODNdLFsxOTg5LDAuMDEwMTk0MTE0ODgwMzMzNTUxXSxbMTk5MCwwLjAxMDQ1ODQyODgzNjUxNzA3M10sWzE5OTEsMC4wMTA5NDE3ODQ1MTIyODY1MzJdLFsxOTkyLDAuMDEwOTg1OTcyMzgzOTM1Njc1XSxbMTk5MywwLjAxMTAyNTgyMjc5NTc5MTAzN10sWzE5OTQsMC4wMTA3MTg0MDUzMzI5MDY4MTddLFsxOTk1LDAuMDEwMTIzMDg4OTc2MjEwMzldLFsxOTk2LDAuMDA5NTMwMjEyNDQwNjQ3OTYyXSxbMTk5NywwLjAwOTU5MzM3NjY5ODg5NDg5Nl0sWzE5OTgsMC4wMDk2MzY3NTEyOTY4MzI3MDVdLFsxOTk5LDAuMDA5ODczNjg1MDM4MDY3OTg2XSxbMjAwMCwwLjAxMDEwODQ1MDA0OTQwNjM3OF1dLFxyXG4gICAgXCJJbmRleGVkIEdEUFwiOiBbWzE5NzUsMC4wNzIyNzM0MTQ5MzYwNDczMl0sWzE5NzYsMC4wODEzNTA1NzA3NjA1NTU2M10sWzE5NzcsMC4wOTA0Mjc3MjY1ODUwNjM5Nl0sWzE5NzgsMC4wOTk1MDQ4ODI0MDk1NzIyN10sWzE5NzksMC4xMDg1ODIwMzgyMzQwODA2XSxbMTk4MCwwLjExNzY1OTE5NDA1ODU4ODkyXSxbMTk4MSwwLjEzNDQ3MjU2MjIzMzUzMDQ2XSxbMTk4MiwwLjE0MzM3NzgwMjIyODAyOTE1XSxbMTk4MywwLjE2NzM3NzI1MjA5NzM3MzFdLFsxOTg0LDAuMTgxMzM2ODE3NDk0MTU0ODddLFsxOTg1LDAuMjA4MjI0NDUzMzA3NjYwNTddLFsxOTg2LDAuMjMwMjI5Njc5NTQ4ODkyODddLFsxOTg3LDAuMjM4NzkxMDg3ODgzMzcyM10sWzE5ODgsMC4yNTY3MzkxMDA1MzYzNzc0XSxbMTk4OSwwLjI2NTAyNTQ0MzU0Mjg0MTRdLFsxOTkwLDAuMjc2MTY1NTg5MzI3NDY1MjddLFsxOTkxLDAuMjk1OTAxNTI2NjEyNTcwNDZdLFsxOTkyLDAuMzA2NzY2NjA3MDY5MTc4OV0sWzE5OTMsMC4zMjUzNjc4OTk4NzYyMjA2XSxbMTk5NCwwLjMyNTYwODU4MjAzODIzNDA2XSxbMTk5NSwwLjI5NTg2NzE0MzQ0NjU2ODU2XSxbMTk5NiwwLjI5MTQ2NjA5ODE5ODMyMjFdLFsxOTk3LDAuMjk1ODMyNzYwMjgwNTY2NjVdLFsxOTk4LDAuMzEyNDA1NDQ2MjkzNDk0N10sWzE5OTksMC4zMjUzMzM1MTY3MTAyMTg2NV0sWzIwMDAsMC4zMzg0Njc4ODYxMjI5NTQyXV1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIkluZGlhXCIsXHJcbiAgICBcInJlZ2lvblwiOiBcIkFTXCIsXHJcbiAgICBcImNvZGVcIjogXCJJTkRcIixcclxuICAgIFwiUG9wdWxhdGlvblwiOiBbWzE5NzUsNTYxNDI3MzgyXSxbMTk3Niw1NzM5MDE3ODVdLFsxOTc3LDU4Njc2MjgxOV0sWzE5NzgsNjAwMDQ0MzE2XSxbMTk3OSw2MTM3NjcyMzNdLFsxOTgwLDYyNzk0MTgyNV0sWzE5ODEsNjQyNTUyNjYxXSxbMTk4Miw2NTc1NjIwNjRdLFsxOTgzLDY3MjkxNjkwMl0sWzE5ODQsNjg4NTc1NDE4XSxbMTk4NSw3MDQ1MTk3NzBdLFsxOTg2LDcyMDc0OTI1Ml0sWzE5ODcsNzM3MjU5MzQyXSxbMTk4OCw3NTQwNTA2OTZdLFsxOTg5LDc3MTEyMDU1Ml0sWzE5OTAsNzg4NDQyODcwXSxbMTk5MSw4MDU5OTg2NzBdLFsxOTkyLDgyMzc5OTE2OF0sWzE5OTMsODQxODY0MTE5XSxbMTk5NCw4NjAxOTUyNDJdLFsxOTk1LDg3ODc4OTIxN10sWzE5OTYsODk3NTk5MjEwXSxbMTk5Nyw5MTY1MjkyNTddLFsxOTk4LDkzNTQ1NTQ5Ml0sWzE5OTksOTU0MjgxNzMzXSxbMjAwMCw5NzI5Njg0NzddXSxcclxuICAgIFwiQXJhYmxlIEFyZWFcIjogW1sxOTc1LDE2NDQ0MF0sWzE5NzYsMTY1MjYwXSxbMTk3NywxNjY1MzBdLFsxOTc4LDE2NzIzMF0sWzE5NzksMTY4MDEwXSxbMTk4MCwxNjgxODldLFsxOTgxLDE2ODI2MF0sWzE5ODIsMTY4NjM1XSxbMTk4MywxNjg0MjNdLFsxOTg0LDE2ODI1NV0sWzE5ODUsMTY4MzkxXSxbMTk4NiwxNjg2NzVdLFsxOTg3LDE2ODUyMF0sWzE5ODgsMTY5MDc4XSxbMTk4OSwxNjkwMTVdLFsxOTkwLDE2OTI1MF0sWzE5OTEsMTY5NzcwXSxbMTk5MiwxNjkzMTBdLFsxOTkzLDE2OTQ4NV0sWzE5OTQsMTY5NDM4XSxbMTk5NSwxNjkzNDBdLFsxOTk2LDE2OTI3MF0sWzE5OTcsMTY5NzM3XSxbMTk5OCwxNjk3OTBdLFsxOTk5LDE2OTc1MF0sWzIwMDAsMTY5NTMwXV0sXHJcbiAgICBcIkVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsNjYzODNdLFsxOTc2LDcwNTA4XSxbMTk3Nyw3Mjc4NV0sWzE5NzgsNzY2NjVdLFsxOTc5LDg1OTA4XSxbMTk4MCw5NTU5MV0sWzE5ODEsOTg5MDNdLFsxOTgyLDExMDA4Nl0sWzE5ODMsMTEyNzg2XSxbMTk4NCwxMTkyMjNdLFsxOTg1LDEzMTAzNl0sWzE5ODYsMTQwMjI3XSxbMTk4NywxNTA5MDldLFsxOTg4LDE2OTEwMF0sWzE5ODksMTgzMjk5XSxbMTk5MCwyMDEzODJdLFsxOTkxLDIxOTgzOF0sWzE5OTIsMjQyNTA4XSxbMTk5MywyNjk5NjFdLFsxOTk0LDI5MDgxNV0sWzE5OTUsMzE3MDg0XSxbMTk5NiwzMzM5MTldLFsxOTk3LDM1Nzc4MV0sWzE5OTgsMzg2OTgwXSxbMTk5OSw0MTk1NjVdLFsyMDAwLDQzODM3Ml1dLFxyXG4gICAgXCJHRFAgUGVyIENhcGl0YVwiOiBbWzE5NzUsMzQ0XSxbMTk3NiwzNjZdLFsxOTc3LDM4OF0sWzE5NzgsNDEwXSxbMTk3OSw0MzJdLFsxOTgwLDQ1NF0sWzE5ODEsNTA2XSxbMTk4Miw1NjBdLFsxOTgzLDU2MF0sWzE5ODQsNjM2XSxbMTk4NSw3MjZdLFsxOTg2LDc4NF0sWzE5ODcsODU1XSxbMTk4OCw5MDVdLFsxOTg5LDk2NV0sWzE5OTAsMTAxM10sWzE5OTEsMTA2NF0sWzE5OTIsMTE4OF0sWzE5OTMsMTI4N10sWzE5OTQsMTM4OF0sWzE5OTUsMTQyNF0sWzE5OTYsMTUwNV0sWzE5OTcsMTU4M10sWzE5OTgsMTcwNF0sWzE5OTksMTgzNl0sWzIwMDAsMTk3MV1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKFdvbWVuKVwiOiBbWzE5NzUsNDYuODhdLFsxOTc2LDQ3LjY2XSxbMTk3Nyw0OC40NF0sWzE5NzgsNDkuMjJdLFsxOTc5LDUwXSxbMTk4MCw1MC43OF0sWzE5ODEsNTEuNTZdLFsxOTgyLDUyLjMzXSxbMTk4Myw1My4xMl0sWzE5ODQsNTMuOV0sWzE5ODUsNTQuNDRdLFsxOTg2LDU0Ljk4XSxbMTk4Nyw1NS41Ml0sWzE5ODgsNTYuMDZdLFsxOTg5LDU2LjZdLFsxOTkwLDU3LjA0XSxbMTk5MSw1Ny40OF0sWzE5OTIsNTcuOTJdLFsxOTkzLDU4LjM2XSxbMTk5NCw1OC44XSxbMTk5NSw1OS4xOV0sWzE5OTYsNTkuNTldLFsxOTk3LDYwXSxbMTk5OCw2MC40XSxbMTk5OSw2MC44XSxbMjAwMCw2MS4xOV1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKE1lbilcIjogW1sxOTc1LDQ4LjgzXSxbMTk3Niw0OS40OF0sWzE5NzcsNTAuMTJdLFsxOTc4LDUwLjc2XSxbMTk3OSw1MS40XSxbMTk4MCw1Mi4wNF0sWzE5ODEsNTIuNjhdLFsxOTgyLDUzLjMyXSxbMTk4Myw1My45Nl0sWzE5ODQsNTQuNl0sWzE5ODUsNTUuMDRdLFsxOTg2LDU1LjQ4XSxbMTk4Nyw1NS45Ml0sWzE5ODgsNTYuMzZdLFsxOTg5LDU2LjhdLFsxOTkwLDU3LjE0XSxbMTk5MSw1Ny40OF0sWzE5OTIsNTcuODJdLFsxOTkzLDU4LjE2XSxbMTk5NCw1OC41XSxbMTk5NSw1OC43OF0sWzE5OTYsNTkuMDZdLFsxOTk3LDU5LjMzXSxbMTk5OCw1OS42Ml0sWzE5OTksNTkuOV0sWzIwMDAsNjAuMThdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5XCI6IFtbMTk3NSw0Ny43Ml0sWzE5NzYsNDguNDRdLFsxOTc3LDQ5LjE2XSxbMTk3OCw0OS44OF0sWzE5NzksNTAuNl0sWzE5ODAsNTEuMzJdLFsxOTgxLDUyLjA0XSxbMTk4Miw1Mi43Nl0sWzE5ODMsNTMuNDhdLFsxOTg0LDU0LjJdLFsxOTg1LDU0LjY4XSxbMTk4Niw1NS4xNl0sWzE5ODcsNTUuNjRdLFsxOTg4LDU2LjEyXSxbMTk4OSw1Ni42XSxbMTk5MCw1Ni45OF0sWzE5OTEsNTcuMzZdLFsxOTkyLDU3Ljc0XSxbMTk5Myw1OC4xMl0sWzE5OTQsNTguNV0sWzE5OTUsNTguODRdLFsxOTk2LDU5LjE4XSxbMTk5Nyw1OS41Ml0sWzE5OTgsNTkuODZdLFsxOTk5LDYwLjJdLFsyMDAwLDYwLjU0XV0sXHJcbiAgICBcIkluZmFudCBNb3J0YWxpdHlcIjogW1sxOTc1LDEyNS4wN10sWzE5NzYsMTIzXSxbMTk3NywxMjAuODldLFsxOTc4LDExOC45XSxbMTk3OSwxMTYuOF0sWzE5ODAsMTE0LjY5XSxbMTk4MSwxMTIuN10sWzE5ODIsMTEwLjZdLFsxOTgzLDEwOC40OV0sWzE5ODQsMTA2LjVdLFsxOTg1LDEwNC40XSxbMTk4NiwxMDIuNDZdLFsxOTg3LDEwMC41Ml0sWzE5ODgsOTguNThdLFsxOTg5LDk2LjY0XSxbMTk5MCw5NC43XSxbMTk5MSw5Mi45XSxbMTk5Miw5MS4xXSxbMTk5Myw4OS4zXSxbMTk5NCw4Ny41XSxbMTk5NSw4NS43XSxbMTk5Niw4NF0sWzE5OTcsODIuM10sWzE5OTgsODAuNl0sWzE5OTksNzguOV0sWzIwMDAsNzcuMl1dLFxyXG4gICAgXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCI6IFtbMTk3NSwwXSxbMTk3NiwwXSxbMTk3NywwXSxbMTk3OCwwXSxbMTk3OSwwXSxbMTk4MCwwXSxbMTk4MSwwXSxbMTk4MiwwXSxbMTk4MywwXSxbMTk4NCwwXSxbMTk4NSwwXSxbMTk4NiwwXSxbMTk4NywwXSxbMTk4OCwwXSxbMTk4OSwwXSxbMTk5MCwwXSxbMTk5MSwwXSxbMTk5MiwwXSxbMTk5MywwXSxbMTk5NCwwXSxbMTk5NSwwXSxbMTk5NiwwXSxbMTk5NywwLjFdLFsxOTk4LDAuMV0sWzE5OTksMC4xXSxbMjAwMCwwLjJdXSxcclxuICAgIFwiSW5kZXhlZCBQb3B1bGF0aW9uXCI6IFtbMTk3NSwwLjQ1ODA1MzkxMjA3OTkyMjc0XSxbMTk3NiwwLjQ2ODIzMTQ1MTExMzgzMzg1XSxbMTk3NywwLjQ3ODcyNDQzMjI2NTAzMjddLFsxOTc4LDAuNDg5NTYwNDU4MTc3MTU2NF0sWzE5NzksMC41MDA3NTY2MjcxMTgxOTY4XSxbMTk4MCwwLjUxMjMyMTMwNTg3NDM0NzddLFsxOTgxLDAuNTI0MjQxOTA0Njk2NDM3NV0sWzE5ODIsMC41MzY0ODc2ODM5MDU5Mjc3XSxbMTk4MywwLjU0OTAxNTI5NDQ5NDEzNjNdLFsxOTg0LDAuNTYxNzkwNjY4MDE3MjcxOF0sWzE5ODUsMC41NzQ3OTkyNDc2NTQzNDNdLFsxOTg2LDAuNTg4MDQwNDU3Mzk4NDIxMV0sWzE5ODcsMC42MDE1MTA2MDc4NjgwMTc2XSxbMTk4OCwwLjYxNTIxMDIzNDI3NjM2OTFdLFsxOTg5LDAuNjI5MTM3MDgzMTc5OTM5Ml0sWzE5OTAsMC42NDMyNjk5MDkyMjQwMjQ5XSxbMTk5MSwwLjY1NzU5MzIyNzEyMzIwOTFdLFsxOTkyLDAuNjcyMTE2MTg3NzE4NDQyMV0sWzE5OTMsMC42ODY4NTQ5MDg1OTczNjQ0XSxbMTk5NCwwLjcwMTgxMDc5MjI0NzEwMTFdLFsxOTk1LDAuNzE2OTgxMTI5OTY2NTE0OF0sWzE5OTYsMC43MzIzMjc3MTExMjAzNDZdLFsxOTk3LDAuNzQ3NzcyMjQxMTkxNzQ2N10sWzE5OTgsMC43NjMyMTM2NjExNTIwODI3XSxbMTk5OSwwLjc3ODU3MzQ5ODYyNDAwOTZdLFsyMDAwLDAuNzkzODE5NTI0MTQzMzYzNF1dLFxyXG4gICAgXCJJbmRleGVkIEVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsMC4wMTc5OTU4NDk1OTMxNTk4MjVdLFsxOTc2LDAuMDE5MTE0MTAwOTQ2MjQzOTY0XSxbMTk3NywwLjAxOTczMTM3NTY5MzE0NjQwN10sWzE5NzgsMC4wMjA3ODMyMDk2OTMxMzgyNzNdLFsxOTc5LDAuMDIzMjg4OTA1OTk3NzU4MDc2XSxbMTk4MCwwLjAyNTkxMzg4MjQ0NjcwNjg1XSxbMTk4MSwwLjAyNjgxMTczNjYyNDAxOTVdLFsxOTgyLDAuMDI5ODQzMzQ5OTI4NjM1MjMzXSxbMTk4MywwLjAzMDU3NTI5NjI2ODgzNTc1OF0sWzE5ODQsMC4wMzIzMjAzMTA1NjIxMjEyMzZdLFsxOTg1LDAuMDM1NTIyNzExMzQ2MTE3MDldLFsxOTg2LDAuMDM4MDE0MzEwOTA2NDA3MTA1XSxbMTk4NywwLjA0MDkxMDEwNzUwMTIzMDA4XSxbMTk4OCwwLjA0NTg0MTUyODE5NTUyMTg0XSxbMTk4OSwwLjA0OTY5MDc1MjY3MTI2NTI4XSxbMTk5MCwwLjA1NDU5Mjg5NTUxMTk0OTAzXSxbMTk5MSwwLjA1OTU5NjE1NTM4NDA3NTI5XSxbMTk5MiwwLjA2NTc0MTc5MzcyOTM4ODZdLFsxOTkzLDAuMDczMTg0MDYxNDYxODA1MjhdLFsxOTk0LDAuMDc4ODM3Mzk4MTIwNTI0NDVdLFsxOTk1LDAuMDg1OTU4NjkzODI4MjAxMzRdLFsxOTk2LDAuMDkwNTIyNTE0ODA0OTcwMTldLFsxOTk3LDAuMDk2OTkxMjkzOTA0OTIwMTddLFsxOTk4LDAuMTA0OTA2ODg2OTM3MzMzMTldLFsxOTk5LDAuMTEzNzQwMzk0ODk4NjA1MV0sWzIwMDAsMC4xMTg4Mzg4MDc3OTQ5NTc0NF1dLFxyXG4gICAgXCJJbmRleGVkIEdEUFwiOiBbWzE5NzUsMC4wMTE4Mjc4MDkxMDQ2NjIzNTddLFsxOTc2LDAuMDEyNTg0MjM4NzU2NzA0NzE3XSxbMTk3NywwLjAxMzM0MDY2ODQwODc0NzA3OF0sWzE5NzgsMC4wMTQwOTcwOTgwNjA3ODk0MzhdLFsxOTc5LDAuMDE0ODUzNTI3NzEyODMxNzk3XSxbMTk4MCwwLjAxNTYwOTk1NzM2NDg3NDE1OF0sWzE5ODEsMC4wMTczOTc4ODE5OTY5NzQyOF0sWzE5ODIsMC4wMTkyNTQ1NzI5NjEwNzgyNTZdLFsxOTgzLDAuMDE5MjU0NTcyOTYxMDc4MjU2XSxbMTk4NCwwLjAyMTg2NzY5MzU3NzIyNDU5XSxbMTk4NSwwLjAyNDk2MjE3ODUxNzM5Nzg4M10sWzE5ODYsMC4wMjY5NTY0MDIxNDU1MDk1Nl0sWzE5ODcsMC4wMjkzOTc2MDY5MzE2NDYyNjddLFsxOTg4LDAuMDMxMTE2NzY1MjMxNzQyNTRdLFsxOTg5LDAuMDMzMTc5NzU1MTkxODU4MDddLFsxOTkwLDAuMDM0ODMwMTQ3MTU5OTUwNDldLFsxOTkxLDAuMDM2NTgzNjg4NjI2MDQ4NjldLFsxOTkyLDAuMDQwODQ3MjAxMjEwMjg3NDRdLFsxOTkzLDAuMDQ0MjUxMTM0NjQ0NDc4MDY2XSxbMTk5NCwwLjA0NzcyMzgzNDQxMDY3MjU0XSxbMTk5NSwwLjA0ODk2MTYyODM4Njc0MTg1NF0sWzE5OTYsMC4wNTE3NDY2NjQ4MzI4OTc4MV0sWzE5OTcsMC4wNTQ0Mjg1NTE3ODEwNDc5OTZdLFsxOTk4LDAuMDU4NTg4OTE0ODY3MjgwOThdLFsxOTk5LDAuMDYzMTI3NDkyNzc5NTM1MTRdLFsyMDAwLDAuMDY3NzY5MjIwMTg5Nzk1MDddXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiSWNlbGFuZFwiLFxyXG4gICAgXCJyZWdpb25cIjogXCJFVVwiLFxyXG4gICAgXCJjb2RlXCI6IFwiSVNMXCIsXHJcbiAgICBcIlBvcHVsYXRpb25cIjogW1sxOTc1LDIwNjgyMV0sWzE5NzYsMjA5NzIyXSxbMTk3NywyMTI2NzNdLFsxOTc4LDIxNTQ4NV0sWzE5NzksMjE4MDMxXSxbMTk4MCwyMjAyNjBdLFsxOTgxLDIyMjIzOF0sWzE5ODIsMjI0MDk2XSxbMTk4MywyMjYwMjVdLFsxOTg0LDIyODE2MF0sWzE5ODUsMjMwNTQzXSxbMTk4NiwyMzMxMzFdLFsxOTg3LDIzNTg2MV0sWzE5ODgsMjM4NjQxXSxbMTk4OSwyNDEzOThdLFsxOTkwLDI0NDEyM10sWzE5OTEsMjQ2ODM2XSxbMTk5MiwyNDk1MjRdLFsxOTkzLDI1MjE3OF0sWzE5OTQsMjU0NzkzXSxbMTk5NSwyNTczNjBdLFsxOTk2LDI1OTg4Ml0sWzE5OTcsMjYyMzg2XSxbMTk5OCwyNjQ5MDhdLFsxOTk5LDI2NzQ3OF0sWzIwMDAsMjcwMDk2XV0sXHJcbiAgICBcIkFyYWJsZSBBcmVhXCI6IFtbMTk3NSw3XSxbMTk3Niw3XSxbMTk3Nyw4XSxbMTk3OCw4XSxbMTk3OSw4XSxbMTk4MCw4XSxbMTk4MSw4XSxbMTk4Miw4XSxbMTk4Myw4XSxbMTk4NCw4XSxbMTk4NSw4XSxbMTk4Niw4XSxbMTk4Nyw4XSxbMTk4OCw3XSxbMTk4OSw3XSxbMTk5MCw3XSxbMTk5MSw3XSxbMTk5Miw3XSxbMTk5Myw3XSxbMTk5NCw3XSxbMTk5NSw3XSxbMTk5Niw2XSxbMTk5Nyw2XSxbMTk5OCw2XSxbMTk5OSw2XSxbMjAwMCw2XV0sXHJcbiAgICBcIkVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsMTYyMV0sWzE5NzYsMTc5NV0sWzE5NzcsMjM5MF0sWzE5NzgsMjM3NF0sWzE5NzksMjMzMF0sWzE5ODAsMjQyNl0sWzE5ODEsMjYwN10sWzE5ODIsMjY3OV0sWzE5ODMsMjk1OV0sWzE5ODQsMzE1NV0sWzE5ODUsMzMyOV0sWzE5ODYsMzc1OF0sWzE5ODcsMzk2MF0sWzE5ODgsNDEyNV0sWzE5ODksNDA0NF0sWzE5OTAsNDExNF0sWzE5OTEsNDIxMF0sWzE5OTIsNDQ4Ml0sWzE5OTMsNDU0MV0sWzE5OTQsNDUxMF0sWzE5OTUsNDQ5NF0sWzE5OTYsNDU0Nl0sWzE5OTcsNDcyN10sWzE5OTgsNDc4MF0sWzE5OTksNDk4MV0sWzIwMDAsNTEyM11dLFxyXG4gICAgXCJHRFAgUGVyIENhcGl0YVwiOiBbWzE5NzUsMzMyNF0sWzE5NzYsMzk5OV0sWzE5NzcsNDY3NF0sWzE5NzgsNTM0OV0sWzE5NzksNjAyNF0sWzE5ODAsNjY5OV0sWzE5ODEsNzY1MV0sWzE5ODIsODYzNV0sWzE5ODMsOTcyOF0sWzE5ODQsMTExMzVdLFsxOTg1LDEyNjE5XSxbMTk4NiwxMzU4Ml0sWzE5ODcsMTM3NTBdLFsxOTg4LDE0ODIzXSxbMTk4OSwxNTU2NV0sWzE5OTAsMTY2NDldLFsxOTkxLDE4MTU3XSxbMTk5MiwxODUxNl0sWzE5OTMsMTkyNzBdLFsxOTk0LDIwMDYyXSxbMTk5NSwyMDM3N10sWzE5OTYsMTk4MzldLFsxOTk3LDIwMjgzXSxbMTk5OCwyMTUxNF0sWzE5OTksMjE3NDVdLFsyMDAwLDIzMDI0XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoV29tZW4pXCI6IFtbMTk3NSw3NS44OF0sWzE5NzYsNzYuMjZdLFsxOTc3LDc2LjY0XSxbMTk3OCw3Ny4wMl0sWzE5NzksNzcuNF0sWzE5ODAsNzcuNzhdLFsxOTgxLDc4LjE2XSxbMTk4Miw3OC41NF0sWzE5ODMsNzguOTJdLFsxOTg0LDc5LjNdLFsxOTg1LDc5LjM5XSxbMTk4Niw3OS41XSxbMTk4Nyw3OS42XSxbMTk4OCw3OS43XSxbMTk4OSw3OS44XSxbMTk5MCw3OS44OV0sWzE5OTEsODBdLFsxOTkyLDgwLjFdLFsxOTkzLDgwLjJdLFsxOTk0LDgwLjNdLFsxOTk1LDgwLjM5XSxbMTk5Niw4MC41XSxbMTk5Nyw4MC42XSxbMTk5OCw4MC43XSxbMTk5OSw4MC44XSxbMjAwMCw4MC44OV1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKE1lbilcIjogW1sxOTc1LDY5LjhdLFsxOTc2LDcwLjJdLFsxOTc3LDcwLjZdLFsxOTc4LDcxXSxbMTk3OSw3MS40XSxbMTk4MCw3MS44XSxbMTk4MSw3Mi4yXSxbMTk4Miw3Mi42XSxbMTk4Myw3M10sWzE5ODQsNzMuNF0sWzE5ODUsNzMuNV0sWzE5ODYsNzMuNl0sWzE5ODcsNzMuN10sWzE5ODgsNzMuOF0sWzE5ODksNzMuOV0sWzE5OTAsNzQuMThdLFsxOTkxLDc0LjQ2XSxbMTk5Miw3NC43NF0sWzE5OTMsNzUuMDJdLFsxOTk0LDc1LjNdLFsxOTk1LDc1LjVdLFsxOTk2LDc1LjddLFsxOTk3LDc1Ljg5XSxbMTk5OCw3Ni4xXSxbMTk5OSw3Ni4zXSxbMjAwMCw3Ni41XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeVwiOiBbWzE5NzUsNzIuN10sWzE5NzYsNzMuMV0sWzE5NzcsNzMuNV0sWzE5NzgsNzMuODldLFsxOTc5LDc0LjNdLFsxOTgwLDc0LjddLFsxOTgxLDc1LjFdLFsxOTgyLDc1LjVdLFsxOTgzLDc1Ljg5XSxbMTk4NCw3Ni4zXSxbMTk4NSw3Ni4zOV0sWzE5ODYsNzYuNV0sWzE5ODcsNzYuNl0sWzE5ODgsNzYuN10sWzE5ODksNzYuOF0sWzE5OTAsNzddLFsxOTkxLDc3LjJdLFsxOTkyLDc3LjM5XSxbMTk5Myw3Ny42XSxbMTk5NCw3Ny44XSxbMTk5NSw3Ny45Nl0sWzE5OTYsNzguMTFdLFsxOTk3LDc4LjI4XSxbMTk5OCw3OC40NF0sWzE5OTksNzguNl0sWzIwMDAsNzguNzVdXSxcclxuICAgIFwiSW5mYW50IE1vcnRhbGl0eVwiOiBbWzE5NzUsMTMuNjNdLFsxOTc2LDEzLjE0XSxbMTk3NywxMi42NV0sWzE5NzgsMTIuMTldLFsxOTc5LDExLjddLFsxOTgwLDExLjJdLFsxOTgxLDEwLjc0XSxbMTk4MiwxMC4yNV0sWzE5ODMsOS43NV0sWzE5ODQsOS4yOV0sWzE5ODUsOC44XSxbMTk4Niw4LjMyXSxbMTk4Nyw3Ljg0XSxbMTk4OCw3LjM2XSxbMTk4OSw2Ljg4XSxbMTk5MCw2LjRdLFsxOTkxLDYuMzJdLFsxOTkyLDYuMjRdLFsxOTkzLDYuMTZdLFsxOTk0LDYuMDhdLFsxOTk1LDZdLFsxOTk2LDUuNzhdLFsxOTk3LDUuNTZdLFsxOTk4LDUuMzRdLFsxOTk5LDUuMTJdLFsyMDAwLDQuOV1dLFxyXG4gICAgXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCI6IFtbMTk3NSwwXSxbMTk3NiwwXSxbMTk3NywwXSxbMTk3OCwwXSxbMTk3OSwwXSxbMTk4MCwwXSxbMTk4MSwwXSxbMTk4MiwwXSxbMTk4MywwXSxbMTk4NCwwXSxbMTk4NSwwXSxbMTk4NiwwXSxbMTk4NywwXSxbMTk4OCwwXSxbMTk4OSwwXSxbMTk5MCwwXSxbMTk5MSwwXSxbMTk5MiwwXSxbMTk5MywwLjU3XSxbMTk5NCwzLjldLFsxOTk1LDcuN10sWzE5OTYsMTEuNF0sWzE5OTcsMTMuMl0sWzE5OTgsMTYuOV0sWzE5OTksMjAuNV0sWzIwMDAsMjZdXSxcclxuICAgIFwiSW5kZXhlZCBQb3B1bGF0aW9uXCI6IFtbMTk3NSwwLjAwMDE2ODczOTg0Mjc0Mjk3Nzc1XSxbMTk3NiwwLjAwMDE3MTEwNjY5Mjc0MjcyMzMyXSxbMTk3NywwLjAwMDE3MzUxNDMzNjQzNDI5NDldLFsxOTc4LDAuMDAwMTc1ODA4NTczNjYyNTkwMThdLFsxOTc5LDAuMDAwMTc3ODg1Nzg4NDUwMzcxMDFdLFsxOTgwLDAuMDAwMTc5NzA0MzcxMjMxOTc0OTJdLFsxOTgxLDAuMDAwMTgxMzE4MTY5NjgwNjEyMTddLFsxOTgyLDAuMDAwMTgyODM0MDYzMjY4ODY3XSxbMTk4MywwLjAwMDE4NDQwNzg4Mzg5OTUxNDhdLFsxOTg0LDAuMDAwMTg2MTQ5Nzc0NTQwNDg1NzddLFsxOTg1LDAuMDAwMTg4MDk0MDAxODkyOTEzNzhdLFsxOTg2LDAuMDAwMTkwMjA1NDgzMzgxODI4NDddLFsxOTg3LDAuMDAwMTkyNDMyODE4OTU1NTI5MDddLFsxOTg4LDAuMDAwMTk0NzAwOTQ4MjIxMDU1NjddLFsxOTg5LDAuMDAwMTk2OTUwMzEyMzg4MzQyMzJdLFsxOTkwLDAuMDAwMTk5MTczNTY4NTkyODYwM10sWzE5OTEsMC4wMDAyMDEzODcwMzQzMTEzNDAwNF0sWzE5OTIsMC4wMDAyMDM1ODAxMDMxODM5MDY3OF0sWzE5OTMsMC4wMDAyMDU3NDU0MzIzNDYwMzE4Ml0sWzE5OTQsMC4wMDAyMDc4Nzg5NDI0Mjg1MzI1Nl0sWzE5OTUsMC4wMDAyMDk5NzMyOTA1NjY4ODAzM10sWzE5OTYsMC4wMDAyMTIwMzA5MjQzODI1ODQ2OF0sWzE5OTcsMC4wMDAyMTQwNzM4NzI0NjkyMzE2Nl0sWzE5OTgsMC4wMDAyMTYxMzE1MDYyODQ5MzZdLFsxOTk5LDAuMDAwMjE4MjI4MzAyMDQ0NzkzMzRdLFsyMDAwLDAuMDAwMjIwMzY0MjU5NzQ4ODAzNjVdXSxcclxuICAgIFwiSW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb25cIjogW1sxOTc1LDAuMDAwNDM5NDM4ODk1MzU3NDI3MDRdLFsxOTc2LDAuMDAwNDg2NjA4NzcwNjE0Nzk0M10sWzE5NzcsMC4wMDA2NDc5MDgwNTY2OTYwMjEzXSxbMTk3OCwwLjAwMDY0MzU3MDU5NjkwMjI0MDRdLFsxOTc5LDAuMDAwNjMxNjQyNTgyNDY5MzQzXSxbMTk4MCwwLjAwMDY1NzY2NzM0MTIzMjAyODNdLFsxOTgxLDAuMDAwNzA2NzM0ODU1MTQ5MTc0OF0sWzE5ODIsMC4wMDA3MjYyNTM0MjQyMjExODg3XSxbMTk4MywwLjAwMDgwMjE1ODk3MDYxMjM1NDVdLFsxOTg0LDAuMDAwODU1MjkyODUzMDg2MTcwNF0sWzE5ODUsMC4wMDA5MDI0NjI3MjgzNDM1Mzc2XSxbMTk4NiwwLjAwMTAxODc2MDg2OTA2NDI4NzhdLFsxOTg3LDAuMDAxMDczNTIxMjk4OTYwNzcxN10sWzE5ODgsMC4wMDExMTgyNTEzNTMwODQxMzcyXSxbMTk4OSwwLjAwMTA5NjI5Mjk2Mjg3ODEyMTRdLFsxOTkwLDAuMDAxMTE1MjY5MzQ5NDc1OTEzXSxbMTk5MSwwLjAwMTE0MTI5NDEwODIzODU5ODJdLFsxOTkyLDAuMDAxMjE1MDMwOTI0NzMyODczNF0sWzE5OTMsMC4wMDEyMzEwMjUzMDc3MjI0NDA2XSxbMTk5NCwwLjAwMTIyMjYyMTQ3OTM3MTk5MDFdLFsxOTk1LDAuMDAxMjE4Mjg0MDE5NTc4MjA5XSxbMTk5NiwwLjAwMTIzMjM4MDc2MzkwNzk5NzFdLFsxOTk3LDAuMDAxMjgxNDQ4Mjc3ODI1MTQzNV0sWzE5OTgsMC4wMDEyOTU4MTYxMTMzOTIwNDI3XSxbMTk5OSwwLjAwMTM1MDMwNTQ1MjA1MTQxNTJdLFsyMDAwLDAuMDAxMzg4ODAwNDA3NzIxMjIwNl1dLFxyXG4gICAgXCJJbmRleGVkIEdEUFwiOiBbWzE5NzUsMC4xMTQyODk2NDM3OTA0MDAyMV0sWzE5NzYsMC4xMzc0OTgyODA4NDE2OTk5XSxbMTk3NywwLjE2MDcwNjkxNzg5Mjk5OTZdLFsxOTc4LDAuMTgzOTE1NTU0OTQ0Mjk5MjZdLFsxOTc5LDAuMjA3MTI0MTkxOTk1NTk4OTVdLFsxOTgwLDAuMjMwMzMyODI5MDQ2ODk4NjRdLFsxOTgxLDAuMjYzMDY1NjAzMDgwNzMxN10sWzE5ODIsMC4yOTY4OTg2Mzg0MjY2MjYzNF0sWzE5ODMsMC4zMzQ0Nzk0Mzg4NjY3MzA4N10sWzE5ODQsMC4zODI4NTY1NTM0MzE0NF0sWzE5ODUsMC40MzM4ODExNzE3NzgyOTczXSxbMTk4NiwwLjQ2Njk5MjE2MDYzODE1MTZdLFsxOTg3LDAuNDcyNzY4NTMyNTI2NDc1MDVdLFsxOTg4LDAuNTA5NjYxNjY5NjQ2NTQxXSxbMTk4OSwwLjUzNTE3Mzk3ODgxOTk2OThdLFsxOTkwLDAuNTcyNDQ1MzMwNzY2MDU3XSxbMTk5MSwwLjYyNDI5NTE0NTA5Njk2MDVdLFsxOTkyLDAuNjM2NjM4NzAxNjkxNjUxOF0sWzE5OTMsMC42NjI1NjM2MDg4NTcxMDM1XSxbMTk5NCwwLjY4OTc5NTA3NjMzMDYyODVdLFsxOTk1LDAuNzAwNjI1NzczNjIxMjM1XSxbMTk5NiwwLjY4MjEyNzYzMDMxMjE5OTFdLFsxOTk3LDAuNjk3MzkzNzU2MDE3MDU0XSxbMTk5OCwwLjczOTcxOTQzMzM2NTQyNDNdLFsxOTk5LDAuNzQ3NjYxOTQ0NzExODY5MV0sWzIwMDAsMC43OTE2MzgwMTQwMjgzMzE4XV1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIklzcmFlbFwiLFxyXG4gICAgXCJyZWdpb25cIjogXCJBU1wiLFxyXG4gICAgXCJjb2RlXCI6IFwiSVNSXCIsXHJcbiAgICBcIlBvcHVsYXRpb25cIjogW1sxOTc1LDI5ODExNzhdLFsxOTc2LDMwNzI3NDldLFsxOTc3LDMxNjkyMTZdLFsxOTc4LDMyNjU2MTVdLFsxOTc5LDMzNTgyNTFdLFsxOTgwLDM0NDY1MjldLFsxOTgxLDM1MzEzODddLFsxOTgyLDM2MTI1MzFdLFsxOTgzLDM2ODk5NjRdLFsxOTg0LDM3NjM5MDFdLFsxOTg1LDM4MzQ5NTFdLFsxOTg2LDM5MDM3NTJdLFsxOTg3LDM5NzA4MDZdLFsxOTg4LDQwMzY3MTVdLFsxOTg5LDQxMDI2MDFdLFsxOTkwLDQxNjcxMTddLFsxOTkxLDQyMzIwMjBdLFsxOTkyLDQzMDUxNjFdLFsxOTkzLDQzOTY4MzFdLFsxOTk0LDQ1MTM3MDBdLFsxOTk1LDQ2NTkzMTBdLFsxOTk2LDQ4Mjk2OTBdLFsxOTk3LDUwMTQ2MzNdLFsxOTk4LDUxOTk2MTRdLFsxOTk5LDUzNzM5MDBdLFsyMDAwLDU1MzQwNjddXSxcclxuICAgIFwiQXJhYmxlIEFyZWFcIjogW1sxOTc1LDQxMV0sWzE5NzYsNDExXSxbMTk3Nyw0MjFdLFsxOTc4LDQyN10sWzE5NzksNDIyXSxbMTk4MCw0MTJdLFsxOTgxLDQxM10sWzE5ODIsNDEzXSxbMTk4Myw0MTNdLFsxOTg0LDQxM10sWzE5ODUsNDE4XSxbMTk4Niw0MjBdLFsxOTg3LDQwN10sWzE5ODgsNDE5XSxbMTk4OSw0MjBdLFsxOTkwLDQyOF0sWzE5OTEsNDI4XSxbMTk5Miw0MjhdLFsxOTkzLDQyN10sWzE5OTQsNDMxXSxbMTk5NSw0MzNdLFsxOTk2LDQzMl0sWzE5OTcsNDMyXSxbMTk5OCw0MzRdLFsxOTk5LDQyOF0sWzIwMDAsNDE5XV0sXHJcbiAgICBcIkVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsNzYwNl0sWzE5NzYsODQzOF0sWzE5NzcsODY2M10sWzE5NzgsOTA4Nl0sWzE5NzksOTYyNl0sWzE5ODAsMTAyNTVdLFsxOTgxLDEwOTczXSxbMTk4MiwxMTcxMV0sWzE5ODMsMTIyNTFdLFsxOTg0LDEyMzYzXSxbMTk4NSwxMjkzMV0sWzE5ODYsMTM2MjVdLFsxOTg3LDE0Mzg0XSxbMTk4OCwxNDcxMF0sWzE5ODksMTUxMzFdLFsxOTkwLDE1NjMwXSxbMTk5MSwxNzA3NF0sWzE5OTIsMTg5OTFdLFsxOTkzLDIwMDg3XSxbMTk5NCwyMDUwN10sWzE5OTUsMjExNTRdLFsxOTk2LDI0MDcwXSxbMTk5NywyNTM3MF0sWzE5OTgsMjc1ODFdLFsxOTk5LDI5NDc0XSxbMjAwMCwzMTUzMV1dLFxyXG4gICAgXCJHRFAgUGVyIENhcGl0YVwiOiBbWzE5NzUsNDQ1Nl0sWzE5NzYsNDcxNl0sWzE5NzcsNDk3Nl0sWzE5NzgsNTIzNl0sWzE5NzksNTQ5Nl0sWzE5ODAsNTc1Nl0sWzE5ODEsNTkxOF0sWzE5ODIsNjUzNF0sWzE5ODMsNzQwNV0sWzE5ODQsODM4MF0sWzE5ODUsOTM1MF0sWzE5ODYsOTk3MV0sWzE5ODcsMTA1NTFdLFsxOTg4LDExMDQ1XSxbMTk4OSwxMTUxOF0sWzE5OTAsMTIwOTldLFsxOTkxLDEzMDY3XSxbMTk5MiwxMzQ3MV0sWzE5OTMsMTM4NzNdLFsxOTk0LDE0ODkxXSxbMTk5NSwxNTU0OF0sWzE5OTYsMTYyNTNdLFsxOTk3LDE3MDIwXSxbMTk5OCwxODA5MV0sWzE5OTksMTk1MTBdLFsyMDAwLDIwMTIyXV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoV29tZW4pXCI6IFtbMTk3NSw3Mi4xXSxbMTk3Niw3Mi4zOV0sWzE5NzcsNzIuN10sWzE5NzgsNzNdLFsxOTc5LDczLjNdLFsxOTgwLDczLjZdLFsxOTgxLDczLjg5XSxbMTk4Miw3NC4yXSxbMTk4Myw3NC41XSxbMTk4NCw3NC44XSxbMTk4NSw3NS4wOF0sWzE5ODYsNzUuMzZdLFsxOTg3LDc1LjY0XSxbMTk4OCw3NS45Ml0sWzE5ODksNzYuMl0sWzE5OTAsNzYuNDRdLFsxOTkxLDc2LjY4XSxbMTk5Miw3Ni45Ml0sWzE5OTMsNzcuMTZdLFsxOTk0LDc3LjRdLFsxOTk1LDc3LjddLFsxOTk2LDc4XSxbMTk5Nyw3OC4zXSxbMTk5OCw3OC42XSxbMTk5OSw3OC45XSxbMjAwMCw3OS4yXV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiOiBbWzE5NzUsNjkuMDVdLFsxOTc2LDY5LjMyXSxbMTk3Nyw2OS41N10sWzE5NzgsNjkuODNdLFsxOTc5LDcwLjFdLFsxOTgwLDcwLjM2XSxbMTk4MSw3MC42Ml0sWzE5ODIsNzAuODhdLFsxOTgzLDcxLjE0XSxbMTk4NCw3MS40XSxbMTk4NSw3MS42OF0sWzE5ODYsNzEuOTZdLFsxOTg3LDcyLjI0XSxbMTk4OCw3Mi41Ml0sWzE5ODksNzIuOF0sWzE5OTAsNzNdLFsxOTkxLDczLjJdLFsxOTkyLDczLjM5XSxbMTk5Myw3My42XSxbMTk5NCw3My44XSxbMTk5NSw3NC4wOF0sWzE5OTYsNzQuMzZdLFsxOTk3LDc0LjY0XSxbMTk5OCw3NC45Ml0sWzE5OTksNzUuMl0sWzIwMDAsNzUuNDhdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5XCI6IFtbMTk3NSw3MC4zOV0sWzE5NzYsNzAuNjldLFsxOTc3LDcxXSxbMTk3OCw3MS4zXSxbMTk3OSw3MS42XSxbMTk4MCw3MS44OV0sWzE5ODEsNzIuMTldLFsxOTgyLDcyLjVdLFsxOTgzLDcyLjhdLFsxOTg0LDczLjFdLFsxOTg1LDczLjM4XSxbMTk4Niw3My42Nl0sWzE5ODcsNzMuOTRdLFsxOTg4LDc0LjIyXSxbMTk4OSw3NC41XSxbMTk5MCw3NC43Ml0sWzE5OTEsNzQuOTRdLFsxOTkyLDc1LjE2XSxbMTk5Myw3NS4zOF0sWzE5OTQsNzUuNl0sWzE5OTUsNzUuODZdLFsxOTk2LDc2LjEyXSxbMTk5Nyw3Ni4zOF0sWzE5OTgsNzYuNjRdLFsxOTk5LDc2LjldLFsyMDAwLDc3LjE2XV0sXHJcbiAgICBcIkluZmFudCBNb3J0YWxpdHlcIjogW1sxOTc1LDI0LjU2XSxbMTk3NiwyMy45XSxbMTk3NywyMy4yMl0sWzE5NzgsMjIuNThdLFsxOTc5LDIxLjldLFsxOTgwLDIxLjIyXSxbMTk4MSwyMC41OF0sWzE5ODIsMTkuOV0sWzE5ODMsMTkuMjJdLFsxOTg0LDE4LjU4XSxbMTk4NSwxNy45XSxbMTk4NiwxNy4xNl0sWzE5ODcsMTYuNDFdLFsxOTg4LDE1LjY4XSxbMTk4OSwxNC45NF0sWzE5OTAsMTQuMl0sWzE5OTEsMTMuNDddLFsxOTkyLDEyLjc2XSxbMTk5MywxMi4wNF0sWzE5OTQsMTEuMzJdLFsxOTk1LDEwLjZdLFsxOTk2LDEwLjI0XSxbMTk5Nyw5Ljg4XSxbMTk5OCw5LjUyXSxbMTk5OSw5LjE2XSxbMjAwMCw4LjhdXSxcclxuICAgIFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiOiBbWzE5NzUsMF0sWzE5NzYsMF0sWzE5NzcsMF0sWzE5NzgsMF0sWzE5NzksMF0sWzE5ODAsMF0sWzE5ODEsMF0sWzE5ODIsMF0sWzE5ODMsMF0sWzE5ODQsMF0sWzE5ODUsMF0sWzE5ODYsMF0sWzE5ODcsMC4yM10sWzE5ODgsMS4wOV0sWzE5ODksMS45Nl0sWzE5OTAsMi44XSxbMTk5MSwzLjYyXSxbMTk5Miw0LjRdLFsxOTkzLDUuNF0sWzE5OTQsNi4zXSxbMTk5NSw3XSxbMTk5Niw3LjddLFsxOTk3LDguM10sWzE5OTgsOS44XSxbMTk5OSwxMy4zXSxbMjAwMCwxNS42XV0sXHJcbiAgICBcIkluZGV4ZWQgUG9wdWxhdGlvblwiOiBbWzE5NzUsMC4wMDI0MzIyNjUxMzIyMTAwOTk1XSxbMTk3NiwwLjAwMjUwNjk3NTUxNTI5NDEwNTRdLFsxOTc3LDAuMDAyNTg1NjgwNDE2NjgxNzE1XSxbMTk3OCwwLjAwMjY2NDMyOTgzODY0ODQ0MTVdLFsxOTc5LDAuMDAyNzM5OTA5MTI3MzY4MzQxNl0sWzE5ODAsMC4wMDI4MTE5MzI4Mzc5MDg2ODZdLFsxOTgxLDAuMDAyODgxMTY2MjU5OTI4MTMxXSxbMTk4MiwwLjAwMjk0NzM2OTUyNjUxODczOTJdLFsxOTgzLDAuMDAzMDEwNTQ1MDg1MzAyMDIwNV0sWzE5ODQsMC4wMDMwNzA4NjgzNDkxNTI4MjY1XSxbMTk4NSwwLjAwMzEyODgzNjE4NTIzNzU5OF0sWzE5ODYsMC4wMDMxODQ5NjkxMjEwNjQwMzU3XSxbMTk4NywwLjAwMzIzOTY3NjcyNTI5ODA3Ml0sWzE5ODgsMC4wMDMyOTM0NTAxNTM5ODkyOTI1XSxbMTk4OSwwLjAwMzM0NzIwNDgxNzU4MjI3M10sWzE5OTAsMC4wMDMzOTk4NDE3MzQwMTkyMjA2XSxbMTk5MSwwLjAwMzQ1Mjc5NDM5MzYzMDkwMTddLFsxOTkyLDAuMDAzNTEyNDY4MjIxOTA3ODM3NV0sWzE5OTMsMC4wMDM1ODcyNTkzNzY1MDE2NTldLFsxOTk0LDAuMDAzNjgyNjA5NzM1OTAxOTU3M10sWzE5OTUsMC4wMDM4MDE0MDkxMjUyMzc2ODc0XSxbMTk5NiwwLjAwMzk0MDQxNzcwOTUwNDAyN10sWzE5OTcsMC4wMDQwOTEzMDc4NjQ0NTE2MTJdLFsxOTk4LDAuMDA0MjQyMjI5MDIyNjA0OTg1XSxbMTk5OSwwLjAwNDM4NDQyNDQxMDA3Njc3MjVdLFsyMDAwLDAuMDA0NTE1MTAwNDc0ODUwNzI5XV0sXHJcbiAgICBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwwLjAwMjA2MTkxOTk0OTQ2ODU5MzNdLFsxOTc2LDAuMDAyMjg3NDY3ODU4NzQ1Ml0sWzE5NzcsMC4wMDIzNDg0NjMzODcwOTUyNDM3XSxbMTk3OCwwLjAwMjQ2MzEzNDk4MDM5MzMyNjVdLFsxOTc5LDAuMDAyNjA5NTI0MjQ4NDMzNDMxNl0sWzE5ODAsMC4wMDI3ODAwNDA2MzY1NzY0NDNdLFsxOTgxLDAuMDAyOTc0Njg0MTQ0ODIyMzYwN10sWzE5ODIsMC4wMDMxNzQ3NDk0Nzc4MTA1MDQ0XSxbMTk4MywwLjAwMzMyMTEzODc0NTg1MDYxXSxbMTk4NCwwLjAwMzM1MTUwMDk2NDQwNzA3Nl0sWzE5ODUsMC4wMDM1MDU0ODA3ODcwODYyOTc3XSxbMTk4NiwwLjAwMzY5MzYxODEwNTY0MTU0NF0sWzE5ODcsMC4wMDM4OTkzNzYzNTQ2MDkwMjUzXSxbMTk4OCwwLjAwMzk4Nzc1MjA5NzkwNzMxMV0sWzE5ODksMC4wMDQxMDE4ODE1MDg3MzExNzFdLFsxOTkwLDAuMDA0MjM3MTU2MDM2MDQ5NzEyXSxbMTk5MSwwLjAwNDYyODYxMTc4MjQzODQzOF0sWzE5OTIsMC4wMDUxNDgyOTM2ODM5ODA4MTJdLFsxOTkzLDAuMDA1NDQ1NDA5Njc5ODU0ODAzNV0sWzE5OTQsMC4wMDU1NTkyNjc5OTk0NDE1NTJdLFsxOTk1LDAuMDA1NzM0NjY0MDI5ODUyNTY3XSxbMTk5NiwwLjAwNjUyNTE2NjA3NzI2OTEzNV0sWzE5OTcsMC4wMDY4Nzc1ODQ2ODU1MTM4MzNdLFsxOTk4LDAuMDA3NDc2OTY3NDEwNzY2OTMxXSxbMTk5OSwwLjAwNzk5MDE0MzEyMjYxODYzMl0sWzIwMDAsMC4wMDg1NDc3Nzc3OTczNTY1OV1dLFxyXG4gICAgXCJJbmRleGVkIEdEUFwiOiBbWzE5NzUsMC4xNTMyMTEzODc3MDQ1Nzk4NF0sWzE5NzYsMC4xNjIxNTEwMTA4NjUwODA0Nl0sWzE5NzcsMC4xNzEwOTA2MzQwMjU1ODEwOF0sWzE5NzgsMC4xODAwMzAyNTcxODYwODE3XSxbMTk3OSwwLjE4ODk2OTg4MDM0NjU4MjMzXSxbMTk4MCwwLjE5NzkwOTUwMzUwNzA4Mjk1XSxbMTk4MSwwLjIwMzQ3OTU3NjM5OTM5NDg1XSxbMTk4MiwwLjIyNDY1OTYwNjY1NjU4MDk0XSxbMTk4MywwLjI1NDYwNzM0NDI0NDI1OF0sWzE5ODQsMC4yODgxMzA5MzEwOTYxMzUzNl0sWzE5ODUsMC4zMjE0ODI2MDIxMTgwMDNdLFsxOTg2LDAuMzQyODM0NTQ4MjA1MTk4N10sWzE5ODcsMC4zNjI3NzY3ODQ0ODYzMTU1XSxbMTk4OCwwLjM3OTc2MjA2ODQ5MTI2NjddLFsxOTg5LDAuMzk2MDI1MzA2MDEwMTc3NDRdLFsxOTkwLDAuNDE2MDAxOTI1NDU3Mjk2MV0sWzE5OTEsMC40NDkyODQ4MzAxNDcxNl0sWzE5OTIsMC40NjMxNzU2MjkyMTE5Mzc4M10sWzE5OTMsMC40NzY5OTc2NjE5NDQ3MTE5XSxbMTk5NCwwLjUxMTk5OTcyNDkzNDY3MTldLFsxOTk1LDAuNTM0NTg5NDY0OTk3OTM3XSxbMTk5NiwwLjU1ODgyOTU5NzAyOTI5NDVdLFsxOTk3LDAuNTg1MjAxNDg1MzUyNzcxM10sWzE5OTgsMC42MjIwMjU4NTYxNDA4MzM1XSxbMTk5OSwwLjY3MDgxNTU2ODY5NzU2NTZdLFsyMDAwLDAuNjkxODU4MDY2MjkwNzQ0MV1dXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJMaWJlcmlhXCIsXHJcbiAgICBcInJlZ2lvblwiOiBcIkFGXCIsXHJcbiAgICBcImNvZGVcIjogXCJMQlJcIixcclxuICAgIFwiUG9wdWxhdGlvblwiOiBbWzE5NzUsMTQyNzE2OF0sWzE5NzYsMTQ2OTE1OF0sWzE5NzcsMTUxMjY3MF0sWzE5NzgsMTU1NzkxNF0sWzE5NzksMTYwNTAzNl0sWzE5ODAsMTY1MzA4OV0sWzE5ODEsMTcwMTgwNl0sWzE5ODIsMTc1MjcwNl0sWzE5ODMsMTgwNzg5MF0sWzE5ODQsMTg2ODI1OV0sWzE5ODUsMTkzNTQxMF0sWzE5ODYsMjAwNzIzMV0sWzE5ODcsMjA3NjQ1NV0sWzE5ODgsMjEzMzMwM10sWzE5ODksMjE3MTEyMl0sWzE5OTAsMjE4OTMwNV0sWzE5OTEsMjE5MTM1Ml0sWzE5OTIsMjE4MDE3NV0sWzE5OTMsMjE2MDMyM10sWzE5OTQsMjEzNjcxOF0sWzE5OTUsMjEwNjEyMF0sWzE5OTYsMjA3MTU2Ml0sWzE5OTcsMjA1MTU3M10sWzE5OTgsMjA3MDM0N10sWzE5OTksMjE0MzQ0Ml0sWzIwMDAsMjI4MTg0Ml1dLFxyXG4gICAgXCJBcmFibGUgQXJlYVwiOiBbWzE5NzUsNTcxXSxbMTk3Niw1NzFdLFsxOTc3LDU3MV0sWzE5NzgsNTcxXSxbMTk3OSw1NzFdLFsxOTgwLDU3MV0sWzE5ODEsNTc2XSxbMTk4Miw1NzZdLFsxOTgzLDU3Nl0sWzE5ODQsNTc2XSxbMTk4NSw1NzZdLFsxOTg2LDU4MF0sWzE5ODcsNTg1XSxbMTk4OCw1ODZdLFsxOTg5LDU4OF0sWzE5OTAsNTk3XSxbMTk5MSw2MDNdLFsxOTkyLDYxM10sWzE5OTMsNjE1XSxbMTk5NCw2MTVdLFsxOTk1LDYwNV0sWzE5OTYsNjA1XSxbMTk5Nyw1ODVdLFsxOTk4LDU4NV0sWzE5OTksNTg1XSxbMjAwMCw1ODVdXSxcclxuICAgIFwiRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSw2NTBdLFsxOTc2LDg0Nl0sWzE5NzcsODM0XSxbMTk3OCw4NjBdLFsxOTc5LDg1M10sWzE5ODAsODgzXSxbMTk4MSw4OTNdLFsxOTgyLDg0MV0sWzE5ODMsOTAwXSxbMTk4NCw4OTBdLFsxOTg1LDgzN10sWzE5ODYsODQxXSxbMTk4Nyw4MjldLFsxOTg4LDg2Ml0sWzE5ODksODYyXSxbMTk5MCw4NDldLFsxOTkxLDgyNV0sWzE5OTIsODM0XSxbMTk5Myw4MThdLFsxOTk0LDU2NV0sWzE5OTUsNDUwXSxbMTk5Niw0NjBdLFsxOTk3LDQ4MF0sWzE5OTgsNDgwXSxbMTk5OSw0ODZdLFsyMDAwLDQ4OF1dLFxyXG4gICAgXCJHRFAgUGVyIENhcGl0YVwiOiBbWzE5NzUsMzgzXSxbMTk3NiwzODVdLFsxOTc3LDQxOV0sWzE5NzgsNDQ2XSxbMTk3OSw0OThdLFsxOTgwLDQ5NV0sWzE5ODEsNTQ5XSxbMTk4Miw1NDldLFsxOTgzLDUyN10sWzE5ODQsNTA2XSxbMTk4NSw0OTFdLFsxOTg2LDQ4MF0sWzE5ODcsNTA3XSxbMTk4OCw1NDZdLFsxOTg5LDU3MV0sWzE5OTAsMjg0XSxbMTk5MSwyNjJdLFsxOTkyLDE3MV0sWzE5OTMsMTI0XSxbMTk5NCwxMDJdLFsxOTk1LDEwMV0sWzE5OTYsMTEzXSxbMTk5NywxNzddLFsxOTk4LDIwMF0sWzE5OTksMjI1XSxbMjAwMCwyMjRdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5IChXb21lbilcIjogW1sxOTc1LDQyLjQ2XSxbMTk3Niw0Mi43Ml0sWzE5NzcsNDIuOThdLFsxOTc4LDQzLjI0XSxbMTk3OSw0My41XSxbMTk4MCw0My43Nl0sWzE5ODEsNDQuMDFdLFsxOTgyLDQ0LjI4XSxbMTk4Myw0NC41NF0sWzE5ODQsNDQuOF0sWzE5ODUsNDUuMDRdLFsxOTg2LDQ1LjI4XSxbMTk4Nyw0NS41MV0sWzE5ODgsNDUuNzZdLFsxOTg5LDQ2XSxbMTk5MCw0Ni4yNF0sWzE5OTEsNDYuNDhdLFsxOTkyLDQ2LjcyXSxbMTk5Myw0Ni45Nl0sWzE5OTQsNDcuMl0sWzE5OTUsNDYuMTZdLFsxOTk2LDQ1LjEyXSxbMTk5Nyw0NC4wOF0sWzE5OTgsNDMuMDRdLFsxOTk5LDQyXSxbMjAwMCw0MC45Nl1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKE1lbilcIjogW1sxOTc1LDQxXSxbMTk3Niw0MS4xOV0sWzE5NzcsNDEuNF0sWzE5NzgsNDEuNTldLFsxOTc5LDQxLjhdLFsxOTgwLDQyXSxbMTk4MSw0Mi4xOV0sWzE5ODIsNDIuNF0sWzE5ODMsNDIuNTldLFsxOTg0LDQyLjhdLFsxOTg1LDQyLjk4XSxbMTk4Niw0My4xNl0sWzE5ODcsNDMuMzRdLFsxOTg4LDQzLjUyXSxbMTk4OSw0My43XSxbMTk5MCw0My45NF0sWzE5OTEsNDQuMThdLFsxOTkyLDQ0LjQyXSxbMTk5Myw0NC42Nl0sWzE5OTQsNDQuOV0sWzE5OTUsNDMuODNdLFsxOTk2LDQyLjc4XSxbMTk5Nyw0MS43Ml0sWzE5OTgsNDAuNjZdLFsxOTk5LDM5LjZdLFsyMDAwLDM4LjU0XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeVwiOiBbWzE5NzUsNDEuNjRdLFsxOTc2LDQxLjg4XSxbMTk3Nyw0Mi4xMl0sWzE5NzgsNDIuMzZdLFsxOTc5LDQyLjZdLFsxOTgwLDQyLjg0XSxbMTk4MSw0My4wOF0sWzE5ODIsNDMuMzJdLFsxOTgzLDQzLjU1XSxbMTk4NCw0My44XSxbMTk4NSw0NC4wMV0sWzE5ODYsNDQuMjNdLFsxOTg3LDQ0LjQ2XSxbMTk4OCw0NC42OF0sWzE5ODksNDQuOV0sWzE5OTAsNDUuMTJdLFsxOTkxLDQ1LjMzXSxbMTk5Miw0NS41Nl0sWzE5OTMsNDUuNzhdLFsxOTk0LDQ2XSxbMTk5NSw0NC45Nl0sWzE5OTYsNDMuOTJdLFsxOTk3LDQyLjg3XSxbMTk5OCw0MS44M10sWzE5OTksNDAuOF0sWzIwMDAsMzkuNzZdXSxcclxuICAgIFwiSW5mYW50IE1vcnRhbGl0eVwiOiBbWzE5NzUsMTcwLjAzXSxbMTk3NiwxNjguOF0sWzE5NzcsMTY3LjU0XSxbMTk3OCwxNjYuMzVdLFsxOTc5LDE2NS4xXSxbMTk4MCwxNjMuODRdLFsxOTgxLDE2Mi42NV0sWzE5ODIsMTYxLjM5XSxbMTk4MywxNjAuMTRdLFsxOTg0LDE1OC45NV0sWzE5ODUsMTU3LjddLFsxOTg2LDE1Ni4xN10sWzE5ODcsMTU0LjY2XSxbMTk4OCwxNTMuMTRdLFsxOTg5LDE1MS42Ml0sWzE5OTAsMTUwLjFdLFsxOTkxLDE0Ny43OF0sWzE5OTIsMTQ1LjQ2XSxbMTk5MywxNDMuMTRdLFsxOTk0LDE0MC44Ml0sWzE5OTUsMTM4LjVdLFsxOTk2LDE0Ni42Ml0sWzE5OTcsMTU0Ljc0XSxbMTk5OCwxNjIuODVdLFsxOTk5LDE3MC45OF0sWzIwMDAsMTc5LjFdXSxcclxuICAgIFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiOiBbWzE5NzUsMF0sWzE5NzYsMF0sWzE5NzcsMF0sWzE5NzgsMF0sWzE5NzksMF0sWzE5ODAsMF0sWzE5ODEsMF0sWzE5ODIsMF0sWzE5ODMsMF0sWzE5ODQsMF0sWzE5ODUsMF0sWzE5ODYsMF0sWzE5ODcsMF0sWzE5ODgsMF0sWzE5ODksMF0sWzE5OTAsMF0sWzE5OTEsMF0sWzE5OTIsMF0sWzE5OTMsMF0sWzE5OTQsMF0sWzE5OTUsMF0sWzE5OTYsMF0sWzE5OTcsMF0sWzE5OTgsMF0sWzE5OTksMF0sWzIwMDAsMF1dLFxyXG4gICAgXCJJbmRleGVkIFBvcHVsYXRpb25cIjogW1sxOTc1LDAuMDAxMTY0Mzg5MDMxNTE5MDkxOV0sWzE5NzYsMC4wMDExOTg2NDc1NzM5MTQ1ODE4XSxbMTk3NywwLjAwMTIzNDE0Nzg3NjI4OTI1NTddLFsxOTc4LDAuMDAxMjcxMDYxMjcyMTQ4NzgzXSxbMTk3OSwwLjAwMTMwOTUwNjg3OTA3MzI5NTVdLFsxOTgwLDAuMDAxMzQ4NzEyMDY0NTM5NjA4NF0sWzE5ODEsMC4wMDEzODg0NTg5OTAyMzMzNzFdLFsxOTgyLDAuMDAxNDI5OTg2OTY4NTEyMjU3NF0sWzE5ODMsMC4wMDE0NzUwMTAxNTAzMDY3OTddLFsxOTg0LDAuMDAxNTI0MjYzNjM3OTQzNjk0N10sWzE5ODUsMC4wMDE1NzkwNTAzODE5Mzk4NzM2XSxbMTk4NiwwLjAwMTYzNzY0NzI1Njc1MjYwMjRdLFsxOTg3LDAuMDAxNjk0MTI1MzA3MjExODg4XSxbMTk4OCwwLjAwMTc0MDUwNjEwMzA3MDM5NzRdLFsxOTg5LDAuMDAxNzcxMzYxNjM1NjkzNzYxXSxbMTk5MCwwLjAwMTc4NjE5NjY2OTY2MzIxMDhdLFsxOTkxLDAuMDAxNzg3ODY2NzYzNDA2NTY4XSxbMTk5MiwwLjAwMTc3ODc0Nzc0MTUzNTc3OThdLFsxOTkzLDAuMDAxNzYyNTUxMDE0MTMzMTc3N10sWzE5OTQsMC4wMDE3NDMyOTIzMTIyMjIxMTQ1XSxbMTk5NSwwLjAwMTcxODMyODIwNDU3MjI2NDZdLFsxOTk2LDAuMDAxNjkwMTMzMjM2NTI5Nzk0XSxbMTk5NywwLjAwMTY3MzgyNDczNDQxMTU4ODRdLFsxOTk4LDAuMDAxNjg5MTQxOTQ5ODE4NDIxNV0sWzE5OTksMC4wMDE3NDg3NzgyNDc4OTg4Nzc1XSxbMjAwMCwwLjAwMTg2MTY5NTE4Njg3MzI5NTVdXSxcclxuICAgIFwiSW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb25cIjogW1sxOTc1LDAuMDAwMTc2MjA5MzA0MTIyMzQ4OV0sWzE5NzYsMC4wMDAyMjkzNDMxODY1OTYxNjQ4Nl0sWzE5NzcsMC4wMDAyMjYwOTAwOTE3NTA4MjkyXSxbMTk3OCwwLjAwMDIzMzEzODQ2MzkxNTcyMzE3XSxbMTk3OSwwLjAwMDIzMTI0MDgyNTI1NTk0NDAzXSxbMTk4MCwwLjAwMDIzOTM3MzU2MjM2OTI4MzJdLFsxOTgxLDAuMDAwMjQyMDg0NDc0NzQwMzk2MjRdLFsxOTgyLDAuMDAwMjI3OTg3NzMwNDEwNjA4MzVdLFsxOTgzLDAuMDAwMjQzOTgyMTEzNDAwMTc1NF0sWzE5ODQsMC4wMDAyNDEyNzEyMDEwMjkwNjIzNF0sWzE5ODUsMC4wMDAyMjY5MDMzNjU0NjIxNjMxMl0sWzE5ODYsMC4wMDAyMjc5ODc3MzA0MTA2MDgzNV0sWzE5ODcsMC4wMDAyMjQ3MzQ2MzU1NjUyNzI2N10sWzE5ODgsMC4wMDAyMzM2ODA2NDYzODk5NDU3N10sWzE5ODksMC4wMDAyMzM2ODA2NDYzODk5NDU3N10sWzE5OTAsMC4wMDAyMzAxNTY0NjAzMDc0OTg4XSxbMTk5MSwwLjAwMDIyMzY1MDI3MDYxNjgyNzQ0XSxbMTk5MiwwLjAwMDIyNjA5MDA5MTc1MDgyOTJdLFsxOTkzLDAuMDAwMjIxNzUyNjMxOTU3MDQ4M10sWzE5OTQsMC4wMDAxNTMxNjY1NDg5Njc4ODc4OF0sWzE5OTUsMC4wMDAxMjE5OTEwNTY3MDAwODc3XSxbMTk5NiwwLjAwMDEyNDcwMTk2OTA3MTIwMDc2XSxbMTk5NywwLjAwMDEzMDEyMzc5MzgxMzQyNjg4XSxbMTk5OCwwLjAwMDEzMDEyMzc5MzgxMzQyNjg4XSxbMTk5OSwwLjAwMDEzMTc1MDM0MTIzNjA5NDcyXSxbMjAwMCwwLjAwMDEzMjI5MjUyMzcxMDMxNzMzXV0sXHJcbiAgICBcIkluZGV4ZWQgR0RQXCI6IFtbMTk3NSwwLjAxMzE2ODc1MjU3ODczNzQ1MV0sWzE5NzYsMC4wMTMyMzc1MTg5MTA3NDEzXSxbMTk3NywwLjAxNDQwNjU0NjU1NDgwNjc2Nl0sWzE5NzgsMC4wMTUzMzQ4OTIwMzY4NTg3NTNdLFsxOTc5LDAuMDE3MTIyODE2NjY4OTU4ODc3XSxbMTk4MCwwLjAxNzAxOTY2NzE3MDk1MzFdLFsxOTgxLDAuMDE4ODc2MzU4MTM1MDU3MDc2XSxbMTk4MiwwLjAxODg3NjM1ODEzNTA1NzA3Nl0sWzE5ODMsMC4wMTgxMTk5Mjg0ODMwMTQ3MTVdLFsxOTg0LDAuMDE3Mzk3ODgxOTk2OTc0MjhdLFsxOTg1LDAuMDE2ODgyMTM0NTA2OTQ1NF0sWzE5ODYsMC4wMTY1MDM5MTk2ODA5MjQyMl0sWzE5ODcsMC4wMTc0MzIyNjUxNjI5NzYyMDhdLFsxOTg4LDAuMDE4NzczMjA4NjM3MDUxM10sWzE5ODksMC4wMTk2MzI3ODc3ODcwOTk0MzZdLFsxOTkwLDAuMDA5NzY0ODE5MTQ0NTQ2ODNdLFsxOTkxLDAuMDA5MDA4Mzg5NDkyNTA0NDddLFsxOTkyLDAuMDA1ODc5NTIxMzg2MzI5MjUzXSxbMTk5MywwLjAwNDI2MzUxMjU4NDIzODc1N10sWzE5OTQsMC4wMDM1MDcwODI5MzIxOTYzOTddLFsxOTk1LDAuMDAzNDcyNjk5NzY2MTk0NDcxMl0sWzE5OTYsMC4wMDM4ODUyOTc3NTgyMTc1NzY2XSxbMTk5NywwLjAwNjA4NTgyMDM4MjM0MDgwNl0sWzE5OTgsMC4wMDY4NzY2MzMyMDAzODUwOTFdLFsxOTk5LDAuMDA3NzM2MjEyMzUwNDMzMjI4XSxbMjAwMCwwLjAwNzcwMTgyOTE4NDQzMTMwMl1dXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJOb3J3YXlcIixcclxuICAgIFwicmVnaW9uXCI6IFwiRVVcIixcclxuICAgIFwiY29kZVwiOiBcIk5PUlwiLFxyXG4gICAgXCJQb3B1bGF0aW9uXCI6IFtbMTk3NSwzOTA2NDkxXSxbMTk3NiwzOTM0NTMwXSxbMTk3NywzOTYxMDIxXSxbMTk3OCwzOTg1NDAwXSxbMTk3OSw0MDA3MzExXSxbMTk4MCw0MDI2NTg0XSxbMTk4MSw0MDQzNDM4XSxbMTk4Miw0MDU4NDA2XSxbMTk4Myw0MDcyMjU2XSxbMTk4NCw0MDg1NjE5XSxbMTk4NSw0MDk4Njk3XSxbMTk4Niw0MTExNTY2XSxbMTk4Nyw0MTI0NTg4XSxbMTk4OCw0MTM4MTUwXSxbMTk4OSw0MTUyNTU5XSxbMTk5MCw0MTY3OTk0XSxbMTk5MSw0MTg0NTQyXSxbMTk5Miw0MjAyMjg3XSxbMTk5Myw0MjIxMjY3XSxbMTk5NCw0MjQxNDg3XSxbMTk5NSw0MjYzMDU4XSxbMTk5Niw0Mjg1OTYwXSxbMTk5Nyw0MzA5ODgxXSxbMTk5OCw0MzM0MzkyXSxbMTk5OSw0MzU5MTg0XSxbMjAwMCw0Mzg0MDc3XV0sXHJcbiAgICBcIkFyYWJsZSBBcmVhXCI6IFtbMTk3NSw4MDZdLFsxOTc2LDc5NV0sWzE5NzcsNzkwXSxbMTk3OCw3OTNdLFsxOTc5LDc5Ml0sWzE5ODAsNzk1XSxbMTk4MSw4MDBdLFsxOTgyLDgwNl0sWzE5ODMsODMwXSxbMTk4NCw4MTddLFsxOTg1LDgyOF0sWzE5ODYsODQxXSxbMTk4Nyw4NDldLFsxOTg4LDg1NV0sWzE5ODksODU4XSxbMTk5MCw4NjldLFsxOTkxLDg2OV0sWzE5OTIsODc0XSxbMTk5Myw4ODJdLFsxOTk0LDg2NF0sWzE5OTUsODkyXSxbMTk5Niw4ODNdLFsxOTk3LDg5MF0sWzE5OTgsOTAxXSxbMTk5OSw5OTJdLFsyMDAwLDEwMDBdXSxcclxuICAgIFwiRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSw3MTY0Ml0sWzE5NzYsNzMzOTddLFsxOTc3LDg1MzE4XSxbMTk3OCw3ODA4OV0sWzE5NzksNzg3NDRdLFsxOTgwLDgyMzQ4XSxbMTk4MSw4MTI1N10sWzE5ODIsODU1NDZdLFsxOTgzLDkzNzA3XSxbMTk4NCw5MTUyNl0sWzE5ODUsOTcxMjJdLFsxOTg2LDk1OTk2XSxbMTk4NywxMDE5NDZdLFsxOTg4LDEwNzE2MV0sWzE5ODksMTA2ODIyXSxbMTk5MCw5OTgzNF0sWzE5OTEsMTA0NDI2XSxbMTk5MiwxMDQzOTFdLFsxOTkzLDEwNDYxMV0sWzE5OTQsMTA2MTY3XSxbMTk5NSwxMDg2NDhdLFsxOTk2LDEwOTMzNV0sWzE5OTcsMTEyNzIxXSxbMTk5OCwxMDYyNDJdLFsxOTk5LDExNzgwNV0sWzIwMDAsMTE0MDQ1XV0sXHJcbiAgICBcIkdEUCBQZXIgQ2FwaXRhXCI6IFtbMTk3NSwzMTAyXSxbMTk3NiwzODg2XSxbMTk3Nyw0NjcwXSxbMTk3OCw1NDU0XSxbMTk3OSw2MjM4XSxbMTk4MCw3MDIyXSxbMTk4MSw3Nzk0XSxbMTk4Miw4NjI4XSxbMTk4Myw5NzY5XSxbMTk4NCwxMTEwNl0sWzE5ODUsMTIyNzVdLFsxOTg2LDEzMDY0XSxbMTk4NywxMzk2M10sWzE5ODgsMTUzMjZdLFsxOTg5LDE2NDg4XSxbMTk5MCwxNzQxN10sWzE5OTEsMTgxMjVdLFsxOTkyLDE4ODY2XSxbMTk5MywxOTc3OV0sWzE5OTQsMjA5MjRdLFsxOTk1LDIyNDA5XSxbMTk5NiwyMzI4NV0sWzE5OTcsMjQzNjZdLFsxOTk4LDI1ODc3XSxbMTk5OSwyNzI3N10sWzIwMDAsMjkwODRdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5IChXb21lbilcIjogW1sxOTc1LDc2LjhdLFsxOTc2LDc3XSxbMTk3Nyw3Ny4xOV0sWzE5NzgsNzcuMzldLFsxOTc5LDc3LjZdLFsxOTgwLDc3LjhdLFsxOTgxLDc4XSxbMTk4Miw3OC4xOV0sWzE5ODMsNzguMzldLFsxOTg0LDc4LjZdLFsxOTg1LDc4Ljc4XSxbMTk4Niw3OC45Nl0sWzE5ODcsNzkuMTRdLFsxOTg4LDc5LjMyXSxbMTk4OSw3OS41XSxbMTk5MCw3OS41Nl0sWzE5OTEsNzkuNjJdLFsxOTkyLDc5LjY3XSxbMTk5Myw3OS43NF0sWzE5OTQsNzkuOF0sWzE5OTUsNzkuODldLFsxOTk2LDgwXSxbMTk5Nyw4MC4xXSxbMTk5OCw4MC4yXSxbMTk5OSw4MC4zXSxbMjAwMCw4MC4zOV1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKE1lbilcIjogW1sxOTc1LDcwLjc2XSxbMTk3Niw3MC45Ml0sWzE5NzcsNzEuMDhdLFsxOTc4LDcxLjI0XSxbMTk3OSw3MS40XSxbMTk4MCw3MS41Nl0sWzE5ODEsNzEuNzJdLFsxOTgyLDcxLjg4XSxbMTk4Myw3Mi4wNF0sWzE5ODQsNzIuMl0sWzE5ODUsNzIuMzJdLFsxOTg2LDcyLjQ0XSxbMTk4Nyw3Mi41Nl0sWzE5ODgsNzIuNjddLFsxOTg5LDcyLjhdLFsxOTkwLDcyLjg0XSxbMTk5MSw3Mi44OF0sWzE5OTIsNzIuOTJdLFsxOTkzLDcyLjk2XSxbMTk5NCw3M10sWzE5OTUsNzMuMjZdLFsxOTk2LDczLjUyXSxbMTk5Nyw3My43OF0sWzE5OTgsNzQuMDNdLFsxOTk5LDc0LjNdLFsyMDAwLDc0LjU2XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeVwiOiBbWzE5NzUsNzMuNjhdLFsxOTc2LDczLjg2XSxbMTk3Nyw3NC4wNF0sWzE5NzgsNzQuMjJdLFsxOTc5LDc0LjRdLFsxOTgwLDc0LjU4XSxbMTk4MSw3NC43Nl0sWzE5ODIsNzQuOTRdLFsxOTgzLDc1LjEyXSxbMTk4NCw3NS4zXSxbMTk4NSw3NS40NF0sWzE5ODYsNzUuNThdLFsxOTg3LDc1LjcyXSxbMTk4OCw3NS44Nl0sWzE5ODksNzZdLFsxOTkwLDc2LjA2XSxbMTk5MSw3Ni4xMl0sWzE5OTIsNzYuMTddLFsxOTkzLDc2LjI0XSxbMTk5NCw3Ni4zXSxbMTk5NSw3Ni41Ml0sWzE5OTYsNzYuNzRdLFsxOTk3LDc2Ljk2XSxbMTk5OCw3Ny4xOF0sWzE5OTksNzcuNF0sWzIwMDAsNzcuNjJdXSxcclxuICAgIFwiSW5mYW50IE1vcnRhbGl0eVwiOiBbWzE5NzUsMTMuNDZdLFsxOTc2LDEzLjA1XSxbMTk3NywxMi42Ml0sWzE5NzgsMTIuMjJdLFsxOTc5LDExLjhdLFsxOTgwLDExLjM3XSxbMTk4MSwxMC45N10sWzE5ODIsMTAuNTVdLFsxOTgzLDEwLjEyXSxbMTk4NCw5LjcyXSxbMTk4NSw5LjNdLFsxOTg2LDkuMDRdLFsxOTg3LDguNzhdLFsxOTg4LDguNTJdLFsxOTg5LDguMjZdLFsxOTkwLDhdLFsxOTkxLDcuOThdLFsxOTkyLDcuOTZdLFsxOTkzLDcuOTRdLFsxOTk0LDcuOTJdLFsxOTk1LDcuOV0sWzE5OTYsNy40Ml0sWzE5OTcsNi45NF0sWzE5OTgsNi40Nl0sWzE5OTksNS45OF0sWzIwMDAsNS41XV0sXHJcbiAgICBcIk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnNcIjogW1sxOTc1LDBdLFsxOTc2LDBdLFsxOTc3LDBdLFsxOTc4LDBdLFsxOTc5LDBdLFsxOTgwLDBdLFsxOTgxLDBdLFsxOTgyLDBdLFsxOTgzLDBdLFsxOTg0LDBdLFsxOTg1LDBdLFsxOTg2LDBdLFsxOTg3LDBdLFsxOTg4LDBdLFsxOTg5LDBdLFsxOTkwLDBdLFsxOTkxLDEuOTddLFsxOTkyLDQuNzldLFsxOTkzLDcuODFdLFsxOTk0LDExLjA2XSxbMTk5NSwxNC41XSxbMTk5NiwxNi4yXSxbMTk5NywxOC45XSxbMTk5OCwyMi45XSxbMTk5OSwyNy4zXSxbMjAwMCwzMS43XV0sXHJcbiAgICBcIkluZGV4ZWQgUG9wdWxhdGlvblwiOiBbWzE5NzUsMC4wMDMxODcyMDM3OTk1MDIyNjQ3XSxbMTk3NiwwLjAwMzIxMDA4MDA4NjAwNDQ1OTNdLFsxOTc3LDAuMDAzMjMxNjkzMzk5ODA3NzIwMl0sWzE5NzgsMC4wMDMyNTE1ODM1ODgwNjgyNV0sWzE5NzksMC4wMDMyNjk0NjAxOTk3MDAyNDc3XSxbMTk4MCwwLjAwMzI4NTE4NDUzNjE1MTUwNDddLFsxOTgxLDAuMDAzMjk4OTM1MjczNzkyMjE4N10sWzE5ODIsMC4wMDMzMTExNDcyNzMzNzcyNTU3XSxbMTk4MywwLjAwMzMyMjQ0NzEyNjAxMzA2M10sWzE5ODQsMC4wMDMzMzMzNDk2NDgwOTA0ODQzXSxbMTk4NSwwLjAwMzM0NDAxOTY0NjEyNDQ5NzRdLFsxOTg2LDAuMDAzMzU0NTE5MTI2NTI2Njc4M10sWzE5ODcsMC4wMDMzNjUxNDM0MzU2MjU4NDYzXSxbMTk4OCwwLjAwMzM3NjIwODMxNjU5NjczNTNdLFsxOTg5LDAuMDAzMzg3OTY0MjQyNzA3MTU3XSxbMTk5MCwwLjAwMzQwMDU1NzI1NTM3Mzg0OV0sWzE5OTEsMC4wMDM0MTQwNTgzMzU2MjA1ODhdLFsxOTkyLDAuMDAzNDI4NTM2MDE2ODQ5NjQxN10sWzE5OTMsMC4wMDM0NDQwMjEzMDIyNjY3OThdLFsxOTk0LDAuMDAzNDYwNTE4MjcxMjQxMjRdLFsxOTk1LDAuMDAzNDc4MTE3NDg1NzY4ODIwOF0sWzE5OTYsMC4wMDM0OTY4MDI2MjgzNzI4MV0sWzE5OTcsMC4wMDM1MTYzMTkxNDY0MTYyMTM3XSxbMTk5OCwwLjAwMzUzNjMxNzAzMDAyMzE2NDNdLFsxOTk5LDAuMDAzNTU2NTQ0MTc0MTc4MTc3XSxbMjAwMCwwLjAwMzU3Njg1MzcyMTU5MDY3ODNdXSxcclxuICAgIFwiSW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb25cIjogW1sxOTc1LDAuMDE5NDIxNTE4NDA5MTI4MTg1XSxbMTk3NiwwLjAxOTg5NzI4MzUzMDI1ODUyNl0sWzE5NzcsMC4wMjMxMjg5NjIxNjc4NjI0MDRdLFsxOTc4LDAuMDIxMTY5MjQzNjE0Nzg0NzcyXSxbMTk3OSwwLjAyMTM0NjgwODM3NTA5MjY4XSxbMTk4MCwwLjAyMjMyMzgyMTE5MzY0MTgyNV0sWzE5ODEsMC4wMjIwMjgwNjA2NTM5NTMzOV0sWzE5ODIsMC4wMjMxOTA3NzA5Njk5MjM3ODNdLFsxOTgzLDAuMDI1NDAzMTQ2NTU1OTg5MTUyXSxbMTk4NCwwLjAyNDgxMTg5NjU2Nzg0OTM5Ml0sWzE5ODUsMC4wMjYzMjg5MjMxMzA3MjQyNjJdLFsxOTg2LDAuMDI2MDIzNjc0Mzk3NzM2OTNdLFsxOTg3LDAuMDI3NjM2NjY3MjU4NTQ5Ml0sWzE5ODgsMC4wMjkwNTA0MDgwNjAwODQ2NjNdLFsxOTg5LDAuMDI4OTU4NTA4MTMwNzAzOTI4XSxbMTk5MCwwLjAyNzA2NDEyMjU2NTc3MDEyXSxbMTk5MSwwLjAyODMwODk3MzUyNjU4NTI0XSxbMTk5MiwwLjAyODI5OTQ4NTMzMzI4NjM0Nl0sWzE5OTMsMC4wMjgzNTkxMjU0MDU0NTA4M10sWzE5OTQsMC4wMjg3ODA5NDMzNzAzOTYwMjNdLFsxOTk1LDAuMDI5NDUzNTIwNzI5NjY5MTczXSxbMTk5NiwwLjAyOTYzOTc2MDQwOTU2NDY0XSxbMTk5NywwLjAzMDU1NzY3NTMzODQyMzUyNV0sWzE5OTgsMC4wMjg4MDEyNzUyMTMxNzkzN10sWzE5OTksMC4wMzE5MzU5MDMxODc4OTc0XSxbMjAwMCwwLjAzMDkxNjYwMDEzNjM1ODg5Ml1dLFxyXG4gICAgXCJJbmRleGVkIEdEUFwiOiBbWzE5NzUsMC4xMDY2NTY1ODA5Mzc5NzI3N10sWzE5NzYsMC4xMzM2MTI5ODMwODM0ODIzMl0sWzE5NzcsMC4xNjA1NjkzODUyMjg5OTE5XSxbMTk3OCwwLjE4NzUyNTc4NzM3NDUwMTQ2XSxbMTk3OSwwLjIxNDQ4MjE4OTUyMDAxMV0sWzE5ODAsMC4yNDE0Mzg1OTE2NjU1MjA1Nl0sWzE5ODEsMC4yNjc5ODIzOTU4MTkwMDddLFsxOTgyLDAuMjk2NjU3OTU2MjY0NjEyODNdLFsxOTgzLDAuMzM1ODg5MTQ4NjcyODA5OF0sWzE5ODQsMC4zODE4NTk0NDE2MTczODQxXSxbMTk4NSwwLjQyMjA1MzM2MjY3MzYzNDk3XSxbMTk4NiwwLjQ0OTE4MTY4MDY0OTE1NDE1XSxbMTk4NywwLjQ4MDA5MjE0Njg4NDg4NTE2XSxbMTk4OCwwLjUyNjk1NjQwMjE0NTUwOTVdLFsxOTg5LDAuNTY2OTA5NjQxMDM5NzQ3XSxbMTk5MCwwLjU5ODg1MTYwMjI1NTUzNTddLFsxOTkxLDAuNjIzMTk0ODgzNzg0ODk5XSxbMTk5MiwwLjY0ODY3MjgwOTc5MjMyNTddLFsxOTkzLDAuNjgwMDY0NjQwMzUyMDgzNl0sWzE5OTQsMC43MTk0MzMzNjU0MjQyODgzXSxbMTk5NSwwLjc3MDQ5MjM2NjkzNzE0NzZdLFsxOTk2LDAuODAwNjEyMDIwMzU0ODM0M10sWzE5OTcsMC44Mzc3ODAyMjI4MDI5MTU2XSxbMTk5OCwwLjg4OTczMzE4NjYzMTgyNTFdLFsxOTk5LDAuOTM3ODY5NjE5MDM0NTIwN10sWzIwMDAsMV1dXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJGcmVuY2ggUG9seW5lc2lhXCIsXHJcbiAgICBcInJlZ2lvblwiOiBcIk9DXCIsXHJcbiAgICBcImNvZGVcIjogXCJQWUZcIixcclxuICAgIFwiUG9wdWxhdGlvblwiOiBbWzE5NzUsMTE0NTkyXSxbMTk3NiwxMTgzMDRdLFsxOTc3LDEyMjA0NF0sWzE5NzgsMTI1ODY1XSxbMTk3OSwxMjk4MDddLFsxOTgwLDEzMzg2OV0sWzE5ODEsMTM4MDMxXSxbMTk4MiwxNDIyOTVdLFsxOTgzLDE0NjY1NF0sWzE5ODQsMTUxMTAxXSxbMTk4NSwxNTU2MzldLFsxOTg2LDE2MDI1M10sWzE5ODcsMTY0ODk0XSxbMTk4OCwxNjk1MDBdLFsxOTg5LDE3NDAyNF0sWzE5OTAsMTc4NDQ2XSxbMTk5MSwxODI3NzZdLFsxOTkyLDE4NzAyNl0sWzE5OTMsMTkxMjIyXSxbMTk5NCwxOTUzODZdLFsxOTk1LDE5OTUxNV0sWzE5OTYsMjAzNjA1XSxbMTk5NywyMDc2NzFdLFsxOTk4LDIxMTczMF0sWzE5OTksMjE1Nzk2XSxbMjAwMCwyMTk4NzFdXSxcclxuICAgIFwiQXJhYmxlIEFyZWFcIjogW1sxOTc1LDI0XSxbMTk3NiwyNF0sWzE5NzcsMjRdLFsxOTc4LDI0XSxbMTk3OSwyNF0sWzE5ODAsMjRdLFsxOTgxLDI0XSxbMTk4MiwyNF0sWzE5ODMsMjRdLFsxOTg0LDI0XSxbMTk4NSwyNF0sWzE5ODYsMjRdLFsxOTg3LDI0XSxbMTk4OCwyNF0sWzE5ODksMjRdLFsxOTkwLDI0XSxbMTk5MSwyM10sWzE5OTIsMjNdLFsxOTkzLDIzXSxbMTk5NCwyM10sWzE5OTUsMjNdLFsxOTk2LDIzXSxbMTk5NywyM10sWzE5OTgsMjNdLFsxOTk5LDIzXSxbMjAwMCwyM11dLFxyXG4gICAgXCJFbmVyZ3kgQ29uc3VtcHRpb25cIjogW1sxOTc1LDEwMl0sWzE5NzYsMTA5XSxbMTk3NywxMTldLFsxOTc4LDEyOV0sWzE5NzksMTQxXSxbMTk4MCwxNTNdLFsxOTgxLDE5Nl0sWzE5ODIsMjE1XSxbMTk4MywyMzVdLFsxOTg0LDI1NV0sWzE5ODUsMjgwXSxbMTk4NiwyOTBdLFsxOTg3LDE4N10sWzE5ODgsMjAzXSxbMTk4OSwyMjBdLFsxOTkwLDIyNV0sWzE5OTEsMjI1XSxbMTk5MiwyNTZdLFsxOTkzLDI3MV0sWzE5OTQsMjkxXSxbMTk5NSwzMDJdLFsxOTk2LDMxN10sWzE5OTcsMzIzXSxbMTk5OCwzMzVdLFsxOTk5LDM0OV0sWzIwMDAsMzM1XV0sXHJcbiAgICBcIkdEUCBQZXIgQ2FwaXRhXCI6IFtbMTk3NSwzNDA4XSxbMTk3Niw0MDczXSxbMTk3Nyw0NzM4XSxbMTk3OCw1NDAzXSxbMTk3OSw2MDY4XSxbMTk4MCw2NzMzXSxbMTk4MSw3MDg4XSxbMTk4Miw4MDg3XSxbMTk4Myw4ODMyXSxbMTk4NCw5Mzk2XSxbMTk4NSwxMDgyOF0sWzE5ODYsMTIyNjldLFsxOTg3LDEzMDY1XSxbMTk4OCwxMzkwMF0sWzE5ODksMTQ3MDldLFsxOTkwLDE1ODk2XSxbMTk5MSwxNzA4MF0sWzE5OTIsMTc2NzldLFsxOTkzLDE4NDg2XSxbMTk5NCwxOTIwNV0sWzE5OTUsMjA0MThdLFsxOTk2LDIwNjUzXSxbMTk5NywyMDczNF0sWzE5OTgsMjA5MzFdLFsxOTk5LDIxMDYyXSxbMjAwMCwyMTEzMV1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKFdvbWVuKVwiOiBbWzE5NzUsNjEuNDhdLFsxOTc2LDYxLjg2XSxbMTk3Nyw2Mi4yM10sWzE5NzgsNjIuNjJdLFsxOTc5LDYzXSxbMTk4MCw2My4zOF0sWzE5ODEsNjMuNzZdLFsxOTgyLDY0LjE0XSxbMTk4Myw2NC41Ml0sWzE5ODQsNjQuOV0sWzE5ODUsNjUuNzJdLFsxOTg2LDY2LjU0XSxbMTk4Nyw2Ny4zNl0sWzE5ODgsNjguMThdLFsxOTg5LDY5XSxbMTk5MCw2OS40Ml0sWzE5OTEsNjkuODRdLFsxOTkyLDcwLjI1XSxbMTk5Myw3MC42N10sWzE5OTQsNzEuMV0sWzE5OTUsNzEuNDRdLFsxOTk2LDcxLjc4XSxbMTk5Nyw3Mi4xMV0sWzE5OTgsNzIuNDZdLFsxOTk5LDcyLjhdLFsyMDAwLDczLjE0XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiOiBbWzE5NzUsNTguMzNdLFsxOTc2LDU4LjU4XSxbMTk3Nyw1OC44MV0sWzE5NzgsNTkuMDVdLFsxOTc5LDU5LjNdLFsxOTgwLDU5LjU0XSxbMTk4MSw1OS43OF0sWzE5ODIsNjAuMDFdLFsxOTgzLDYwLjI2XSxbMTk4NCw2MC41XSxbMTk4NSw2MS4yXSxbMTk4Niw2MS45XSxbMTk4Nyw2Mi42XSxbMTk4OCw2My4zXSxbMTk4OSw2NF0sWzE5OTAsNjQuMzZdLFsxOTkxLDY0LjcyXSxbMTk5Miw2NS4wOF0sWzE5OTMsNjUuNDRdLFsxOTk0LDY1LjhdLFsxOTk1LDY2LjIyXSxbMTk5Niw2Ni42NF0sWzE5OTcsNjcuMDZdLFsxOTk4LDY3LjQ4XSxbMTk5OSw2Ny45XSxbMjAwMCw2OC4zMl1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3lcIjogW1sxOTc1LDU5LjY5XSxbMTk3Niw2MF0sWzE5NzcsNjAuM10sWzE5NzgsNjAuNl0sWzE5NzksNjAuOV0sWzE5ODAsNjEuMTldLFsxOTgxLDYxLjVdLFsxOTgyLDYxLjhdLFsxOTgzLDYyLjFdLFsxOTg0LDYyLjRdLFsxOTg1LDYzLjE2XSxbMTk4Niw2My45Ml0sWzE5ODcsNjQuNjhdLFsxOTg4LDY1LjQ0XSxbMTk4OSw2Ni4yXSxbMTk5MCw2Ni42XSxbMTk5MSw2N10sWzE5OTIsNjcuNF0sWzE5OTMsNjcuOF0sWzE5OTQsNjguMl0sWzE5OTUsNjguNl0sWzE5OTYsNjldLFsxOTk3LDY5LjRdLFsxOTk4LDY5LjhdLFsxOTk5LDcwLjJdLFsyMDAwLDcwLjZdXSxcclxuICAgIFwiSW5mYW50IE1vcnRhbGl0eVwiOiBbWzE5NzUsNjkuMzNdLFsxOTc2LDY4XSxbMTk3Nyw2Ni42NF0sWzE5NzgsNjUuMzZdLFsxOTc5LDY0XSxbMTk4MCw2Mi42NF0sWzE5ODEsNjEuMzZdLFsxOTgyLDYwXSxbMTk4Myw1OC42NF0sWzE5ODQsNTcuMzZdLFsxOTg1LDU2XSxbMTk4Niw1MC44XSxbMTk4Nyw0NS42XSxbMTk4OCw0MC40XSxbMTk4OSwzNS4yXSxbMTk5MCwzMF0sWzE5OTEsMjcuNTZdLFsxOTkyLDI1LjEyXSxbMTk5MywyMi42OF0sWzE5OTQsMjAuMjRdLFsxOTk1LDE3LjhdLFsxOTk2LDE2LjVdLFsxOTk3LDE1LjJdLFsxOTk4LDEzLjldLFsxOTk5LDEyLjZdLFsyMDAwLDExLjNdXSxcclxuICAgIFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiOiBbWzE5NzUsMF0sWzE5NzYsMF0sWzE5NzcsMF0sWzE5NzgsMF0sWzE5NzksMF0sWzE5ODAsMF0sWzE5ODEsMF0sWzE5ODIsMF0sWzE5ODMsMF0sWzE5ODQsMF0sWzE5ODUsMF0sWzE5ODYsMF0sWzE5ODcsMF0sWzE5ODgsMF0sWzE5ODksMF0sWzE5OTAsMF0sWzE5OTEsMF0sWzE5OTIsMF0sWzE5OTMsMF0sWzE5OTQsMF0sWzE5OTUsMF0sWzE5OTYsMF0sWzE5OTcsMF0sWzE5OTgsMF0sWzE5OTksMF0sWzIwMDAsMF1dLFxyXG4gICAgXCJJbmRleGVkIFBvcHVsYXRpb25cIjogW1sxOTc1LDAuMDAwMDkzNDkyNjE0Njc0NTQxM10sWzE5NzYsMC4wMDAwOTY1MjExMzgzNTU3MDQ4OF0sWzE5NzcsMC4wMDAwOTk1NzI1MDY1MDQyOTEwNF0sWzE5NzgsMC4wMDAxMDI2ODk5NjA0MzM2MzUzNV0sWzE5NzksMC4wMDAxMDU5MDYxMzUwOTcxOTg2Ml0sWzE5ODAsMC4wMDAxMDkyMjAyMTQ2MjExNDQzMl0sWzE5ODEsMC4wMDAxMTI2MTU4ODE1Mjg3NDIwN10sWzE5ODIsMC4wMDAxMTYwOTQ3Njc1Njc2NjQ5XSxbMTk4MywwLjAwMDExOTY1MTE2MTYyMTA1NzE1XSxbMTk4NCwwLjAwMDEyMzI3OTM1MjU3MjA2MzJdLFsxOTg1LDAuMDAwMTI2OTgxNzg4MDQyMTkyNTldLFsxOTg2LDAuMDAwMTMwNzQ2MjI5OTIzODk3NTVdLFsxOTg3LDAuMDAwMTM0NTMyNzAwMzk5MTg4NTVdLFsxOTg4LDAuMDAwMTM4MjkwNjE1MjkwMjAxMzRdLFsxOTg5LDAuMDAwMTQxOTgxNjI4NTI2NjE5NDZdLFsxOTkwLDAuMDAwMTQ1NTg5NDIyNjMxNzEyNDhdLFsxOTkxLDAuMDAwMTQ5MTIyMTU2MzQzODQ1NjVdLFsxOTkyLDAuMDAwMTUyNTg5NjIwMTQ5MDU3Ml0sWzE5OTMsMC4wMDAxNTYwMTMwMjY3NjcwOTY2NF0sWzE5OTQsMC4wMDAxNTk0MTAzMjU0MjIzNjc0M10sWzE5OTUsMC4wMDAxNjI3NzkwNjg0OTMzNTk5OV0sWzE5OTYsMC4wMDAxNjYxMTU5OTI0ODQ3MjgyNl0sWzE5OTcsMC4wMDAxNjk0MzMzMzU1MDQwMjAwOF0sWzE5OTgsMC4wMDAxNzI3NDQ5Njc0MDY0NTYyMl0sWzE5OTksMC4wMDAxNzYwNjIzMTA0MjU3NDhdLFsyMDAwLDAuMDAwMTc5Mzg2OTk2MzA5NTY4NDhdXSxcclxuICAgIFwiSW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb25cIjogW1sxOTc1LDAuMDAwMDI3NjUxMzA2MTg1MzUzMjFdLFsxOTc2LDAuMDAwMDI5NTQ4OTQ0ODQ1MTMyMzUyXSxbMTk3NywwLjAwMDAzMjI1OTg1NzIxNjI0NTQxXSxbMTk3OCwwLjAwMDAzNDk3MDc2OTU4NzM1ODQ3XSxbMTk3OSwwLjAwMDAzODIyMzg2NDQzMjY5NDE0XSxbMTk4MCwwLjAwMDA0MTQ3Njk1OTI3ODAyOTgxNF0sWzE5ODEsMC4wMDAwNTMxMzM4ODI0NzM4MTU5NzRdLFsxOTgyLDAuMDAwMDU4Mjg0NjE1OTc4OTMwNzldLFsxOTgzLDAuMDAwMDYzNzA2NDQwNzIxMTU2OV0sWzE5ODQsMC4wMDAwNjkxMjgyNjU0NjMzODMwM10sWzE5ODUsMC4wMDAwNzU5MDU1NDYzOTExNjU2OF0sWzE5ODYsMC4wMDAwNzg2MTY0NTg3NjIyNzg3NF0sWzE5ODcsMC4wMDAwNTA2OTQwNjEzMzk4MTQyMl0sWzE5ODgsMC4wMDAwNTUwMzE1MjExMzM1OTUxMTVdLFsxOTg5LDAuMDAwMDU5NjQwMDcyMTY0NDg3MzJdLFsxOTkwLDAuMDAwMDYwOTk1NTI4MzUwMDQzODVdLFsxOTkxLDAuMDAwMDYwOTk1NTI4MzUwMDQzODVdLFsxOTkyLDAuMDAwMDY5Mzk5MzU2NzAwNDk0MzRdLFsxOTkzLDAuMDAwMDczNDY1NzI1MjU3MTYzOTJdLFsxOTk0LDAuMDAwMDc4ODg3NTQ5OTk5MzkwMDRdLFsxOTk1LDAuMDAwMDgxODY5NTUzNjA3NjE0NDFdLFsxOTk2LDAuMDAwMDg1OTM1OTIyMTY0Mjg0XSxbMTk5NywwLjAwMDA4NzU2MjQ2OTU4Njk1MTg0XSxbMTk5OCwwLjAwMDA5MDgxNTU2NDQzMjI4NzVdLFsxOTk5LDAuMDAwMDk0NjEwODQxNzUxODQ1NzldLFsyMDAwLDAuMDAwMDkwODE1NTY0NDMyMjg3NV1dLFxyXG4gICAgXCJJbmRleGVkIEdEUFwiOiBbWzE5NzUsMC4xMTcxNzc4Mjk3MzQ1NjE5Nl0sWzE5NzYsMC4xNDAwNDI2MzUxMjU4NDI0XSxbMTk3NywwLjE2MjkwNzQ0MDUxNzEyMjhdLFsxOTc4LDAuMTg1NzcyMjQ1OTA4NDAzMjRdLFsxOTc5LDAuMjA4NjM3MDUxMjk5NjgzNjhdLFsxOTgwLDAuMjMxNTAxODU2NjkwOTY0MV0sWzE5ODEsMC4yNDM3MDc4ODA2MjE2NDc2NF0sWzE5ODIsMC4yNzgwNTY2NjM0NTc1NzEyXSxbMTk4MywwLjMwMzY3MjEyMjEyOTAwNTYzXSxbMTk4NCwwLjMyMzA2NDIyNzc1NDA5MTZdLFsxOTg1LDAuMzcyMzAwOTIxNDY4ODQ4ODZdLFsxOTg2LDAuNDIxODQ3MDYzNjc3NjIzNF0sWzE5ODcsMC40NDkyMTYwNjM4MTUxNTYxXSxbMTk4OCwwLjQ3NzkyNjAwNzQyNjc2MzgzXSxbMTk4OSwwLjUwNTc0MTk4ODcyMjMyMTZdLFsxOTkwLDAuNTQ2NTU0ODA2NzY2NjA3MV0sWzE5OTEsMC41ODcyNjQ0NzUzMTI4ODY4XSxbMTk5MiwwLjYwNzg1OTk5MTc0ODA0MDJdLFsxOTkzLDAuNjM1NjA3MjA2NzExNTk0XSxbMTk5NCwwLjY2MDMyODcwMzA2Njk3ODRdLFsxOTk1LDAuNzAyMDM1NDgzNDI3MzE0XSxbMTk5NiwwLjcxMDExNTUyNzQzNzc2NjVdLFsxOTk3LDAuNzEyOTAwNTYzODgzOTIyNF0sWzE5OTgsMC43MTk2NzQwNDc1ODYzMDE3XSxbMTk5OSwwLjcyNDE3ODI0MjMzMjU1NF0sWzIwMDAsMC43MjY1NTA2ODA3ODY2ODY4XV1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIlJ3YW5kYVwiLFxyXG4gICAgXCJyZWdpb25cIjogXCJBRlwiLFxyXG4gICAgXCJjb2RlXCI6IFwiUldBXCIsXHJcbiAgICBcIlBvcHVsYXRpb25cIjogW1sxOTc1LDM4OTgwMTVdLFsxOTc2LDQwMjAyNjBdLFsxOTc3LDQxNDQ0NjldLFsxOTc4LDQyNzM2NTVdLFsxOTc5LDQ0MTAwMzldLFsxOTgwLDQ1NTQyMzNdLFsxOTgxLDQ3MDU2MDddLFsxOTgyLDQ4NjM3MDBdLFsxOTgzLDUwMjc2NjVdLFsxOTg0LDUxOTY5ODldLFsxOTg1LDUzNjM1MDRdLFsxOTg2LDU1MjYwMDZdLFsxOTg3LDU2OTgzMjFdLFsxOTg4LDU4OTk2ODNdLFsxOTg5LDYxMzkwODhdLFsxOTkwLDY0NDA1ODhdLFsxOTkxLDY3ODkyODJdLFsxOTkyLDcxMDk3MjNdLFsxOTkzLDcyOTkzMTZdLFsxOTk0LDcyOTM2OTVdLFsxOTk1LDcwNDc0NDFdLFsxOTk2LDY2MDYxNTVdLFsxOTk3LDYxMDcwOTZdLFsxOTk4LDU3NDIwMjldLFsxOTk5LDU2NDM5OTJdLFsyMDAwLDU4NjkwNTRdXSxcclxuICAgIFwiQXJhYmxlIEFyZWFcIjogW1sxOTc1LDc0OF0sWzE5NzYsODA4XSxbMTk3Nyw4MDVdLFsxOTc4LDg4NF0sWzE5NzksOTEyXSxbMTk4MCw5MzldLFsxOTgxLDk2NV0sWzE5ODIsOTgwXSxbMTk4Myw5OTddLFsxOTg0LDEwMTVdLFsxOTg1LDEwNjBdLFsxOTg2LDEwNzVdLFsxOTg3LDEwOTBdLFsxOTg4LDExMDhdLFsxOTg5LDExMTldLFsxOTkwLDExMzBdLFsxOTkxLDExNDJdLFsxOTkyLDExNTNdLFsxOTkzLDExNTVdLFsxOTk0LDExODVdLFsxOTk1LDExODddLFsxOTk2LDExODddLFsxOTk3LDExMzBdLFsxOTk4LDk0MF0sWzE5OTksOTQwXSxbMjAwMCwxMDAwXV0sXHJcbiAgICBcIkVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsODddLFsxOTc2LDEyNF0sWzE5NzcsMTI2XSxbMTk3OCwxMzVdLFsxOTc5LDE0M10sWzE5ODAsMTUwXSxbMTk4MSwxNTNdLFsxOTgyLDE2OV0sWzE5ODMsMTkzXSxbMTk4NCwxNjZdLFsxOTg1LDE2Ml0sWzE5ODYsMTU1XSxbMTk4NywxNjVdLFsxOTg4LDE3Nl0sWzE5ODksMTg0XSxbMTk5MCwyMzRdLFsxOTkxLDI0Nl0sWzE5OTIsMjEzXSxbMTk5MywxNjFdLFsxOTk0LDE4MF0sWzE5OTUsMTc2XSxbMTk5NiwxODVdLFsxOTk3LDE2OF0sWzE5OTgsMTcxXSxbMTk5OSwxNzVdLFsyMDAwLDE3NV1dLFxyXG4gICAgXCJHRFAgUGVyIENhcGl0YVwiOiBbWzE5NzUsMzldLFsxOTc2LDExOF0sWzE5NzcsMTk3XSxbMTk3OCwyNzZdLFsxOTc5LDM1NV0sWzE5ODAsNDM0XSxbMTk4MSw0NTVdLFsxOTgyLDUxNV0sWzE5ODMsNjAyXSxbMTk4NCw2OTBdLFsxOTg1LDc2OV0sWzE5ODYsODA3XSxbMTk4Nyw4NjldLFsxOTg4LDgzN10sWzE5ODksODc0XSxbMTk5MCw5MDJdLFsxOTkxLDg4M10sWzE5OTIsOTEzXSxbMTk5Myw5MjRdLFsxOTk0LDkzOV0sWzE5OTUsOTg1XSxbMTk5NiwxMTQxXSxbMTk5NywxMTY2XSxbMTk5OCw2MjldLFsxOTk5LDg3NV0sWzIwMDAsOTc4XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoV29tZW4pXCI6IFtbMTk3NSw0Ni4wNF0sWzE5NzYsNDYuMDhdLFsxOTc3LDQ2LjEyXSxbMTk3OCw0Ni4xNl0sWzE5NzksNDYuMl0sWzE5ODAsNDYuMjRdLFsxOTgxLDQ2LjI4XSxbMTk4Miw0Ni4zMl0sWzE5ODMsNDYuMzZdLFsxOTg0LDQ2LjRdLFsxOTg1LDQ2LjcyXSxbMTk4Niw0Ny4wNF0sWzE5ODcsNDcuMzZdLFsxOTg4LDQ3LjY4XSxbMTk4OSw0OF0sWzE5OTAsNDcuNjZdLFsxOTkxLDQ3LjMyXSxbMTk5Miw0Ni45OF0sWzE5OTMsNDYuNjRdLFsxOTk0LDQ2LjNdLFsxOTk1LDQyLjE0XSxbMTk5NiwzNy45OF0sWzE5OTcsMzMuODJdLFsxOTk4LDI5LjY2XSxbMTk5OSwyNS41XSxbMjAwMCwyNS41XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiOiBbWzE5NzUsNDIuODNdLFsxOTc2LDQyLjg3XSxbMTk3Nyw0Mi45Ml0sWzE5NzgsNDIuOTZdLFsxOTc5LDQzXSxbMTk4MCw0My4wNF0sWzE5ODEsNDMuMDhdLFsxOTgyLDQzLjEyXSxbMTk4Myw0My4xNl0sWzE5ODQsNDMuMl0sWzE5ODUsNDMuNDZdLFsxOTg2LDQzLjcyXSxbMTk4Nyw0My45OF0sWzE5ODgsNDQuMjRdLFsxOTg5LDQ0LjVdLFsxOTkwLDQzLjk4XSxbMTk5MSw0My40Nl0sWzE5OTIsNDIuOTRdLFsxOTkzLDQyLjQyXSxbMTk5NCw0MS45XSxbMTk5NSwzNy45XSxbMTk5NiwzMy45XSxbMTk5NywyOS45XSxbMTk5OCwyNS45XSxbMTk5OSwyMS45XSxbMjAwMCwyMS45XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeVwiOiBbWzE5NzUsNDQuMjhdLFsxOTc2LDQ0LjM2XSxbMTk3Nyw0NC40NF0sWzE5NzgsNDQuNTJdLFsxOTc5LDQ0LjZdLFsxOTgwLDQ0LjY4XSxbMTk4MSw0NC43Nl0sWzE5ODIsNDQuODRdLFsxOTgzLDQ0LjkyXSxbMTk4NCw0NV0sWzE5ODUsNDUuMjRdLFsxOTg2LDQ1LjQ4XSxbMTk4Nyw0NS43Ml0sWzE5ODgsNDUuOTZdLFsxOTg5LDQ2LjJdLFsxOTkwLDQ1Ljc2XSxbMTk5MSw0NS4zMl0sWzE5OTIsNDQuODhdLFsxOTkzLDQ0LjQ0XSxbMTk5NCw0NF0sWzE5OTUsMzkuOTJdLFsxOTk2LDM1Ljg0XSxbMTk5NywzMS43Nl0sWzE5OTgsMjcuNjhdLFsxOTk5LDIzLjZdLFsyMDAwLDIzLjZdXSxcclxuICAgIFwiSW5mYW50IE1vcnRhbGl0eVwiOiBbWzE5NzUsMTM1LjhdLFsxOTc2LDEzNS40NV0sWzE5NzcsMTM1LjA5XSxbMTk3OCwxMzQuNzVdLFsxOTc5LDEzNC40XSxbMTk4MCwxMzQuMDRdLFsxOTgxLDEzMy43XSxbMTk4MiwxMzMuMzVdLFsxOTgzLDEzMi45OV0sWzE5ODQsMTMyLjY1XSxbMTk4NSwxMzIuM10sWzE5ODYsMTMwLjddLFsxOTg3LDEyOS4xXSxbMTk4OCwxMjcuNV0sWzE5ODksMTI1LjldLFsxOTkwLDEyNC4zXSxbMTk5MSwxMjIuODZdLFsxOTkyLDEyMS40Ml0sWzE5OTMsMTE5Ljk3XSxbMTk5NCwxMTguNTNdLFsxOTk1LDExNy4xXSxbMTk5NiwxMjAuNV0sWzE5OTcsMTIzLjg5XSxbMTk5OCwxMjcuM10sWzE5OTksMTMwLjddLFsyMDAwLDEzMC43XV0sXHJcbiAgICBcIk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnNcIjogW1sxOTc1LDBdLFsxOTc2LDBdLFsxOTc3LDBdLFsxOTc4LDBdLFsxOTc5LDBdLFsxOTgwLDBdLFsxOTgxLDBdLFsxOTgyLDBdLFsxOTgzLDBdLFsxOTg0LDBdLFsxOTg1LDBdLFsxOTg2LDBdLFsxOTg3LDBdLFsxOTg4LDBdLFsxOTg5LDBdLFsxOTkwLDBdLFsxOTkxLDBdLFsxOTkyLDBdLFsxOTkzLDBdLFsxOTk0LDBdLFsxOTk1LDBdLFsxOTk2LDBdLFsxOTk3LDBdLFsxOTk4LDBdLFsxOTk5LDBdLFsyMDAwLDBdXSxcclxuICAgIFwiSW5kZXhlZCBQb3B1bGF0aW9uXCI6IFtbMTk3NSwwLjAwMzE4MDI4ODQ1Mjg2MzkxOF0sWzE5NzYsMC4wMDMyODAwMjQ5NTAwMDkzNV0sWzE5NzcsMC4wMDMzODEzNjM4MjMzNjk3MDc2XSxbMTk3OCwwLjAwMzQ4Njc2MzMwMDgxNDQyN10sWzE5NzksMC4wMDM1OTgwMzU0MzgxMzQ0Ml0sWzE5ODAsMC4wMDM3MTU2Nzk1NTAxMTc2MzddLFsxOTgxLDAuMDAzODM5MTgxNjM2MjQ3MDcwM10sWzE5ODIsMC4wMDM5NjgxNjU1Nzg2ODQwODRdLFsxOTgzLDAuMDA0MTAxOTQwMzMyMjg5MTQ1XSxbMTk4NCwwLjAwNDI0MDA4NzM1Mzc4NDExOV0sWzE5ODUsMC4wMDQzNzU5NDI1ODU2NzIzMDY1XSxbMTk4NiwwLjAwNDUwODUyMzcxNTg1NDUzOF0sWzE5ODcsMC4wMDQ2NDkxMTEwMTU5OTQ1NDVdLFsxOTg4LDAuMDA0ODEzMzk3MDAzNDYzOTU4XSxbMTk4OSwwLjAwNTAwODcyMTI3OTI5NjExNl0sWzE5OTAsMC4wMDUyNTQ3MDcyNDEwMDcwMDRdLFsxOTkxLDAuMDA1NTM5MTk3NTUyNTU4NjM1XSxbMTk5MiwwLjAwNTgwMDYzNjk4MDYwNzA1N10sWzE5OTMsMC4wMDU5NTUzMjA5NDg4OTQ0NjFdLFsxOTk0LDAuMDA1OTUwNzM0OTIyMDU5MzhdLFsxOTk1LDAuMDA1NzQ5ODIyNzI2MzIwODk2XSxbMTk5NiwwLjAwNTM4OTc4OTAyNDQ5ODE3MV0sWzE5OTcsMC4wMDQ5ODI2MTk4NDM1MTgxNTZdLFsxOTk4LDAuMDA0Njg0NzcxMjI5NjQxMTc3XSxbMTk5OSwwLjAwNDYwNDc4NTQwNjMzMDIzXSxbMjAwMCwwLjAwNDc4ODQwNzYwMzcyNTE3NTVdXSxcclxuICAgIFwiSW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb25cIjogW1sxOTc1LDAuMDAwMDIzNTg0OTM3NjI4NjgzNjJdLFsxOTc2LDAuMDAwMDMzNjE1MzEzNDAxODAxOTRdLFsxOTc3LDAuMDAwMDM0MTU3NDk1ODc2MDI0NTVdLFsxOTc4LDAuMDAwMDM2NTk3MzE3MDEwMDI2MzFdLFsxOTc5LDAuMDAwMDM4NzY2MDQ2OTA2OTE2NzZdLFsxOTgwLDAuMDAwMDQwNjYzNjg1NTY2Njk1OV0sWzE5ODEsMC4wMDAwNDE0NzY5NTkyNzgwMjk4MTRdLFsxOTgyLDAuMDAwMDQ1ODE0NDE5MDcxODEwNzFdLFsxOTgzLDAuMDAwMDUyMzIwNjA4NzYyNDgyMDU0XSxbMTk4NCwwLjAwMDA0NTAwMTE0NTM2MDQ3Njc5NF0sWzE5ODUsMC4wMDAwNDM5MTY3ODA0MTIwMzE1N10sWzE5ODYsMC4wMDAwNDIwMTkxNDE3NTIyNTI0M10sWzE5ODcsMC4wMDAwNDQ3MzAwNTQxMjMzNjU0OV0sWzE5ODgsMC4wMDAwNDc3MTIwNTc3MzE1ODk4NTRdLFsxOTg5LDAuMDAwMDQ5ODgwNzg3NjI4NDgwM10sWzE5OTAsMC4wMDAwNjM0MzUzNDk0ODQwNDU2XSxbMTk5MSwwLjAwMDA2NjY4ODQ0NDMyOTM4MTI4XSxbMTk5MiwwLjAwMDA1Nzc0MjQzMzUwNDcwODE3NV0sWzE5OTMsMC4wMDAwNDM2NDU2ODkxNzQ5MjAyNjNdLFsxOTk0LDAuMDAwMDQ4Nzk2NDIyNjgwMDM1MDhdLFsxOTk1LDAuMDAwMDQ3NzEyMDU3NzMxNTg5ODU0XSxbMTk5NiwwLjAwMDA1MDE1MTg3ODg2NTU5MTYxXSxbMTk5NywwLjAwMDA0NTU0MzMyNzgzNDY5OTQwNF0sWzE5OTgsMC4wMDAwNDYzNTY2MDE1NDYwMzMzMjRdLFsxOTk5LDAuMDAwMDQ3NDQwOTY2NDk0NDc4NTVdLFsyMDAwLDAuMDAwMDQ3NDQwOTY2NDk0NDc4NTVdXSxcclxuICAgIFwiSW5kZXhlZCBHRFBcIjogW1sxOTc1LDAuMDAxMzQwOTQzNDc0MDc1MDkyOF0sWzE5NzYsMC4wMDQwNTcyMTM1ODgyMjcyMDM1XSxbMTk3NywwLjAwNjc3MzQ4MzcwMjM3OTMxNV0sWzE5NzgsMC4wMDk0ODk3NTM4MTY1MzE0MjZdLFsxOTc5LDAuMDEyMjA2MDIzOTMwNjgzNTM3XSxbMTk4MCwwLjAxNDkyMjI5NDA0NDgzNTY0OF0sWzE5ODEsMC4wMTU2NDQzNDA1MzA4NzYwODJdLFsxOTgyLDAuMDE3NzA3MzMwNDkwOTkxNjFdLFsxOTgzLDAuMDIwNjk4NjY1OTMzMTU5MTI0XSxbMTk4NCwwLjAyMzcyNDM4NDU0MTMyODU2Nl0sWzE5ODUsMC4wMjY0NDA2NTQ2NTU0ODA2NzhdLFsxOTg2LDAuMDI3NzQ3MjE0OTYzNTUzODQ0XSxbMTk4NywwLjAyOTg3ODk3MTI1NTY3MzIyM10sWzE5ODgsMC4wMjg3Nzg3MDk5NDM2MTE2MV0sWzE5ODksMC4wMzAwNTA4ODcwODU2ODI4NDhdLFsxOTkwLDAuMDMxMDEzNjE1NzMzNzM2NzY0XSxbMTk5MSwwLjAzMDM2MDMzNTU3OTcwMDE4XSxbMTk5MiwwLjAzMTM5MTgzMDU1OTc1Nzk0NF0sWzE5OTMsMC4wMzE3NzAwNDUzODU3NzkxMl0sWzE5OTQsMC4wMzIyODU3OTI4NzU4MDhdLFsxOTk1LDAuMDMzODY3NDE4NTExODk2NThdLFsxOTk2LDAuMDM5MjMxMTkyNDA4MTk2OTQ3XSxbMTk5NywwLjA0MDA5MDc3MTU1ODI0NTA4Nl0sWzE5OTgsMC4wMjE2MjcwMTE0MTUyMTExMTRdLFsxOTk5LDAuMDMwMDg1MjcwMjUxNjg0Nzc0XSxbMjAwMCwwLjAzMzYyNjczNjM0OTg4MzFdXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiU2F1ZGkgQXJhYmlhXCIsXHJcbiAgICBcInJlZ2lvblwiOiBcIkFTXCIsXHJcbiAgICBcImNvZGVcIjogXCJTQVVcIixcclxuICAgIFwiUG9wdWxhdGlvblwiOiBbWzE5NzUsNTk5MTM2OV0sWzE5NzYsNjI2MjA2OF0sWzE5NzcsNjU2MDA3Ml0sWzE5NzgsNjg4ODkwOV0sWzE5NzksNzI1MTQwMV0sWzE5ODAsNzY0NzM4MF0sWzE5ODEsODA3NzE2OF0sWzE5ODIsODU0NDIzNV0sWzE5ODMsOTA1MjcxNl0sWzE5ODQsOTYwNDM3NF0sWzE5ODUsMTAxOTY4ODhdLFsxOTg2LDEwODI1MTM3XSxbMTk4NywxMTQ4Mzg2OV0sWzE5ODgsMTIxNjYzNDBdLFsxOTg5LDEyODY0NzYwXSxbMTk5MCwxMzU4MTk5N10sWzE5OTEsMTQzMTEwMTZdLFsxOTkyLDE1MDIyNTk2XSxbMTk5MywxNTY3OTEyMF0sWzE5OTQsMTYyNTU3NDNdLFsxOTk1LDE2NzM4NDA2XSxbMTk5NiwxNzEzOTYwMV0sWzE5OTcsMTc0OTQxNDZdLFsxOTk4LDE3ODUyMjE5XSxbMTk5OSwxODI1MDU4M10sWzIwMDAsMTg3MDA0NzNdXSxcclxuICAgIFwiQXJhYmxlIEFyZWFcIjogW1sxOTc1LDE0NjddLFsxOTc2LDE1MTddLFsxOTc3LDE1NzBdLFsxOTc4LDE2NDBdLFsxOTc5LDE2ODRdLFsxOTgwLDE3NTBdLFsxOTgxLDE4MDRdLFsxOTgyLDE4NTZdLFsxOTgzLDE5MDldLFsxOTg0LDE5NjJdLFsxOTg1LDIwMTNdLFsxOTg2LDIwNjhdLFsxOTg3LDIyNzBdLFsxOTg4LDI0MjNdLFsxOTg5LDI2MjVdLFsxOTkwLDI3ODBdLFsxOTkxLDI5ODBdLFsxOTkyLDMxMzBdLFsxOTkzLDMyOTBdLFsxOTk0LDM0ODFdLFsxOTk1LDM2NzJdLFsxOTk2LDM3NDZdLFsxOTk3LDM3ODVdLFsxOTk4LDM3ODVdLFsxOTk5LDM3ODVdLFsyMDAwLDM1MDBdXSxcclxuICAgIFwiRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwxMTUwXSxbMTk3NiwxMzUwXSxbMTk3NywxNTY0XSxbMTk3OCwxNjcwXSxbMTk3OSwyNDc4XSxbMTk4MCw2Mzg5XSxbMTk4MSw3MjYzXSxbMTk4Miw5NzEzXSxbMTk4MywxNTQ3MF0sWzE5ODQsMTg5MDldLFsxOTg1LDI1MDYxXSxbMTk4NiwzMTAxNF0sWzE5ODcsMzA2MTVdLFsxOTg4LDMxNzc4XSxbMTk4OSwzMzYwMV0sWzE5OTAsNTI4NjNdLFsxOTkxLDU3ODQ5XSxbMTk5Miw2MTMwNl0sWzE5OTMsNjYwNjFdLFsxOTk0LDcwMTE1XSxbMTk5NSw3NDU3NF0sWzE5OTYsNzk2MjhdLFsxOTk3LDg3OTA2XSxbMTk5OCw5Njg4MF0sWzE5OTksOTk4MzNdLFsyMDAwLDEwMzM1M11dLFxyXG4gICAgXCJHRFAgUGVyIENhcGl0YVwiOiBbWzE5NzUsMzkxOF0sWzE5NzYsNDk4OF0sWzE5NzcsNjA1OF0sWzE5NzgsNzEyOF0sWzE5NzksODE5OF0sWzE5ODAsOTI2OF0sWzE5ODEsOTkzNV0sWzE5ODIsOTk2N10sWzE5ODMsMTA4ODNdLFsxOTg0LDEyMTg0XSxbMTk4NSwxMzA4OF0sWzE5ODYsMTExNDFdLFsxOTg3LDk1NzddLFsxOTg4LDkyMDNdLFsxOTg5LDg0NDddLFsxOTkwLDg0NDFdLFsxOTkxLDc5NDddLFsxOTkyLDg1MDFdLFsxOTkzLDg1MzVdLFsxOTk0LDk1MDZdLFsxOTk1LDEwNTYzXSxbMTk5NiwxMTEyOF0sWzE5OTcsMTEyMjhdLFsxOTk4LDExNDc5XSxbMTk5OSwxMTM1MV0sWzIwMDAsMTE2OTFdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5IChXb21lbilcIjogW1sxOTc1LDUxLjk4XSxbMTk3Niw1Mi44Nl0sWzE5NzcsNTMuNzRdLFsxOTc4LDU0LjYyXSxbMTk3OSw1NS41XSxbMTk4MCw1Ni4zOF0sWzE5ODEsNTcuMjZdLFsxOTgyLDU4LjE0XSxbMTk4Myw1OS4wMV0sWzE5ODQsNTkuOV0sWzE5ODUsNjAuODJdLFsxOTg2LDYxLjc0XSxbMTk4Nyw2Mi42Nl0sWzE5ODgsNjMuNThdLFsxOTg5LDY0LjVdLFsxOTkwLDY1LjIyXSxbMTk5MSw2NS45NF0sWzE5OTIsNjYuNjZdLFsxOTkzLDY3LjM4XSxbMTk5NCw2OC4xXSxbMTk5NSw2OC42NF0sWzE5OTYsNjkuMTddLFsxOTk3LDY5LjcyXSxbMTk5OCw3MC4yNV0sWzE5OTksNzAuOF0sWzIwMDAsNzEuMzRdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5IChNZW4pXCI6IFtbMTk3NSw0OC4yM10sWzE5NzYsNDkuMjddLFsxOTc3LDUwLjMyXSxbMTk3OCw1MS4zNl0sWzE5NzksNTIuNF0sWzE5ODAsNTMuNDRdLFsxOTgxLDU0LjQ4XSxbMTk4Miw1NS41Ml0sWzE5ODMsNTYuNTZdLFsxOTg0LDU3LjZdLFsxOTg1LDU4LjQ2XSxbMTk4Niw1OS4zMl0sWzE5ODcsNjAuMThdLFsxOTg4LDYxLjA0XSxbMTk4OSw2MS45XSxbMTk5MCw2Mi41MV0sWzE5OTEsNjMuMTRdLFsxOTkyLDYzLjc2XSxbMTk5Myw2NC4zOF0sWzE5OTQsNjVdLFsxOTk1LDY1LjQ4XSxbMTk5Niw2NS45Nl0sWzE5OTcsNjYuNDRdLFsxOTk4LDY2LjkyXSxbMTk5OSw2Ny40XSxbMjAwMCw2Ny44OF1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3lcIjogW1sxOTc1LDUwLjA1XSxbMTk3Niw1MS4wMV0sWzE5NzcsNTEuOThdLFsxOTc4LDUyLjk0XSxbMTk3OSw1My45XSxbMTk4MCw1NC44Nl0sWzE5ODEsNTUuODJdLFsxOTgyLDU2Ljc4XSxbMTk4Myw1Ny43NF0sWzE5ODQsNTguN10sWzE5ODUsNTkuNTZdLFsxOTg2LDYwLjQyXSxbMTk4Nyw2MS4yOF0sWzE5ODgsNjIuMTRdLFsxOTg5LDYzXSxbMTk5MCw2My42Nl0sWzE5OTEsNjQuMzJdLFsxOTkyLDY0Ljk4XSxbMTk5Myw2NS42NF0sWzE5OTQsNjYuM10sWzE5OTUsNjYuOF0sWzE5OTYsNjcuM10sWzE5OTcsNjcuOF0sWzE5OTgsNjguM10sWzE5OTksNjguOF0sWzIwMDAsNjkuM11dLFxyXG4gICAgXCJJbmZhbnQgTW9ydGFsaXR5XCI6IFtbMTk3NSwxMjNdLFsxOTc2LDExOC41XSxbMTk3NywxMTMuOTFdLFsxOTc4LDEwOS41OV0sWzE5NzksMTA1XSxbMTk4MCwxMDAuNDFdLFsxOTgxLDk2LjA5XSxbMTk4Miw5MS41XSxbMTk4Myw4Ni45MV0sWzE5ODQsODIuNTldLFsxOTg1LDc4XSxbMTk4Niw3My42OF0sWzE5ODcsNjkuMzZdLFsxOTg4LDY1LjAzXSxbMTk4OSw2MC43Ml0sWzE5OTAsNTYuNF0sWzE5OTEsNTMuNjJdLFsxOTkyLDUwLjgzXSxbMTk5Myw0OC4wNl0sWzE5OTQsNDUuMjhdLFsxOTk1LDQyLjVdLFsxOTk2LDQwLjQyXSxbMTk5NywzOC4zNF0sWzE5OTgsMzYuMjZdLFsxOTk5LDM0LjE4XSxbMjAwMCwzMi4xXV0sXHJcbiAgICBcIk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnNcIjogW1sxOTc1LDBdLFsxOTc2LDBdLFsxOTc3LDBdLFsxOTc4LDAuMDddLFsxOTc5LDAuMjFdLFsxOTgwLDAuMzVdLFsxOTgxLDAuNDldLFsxOTgyLDAuNjNdLFsxOTgzLDAuNzddLFsxOTg0LDAuOTFdLFsxOTg1LDEuMDVdLFsxOTg2LDEuMTldLFsxOTg3LDEuMzJdLFsxOTg4LDEuNDZdLFsxOTg5LDEuNjJdLFsxOTkwLDEuNzZdLFsxOTkxLDEuODldLFsxOTkyLDEuOTldLFsxOTkzLDIuMTVdLFsxOTk0LDIuNF0sWzE5OTUsMi41XSxbMTk5NiwyLjVdLFsxOTk3LDIuNV0sWzE5OTgsM10sWzE5OTksMy42XSxbMjAwMCw0XV0sXHJcbiAgICBcIkluZGV4ZWQgUG9wdWxhdGlvblwiOiBbWzE5NzUsMC4wMDQ4ODgyMDEyMTIwMzkxNjRdLFsxOTc2LDAuMDA1MTA5MDU3NDQzNzExMzg5XSxbMTk3NywwLjAwNTM1MjE5MTExMDQ4OTgwM10sWzE5NzgsMC4wMDU2MjA0ODA2MTUyNjk2NDldLFsxOTc5LDAuMDA1OTE2MjI4MzU0MDE3NTg5XSxbMTk4MCwwLjAwNjIzOTI5NzI1OTkyOTA4NV0sWzE5ODEsMC4wMDY1ODk5NTAwNDQzNzk0OThdLFsxOTgyLDAuMDA2OTcxMDE3Nzg5NTgxNTU0XSxbMTk4MywwLjAwNzM4NTg3NDEzMzg0OTI2NF0sWzE5ODQsMC4wMDc4MzU5NTc0NjI3NTY0MTRdLFsxOTg1LDAuMDA4MzE5Mzc0MTMzMTI4NDRdLFsxOTg2LDAuMDA4ODMxOTQ2MDU1MDQ4NTJdLFsxOTg3LDAuMDA5MzY5Mzg4MjU5MTI3MjUyXSxbMTk4OCwwLjAwOTkyNjE5ODQ5MjIxMTEzOV0sWzE5ODksMC4wMTA0OTYwMjEwOTcxMTM2OV0sWzE5OTAsMC4wMTEwODExOTU5OTk5OTgwNDVdLFsxOTkxLDAuMDExNjc1OTgzNTI4NDI0MjgzXSxbMTk5MiwwLjAxMjI1NjU0MzAzMzAxNTQ0M10sWzE5OTMsMC4wMTI3OTIxODM3ODc2NjMxMzZdLFsxOTk0LDAuMDEzMjYyNjM1NDA2ODk5MDE2XSxbMTk5NSwwLjAxMzY1NjQyNzUyMDQ1NTQ0NV0sWzE5OTYsMC4wMTM5ODM3NTIwMjQyOTgyM10sWzE5OTcsMC4wMTQyNzMwMTYwMTM2NjczNDNdLFsxOTk4LDAuMDE0NTY1MTU4NDA1OTMxNjk4XSxbMTk5OSwwLjAxNDg5MDE3MzE3MDk0MzI5Nl0sWzIwMDAsMC4wMTUyNTcyMjY2NTEyNTU0NF1dLFxyXG4gICAgXCJJbmRleGVkIEVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsMC4wMDAzMTE3NTQ5MjI2NzgwMDE5XSxbMTk3NiwwLjAwMDM2NTk3MzE3MDEwMDI2MzFdLFsxOTc3LDAuMDAwNDIzOTg2Njk0ODQyMDgyNl0sWzE5NzgsMC4wMDA0NTI3MjIzNjU5NzU4ODFdLFsxOTc5LDAuMDAwNjcxNzY0MDg1NTYxODE2Ml0sWzE5ODAsMC4wMDE3MzIwMDE5MTM5MDQxMzRdLFsxOTgxLDAuMDAxOTY4OTM1NjU1MTM5NDE1Nl0sWzE5ODIsMC4wMDI2MzMxMDkxODYwNjIxMTVdLFsxOTgzLDAuMDA0MTkzNzgxNDM4MTExOTA0XSxbMTk4NCwwLjAwNTEyNjA2NDIwMjUzNzY4NV0sWzE5ODUsMC4wMDY3OTM4MTc0OTMyNDY0NF0sWzE5ODYsMC4wMDg0MDc2MjM2Mjc3NzAwNDRdLFsxOTg3LDAuMDA4Mjk5NDU4MjI0MTYyNjM0XSxbMTk4OCwwLjAwODYxNDczNzMzMjkyMzA4Ml0sWzE5ODksMC4wMDkxMDg5MzY2NTgxNzY5OTRdLFsxOTkwLDAuMDE0MzMwNjk2MDY3NDE0OTY4XSxbMTk5MSwwLjAxNTY4MjM1Njk3NTY1MTk0XSxbMTk5MiwwLjAxNjYxOTUxOTM4MjM0NTcyNF0sWzE5OTMsMC4wMTc5MDg1NTgyMTQ4MDk5ODRdLFsxOTk0LDAuMDE5MDA3NTYyMDkwMDU5MjJdLFsxOTk1LDAuMDIwMjE2MzU3OTE2MzM4NTM0XSxbMTk5NiwwLjAyMTU4NjQ1MzAyODY5OTA3M10sWzE5OTcsMC4wMjM4MzA1NDYyODk1MDY0NjVdLFsxOTk4LDAuMDI2MjYzMzE5MDUxMzQzMzI2XSxbMTk5OSwwLjAyNzA2Mzg1MTQ3NDUzMzAxXSxbMjAwMCwwLjAyODAxODA5MjYyOTE2NDgxXV0sXHJcbiAgICBcIkluZGV4ZWQgR0RQXCI6IFtbMTk3NSwwLjEzNDcxMzI0NDM5NTU0Mzk0XSxbMTk3NiwwLjE3MTUwMzIzMjAxNzYwNDE3XSxbMTk3NywwLjIwODI5MzIxOTYzOTY2NDRdLFsxOTc4LDAuMjQ1MDgzMjA3MjYxNzI0NjddLFsxOTc5LDAuMjgxODczMTk0ODgzNzg0ODddLFsxOTgwLDAuMzE4NjYzMTgyNTA1ODQ1MTNdLFsxOTgxLDAuMzQxNTk2NzU0MjI5MTI5NDRdLFsxOTgyLDAuMzQyNjk3MDE1NTQxMTkxMDNdLFsxOTgzLDAuMzc0MTkxOTk1NTk4OTU0OF0sWzE5ODQsMC40MTg5MjQ0OTQ1Njc0NTk4XSxbMTk4NSwwLjQ1MDAwNjg3NjYzMzIwMDRdLFsxOTg2LDAuMzgzMDYyODUyNDI3NDUxNTNdLFsxOTg3LDAuMzI5Mjg3NTgwODAwNDQwMV0sWzE5ODgsMC4zMTY0MjgyNzY3MTU3Ml0sWzE5ODksMC4yOTA0MzQ2MDMyMTgyNjQzNl0sWzE5OTAsMC4yOTAyMjgzMDQyMjIyNTI3Nl0sWzE5OTEsMC4yNzMyNDMwMjAyMTczMDE2XSxbMTk5MiwwLjI5MjI5MTI5NDE4MjM2ODNdLFsxOTkzLDAuMjkzNDYwMzIxODI2NDMzOF0sWzE5OTQsMC4zMjY4NDYzNzYwMTQzMDM0XSxbMTk5NSwwLjM2MzE4OTM4MjQ3ODMzODZdLFsxOTk2LDAuMzgyNjE1ODcxMjY5NDI2NV0sWzE5OTcsMC4zODYwNTQxODc4Njk2MTkwNF0sWzE5OTgsMC4zOTQ2ODQzNjI1MzYxMDIzNF0sWzE5OTksMC4zOTAyODMzMTcyODc4NTU4N10sWzIwMDAsMC40MDE5NzM1OTM3Mjg1MTA1NV1dXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJTd2VkZW5cIixcclxuICAgIFwicmVnaW9uXCI6IFwiRVVcIixcclxuICAgIFwiY29kZVwiOiBcIlNXRVwiLFxyXG4gICAgXCJQb3B1bGF0aW9uXCI6IFtbMTk3NSw4MDg0OTY1XSxbMTk3Niw4MTE3ODYyXSxbMTk3Nyw4MTQ0MjE2XSxbMTk3OCw4MTY4MTMyXSxbMTk3OSw4MTkyNTY3XSxbMTk4MCw4MjE4OTMyXSxbMTk4MSw4MjQ2MzAzXSxbMTk4Miw4MjcyNTgzXSxbMTk4Myw4Mjk0NjA3XSxbMTk4NCw4MzEwNDY4XSxbMTk4NSw4MzE5MjYzXSxbMTk4Niw4MzIyODk3XSxbMTk4Nyw4MzI1NjYzXSxbMTk4OCw4MzMzNDIyXSxbMTk4OSw4MzUwMzY1XSxbMTk5MCw4Mzc3NDE4XSxbMTk5MSw4NDEzMjAyXSxbMTk5Miw4NDU2NjUzXSxbMTk5Myw4NTA1ODM2XSxbMTk5NCw4NTU4ODMwXSxbMTk5NSw4NjE2NTIxXSxbMTk5Niw4Njc4MTU1XSxbMTk5Nyw4NzM4MTg3XSxbMTk5OCw4Nzg5Mzg0XSxbMTk5OSw4ODI2OTQ5XSxbMjAwMCw4ODQ4MTc0XV0sXHJcbiAgICBcIkFyYWJsZSBBcmVhXCI6IFtbMTk3NSwzMDU1XSxbMTk3NiwzMDM1XSxbMTk3NywzMDIyXSxbMTk3OCwzMDIzXSxbMTk3OSwzMDEwXSxbMTk4MCwzMDA3XSxbMTk4MSwyOTk4XSxbMTk4MiwzMDA0XSxbMTk4MywyOTg5XSxbMTk4NCwyOTgzXSxbMTk4NSwyOTY0XSxbMTk4NiwyOTU0XSxbMTk4NywyOTQ1XSxbMTk4OCwyOTM3XSxbMTk4OSwyOTI2XSxbMTk5MCwyOTEyXSxbMTk5MSwyODk0XSxbMTk5MiwyODc2XSxbMTk5MywyODU3XSxbMTk5NCwyODQ5XSxbMTk5NSwyNzkzXSxbMTk5NiwyNzcxXSxbMTk5NywyNzgzXSxbMTk5OCwyNzgzXSxbMTk5OSwyNzcwXSxbMjAwMCwyODE1XV0sXHJcbiAgICBcIkVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsNzM1NzFdLFsxOTc2LDc4OTg4XSxbMTk3Nyw4NDg4OV0sWzE5NzgsODQ0NjRdLFsxOTc5LDg3ODcwXSxbMTk4MCw5MjY3Nl0sWzE5ODEsOTQ4MjJdLFsxOTgyLDk4MDY3XSxbMTk4MywxMDMwNjddLFsxOTg0LDk3MjMwXSxbMTk4NSwxMDA2NTZdLFsxOTg2LDEwMzM5Ml0sWzE5ODcsMTE0MzI0XSxbMTk4OCwxMjQyMjldLFsxOTg5LDEzNTc1N10sWzE5OTAsMTMzOTkyXSxbMTk5MSwxNDI1NTZdLFsxOTkyLDE0MzY4M10sWzE5OTMsMTQzMjg2XSxbMTk5NCwxNDU0OTddLFsxOTk1LDE0NjY5OF0sWzE5OTYsMTQ0OTYzXSxbMTk5NywxNDU3MjNdLFsxOTk4LDE0Mzg0OF0sWzE5OTksMTQ2NzM0XSxbMjAwMCwxNDY4MjJdXSxcclxuICAgIFwiR0RQIFBlciBDYXBpdGFcIjogW1sxOTc1LDQ3NDVdLFsxOTc2LDUxNzJdLFsxOTc3LDU1OTldLFsxOTc4LDYwMjZdLFsxOTc5LDY0NTNdLFsxOTgwLDY4ODBdLFsxOTgxLDcxOTddLFsxOTgyLDc4MjddLFsxOTgzLDg3NzhdLFsxOTg0LDk3NjVdLFsxOTg1LDEwNzA1XSxbMTk4NiwxMTY0M10sWzE5ODcsMTIzNTBdLFsxOTg4LDEzMzU3XSxbMTk4OSwxNDA0OV0sWzE5OTAsMTQ2MzVdLFsxOTkxLDE1NDMyXSxbMTk5MiwxNjMxN10sWzE5OTMsMTczMThdLFsxOTk0LDE4MTYzXSxbMTk5NSwxODYxNl0sWzE5OTYsMTg5NTddLFsxOTk3LDE5MDEzXSxbMTk5OCwxOTc0NF0sWzE5OTksMjA4MDJdLFsyMDAwLDIxNDM5XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoV29tZW4pXCI6IFtbMTk3NSw3Ni44Nl0sWzE5NzYsNzcuMDJdLFsxOTc3LDc3LjE4XSxbMTk3OCw3Ny4zNF0sWzE5NzksNzcuNV0sWzE5ODAsNzcuNjZdLFsxOTgxLDc3LjgyXSxbMTk4Miw3Ny45OF0sWzE5ODMsNzguMTRdLFsxOTg0LDc4LjNdLFsxOTg1LDc4LjUzXSxbMTk4Niw3OC43OF0sWzE5ODcsNzkuMDJdLFsxOTg4LDc5LjI2XSxbMTk4OSw3OS41XSxbMTk5MCw3OS42Ml0sWzE5OTEsNzkuNzRdLFsxOTkyLDc5Ljg2XSxbMTk5Myw3OS45N10sWzE5OTQsODAuMV0sWzE5OTUsODAuMjVdLFsxOTk2LDgwLjQyXSxbMTk5Nyw4MC41OF0sWzE5OTgsODAuNzRdLFsxOTk5LDgwLjldLFsyMDAwLDgxLjA2XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiOiBbWzE5NzUsNzEuOTRdLFsxOTc2LDcxLjk3XSxbMTk3Nyw3Mi4wMl0sWzE5NzgsNzIuMDVdLFsxOTc5LDcyLjFdLFsxOTgwLDcyLjE0XSxbMTk4MSw3Mi4xN10sWzE5ODIsNzIuMjJdLFsxOTgzLDcyLjI1XSxbMTk4NCw3Mi4zXSxbMTk4NSw3Mi41M10sWzE5ODYsNzIuNzhdLFsxOTg3LDczLjAyXSxbMTk4OCw3My4yNl0sWzE5ODksNzMuNV0sWzE5OTAsNzMuNjZdLFsxOTkxLDczLjgyXSxbMTk5Miw3My45OF0sWzE5OTMsNzQuMTRdLFsxOTk0LDc0LjNdLFsxOTk1LDc0LjUzXSxbMTk5Niw3NC43OF0sWzE5OTcsNzUuMDJdLFsxOTk4LDc1LjI2XSxbMTk5OSw3NS41XSxbMjAwMCw3NS43NF1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3lcIjogW1sxOTc1LDc0LjNdLFsxOTc2LDc0LjRdLFsxOTc3LDc0LjVdLFsxOTc4LDc0LjZdLFsxOTc5LDc0LjddLFsxOTgwLDc0LjhdLFsxOTgxLDc0LjldLFsxOTgyLDc1XSxbMTk4Myw3NS4xXSxbMTk4NCw3NS4yXSxbMTk4NSw3NS40Ml0sWzE5ODYsNzUuNjRdLFsxOTg3LDc1Ljg2XSxbMTk4OCw3Ni4wOF0sWzE5ODksNzYuM10sWzE5OTAsNzYuNV0sWzE5OTEsNzYuN10sWzE5OTIsNzYuODldLFsxOTkzLDc3LjFdLFsxOTk0LDc3LjNdLFsxOTk1LDc3LjVdLFsxOTk2LDc3LjddLFsxOTk3LDc3Ljg5XSxbMTk5OCw3OC4xXSxbMTk5OSw3OC4zXSxbMjAwMCw3OC41XV0sXHJcbiAgICBcIkluZmFudCBNb3J0YWxpdHlcIjogW1sxOTc1LDExLjczXSxbMTk3NiwxMS4zNF0sWzE5NzcsMTAuOTVdLFsxOTc4LDEwLjU5XSxbMTk3OSwxMC4yXSxbMTk4MCw5LjhdLFsxOTgxLDkuNDRdLFsxOTgyLDkuMDVdLFsxOTgzLDguNjVdLFsxOTg0LDguMjldLFsxOTg1LDcuOV0sWzE5ODYsNy42OF0sWzE5ODcsNy40Nl0sWzE5ODgsNy4yNF0sWzE5ODksNy4wMl0sWzE5OTAsNi44XSxbMTk5MSw2LjY0XSxbMTk5Miw2LjQ3XSxbMTk5Myw2LjMyXSxbMTk5NCw2LjE2XSxbMTk5NSw2XSxbMTk5Niw1Ljg0XSxbMTk5Nyw1LjY4XSxbMTk5OCw1LjUyXSxbMTk5OSw1LjM2XSxbMjAwMCw1LjJdXSxcclxuICAgIFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiOiBbWzE5NzUsMF0sWzE5NzYsMF0sWzE5NzcsMF0sWzE5NzgsMF0sWzE5NzksMF0sWzE5ODAsMF0sWzE5ODEsMF0sWzE5ODIsMF0sWzE5ODMsMF0sWzE5ODQsMF0sWzE5ODUsMF0sWzE5ODYsMF0sWzE5ODcsMF0sWzE5ODgsMF0sWzE5ODksMC4wNV0sWzE5OTAsMi4xNl0sWzE5OTEsNC4xXSxbMTk5Miw1LjldLFsxOTkzLDguMl0sWzE5OTQsMTAuNV0sWzE5OTUsMTIuN10sWzE5OTYsMTMuOF0sWzE5OTcsMTQuOV0sWzE5OTgsMTguMV0sWzE5OTksMjQuOV0sWzIwMDAsMjkuNF1dLFxyXG4gICAgXCJJbmRleGVkIFBvcHVsYXRpb25cIjogW1sxOTc1LDAuMDA2NTk2MzExNDEyNjgyODQ4XSxbMTk3NiwwLjAwNjYyMzE1MTIxNDI4Mjg1OF0sWzE5NzcsMC4wMDY2NDQ2NTI3NTMzNzA1MTVdLFsxOTc4LDAuMDA2NjY0MTY1MTkyMDQ0NzM2Nl0sWzE5NzksMC4wMDY2ODQxMDEwNjkyNDAxMTE1XSxbMTk4MCwwLjAwNjcwNTYxMTU4MjkzOTk3MV0sWzE5ODEsMC4wMDY3Mjc5NDI4NjU3MTkzNjldLFsxOTgyLDAuMDA2NzQ5Mzg0MDMwMTQzMTI1XSxbMTk4MywwLjAwNjc2NzM1MjgzNTUxODY0OV0sWzE5ODQsMC4wMDY3ODAyOTM0MTA0Mzk2OTg1XSxbMTk4NSwwLjAwNjc4NzQ2OTAyMDgzMTg5NV0sWzE5ODYsMC4wMDY3OTA0MzM5MDYzNTM4MV0sWzE5ODcsMC4wMDY3OTI2OTA2MTMzODU2MjZdLFsxOTg4LDAuMDA2Nzk5MDIwOTc4NDgzMTg3XSxbMTk4OSwwLjAwNjgxMjg0NDMyODg5NTM1MV0sWzE5OTAsMC4wMDY4MzQ5MTYxNjM3OTQ3MzZdLFsxOTkxLDAuMDA2ODY0MTExMzkzMTYwNzgyXSxbMTk5MiwwLjAwNjg5OTU2MTkyNzIzMTQyN10sWzE5OTMsMC4wMDY5Mzk2ODkwNTAxMzMwMDldLFsxOTk0LDAuMDA2OTgyOTI1NDY4MjI1NTY5XSxbMTk5NSwwLjAwNzAyOTk5NDA0NTcyODI2NV0sWzE5OTYsMC4wMDcwODAyNzk2MTM3NjgzNjFdLFsxOTk3LDAuMDA3MTI5MjU4MTUxOTIyMzUxXSxbMTk5OCwwLjAwNzE3MTAyODQ0NDczMDY4NF0sWzE5OTksMC4wMDcyMDE2NzY3NDUzOTk1NzJdLFsyMDAwLDAuMDA3MjE4OTkzNjY3NTc5NzE2XV0sXHJcbiAgICBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwwLjAxOTk0NDQ1MzQwNTUxNTg5M10sWzE5NzYsMC4wMjE0MTI5NTQ2MzY5NDc4NF0sWzE5NzcsMC4wMjMwMTI2NjQwMjcxNDE2NTZdLFsxOTc4LDAuMDIyODk3NDUwMjUxMzY5MzVdLFsxOTc5LDAuMDIzODIwNzg3MDA0OTcwNDU4XSxbMTk4MCwwLjAyNTEyMzY1MTQ5MDUyNzM5M10sWzE5ODEsMC4wMjU3MDU0MTMyODUzNjgyNTddLFsxOTgyLDAuMDI2NTg1MTA0MzQ5Nzk0NDQ1XSxbMTk4MywwLjAyNzk0MDU2MDUzNTM1MDk3NV0sWzE5ODQsMC4wMjYzNTgyMDA5ODQzMzIyOF0sWzE5ODUsMC4wMjcyODY5NTk1NjI2NzU2MTddLFsxOTg2LDAuMDI4MDI4NjY1MTg3NDEyMTVdLFsxOTg3LDAuMDMwOTkyMjM0NTkxNTEyOTQ3XSxbMTk4OCwwLjAzMzY3NzM5MzI5NTEwMDQzXSxbMTk4OSwwLjAzNjgwMjUzMzA3NjUxOTU3XSxbMTk5MCwwLjAzNjMyNDA1NzA0MzAxODExXSxbMTk5MSwwLjAzODY0NTY4MjM5NzYzOTM0XSxbMTk5MiwwLjAzODk1MTIwMjIyMTg2Mzc4XSxbMTk5MywwLjAzODg0MzU3OTAwMDczMDU5XSxbMTk5NCwwLjAzOTQ0Mjk2MTcyNTk4MzY5XSxbMTk5NSwwLjAzOTc2ODU0MjMwMTc1NDM3XSxbMTk5NiwwLjAzOTI5ODE5OTAwNTM2NjI1XSxbMTk5NywwLjAzOTUwNDIyODM0NTU3MDg0NV0sWzE5OTgsMC4wMzg5OTU5MzIyNzU5ODcxNV0sWzE5OTksMC4wMzk3NzgzMDE1ODYyOTAzN10sWzIwMDAsMC4wMzk4MDIxNTc2MTUxNTYxN11dLFxyXG4gICAgXCJJbmRleGVkIEdEUFwiOiBbWzE5NzUsMC4xNjMxNDgxMjI2NzkxMzYyOF0sWzE5NzYsMC4xNzc4Mjk3MzQ1NjE5NTg0N10sWzE5NzcsMC4xOTI1MTEzNDY0NDQ3ODA2M10sWzE5NzgsMC4yMDcxOTI5NTgzMjc2MDI4Ml0sWzE5NzksMC4yMjE4NzQ1NzAyMTA0MjQ5OF0sWzE5ODAsMC4yMzY1NTYxODIwOTMyNDcxNF0sWzE5ODEsMC4yNDc0NTU2NDU3MTU4NTc1MV0sWzE5ODIsMC4yNjkxMTcwNDAyOTcwNzA1Nl0sWzE5ODMsMC4zMDE4MTU0MzExNjQ5MDE2N10sWzE5ODQsMC4zMzU3NTE2MTYwMDg4MDIxXSxbMTk4NSwwLjM2ODA3MTc5MjA1MDYxMl0sWzE5ODYsMC40MDAzMjMyMDE3NjA0MTgxXSxbMTk4NywwLjQyNDYzMjEwMDEyMzc3OTRdLFsxOTg4LDAuNDU5MjU1OTQ4Mjg3NzE4M10sWzE5ODksMC40ODMwNDkwOTkxNjEwNTA3N10sWzE5OTAsMC41MDMxOTc2MzQ0MzgxNzkxXSxbMTk5MSwwLjUzMDYwMTAxNzc0MTcxMzZdLFsxOTkyLDAuNTYxMDMwMTE5NjUzNDE3Nl0sWzE5OTMsMC41OTU0NDc2Njg4MjEzNDVdLFsxOTk0LDAuNjI0NTAxNDQ0MDkyOTcyXSxbMTk5NSwwLjY0MDA3NzAxODI5MTg0NDNdLFsxOTk2LDAuNjUxODAxNjc3ODk4NTAwOV0sWzE5OTcsMC42NTM3MjcxMzUxOTQ2MDg3XSxbMTk5OCwwLjY3ODg2MTIyOTU0MjAxNjJdLFsxOTk5LDAuNzE1MjM4NjE5MTcyMDUzM10sWzIwMDAsMC43MzcxNDA2OTU5MTUyNzk5XV1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIlVuaXRlZCBTdGF0ZXNcIixcclxuICAgIFwicmVnaW9uXCI6IFwiTkFcIixcclxuICAgIFwiY29kZVwiOiBcIlVTQVwiLFxyXG4gICAgXCJQb3B1bGF0aW9uXCI6IFtbMTk3NSwyMTIxMjQ1NDFdLFsxOTc2LDIxNDEyNDM0NV0sWzE5NzcsMjE2MTIzMTExXSxbMTk3OCwyMTgxMzMwNzBdLFsxOTc5LDIyMDE2NTAxNl0sWzE5ODAsMjIyMjI2MTk2XSxbMTk4MSwyMjQzMjM0NDFdLFsxOTgyLDIyNjQ2NTY2OF0sWzE5ODMsMjI4NjYxNjE2XSxbMTk4NCwyMzA5MTcxOTddLFsxOTg1LDIzMzIzOTAzN10sWzE5ODYsMjM1NjI2NjY3XSxbMTk4NywyMzgwNjk2NDNdLFsxOTg4LDI0MDU1MjMxMl0sWzE5ODksMjQzMDYzNDc4XSxbMTk5MCwyNDU1OTgyNThdLFsxOTkxLDI0ODE2MDM3Ml0sWzE5OTIsMjUwNzU3MzU2XSxbMTk5MywyNTM0MDA2NDVdLFsxOTk0LDI1NjA5NzU0OV0sWzE5OTUsMjU4ODQ5OTg0XSxbMTk5NiwyNjE2NTIwODZdLFsxOTk3LDI2NDQ5Mzg5OF0sWzE5OTgsMjY3MzYxNjMyXSxbMTk5OSwyNzAyNDQ4MzFdLFsyMDAwLDI3MzEzODI3OF1dLFxyXG4gICAgXCJBcmFibGUgQXJlYVwiOiBbWzE5NzUsMTg5OTAwXSxbMTk3NiwxODkzMDBdLFsxOTc3LDE4ODgwMF0sWzE5NzgsMTg4MjE4XSxbMTk3OSwxODgyMThdLFsxOTgwLDE4ODIxOF0sWzE5ODEsMTg4MjkzXSxbMTk4MiwxOTA2MjRdLFsxOTgzLDE5MDYyNF0sWzE5ODQsMTkwNjI0XSxbMTk4NSwxOTA2MjRdLFsxOTg2LDE4OTc5OV0sWzE5ODcsMTg5Nzk5XSxbMTk4OCwxODk3OTldLFsxOTg5LDE4OTc5OV0sWzE5OTAsMTg5Nzk5XSxbMTk5MSwxODc3NzZdLFsxOTkyLDE4Nzc3Nl0sWzE5OTMsMTg3Nzc2XSxbMTk5NCwxODc3NzZdLFsxOTk1LDE4Nzc3Nl0sWzE5OTYsMTg2MTgwXSxbMTk5NywxODQ5NDhdLFsxOTk4LDE4NDEzOV0sWzE5OTksMTg0MTM5XSxbMjAwMCwxODEzMDZdXSxcclxuICAgIFwiRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwxNzIxMzE3XSxbMTk3NiwxODYxMjE2XSxbMTk3NywxOTc5NzM5XSxbMTk3OCwxOTgxNDEwXSxbMTk3OSwyMDA5MzY1XSxbMTk4MCwyMTMyNDYzXSxbMTk4MSwyMjI4NjQzXSxbMTk4MiwyMzA1NDA4XSxbMTk4MywyMzQ4MDg1XSxbMTk4NCwyMzgxMzc4XSxbMTk4NSwyMzkyMTkzXSxbMTk4NiwyMzMzMTIyXSxbMTk4NywyNDAyOTEwXSxbMTk4OCwyNTE4MTgxXSxbMTk4OSwyNjA5ODE1XSxbMTk5MCwyNjM1ODMyXSxbMTk5MSwyNzY1NzM2XSxbMTk5MiwyOTEwOTAwXSxbMTk5MywzMTIxNjA1XSxbMTk5NCwzMTgxMjI3XSxbMTk5NSwzMjc2Mjc0XSxbMTk5NiwzMjk5NTI5XSxbMTk5NywzNDE3NjU4XSxbMTk5OCwzNDk2NzgzXSxbMTk5OSwzNTk1NzU5XSxbMjAwMCwzNjg4Nzk1XV0sXHJcbiAgICBcIkdEUCBQZXIgQ2FwaXRhXCI6IFtbMTk3NSw0MzQ2XSxbMTk3Niw1MTQyXSxbMTk3Nyw1OTM4XSxbMTk3OCw2NzM0XSxbMTk3OSw3NTMwXSxbMTk4MCw4MzI2XSxbMTk4MSw5MTQxXSxbMTk4MiwxMDIzNl0sWzE5ODMsMTEzNTJdLFsxOTg0LDEyMjAwXSxbMTk4NSwxMzUwNF0sWzE5ODYsMTM3NjZdLFsxOTg3LDE1MDIzXSxbMTk4OCwxNjQzM10sWzE5ODksMTc1MzNdLFsxOTkwLDE4NTMzXSxbMTk5MSwxOTM5NF0sWzE5OTIsMjA1MDZdLFsxOTkzLDIyMDcwXSxbMTk5NCwyMzE1NV0sWzE5OTUsMjM2NDBdLFsxOTk2LDI0NzYwXSxbMTk5NywyNTc5MV0sWzE5OTgsMjcwNzldLFsxOTk5LDI3NzgwXSxbMjAwMCwyODk5MF1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKFdvbWVuKVwiOiBbWzE5NzUsNzMuOTZdLFsxOTc2LDc0LjMyXSxbMTk3Nyw3NC42OF0sWzE5NzgsNzUuMDRdLFsxOTc5LDc1LjRdLFsxOTgwLDc1Ljc2XSxbMTk4MSw3Ni4xMl0sWzE5ODIsNzYuNDhdLFsxOTgzLDc2Ljg0XSxbMTk4NCw3Ny4yXSxbMTk4NSw3Ny4zNF0sWzE5ODYsNzcuNDhdLFsxOTg3LDc3LjYyXSxbMTk4OCw3Ny43Nl0sWzE5ODksNzcuOV0sWzE5OTAsNzhdLFsxOTkxLDc4LjFdLFsxOTkyLDc4LjJdLFsxOTkzLDc4LjNdLFsxOTk0LDc4LjRdLFsxOTk1LDc4LjVdLFsxOTk2LDc4LjZdLFsxOTk3LDc4LjddLFsxOTk4LDc4LjhdLFsxOTk5LDc4LjldLFsyMDAwLDc5XV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiOiBbWzE5NzUsNjYuNDRdLFsxOTc2LDY2Ljc4XSxbMTk3Nyw2Ny4xMV0sWzE5NzgsNjcuNDZdLFsxOTc5LDY3LjhdLFsxOTgwLDY4LjE0XSxbMTk4MSw2OC40OF0sWzE5ODIsNjguODJdLFsxOTgzLDY5LjE2XSxbMTk4NCw2OS41XSxbMTk4NSw2OS43Nl0sWzE5ODYsNzAuMDJdLFsxOTg3LDcwLjI4XSxbMTk4OCw3MC41M10sWzE5ODksNzAuOF0sWzE5OTAsNzAuOTRdLFsxOTkxLDcxLjA4XSxbMTk5Miw3MS4yMl0sWzE5OTMsNzEuMzZdLFsxOTk0LDcxLjVdLFsxOTk1LDcxLjY0XSxbMTk5Niw3MS43OF0sWzE5OTcsNzEuOTJdLFsxOTk4LDcyLjA2XSxbMTk5OSw3Mi4yXSxbMjAwMCw3Mi4zNF1dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3lcIjogW1sxOTc1LDcwLjA2XSxbMTk3Niw3MC40Ml0sWzE5NzcsNzAuNzhdLFsxOTc4LDcxLjE0XSxbMTk3OSw3MS41XSxbMTk4MCw3MS44Nl0sWzE5ODEsNzIuMjJdLFsxOTgyLDcyLjU4XSxbMTk4Myw3Mi45NF0sWzE5ODQsNzMuM10sWzE5ODUsNzMuNDZdLFsxOTg2LDczLjYxXSxbMTk4Nyw3My43OF0sWzE5ODgsNzMuOTRdLFsxOTg5LDc0LjFdLFsxOTkwLDc0LjIyXSxbMTk5MSw3NC4zNF0sWzE5OTIsNzQuNDZdLFsxOTkzLDc0LjU4XSxbMTk5NCw3NC43XSxbMTk5NSw3NC44Ml0sWzE5OTYsNzQuOTRdLFsxOTk3LDc1LjA2XSxbMTk5OCw3NS4xN10sWzE5OTksNzUuM10sWzIwMDAsNzUuNDJdXSxcclxuICAgIFwiSW5mYW50IE1vcnRhbGl0eVwiOiBbWzE5NzUsMjAuNzZdLFsxOTc2LDIwLjFdLFsxOTc3LDE5LjQyXSxbMTk3OCwxOC43OF0sWzE5NzksMTguMV0sWzE5ODAsMTcuNDJdLFsxOTgxLDE2Ljc4XSxbMTk4MiwxNi4xXSxbMTk4MywxNS40Ml0sWzE5ODQsMTQuNzhdLFsxOTg1LDE0LjFdLFsxOTg2LDEzLjM0XSxbMTk4NywxMi41OF0sWzE5ODgsMTEuODJdLFsxOTg5LDExLjA2XSxbMTk5MCwxMC4zXSxbMTk5MSwxMF0sWzE5OTIsOS43XSxbMTk5Myw5LjRdLFsxOTk0LDkuMV0sWzE5OTUsOC44XSxbMTk5Niw4LjZdLFsxOTk3LDguNF0sWzE5OTgsOC4yXSxbMTk5OSw4XSxbMjAwMCw3LjhdXSxcclxuICAgIFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiOiBbWzE5NzUsMF0sWzE5NzYsMF0sWzE5NzcsMF0sWzE5NzgsMF0sWzE5NzksMF0sWzE5ODAsMF0sWzE5ODEsMF0sWzE5ODIsMF0sWzE5ODMsMF0sWzE5ODQsMF0sWzE5ODUsMC45XSxbMTk4NiwyLjRdLFsxOTg3LDUuMl0sWzE5ODgsOC4xXSxbMTk4OSwxMC42XSxbMTk5MCwxMi45XSxbMTk5MSwxNS42XSxbMTk5MiwxOC40XSxbMTk5MywyMF0sWzE5OTQsMjEuOF0sWzE5OTUsMjMuNF0sWzE5OTYsMjUuM10sWzE5OTcsMjcuMl0sWzE5OTgsMjkuN10sWzE5OTksMzIuNF0sWzIwMDAsMzUuOV1dLFxyXG4gICAgXCJJbmRleGVkIFBvcHVsYXRpb25cIjogW1sxOTc1LDAuMTczMDY2ODYzMDg1NzkwOF0sWzE5NzYsMC4xNzQ2OTg0NTA4NDc1NTk1Nl0sWzE5NzcsMC4xNzYzMjkxOTE3MzIyODZdLFsxOTc4LDAuMTc3OTY5MDY0NjkyODY0NjRdLFsxOTc5LDAuMTc5NjI2ODc2MjcxNDg2ODVdLFsxOTgwLDAuMTgxMzA4NTM5MTA1ODQ1ODhdLFsxOTgxLDAuMTgzMDE5NjI2NDMwMTE5MDRdLFsxOTgyLDAuMTg0NzY3NDEzMzkxMzA2NTNdLFsxOTgzLDAuMTg2NTU5MDI5OTEwODY1NzZdLFsxOTg0LDAuMTg4Mzk5Mjk5NDM0OTE4Ml0sWzE5ODUsMC4xOTAyOTM2Mjc5NDM1MDQ2M10sWzE5ODYsMC4xOTIyNDE2MzI3OTE3OTU3NF0sWzE5ODcsMC4xOTQyMzQ3OTI5OTM0NDI5XSxbMTk4OCwwLjE5NjI2MDMzNzY3NTI4MzFdLFsxOTg5LDAuMTk4MzA5MTMyMzEzODQyNTZdLFsxOTkwLDAuMjAwMzc3MTkyOTk3MTc3NjZdLFsxOTkxLDAuMjAyNDY3NTU0Nzc1OTYwMThdLFsxOTkyLDAuMjA0NTg2MzY2MDc1NDIyMl0sWzE5OTMsMC4yMDY3NDI5NTY0MTI4ODQyNl0sWzE5OTQsMC4yMDg5NDMyODk4MjYwOTEzN10sWzE5OTUsMC4yMTExODg5Mjk1MjkzMTQyOF0sWzE5OTYsMC4yMTM0NzUwOTEyMzgzNzU2Nl0sWzE5OTcsMC4yMTU3OTM2NTEyOTc0ODUyNl0sWzE5OTgsMC4yMTgxMzMzNjA0MzgxODUxNV0sWzE5OTksMC4yMjA0ODU2ODcwNjc3NjY4XSxbMjAwMCwwLjIyMjg0NjM3NDc3MjQyNTE0XV0sXHJcbiAgICBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCI6IFtbMTk3NSwwLjQ2NjYzMzk1NDk5MDcyMTldLFsxOTc2LDAuNTA0NTU5MzQ3OTcxMzU2NV0sWzE5NzcsMC41MzY2ODk4OTQ2Njc0OTk4XSxbMTk3OCwwLjUzNzE0Mjg4ODEyNDcxMjhdLFsxOTc5LDAuNTQ0NzIxMjQzNjU4MTU5M10sWzE5ODAsMC41NzgwOTIwMzI3NjQwODY5XSxbMTk4MSwwLjYwNDE2NTU4Nzk0OTQ1MjNdLFsxOTgyLDAuNjI0OTc1OTA2NzY2MzAxOF0sWzE5ODMsMC42MzY1NDUyNjc0OTI1MDFdLFsxOTg0LDAuNjQ1NTcwNzA4MDQ5NjQ3N10sWzE5ODUsMC42NDg1MDI1NTk3NzkwMDY0XSxbMTk4NiwwLjYzMjQ4ODkyOTMxMTYwNDVdLFsxOTg3LDAuNjUxNDA3ODQ0NTY3MTI4M10sWzE5ODgsMC42ODI2NTY4MDI1NjAxODU3XSxbMTk4OSwwLjcwNzQ5Nzk3Njk4MTY0MzFdLFsxOTkwLDAuNzE0NTUwOTU3Njk3NTY3OV0sWzE5OTEsMC43NDk3NjY3OTM3NjMyNzVdLFsxOTkyLDAuNzg5MTE5NDgyMTA3MzAwN10sWzE5OTMsMC44NDYyMzk3NjEyMjI4Mzg0XSxbMTk5NCwwLjg2MjQwMjc2Mjk2MTg4ODddLFsxOTk1LDAuODg4MTY5MTcxNzc1NjA3XSxbMTk5NiwwLjg5NDQ3MzM5ODQ5NDYzMDRdLFsxOTk3LDAuOTI2NDk3MTM1MjQzMzUxOV0sWzE5OTgsMC45NDc5NDcyMjkzNzk3ODM5XSxbMTk5OSwwLjk3NDc3ODc1NTY2NDExMjVdLFsyMDAwLDFdXSxcclxuICAgIFwiSW5kZXhlZCBHRFBcIjogW1sxOTc1LDAuMTQ5NDI5MjM5NDQ0MzY4MDNdLFsxOTc2LDAuMTc2Nzk4MjM5NTgxOTAwN10sWzE5NzcsMC4yMDQxNjcyMzk3MTk0MzMzN10sWzE5NzgsMC4yMzE1MzYyMzk4NTY5NjYwM10sWzE5NzksMC4yNTg5MDUyMzk5OTQ0OTg3XSxbMTk4MCwwLjI4NjI3NDI0MDEzMjAzMTM0XSxbMTk4MSwwLjMxNDI5NjUyMDQyMzYwMDZdLFsxOTgyLDAuMzUxOTQ2MDg3MTk1NzA4OTddLFsxOTgzLDAuMzkwMzE3NzAwNDUzODU3OF0sWzE5ODQsMC40MTk0NzQ2MjUyMjM0OTA2XSxbMTk4NSwwLjQ2NDMxMDI3MzY5MDAwMTRdLFsxOTg2LDAuNDczMzE4NjYzMTgyNTA1ODddLFsxOTg3LDAuNTE2NTM4MzAyODQ2OTI2MV0sWzE5ODgsMC41NjUwMTg1NjY5MDk2NDFdLFsxOTg5LDAuNjAyODQwMDQ5NTExNzU5MV0sWzE5OTAsMC42MzcyMjMyMTU1MTM2ODQ1XSxbMTk5MSwwLjY2NjgyNzEyMTQ0MTM0MjRdLFsxOTkyLDAuNzA1MDYxMjAyMDM1NDgzNF0sWzE5OTMsMC43NTg4MzY0NzM2NjI0OTQ4XSxbMTk5NCwwLjc5NjE0MjIwODc3NDU4NF0sWzE5OTUsMC44MTI4MTgwNDQyODU1MTc4XSxbMTk5NiwwLjg1MTMyNzE5MDIwNzY3NDNdLFsxOTk3LDAuODg2Nzc2MjM0MzU1NjU5NF0sWzE5OTgsMC45MzEwNjE3NTIxNjYxMzk1XSxbMTk5OSwwLjk1NTE2NDM1MTUzMzQ4OTJdLFsyMDAwLDAuOTk2NzY3OTgyMzk1ODE5XV1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcIlNvdXRoIEFmcmljYVwiLFxyXG4gICAgXCJyZWdpb25cIjogXCJBRlwiLFxyXG4gICAgXCJjb2RlXCI6IFwiWkFGXCIsXHJcbiAgICBcIlBvcHVsYXRpb25cIjogW1sxOTc1LDIzMTA1Njc5XSxbMTk3NiwyMzczNTE5OV0sWzE5NzcsMjQzODMxMTddLFsxOTc4LDI1MDM5NDgxXSxbMTk3OSwyNTY5NzQ2OF0sWzE5ODAsMjYzNTI1MjhdLFsxOTgxLDI3MDA3NDMwXSxbMTk4MiwyNzY3MTM0MV0sWzE5ODMsMjgzNTc0ODFdLFsxOTg0LDI5MDc0MjkyXSxbMTk4NSwyOTgyOTE2M10sWzE5ODYsMzA2MTY3MjNdLFsxOTg3LDMxNDE3NTk0XSxbMTk4OCwzMjIwNDczNF0sWzE5ODksMzI5NjA3NzBdLFsxOTkwLDMzNjcyMTMyXSxbMTk5MSwzNDM0OTUwNF0sWzE5OTIsMzUwMjg3NzNdLFsxOTkzLDM1NzYwMjg2XSxbMTk5NCwzNjU3NzQyNF0sWzE5OTUsMzc0OTI1NjRdLFsxOTk2LDM4NDg2MTEyXSxbMTk5NywzOTUyMDAyM10sWzE5OTgsNDA1Mzk4NThdLFsxOTk5LDQxNTA0NTI5XSxbMjAwMCw0MjQwMTE0MV1dLFxyXG4gICAgXCJBcmFibGUgQXJlYVwiOiBbWzE5NzUsMTMyNDhdLFsxOTc2LDEzMjg0XSxbMTk3NywxMzMyMF0sWzE5NzgsMTMzNTZdLFsxOTc5LDEzMzkyXSxbMTk4MCwxMzQzMF0sWzE5ODEsMTMzODRdLFsxOTgyLDEzMzQ0XSxbMTk4MywxMzI5NF0sWzE5ODQsMTMyNTRdLFsxOTg1LDEzMjE0XSxbMTk4NiwxMzE2OV0sWzE5ODcsMTMxNjldLFsxOTg4LDEzMTY5XSxbMTk4OSwxMzE2OV0sWzE5OTAsMTMzMDBdLFsxOTkxLDEzNTAwXSxbMTk5MiwxMzcwMF0sWzE5OTMsMTQwMDBdLFsxOTk0LDE0MzAwXSxbMTk5NSwxNDYwMF0sWzE5OTYsMTQ5MDBdLFsxOTk3LDE1MjAwXSxbMTk5OCwxNTUwMF0sWzE5OTksMTU4MjVdLFsyMDAwLDE1ODAwXV0sXHJcbiAgICBcIkVuZXJneSBDb25zdW1wdGlvblwiOiBbWzE5NzUsNTQ4MjNdLFsxOTc2LDU5MzQ2XSxbMTk3Nyw2NDQ5NV0sWzE5NzgsNzAzNDBdLFsxOTc5LDc1MTM5XSxbMTk4MCw4MDg4Nl0sWzE5ODEsNzkyNTNdLFsxOTgyLDg0ODQ2XSxbMTk4Myw5MjUyOV0sWzE5ODQsOTk5MjNdLFsxOTg1LDEwNzAyOV0sWzE5ODYsMTExMDMyXSxbMTk4NywxMjg0NTddLFsxOTg4LDEyMjcxNF0sWzE5ODksMTIyMjUwXSxbMTk5MCwxNDQxNzldLFsxOTkxLDE0ODE3MF0sWzE5OTIsMTU3MDIxXSxbMTk5MywxNjI2MDRdLFsxOTk0LDE2NTQ3M10sWzE5OTUsMTY4MzI1XSxbMTk5NiwxNjgxMDhdLFsxOTk3LDE3NDg1NV0sWzE5OTgsMTgyNzU3XSxbMTk5OSwxODg2ODhdLFsyMDAwLDE5ODcwMV1dLFxyXG4gICAgXCJHRFAgUGVyIENhcGl0YVwiOiBbWzE5NzUsMzA4Ml0sWzE5NzYsMzMxOV0sWzE5NzcsMzU1Nl0sWzE5NzgsMzc5M10sWzE5NzksNDAzMF0sWzE5ODAsNDI2N10sWzE5ODEsNDQ0N10sWzE5ODIsNDc5Nl0sWzE5ODMsNTI2N10sWzE5ODQsNTk4MV0sWzE5ODUsNjc0MV0sWzE5ODYsNjkzNF0sWzE5ODcsNjg4NV0sWzE5ODgsNzMxN10sWzE5ODksNzI5OF0sWzE5OTAsNzI3NF0sWzE5OTEsNzM3Nl0sWzE5OTIsNzc0N10sWzE5OTMsODA1N10sWzE5OTQsODE5OV0sWzE5OTUsODEzMl0sWzE5OTYsNzkzOV0sWzE5OTcsODAzM10sWzE5OTgsODI2Nl0sWzE5OTksODUyMl0sWzIwMDAsODg4M11dLFxyXG4gICAgXCJMaWZlIEV4cGVjdGFuY3kgKFdvbWVuKVwiOiBbWzE5NzUsNTQuODRdLFsxOTc2LDU1LjI4XSxbMTk3Nyw1NS43Ml0sWzE5NzgsNTYuMTZdLFsxOTc5LDU2LjZdLFsxOTgwLDU3LjA0XSxbMTk4MSw1Ny40OF0sWzE5ODIsNTcuOTJdLFsxOTgzLDU4LjM2XSxbMTk4NCw1OC44XSxbMTk4NSw1OS4zN10sWzE5ODYsNTkuOTZdLFsxOTg3LDYwLjU0XSxbMTk4OCw2MS4xMl0sWzE5ODksNjEuN10sWzE5OTAsNjIuM10sWzE5OTEsNjIuOV0sWzE5OTIsNjMuNV0sWzE5OTMsNjQuMV0sWzE5OTQsNjQuN10sWzE5OTUsNjQuOTJdLFsxOTk2LDY1LjE0XSxbMTk5Nyw2NS4zNl0sWzE5OTgsNjUuNThdLFsxOTk5LDY1LjhdLFsyMDAwLDY2LjAyXV0sXHJcbiAgICBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiOiBbWzE5NzUsNDkuOF0sWzE5NzYsNTAuMV0sWzE5NzcsNTAuNF0sWzE5NzgsNTAuN10sWzE5NzksNTFdLFsxOTgwLDUxLjNdLFsxOTgxLDUxLjZdLFsxOTgyLDUxLjldLFsxOTgzLDUyLjJdLFsxOTg0LDUyLjVdLFsxOTg1LDUyLjk4XSxbMTk4Niw1My40Nl0sWzE5ODcsNTMuOTRdLFsxOTg4LDU0LjQyXSxbMTk4OSw1NC45XSxbMTk5MCw1NS40XSxbMTk5MSw1NS45XSxbMTk5Miw1Ni40XSxbMTk5Myw1Ni45XSxbMTk5NCw1Ny40XSxbMTk5NSw1Ny41OF0sWzE5OTYsNTcuNzZdLFsxOTk3LDU3Ljk0XSxbMTk5OCw1OC4xMl0sWzE5OTksNTguM10sWzIwMDAsNTguNDhdXSxcclxuICAgIFwiTGlmZSBFeHBlY3RhbmN5XCI6IFtbMTk3NSw1Mi4yNl0sWzE5NzYsNTIuNjJdLFsxOTc3LDUyLjk4XSxbMTk3OCw1My4zNF0sWzE5NzksNTMuN10sWzE5ODAsNTQuMDZdLFsxOTgxLDU0LjQyXSxbMTk4Miw1NC43OF0sWzE5ODMsNTUuMTRdLFsxOTg0LDU1LjVdLFsxOTg1LDU2LjA0XSxbMTk4Niw1Ni41OF0sWzE5ODcsNTcuMTJdLFsxOTg4LDU3LjY2XSxbMTk4OSw1OC4yXSxbMTk5MCw1OC43Ml0sWzE5OTEsNTkuMjRdLFsxOTkyLDU5Ljc2XSxbMTk5Myw2MC4yOF0sWzE5OTQsNjAuOF0sWzE5OTUsNjEuMDFdLFsxOTk2LDYxLjIzXSxbMTk5Nyw2MS40Nl0sWzE5OTgsNjEuNjhdLFsxOTk5LDYxLjldLFsyMDAwLDYyLjEyXV0sXHJcbiAgICBcIkluZmFudCBNb3J0YWxpdHlcIjogW1sxOTc1LDgxLjQzXSxbMTk3Niw4MC4zNV0sWzE5NzcsNzkuMjRdLFsxOTc4LDc4LjJdLFsxOTc5LDc3LjFdLFsxOTgwLDc1Ljk5XSxbMTk4MSw3NC45NV0sWzE5ODIsNzMuODVdLFsxOTgzLDcyLjc0XSxbMTk4NCw3MS43XSxbMTk4NSw3MC42XSxbMTk4Niw2OC42MV0sWzE5ODcsNjYuNjRdLFsxOTg4LDY0LjY2XSxbMTk4OSw2Mi42OF0sWzE5OTAsNjAuN10sWzE5OTEsNTguODJdLFsxOTkyLDU2Ljk0XSxbMTk5Myw1NS4wNl0sWzE5OTQsNTMuMThdLFsxOTk1LDUxLjNdLFsxOTk2LDUwLjc4XSxbMTk5Nyw1MC4yNl0sWzE5OTgsNDkuNzRdLFsxOTk5LDQ5LjIyXSxbMjAwMCw0OC43XV0sXHJcbiAgICBcIk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnNcIjogW1sxOTc1LDBdLFsxOTc2LDBdLFsxOTc3LDBdLFsxOTc4LDBdLFsxOTc5LDBdLFsxOTgwLDBdLFsxOTgxLDBdLFsxOTgyLDBdLFsxOTgzLDBdLFsxOTg0LDBdLFsxOTg1LDBdLFsxOTg2LDBdLFsxOTg3LDBdLFsxOTg4LDBdLFsxOTg5LDBdLFsxOTkwLDBdLFsxOTkxLDBdLFsxOTkyLDBdLFsxOTkzLDBdLFsxOTk0LDAuMzhdLFsxOTk1LDAuOV0sWzE5OTYsMS4yXSxbMTk5NywxLjVdLFsxOTk4LDIuM10sWzE5OTksMi44XSxbMjAwMCwzLjVdXSxcclxuICAgIFwiSW5kZXhlZCBQb3B1bGF0aW9uXCI6IFtbMTk3NSwwLjAxODg1MTMxODk3MTEzNzk1N10sWzE5NzYsMC4wMTkzNjQ5Mjc4Njg3MDQyNTVdLFsxOTc3LDAuMDE5ODkzNTQ3MjEzMTE0ODU3XSxbMTk3OCwwLjAyMDQyOTA1NzQyNzk0ODcwOF0sWzE5NzksMC4wMjA5NjU4OTE4MDYwMTkyM10sWzE5ODAsMC4wMjE1MDAzMzgxMjEzNzAyNl0sWzE5ODEsMC4wMjIwMzQ2NTU1Mjg2NTUxMTZdLFsxOTgyLDAuMDIyNTc2MzIzMTQzMzMzMTg4XSxbMTk4MywwLjAyMzEzNjEyNjgxNzUyMzI2OF0sWzE5ODQsMC4wMjM3MjA5NTQxNTgxNTMyNjRdLFsxOTg1LDAuMDI0MzM2ODMzNjU3MDAxMjI2XSxbMTk4NiwwLjAyNDk3OTM4MzI1NTY5MTJdLFsxOTg3LDAuMDI1NjMyNzkyOTUxMDE5MTAyXSxbMTk4OCwwLjAyNjI3NDk5OTg4MjY5NzczOF0sWzE5ODksMC4wMjY4OTE4Mjk4NzQ1NjUyNV0sWzE5OTAsMC4wMjc0NzIyMTE1MTg2NjAwNDVdLFsxOTkxLDAuMDI4MDI0ODYxNjExMDUxNTE3XSxbMTk5MiwwLjAyODU3OTA1OTQxNjExMDg2NV0sWzE5OTMsMC4wMjkxNzU4ODE3MzM4ODUzODRdLFsxOTk0LDAuMDI5ODQyNTYzMjQ4OTExOTZdLFsxOTk1LDAuMDMwNTg5MjAyMDMxNjY1MjA1XSxbMTk5NiwwLjAzMTM5OTgxMTg1MDE5MjM0XSxbMTk5NywwLjAzMjI0MzM1Mjc4NDM4Mjk0XSxbMTk5OCwwLjAzMzA3NTQwOTQ3ODQ1MDY4XSxbMTk5OSwwLjAzMzg2MjQ1OTMwODIwMDYxNV0sWzIwMDAsMC4wMzQ1OTM5ODE1ODA1MTA4MTZdXSxcclxuICAgIFwiSW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb25cIjogW1sxOTc1LDAuMDE0ODYyMDM0ODkyMTUzMTI5XSxbMTk3NiwwLjAxNjA4ODE4MDU1NzYwNzU2NV0sWzE5NzcsMC4wMTc0ODQwMjkzMzc0OTM2OF0sWzE5NzgsMC4wMTkwNjg1NTc2MTg0MDkyNjVdLFsxOTc5LDAuMDIwMzY5NTI0NDY1MzA2NDIyXSxbMTk4MCwwLjAyMTkyNzQ4NTgwNDk4NTA5Nl0sWzE5ODEsMC4wMjE0ODQ3OTM4MTQ3ODIzMzRdLFsxOTgyLDAuMDIzMDAxMDA3MTAzOTQ1ODddLFsxOTgzLDAuMDI1MDgzODAxMDc4NjcyMDMzXSxbMTk4NCwwLjAyNzA4ODI0OTY4NTg3MzAzXSxbMTk4NSwwLjAyOTAxNDYyNDAxNjc4NTk2OF0sWzE5ODYsMC4wMzAwOTk4MDIyMzg5NDI1MjddLFsxOTg3LDAuMDM0ODIzNTY3MDQ1NjA3MDNdLFsxOTg4LDAuMDMzMjY2NjkwMDcwODc2ODA2XSxbMTk4OSwwLjAzMzE0MDkwMzczNjg1NzE2XSxbMTk5MCwwLjAzOTA4NTY2MzQ3NTQ3MDk5XSxbMTk5MSwwLjA0MDE2NzU4ODYwMjc4MjIxXSxbMTk5MiwwLjA0MjU2NzAxNzE0MjQ1NDM4XSxbMTk5MywwLjA0NDA4MDUxOTUxOTI0NjhdLFsxOTk0LDAuMDQ0ODU4MjgwMjc4NTE5MTRdLFsxOTk1LDAuMDQ1NjMxNDMyNDg2NzYwNThdLFsxOTk2LDAuMDQ1NTcyNjA1Njg4MzA3NDNdLFsxOTk3LDAuMDQ3NDAxNjU4MjY1MDk3NDFdLFsxOTk4LDAuMDQ5NTQzODIxMjIwNzUwOTVdLFsxOTk5LDAuMDUxMTUxNjYzMzQ4MDU4MV0sWzIwMDAsMC4wNTM4NjYwOTk5MDUyNTM2MTZdXSxcclxuICAgIFwiSW5kZXhlZCBHRFBcIjogW1sxOTc1LDAuMTA1OTY4OTE3NjE3OTM0MjZdLFsxOTc2LDAuMTE0MTE3NzI3OTYwMzkwNTldLFsxOTc3LDAuMTIyMjY2NTM4MzAyODQ2OTJdLFsxOTc4LDAuMTMwNDE1MzQ4NjQ1MzAzMjddLFsxOTc5LDAuMTM4NTY0MTU4OTg3NzU5Nl0sWzE5ODAsMC4xNDY3MTI5NjkzMzAyMTU5NF0sWzE5ODEsMC4xNTI5MDE5MzkyMTA1NjI1XSxbMTk4MiwwLjE2NDkwMTY2NDE0NTIzNDVdLFsxOTgzLDAuMTgxMDk2MTM1MzMyMTQxNF0sWzE5ODQsMC4yMDU2NDU3MTU4NTc1MTYxNV0sWzE5ODUsMC4yMzE3NzY5MjIwMTg5Nzk1XSxbMTk4NiwwLjIzODQxMjg3MzA1NzM1MTEyXSxbMTk4NywwLjIzNjcyODA5NzkyMzI1Njc4XSxbMTk4OCwwLjI1MTU4MTYyNTYzNjA4ODU1XSxbMTk4OSwwLjI1MDkyODM0NTQ4MjA1Ml0sWzE5OTAsMC4yNTAxMDMxNDk0OTgwMDU4XSxbMTk5MSwwLjI1MzYxMDIzMjQzMDIwMjJdLFsxOTkyLDAuMjY2MzY2Mzg3MDE2OTE2NV0sWzE5OTMsMC4yNzcwMjUxNjg0Nzc1MTM0XSxbMTk5NCwwLjI4MTkwNzU3ODA0OTc4NjgzXSxbMTk5NSwwLjI3OTYwMzkwNTkyNzY1NzhdLFsxOTk2LDAuMjcyOTY3OTU0ODg5Mjg2Ml0sWzE5OTcsMC4yNzYxOTk5NzI0OTM0NjcxN10sWzE5OTgsMC4yODQyMTEyNTAxNzE5MTU4NF0sWzE5OTksMC4yOTMwMTMzNDA2Njg0MDg3M10sWzIwMDAsMC4zMDU0MjU2NjM1OTUxMDM4XV1cclxuICB9XHJcbl07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWR5RGF0YTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9kYXRhL3N0dWR5RGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZDMgPSByZXF1aXJlKFwiZDNcIik7XHJcbnZhciBmbHViYmVyID0gcmVxdWlyZShcImZsdWJiZXJcIik7XHJcbnZhciBnbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcclxuXHJcbmQzLmNoYXJ0ID0gZnVuY3Rpb24gKCkgeyAgXHJcblxyXG4gIC8qKlxyXG5cclxuICBHTE9CQUwgQ0hBUlQgVkFSSUFCTEVTXHJcblxyXG4gICoqL1xyXG5cclxuICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgIHBhcmFtcy55ZWFyTWluID0gZ2xvYmFscy5wYXJhbV95ZWFyTWluO1xyXG4gICAgICBwYXJhbXMueWVhck1heCA9IGdsb2JhbHMucGFyYW1feWVhck1heDsgICAgICBcclxuICAgICAgcGFyYW1zLnggPSBnbG9iYWxzLnBhcmFtX3g7XHJcbiAgICAgIHBhcmFtcy55ID0gZ2xvYmFscy5wYXJhbV95O1xyXG4gICAgICBwYXJhbXMucmFkaXVzID0gZ2xvYmFscy5wYXJhbV9yO1xyXG4gICAgICBwYXJhbXMuY29sb3IgPSAncmVnaW9uJztcclxuICAgICAgcGFyYW1zLmZhY2V0ID0gJ2ZhY2V0JztcclxuICAgICAgcGFyYW1zLmtleSA9ICdjb2RlJztcclxuICBcclxuICB2YXIgc2NhbGVfcG9wID0gZDMuc2NhbGVMaW5lYXIoKSwgXHJcbiAgICAgIHNjYWxlX3ggPSBkMy5zY2FsZUxpbmVhcigpLCBcclxuICAgICAgc2NhbGVfeSA9IGQzLnNjYWxlTGluZWFyKCksIFxyXG4gICAgICBzY2FsZV9zY3JvbGwgPSBkMy5zY2FsZUxpbmVhcigpLFxyXG4gICAgICBzY2FsZV9yZWcgPSBkMy5zY2FsZU9yZGluYWwoKSxcclxuICAgICAgc2NhbGVfdG1wID0gZDMuc2NhbGVMaW5lYXIoKSxcclxuICAgICAgYW5pbWF0aW9uID0gJ29mZicsXHJcbiAgICAgIGxvb3BfY291bnQgPSAwLFxyXG4gICAgICBhbmltYXRpb25fZHVyYXRpb24gPSAocGFyYW1zLnllYXJNYXggLSBwYXJhbXMueWVhck1pbikgKiA1MDAsXHJcbiAgICAgIGN1cnJlbnRfeWVhciA9IHBhcmFtcy55ZWFyTWluLFxyXG4gICAgICBzY3JvbGxfeWVhciA9IGN1cnJlbnRfeWVhcixcclxuICAgICAgZmFjZXRzID0gZ2xvYmFscy5mYWNldHMsIC8vc2hvdyBmYWNldHM/XHJcbiAgICAgIG51bV9mYWNldHMgPSAwLFxyXG4gICAgICBudW1fZmFjZXRfY29scyA9IDAsXHJcbiAgICAgIGZhY2V0X2RpbSA9IDAsXHJcbiAgICAgIGxpbmVzID0gZ2xvYmFscy5saW5lcywgLy9zaG93IGxpbmVzP1xyXG4gICAgICB0aGlzX2NoYXJ0LFxyXG4gICAgICB0aG91c2FuZF9mb3JtYXQgPSBkMy5mb3JtYXQoXCIuMnNcIiksXHJcbiAgICAgIGNhcHRpb25fdGV4dCA9IFwiXCI7XHJcblxyXG4gIGZ1bmN0aW9uIGNoYXJ0IChzZWxlY3Rpb24pIHtcclxuICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChkYXRhKXtcclxuXHJcbiAgICAgIHRoaXNfY2hhcnQgPSBkMy5zZWxlY3QodGhpcyk7XHJcbiAgICAgIHRoaXNfY2hhcnQuaW50ZXJydXB0KCk7XHJcblxyXG4gICAgICAvKipcclxuXHJcbiAgICAgIERBVEEgV1JBTkdMSU5HXHJcblxyXG4gICAgICAqKi9cclxuXHJcbiAgICAgIC8vc29ydCBkYXRhIGFscGhhYmV0aWNhbGx5IGJ5IGNvdW50cnkgY29kZVxyXG4gICAgICBkYXRhLnNvcnQoZnVuY3Rpb24oeCwgeSl7XHJcbiAgICAgICAgcmV0dXJuIGQzLmFzY2VuZGluZyh4W3BhcmFtcy5rZXldLCB5W3BhcmFtcy5rZXldKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvL2Fzc2lnbiBmYWNldCBpbmRleFxyXG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCxpKXtcclxuICAgICAgICBkW3BhcmFtcy5mYWNldF0gPSBpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIG51bV9mYWNldHMgPSBkMy5tYXgoZGF0YSwgZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgcmV0dXJuIGRbcGFyYW1zLmZhY2V0XSArIDE7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbnVtX2ZhY2V0X2NvbHMgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KG51bV9mYWNldHMpKTtcclxuXHJcbiAgICAgIGZhY2V0X2RpbSA9IGNoYXJ0X2RpbSAvIG51bV9mYWNldF9jb2xzOyAgICAgIFxyXG5cclxuICAgICAgdmFyIGNvdW50cmllcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpe1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBpZDogZC5jb2RlLFxyXG4gICAgICAgICAgcmVnaW9uOiBkLnJlZ2lvbixcclxuICAgICAgICAgIGZhY2V0OiBkLmZhY2V0LFxyXG4gICAgICAgICAgcGFyYW1feDogZFtwYXJhbXMueF0ubWFwKGZ1bmN0aW9uKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRbMV07XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIHBhcmFtX3k6IGRbcGFyYW1zLnldLm1hcChmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkWzFdO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvdW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uKGQpe1xyXG4gICAgICAgIGQudmFsdWVzID0gW107XHJcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGQucGFyYW1feC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICBpZiAoZC5wYXJhbV94W2ldICE9IG51bGwgJiYgZC5wYXJhbV95W2ldICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZC52YWx1ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgJ3BhcmFtX3gnOiBkLnBhcmFtX3hbaV0sXHJcbiAgICAgICAgICAgICAgJ3BhcmFtX3knOiBkLnBhcmFtX3lbaV1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTsgXHJcbiAgICAgIFxyXG4gICAgICAvKipcclxuXHJcbiAgICAgIFNDQUxFUzogaW5pdGlhbGl6ZSBkb21haW5zIGFuZCByYW5nZXNcclxuXHJcbiAgICAgICoqL1xyXG5cclxuICAgICAgLy9yZWdpb24gc2NhbGUgKGNvbG9yKVxyXG5cclxuICAgICAgc2NhbGVfcmVnLnJhbmdlKFtcclxuICAgICAgICBcIiNmYWQxMzlcIixcclxuICAgICAgICBcIiM1NGIyZmNcIixcclxuICAgICAgICBcIiNmNjdhZmVcIixcclxuICAgICAgICBcIiM4YmJhMzJcIixcclxuICAgICAgICBcIiNjMjlhZWJcIl1cclxuXHJcbiAgICAgICk7XHJcblxyXG4gICAgICAvL3NpemUgc2NhbGVcclxuXHJcbiAgICAgIGlmIChmYWNldHMgPT0gJ29uJykge1xyXG4gICAgICAgIHNjYWxlX3BvcC5yYW5nZShbMS43NSw3XSk7IC8vIHIgc2NhbGUgcmFuZ2UgICAgICBcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBzY2FsZV9wb3AucmFuZ2UoWzcsMjhdKTsgLy8gciBzY2FsZSByYW5nZSAgICAgIFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB2YXIgcG9wX21heCA9IGQzLm1heChkYXRhLCBmdW5jdGlvbihkKXtcclxuICAgICAgICByZXR1cm4gZDMubWF4KGRbcGFyYW1zLnJhZGl1c10sIGZ1bmN0aW9uIChkZCkge1xyXG4gICAgICAgICAgcmV0dXJuIE1hdGguc3FydChkZFsxXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgdmFyIHBvcF9idWZmZXIgPSBwb3BfbWF4ICogMC4wNTtcclxuICAgICAgXHJcbiAgICAgIHNjYWxlX3BvcC5kb21haW4oWzAscG9wX21heCArIHBvcF9idWZmZXJdKTtcclxuICAgICAgc2NhbGVfcG9wLm5pY2UoKTtcclxuXHJcbiAgICAgIC8veSBzY2FsZVxyXG5cclxuICAgICAgaWYgKGZhY2V0cyA9PSAnb24nKSB7XHJcbiAgICAgICAgc2NhbGVfeS5yYW5nZShbZmFjZXRfZGltLCAwXSk7IC8vIHkgc2NhbGUgcmFuZ2VcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBzY2FsZV95LnJhbmdlKFtjaGFydF9kaW0sIDBdKTsgLy8geSBzY2FsZSByYW5nZVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB2YXIgeV9taW4gPSBkMy5taW4oZGF0YSwgZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgcmV0dXJuIGQzLm1pbihkW3BhcmFtcy55XSwgZnVuY3Rpb24gKGRkKXtcclxuICAgICAgICAgIHJldHVybiBkZFsxXTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICB2YXIgeV9tYXggPSBkMy5tYXgoZGF0YSwgZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgcmV0dXJuIGQzLm1heChkW3BhcmFtcy55XSwgZnVuY3Rpb24gKGRkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGRbMV07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgdmFyIHlfYnVmZmVyID0gKHlfbWF4IC0geV9taW4pICogMC4wNTtcclxuICAgICAgXHJcbiAgICAgIHNjYWxlX3kuZG9tYWluKFtkMy5tYXgoWzAseV9taW4gLSB5X2J1ZmZlcl0pLHlfbWF4ICsgeV9idWZmZXJdKTtcclxuICAgICAgc2NhbGVfeS5uaWNlKCk7XHJcblxyXG4gICAgICBcclxuICAgICAgLy94IHNjYWxlXHJcbiAgICAgIFxyXG4gICAgICBpZiAoZmFjZXRzID09ICdvbicpIHtcclxuICAgICAgICBzY2FsZV94LnJhbmdlKFswLCBmYWNldF9kaW1dKTsgLy8geCBzY2FsZSByYW5nZVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHNjYWxlX3gucmFuZ2UoWzAsIGNoYXJ0X2RpbV0pOyAvLyB4IHNjYWxlIHJhbmdlXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHZhciB4X21pbiA9IGQzLm1pbihkYXRhLCBmdW5jdGlvbihkKXtcclxuICAgICAgICByZXR1cm4gZDMubWluKGRbcGFyYW1zLnhdLCBmdW5jdGlvbiAoZGQpe1xyXG4gICAgICAgICAgcmV0dXJuIGRkWzFdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIHZhciB4X21heCA9IGQzLm1heChkYXRhLCBmdW5jdGlvbihkKXtcclxuICAgICAgICByZXR1cm4gZDMubWF4KGRbcGFyYW1zLnhdLCBmdW5jdGlvbiAoZGQpIHtcclxuICAgICAgICAgIHJldHVybiBkZFsxXTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICB2YXIgeF9idWZmZXIgPSAoeF9tYXggLSB4X21pbikgKiAwLjA1O1xyXG4gICAgICBcclxuICAgICAgc2NhbGVfeC5kb21haW4oW2QzLm1heChbMCx4X21pbiAtIHhfYnVmZmVyXSkseF9tYXggKyB4X2J1ZmZlcl0pO1xyXG4gICAgICBzY2FsZV94Lm5pY2UoKTtcclxuXHJcbiAgICAgIC8vIHRpbWUgc2NhbGVcclxuXHJcbiAgICAgIHNjYWxlX3RtcC5yYW5nZShbLTUsNV0pO1xyXG4gICAgICBzY2FsZV90bXAuZG9tYWluKFstMC41LDAuNV0pO1xyXG4gICAgICBzY2FsZV90bXAuY2xhbXAodHJ1ZSk7XHJcbiAgICAgIHNjYWxlX3RtcC5uaWNlKCk7XHJcbiAgICAgIHNjYWxlX3RtcC50aWNrRm9ybWF0KGQzLmZvcm1hdChcImRcIikpO1xyXG5cclxuICAgICAgLy9TQ1JPTEwgUklORyBTQ0FMRVxyXG5cclxuICAgICAgc2NhbGVfc2Nyb2xsLnJhbmdlKFstKDQvMTIpLCg0LzEyKV0pO1xyXG4gICAgICBzY2FsZV9zY3JvbGwuZG9tYWluKFstMTAsMTBdKTtcclxuICAgICAgc2NhbGVfc2Nyb2xsLmNsYW1wKHRydWUpO1xyXG5cclxuICAgICAgLyoqIFxyXG4gICAgICAgXHJcbiAgICAgIERFRlM6IGFkZCBhcyByZXF1aXJlZCBcclxuICAgICAgXHJcbiAgICAgICoqL1xyXG4gICAgIFxyXG4gICAgICAvKiogXHJcbiAgICAgIFxyXG4gICAgICAgIEdVSURFUyAvIEFYRVNcclxuXHJcbiAgICAgICoqL1xyXG5cclxuICAgICAgeWVhcl9pbmRpY2F0b3IgPSB0aGlzX2NoYXJ0LnNlbGVjdEFsbCgnLnllYXJfaW5kaWNhdG9yJylcclxuICAgICAgLmRhdGEoW251bGxdKTtcclxuXHJcbiAgICAgIHllYXJfaW5kaWNhdG9yLmVudGVyKClcclxuICAgICAgLmFwcGVuZChcInRleHRcIilcclxuICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInllYXJfaW5kaWNhdG9yXCIpO1xyXG5cclxuICAgICAgeWVhcl9pbmRpY2F0b3IudHJhbnNpdGlvbigpLmR1cmF0aW9uKDI1MClcclxuICAgICAgLmF0dHIoJ2lkJywgZmFjZXRzID09ICdvbicgPyBcImZhY2V0ZWRfeWVhcl9pbmRpY2F0b3JcIiA6IChjdXJyZW50X3llYXIgPT0gcGFyYW1zLnllYXJNaW4pID8gXCJjZW50cmFsX3llYXJfaW5kaWNhdG9yX21pblwiIDogXCJjZW50cmFsX3llYXJfaW5kaWNhdG9yXCIpXHJcbiAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIGZhY2V0cyA9PSAnb24nID8gXCJtaWRkbGVcIiA6IFwibWlkZGxlXCIpXHJcbiAgICAgIC5hdHRyKCdhbGlnbm1lbnQtYmFzZWxpbmUnLGZhY2V0cyA9PSAnb24nID8gICdiYXNlbGluZScgOiAnbWlkZGxlJylcclxuICAgICAgLmF0dHIoJ2R5JyxmYWNldHMgPT0gJ29uJyA/ICAnLTAuMmVtJyA6ICcwZW0nKVxyXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmYWNldHMgPT0gJ29uJyA/ICd0cmFuc2xhdGUoJyArIChjaGFydF9kaW0gLyAyKSArICcsJyArICgwIC0gMC41ICogaW5uZXJfcGFkZGluZykgKyAnKScgOiAndHJhbnNsYXRlKCcgKyAoY2hhcnRfZGltIC8gMikgKyAnLCcgKyAoY2hhcnRfZGltIC8gMikgKyAnKSc7XHJcbiAgICAgIH0pXHJcbiAgICAgIC50ZXh0KGZhY2V0cyA9PSAnb24nID8gKHBhcmFtcy55ZWFyTWluICsgJyDigJUgJyArIHBhcmFtcy55ZWFyTWF4KSA6IE1hdGgucm91bmQoY3VycmVudF95ZWFyKSk7XHJcblxyXG4gICAgICB5ZWFyX2luZGljYXRvci5leGl0KClcclxuICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgICAgdmFyIHhfaW5kaWNhdG9yID0gdGhpc19jaGFydC5zZWxlY3RBbGwoJy54X2luZGljYXRvcicpXHJcbiAgICAgIC5kYXRhKFtudWxsXSk7XHJcblxyXG4gICAgICB2YXIgeF9pbmRpY2F0b3JfZW50ZXIgPSB4X2luZGljYXRvci5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoXCJnXCIpXHJcbiAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4X2luZGljYXRvclwiKTtcclxuXHJcbiAgICAgIHhfaW5kaWNhdG9yX2VudGVyLmFwcGVuZCgnbGluZScpO1xyXG5cclxuICAgICAgeF9pbmRpY2F0b3Iuc2VsZWN0KCdsaW5lJykuYXR0cigneDEnLCAwKVxyXG4gICAgICAuYXR0cigneDInLCBjaGFydF9kaW0pXHJcbiAgICAgIC5hdHRyKCd5MScsIGNoYXJ0X2RpbSlcclxuICAgICAgLmF0dHIoJ3kyJywgY2hhcnRfZGltKVxyXG4gICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZmFjZXRzID09ICdvbicgPyAnbm9uZScgOiAnI2NjYycpO1xyXG5cclxuICAgICAgeF9pbmRpY2F0b3JfZW50ZXIuYXBwZW5kKFwidGV4dFwiKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdpbmRpY2F0b3JfdGV4dCcpO1xyXG5cclxuICAgICAgeF9pbmRpY2F0b3Iuc2VsZWN0KCd0ZXh0JykuYXR0cigndGV4dC1hbmNob3InLCBcIm1pZGRsZVwiKVxyXG4gICAgICAuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywnaGFuZ2luZycpXHJcbiAgICAgIC5hdHRyKCdkeScsJzAuMmVtJylcclxuICAgICAgLnRleHQoJ+KGkCAnICsgcGFyYW1zLnggKyAnIOKGkicpXHJcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIChjaGFydF9kaW0gLyAyKSArICcsJyArIChjaGFydF9kaW0gKyBpbm5lcl9wYWRkaW5nICogMC41KSArICcpJztcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB4X2luZGljYXRvci5leGl0KClcclxuICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgICAgdmFyIHlfaW5kaWNhdG9yID0gdGhpc19jaGFydC5zZWxlY3RBbGwoJy55X2luZGljYXRvcicpXHJcbiAgICAgIC5kYXRhKFtudWxsXSk7XHJcblxyXG4gICAgICB2YXIgeV9pbmRpY2F0b3JfZW50ZXIgPSB5X2luZGljYXRvci5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoXCJnXCIpXHJcbiAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5X2luZGljYXRvclwiKTtcclxuXHJcbiAgICAgIHlfaW5kaWNhdG9yX2VudGVyLmFwcGVuZCgnbGluZScpO1xyXG5cclxuICAgICAgeV9pbmRpY2F0b3Iuc2VsZWN0KCdsaW5lJylcclxuICAgICAgLmF0dHIoJ3gxJywgMClcclxuICAgICAgLmF0dHIoJ3gyJywgMClcclxuICAgICAgLmF0dHIoJ3kxJywgMClcclxuICAgICAgLmF0dHIoJ3kyJywgY2hhcnRfZGltKVxyXG4gICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZmFjZXRzID09ICdvbicgPyAnbm9uZScgOiAnI2NjYycpO1xyXG5cclxuICAgICAgeV9pbmRpY2F0b3JfZW50ZXIuYXBwZW5kKFwidGV4dFwiKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdpbmRpY2F0b3JfdGV4dCcpO1xyXG5cclxuICAgICAgeV9pbmRpY2F0b3Iuc2VsZWN0KCd0ZXh0JylcclxuICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgXCJtaWRkbGVcIilcclxuICAgICAgLmF0dHIoJ2FsaWdubWVudC1iYXNlbGluZScsJ2Jhc2VsaW5lJylcclxuICAgICAgLmF0dHIoJ2R5JywnLTAuNmVtJylcclxuICAgICAgLnRleHQoJ+KGkCAnICsgcGFyYW1zLnkgKyAnIOKGkicpXHJcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArICgwIC0gaW5uZXJfcGFkZGluZyAqIDAuNSkgKyAnLCcgKyAoY2hhcnRfZGltIC8gMikgKyAnKXJvdGF0ZSgtOTApJztcclxuICAgICAgfSk7XHJcblxyXG4gICAgICB5X2luZGljYXRvci5leGl0KClcclxuICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgICAgXHJcbiAgICAgIC8qKlxyXG4gICAgICAgIFxyXG4gICAgICAgIEhFTFBFUiBGVU5DVElPTlNcclxuICAgICAgICBcclxuICAgICAgKiovXHJcblxyXG4gICAgICB2YXIgYmlzZWN0ID0gZDMuYmlzZWN0b3IoZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgcmV0dXJuIGRbMF07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVEYXRhKHllYXIpIHtcclxuICAgICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKGQpe1xyXG4gICAgICAgICAgdmFyIHRtcCA9IHt9O1xyXG4gICAgICAgICAgICB0bXBbcGFyYW1zLmtleV0gPSBkW3BhcmFtcy5rZXldO1xyXG4gICAgICAgICAgICB0bXBbcGFyYW1zLmZhY2V0XSA9IGRbcGFyYW1zLmZhY2V0XTtcclxuICAgICAgICAgICAgdG1wW3BhcmFtcy5jb2xvcl0gPSBkW3BhcmFtcy5jb2xvcl07XHJcbiAgICAgICAgICAgIHRtcFtwYXJhbXMueF0gPSAoaW50ZXJwb2xhdGVWYWx1ZXMoZFtwYXJhbXMueF0sIHllYXIpICE9IG51bGwpID8gaW50ZXJwb2xhdGVWYWx1ZXMoZFtwYXJhbXMueF0sIHllYXIpIDogeF9taW47XHJcbiAgICAgICAgICAgIHRtcFtwYXJhbXMucmFkaXVzXSA9IChpbnRlcnBvbGF0ZVZhbHVlcyhkW3BhcmFtcy5yYWRpdXNdLCB5ZWFyKSAhPSBudWxsKSA/IGludGVycG9sYXRlVmFsdWVzKGRbcGFyYW1zLnJhZGl1c10sIHllYXIpIDogMDtcclxuICAgICAgICAgICAgdG1wW3BhcmFtcy55XSA9IChpbnRlcnBvbGF0ZVZhbHVlcyhkW3BhcmFtcy55XSwgeWVhcikgIT0gbnVsbCkgPyBpbnRlcnBvbGF0ZVZhbHVlcyhkW3BhcmFtcy55XSwgeWVhcikgOiB5X21pbjtcclxuICAgICAgICAgICAgcmV0dXJuIHRtcDtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRmluZHMgKGFuZCBwb3NzaWJseSBpbnRlcnBvbGF0ZXMpIHRoZSB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCB5ZWFyLlxyXG4gICAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVZhbHVlcyh2YWx1ZXMsIHllYXIpIHtcclxuICAgICAgICB2YXIgaSA9IGJpc2VjdC5sZWZ0KHZhbHVlcywgeWVhciwgMCwgdmFsdWVzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgYSA9IHZhbHVlc1tpXTtcclxuICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB2YWx1ZXNbaSAtIDFdLFxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSAoeWVhciAtIGFbMF0pIC8gKGJbMF0gLSBhWzBdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFbMV0gKiAoMSAtIHQpICsgYlsxXSAqIHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhWzFdO1xyXG4gICAgICB9ICAgICAgXHJcblxyXG4gICAgICBmdW5jdGlvbiBvcmRlcihhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGJbcGFyYW1zLnJhZGl1c10gLSBhW3BhcmFtcy5yYWRpdXNdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQb3NpdGlvbnMgdGhlIG1hcmtzIGJhc2VkIG9uIGRhdGEuXHJcbiAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uKG1hcmspIHsgICAgICAgIFxyXG5cclxuICAgICAgICB2YXIgbWFya190cmFuc2l0aW9uO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChhbmltYXRpb24gPT0gJ29mZicpe1xyXG4gICAgICAgICAgbWFya190cmFuc2l0aW9uID0gbWFyay50cmFuc2l0aW9uKClcclxuICAgICAgICAgIC5kZWxheShmdW5jdGlvbihkLGkpe1xyXG4gICAgICAgICAgICByZXR1cm4gaSAqIDEwO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5kdXJhdGlvbig1MDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhbmltYXRpb24gPT0gJ29uJyl7XHJcbiAgICAgICAgICBtYXJrX3RyYW5zaXRpb24gPSBtYXJrLnRyYW5zaXRpb24oKSAgICAgICAgIFxyXG4gICAgICAgICAgLmRlbGF5KGZ1bmN0aW9uKGQsaSl7XHJcbiAgICAgICAgICAgIHJldHVybiBpICogKDUwIC8gZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5kdXJhdGlvbig1MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgbWFya190cmFuc2l0aW9uID0gbWFyaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1hcmtfdHJhbnNpdGlvbi5zZWxlY3QoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoXCJjeFwiLCBmdW5jdGlvbiAoZCkgeyAgICAgICAgIFxyXG4gICAgICAgICAgcmV0dXJuIChkW3BhcmFtcy54XSAhPSBudWxsKSA/IHNjYWxlX3goZFtwYXJhbXMueF0pIDogLSBmYWNldF9kaW07XHJcbiAgICAgICAgfSkgICAgICAgIFxyXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBmdW5jdGlvbihkKXtcclxuICAgICAgICAgIGlmIChmYWNldHMgPT0gJ29uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyM5OTknO1xyXG4gICAgICAgICAgfSAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJyNmZmYnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbihkKXsgICAgICAgICAgICBcclxuICAgICAgICAgIGlmIChmYWNldHMgPT0gJ29uJykge1xyXG4gICAgICAgICAgICBkMy5zZWxlY3QoJyNsaW5lXycrIGRbcGFyYW1zLmtleV0pLnNlbGVjdCgncGF0aCcpLnN0eWxlKCdvcGFjaXR5JywxKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjdGV4dF9tYXJrXycgKyBkW3BhcmFtcy5rZXldKS5hdHRyKFwiY2xhc3NcIiwgJ3RleHRfbWFyaycpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIDE7ICAgICAgICAgICAgICBcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI2xpbmVfJysgZFtwYXJhbXMua2V5XSkuc2VsZWN0KCdwYXRoJykuc3R5bGUoJ29wYWNpdHknLDAuNSk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI3RleHRfbWFya18nICsgZFtwYXJhbXMua2V5XSkuYXR0cihcImNsYXNzXCIsICd0ZXh0X21hcmsnKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybiAwLjU7XHJcbiAgICAgICAgICB9ICAgICAgICAgICAgXHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcImN5XCIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZFtwYXJhbXMueV0gIT0gbnVsbCA/IHNjYWxlX3koZFtwYXJhbXMueV0pIDogLSBmYWNldF9kaW07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcInJcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiAoZFtwYXJhbXMueV0gIT0gbnVsbCAmJiBkW3BhcmFtcy54XSAhPSBudWxsKSA/IHNjYWxlX3BvcChNYXRoLnNxcnQoZFtwYXJhbXMucmFkaXVzXSkpIDogMDtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgaWYgKGZhY2V0cyA9PSAnb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoZmFjZXRfZGltICogKGRbcGFyYW1zLmZhY2V0XSAlIG51bV9mYWNldF9jb2xzKSkgKyAnLCcgKyAoZmFjZXRfZGltICogTWF0aC5mbG9vcihkW3BhcmFtcy5mYWNldF0gLyBudW1fZmFjZXRfY29scykpICsgJyknO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsMCknO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pOyBcclxuICAgICAgICBcclxuICAgICAgICBtYXJrX3RyYW5zaXRpb24uc2VsZWN0KCd0ZXh0JylcclxuICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24gKGQpIHsgICAgICAgICBcclxuICAgICAgICAgIHJldHVybiBmYWNldHMgPT0gJ29uJyA/IDAgOiAoKGRbcGFyYW1zLnhdICE9IG51bGwpID8gc2NhbGVfeChkW3BhcmFtcy54XSkgOiAtIGZhY2V0X2RpbSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cihcImR5XCIsIGZhY2V0cyA9PSBcIm9uXCIgPyAnLTFlbScgOiAnMGVtJykgICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGZhY2V0cyA9PSAnb24nID8gMCA6IChkW3BhcmFtcy55XSAhPSBudWxsID8gc2NhbGVfeShkW3BhcmFtcy55XSkgOiAtIGZhY2V0X2RpbSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIGlmIChmYWNldHMgPT0gJ29uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKGZhY2V0X2RpbSAqIChkW3BhcmFtcy5mYWNldF0gJSBudW1fZmFjZXRfY29scykgKyBmYWNldF9kaW0gKiAwLjUpICsgJywnICsgKGZhY2V0X2RpbSAqIE1hdGguZmxvb3IoZFtwYXJhbXMuZmFjZXRdIC8gbnVtX2ZhY2V0X2NvbHMpICsgZmFjZXRfZGltKSArICcpJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLDApJztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTsgICAgICAgIFxyXG4gICAgICB9ICAgICAgXHJcblxyXG4gICAgICBmdW5jdGlvbiB0d2VlblllYXIoKSB7XHJcbiAgICAgICAgdmFyIHllYXIgPSBkMy5pbnRlcnBvbGF0ZU51bWJlcihwYXJhbXMueWVhck1pbixwYXJhbXMueWVhck1heCk7XHJcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgICAgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgIGlmIChjb3VudGVyICE9IE1hdGguZmxvb3IoKHQgKiBhbmltYXRpb25fZHVyYXRpb24pIC8gMTAwKSkge1xyXG4gICAgICAgICAgICBkaXNwbGF5WWVhcih5ZWFyKHQpKTtcclxuICAgICAgICAgIH0gXHJcbiAgICAgICAgICBjb3VudGVyID0gTWF0aC5mbG9vcigodCAqIGFuaW1hdGlvbl9kdXJhdGlvbikgLyAxMDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHR3ZWVuQ3VycmVudFllYXIoKSB7XHJcbiAgICAgICAgdmFyIHllYXIgPSBkMy5pbnRlcnBvbGF0ZU51bWJlcihjdXJyZW50X3llYXIscGFyYW1zLnllYXJNYXgpO1xyXG4gICAgICAgIHZhciBjb3VudGVyID0gMDtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICBpZiAoY291bnRlciAhPSBNYXRoLmZsb29yKCh0ICogYW5pbWF0aW9uX2R1cmF0aW9uKSAvIDEwMCkpIHtcclxuICAgICAgICAgICAgZGlzcGxheVllYXIoeWVhcih0KSk7XHJcbiAgICAgICAgICB9IFxyXG4gICAgICAgICAgY291bnRlciA9IE1hdGguZmxvb3IoKHQgKiBhbmltYXRpb25fZHVyYXRpb24pIC8gMTAwKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBkaXNwbGF5WWVhcih5ZWFyKSB7ICAgICAgICBcclxuICAgICAgIFxyXG4gICAgICAgIHZhciBwcm9ncmVzcyA9ICAoKHllYXIgKyAxKSAtIHBhcmFtcy55ZWFyTWluKSAvICgocGFyYW1zLnllYXJNYXggKyAxKSAtIHBhcmFtcy55ZWFyTWluKTtcclxuICAgICAgICBpZiAoZ2xvYmFscy5vdXRlcl9wcm9ncmVzc19jaXJjbGUgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBkMy5zZWxlY3QoJyNvdXRlcl9wcm9ncmVzc192YWx1ZScpLmF0dHIoJ2QnLCBnbG9iYWxzLm91dGVyX3Byb2dyZXNzX2NpcmNsZS5lbmRBbmdsZSgoTWF0aC5QSSAqIDIpICogKGxvb3BfY291bnQgKyBwcm9ncmVzcykpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY3VycmVudF95ZWFyID0geWVhcjtcclxuICAgICAgICBjaXJjbGVfbWFya3MuZGF0YShpbnRlcnBvbGF0ZURhdGEoeWVhciksIGZ1bmN0aW9uKGQpe1xyXG4gICAgICAgICAgcmV0dXJuIGRbcGFyYW1zLmtleV07XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2FsbChwb3NpdGlvbilcclxuICAgICAgICAuc29ydChvcmRlcik7ICAgICAgICAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgZDMuc2VsZWN0KCcueWVhcl9pbmRpY2F0b3InKS50ZXh0KGZhY2V0cyA9PSAnb24nID8gKHBhcmFtcy55ZWFyTWluICsgJyDigJUgJyArIHBhcmFtcy55ZWFyTWF4KSA6IE1hdGgucm91bmQoY3VycmVudF95ZWFyKSk7XHJcbiAgICAgICAgXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBsaW5lID0gZDMubGluZSgpXHJcbiAgICAgIC5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKVxyXG4gICAgICAueChmdW5jdGlvbihkKSB7IFxyXG4gICAgICAgIHJldHVybiBzY2FsZV94KGQucGFyYW1feCk7IFxyXG4gICAgICB9KVxyXG4gICAgICAueShmdW5jdGlvbihkKSB7IFxyXG4gICAgICAgIHJldHVybiBzY2FsZV95KGQucGFyYW1feSk7IFxyXG4gICAgICB9KTsgICAgICBcclxuXHJcbiAgICAgIGZ1bmN0aW9uIHJlcGVhdCgpIHtcclxuICAgICAgICBpZiAoYW5pbWF0aW9uID09ICdvbicpIHsgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICBhbmltYXRpb25fZHVyYXRpb24gPSAocGFyYW1zLnllYXJNYXggLSBwYXJhbXMueWVhck1pbikgKiA1MDA7XHJcbiAgICAgICAgICB0aGlzX2NoYXJ0LnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgLmR1cmF0aW9uKGFuaW1hdGlvbl9kdXJhdGlvbilcclxuICAgICAgICAgIC50d2VlbigneWVhcicsdHdlZW5ZZWFyKVxyXG4gICAgICAgICAgLmVhc2UoZDMuZWFzZUxpbmVhcilcclxuICAgICAgICAgIC5vbignZW5kJyxmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBpZiAoZ2xvYmFscy50cmlhbF9pbmRleCA+IC0xICYmIGdsb2JhbHMubnVtX3NlbGVjdGVkID09IGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLm51bV9yZXNwb25zZXMpe1xyXG4gICAgICAgICAgICAgIGQzLnNlbGVjdCgnI3Byb2dyZXNzX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgICAgICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsbnVsbClcclxuICAgICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLG51bGwpXHJcbiAgICAgICAgICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvZG9uZS5zdmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBkMy5zZWxlY3QoJyNzdWJtaXRfYnRuJykuYXR0cignY2xhc3MnLCdtZW51X2J0bl9lbmFibGVkJylcclxuICAgICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvb3BfY291bnQrKztcclxuICAgICAgICAgICAgaWYgKCFpbnRyb2R1Y3Rpb25fY29tcGxldGUgJiYgZ2xvYmFscy5udW1fc2VsZWN0ZWQgPT0gMykgeyAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KCcjcHJvZ3Jlc3NfaW5kaWNhdG9yJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgICAgICAgICAgZDMuc2VsZWN0KCcjZG9uZV9idG4nKS5hdHRyKCdjbGFzcycsJ2ltZ19idG5fZW5hYmxlZCcpXHJcbiAgICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JyxudWxsKVxyXG4gICAgICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsbnVsbClcclxuICAgICAgICAgICAgICAuYXR0cignc3JjJywgJ2Fzc2V0cy9kb25lLnN2ZycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgIGlmIChpbnRyb2R1Y3Rpb25fY29tcGxldGUgJiYgbG9vcF9jb3VudCA+IDAgJiYgZ2xvYmFscy5udW1fc2VsZWN0ZWQgPT0gZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0ubnVtX3Jlc3BvbnNlcyl7XHJcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoJyNkb25lX2J0bicpLmF0dHIoJ2NsYXNzJywnaW1nX2J0bl9lbmFibGVkJylcclxuICAgICAgICAgICAgICAgIC5hdHRyKCdzcmMnLCAnYXNzZXRzL2RvbmUuc3ZnJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcGVhdCgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgZGlzcGxheVllYXIoY3VycmVudF95ZWFyKTtcclxuICAgICAgICB9ICAgICAgICAgXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8qKlxyXG5cclxuICAgICAgREFUQSBFTEVNRU5UIEVOVEVSXHJcblxyXG4gICAgICAqKi9cclxuXHJcbiAgICAgIC8vIENJUkNMRVNcclxuXHJcbiAgICAgIHZhciBjaXJjbGVfbWFya3MgPSB0aGlzX2NoYXJ0LnNlbGVjdEFsbChcIi5tYXJrXCIpXHJcbiAgICAgIC5kYXRhKGludGVycG9sYXRlRGF0YShwYXJhbXMueWVhck1pbiksIGZ1bmN0aW9uKGQpIHtcclxuICAgICAgICByZXR1cm4gZFtwYXJhbXMua2V5XTtcclxuICAgICAgfSk7ICAgICAgXHJcblxyXG4gICAgICAvLyBGQUNFVFNcclxuXHJcbiAgICAgIHZhciBmYWNldF9ib3VuZHMgPSB0aGlzX2NoYXJ0LnNlbGVjdEFsbChcIi5mYWNldFwiKVxyXG4gICAgICAuZGF0YShkYXRhLCBmdW5jdGlvbihkKSB7XHJcbiAgICAgICAgcmV0dXJuIGRbcGFyYW1zLmtleV07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIGZhY2V0X2JvdW5kX2VudGVyID0gZmFjZXRfYm91bmRzLmVudGVyKClcclxuICAgICAgLmFwcGVuZChcImdcIilcclxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwiZmFjZXRcIilcclxuICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBcImZhY2V0X1wiICsgZFtwYXJhbXMua2V5XTtcclxuICAgICAgfSk7XHJcbiAgXHJcbiAgICAgIGZhY2V0X2JvdW5kX2VudGVyLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgIC5hdHRyKFwiY2xhc3NcIixcImZhY2V0X3JlY3RcIikgICAgICBcclxuICAgICAgLmF0dHIoXCJpZFwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBcImZhY2V0X1wiICsgZFtwYXJhbXMua2V5XTtcclxuICAgICAgfSlcclxuICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmYWNldHMgPT0gJ29uJyA/ICd0cmFuc3BhcmVudCcgOiAnbm9uZScpXHJcbiAgICAgIC5hdHRyKCd3aWR0aCcsIGZhY2V0X2RpbSlcclxuICAgICAgLmF0dHIoJ2hlaWdodCcsIGZhY2V0X2RpbSlcclxuICAgICAgLnN0eWxlKFwic3Ryb2tlLWRhc2hhcnJheVwiLCAnMC4xZW0nKVxyXG4gICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZmFjZXRzID09ICdvbicgPyAnIzY2NicgOiAnbm9uZScpXHJcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoZmFjZXRfZGltICogKGRbcGFyYW1zLmZhY2V0XSAlIG51bV9mYWNldF9jb2xzKSkgKyAnLCcgKyAoZmFjZXRfZGltICogTWF0aC5mbG9vcihkW3BhcmFtcy5mYWNldF0gLyBudW1fZmFjZXRfY29scykpICsgJyknO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cigncngnLCA1KTsgICAgICAgICAgICAgXHJcblxyXG4gICAgICAvLyBMSU5FU1xyXG4gICAgICAgICAgICBcclxuICAgICAgdmFyIGxpbmVfbWFya3MgPSB0aGlzX2NoYXJ0LnNlbGVjdEFsbChcIi5saW5lXCIpXHJcbiAgICAgIC5kYXRhKGNvdW50cmllcywgZnVuY3Rpb24oZCkge1xyXG4gICAgICAgIHJldHVybiBkLmlkO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciBsaW5lX21hcmtfZW50ZXIgPSBsaW5lX21hcmtzLmVudGVyKClcclxuICAgICAgLmFwcGVuZChcImdcIilcclxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwibGluZVwiKVxyXG4gICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIFwibGluZV9cIiArIGQuaWQ7XHJcbiAgICAgIH0pO1xyXG4gIFxyXG4gICAgICBsaW5lX21hcmtfZW50ZXIuYXBwZW5kKCdwYXRoJylcclxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwicGF0aF9saW5lXCIpICAgICAgXHJcbiAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBsaW5lcyA9PSAnb24nID8gc2NhbGVfcmVnKGRbcGFyYW1zLmNvbG9yXSkgOiAndHJhbnNwYXJlbnQnO1xyXG4gICAgICB9KVxyXG4gICAgICAuc3R5bGUoJ2ZpbGwnLCdub25lJylcclxuICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHsgXHJcbiAgICAgICAgdmFyIHRtcCA9IGQudmFsdWVzOyAgICAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGxpbmUodG1wKTsgXHJcbiAgICAgIH0pXHJcbiAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKXtcclxuICAgICAgICBpZiAoZmFjZXRzID09ICdvbicpIHtcclxuICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiAwLjU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBpZiAoZmFjZXRzID09ICdvbicpIHtcclxuICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoZmFjZXRfZGltICogKGRbcGFyYW1zLmZhY2V0XSAlIG51bV9mYWNldF9jb2xzKSkgKyAnLCcgKyAoZmFjZXRfZGltICogTWF0aC5mbG9vcihkW3BhcmFtcy5mYWNldF0gLyBudW1fZmFjZXRfY29scykpICsgJyknO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsMCknO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7ICAgXHJcbiAgICAgIFxyXG4gICAgICAvL0NJUkNMRSBFTlRFUlxyXG4gICAgICBcclxuICAgICAgdmFyIGNpcmNsZV9tYXJrX2VudGVyID0gY2lyY2xlX21hcmtzLmVudGVyKClcclxuICAgICAgLmFwcGVuZChcImdcIilcclxuICAgICAgLmF0dHIoXCJjbGFzc1wiLFwibWFya1wiKVxyXG4gICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIFwibWFya19cIiArIGRbcGFyYW1zLmtleV07XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY2lyY2xlX21hcmtfZW50ZXIuYXBwZW5kKCdjaXJjbGUnKVxyXG4gICAgICAuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiY2lyY2xlX21hcmtfXCIgKyBkW3BhcmFtcy5rZXldO1xyXG4gICAgICB9KSAgIFxyXG4gICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKGQpe1xyXG4gICAgICAgIGlmIChmYWNldHMgPT0gJ29uJykge1xyXG4gICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIDAuNTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBmdW5jdGlvbihkKXtcclxuICAgICAgICBpZiAoZmFjZXRzID09ICdvbicpIHtcclxuICAgICAgICAgIHJldHVybiAnIzk5OSc7XHJcbiAgICAgICAgfSAgICAgICAgICAgICBcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiAnI2ZmZic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uIChkKSB7ICAgICAgIFxyXG4gICAgICAgIHJldHVybiBzY2FsZV9yZWcoZFtwYXJhbXMuY29sb3JdKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjaXJjbGVfbWFya19lbnRlci5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAuYXR0cihcImNsYXNzXCIsICd0ZXh0X21hcmsnKVxyXG4gICAgICAuYXR0cigndGV4dC1hbmNob3InLCBcIm1pZGRsZVwiKVxyXG4gICAgICAuYXR0cignYWxpZ25tZW50LWJhc2VsaW5lJywnbWlkZGxlJylcclxuICAgICAgLmF0dHIoJ2lkJywgZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgcmV0dXJuIFwidGV4dF9tYXJrX1wiICsgZFtwYXJhbXMua2V5XTtcclxuICAgICAgfSlcclxuICAgICAgLnN0eWxlKCdkaXNwbGF5JyxudWxsKVxyXG4gICAgICAudGV4dChmdW5jdGlvbihkKXtcclxuICAgICAgICByZXR1cm4gZFtwYXJhbXMua2V5XTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjaXJjbGVfbWFya3MuY2FsbChwb3NpdGlvbilcclxuICAgICAgLnNvcnQob3JkZXIpOyAgXHJcbiAgICAgIFxyXG4gICAgICAvKipcclxuXHJcbiAgICAgIERBVEEgRUxFTUVOVCBVUERBVEUgXHJcblxyXG4gICAgICAqKi9cclxuXHJcbiAgICAgIHJlcGVhdCgpOyAgICBcclxuICAgICAgXHJcbiAgICAgIHZhciBmYWNldF9ib3VuZF91cGRhdGUgPSBmYWNldF9ib3VuZHMudHJhbnNpdGlvbigpXHJcbiAgICAgIC5kZWxheShmdW5jdGlvbihkLGkpe1xyXG4gICAgICAgIHJldHVybiBpICogMTA7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5kdXJhdGlvbig1MDApO1xyXG4gICAgICBcclxuICAgICAgZmFjZXRfYm91bmRfdXBkYXRlLnNlbGVjdEFsbCgncmVjdC5mYWNldF9yZWN0JykgICAgICBcclxuICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIGZ1bmN0aW9uKGQpe1xyXG4gICAgICAgIHJldHVybiBmYWNldHMgPT0gJ29uJyA/ICcjOTk5JyA6ICdub25lJzsgICAgICAgICAgICAgIFxyXG4gICAgICB9KVxyXG4gICAgICAuc3R5bGUoXCJmaWxsXCIsIGZhY2V0cyA9PSAnb24nID8gJ3RyYW5zcGFyZW50JyA6ICdub25lJylcclxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIChmYWNldF9kaW0gKiAoZFtwYXJhbXMuZmFjZXRdICUgbnVtX2ZhY2V0X2NvbHMpKSArICcsJyArIChmYWNldF9kaW0gKiBNYXRoLmZsb29yKGRbcGFyYW1zLmZhY2V0XSAvIG51bV9mYWNldF9jb2xzKSkgKyAnKSc7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIGxpbmVfbWFya191cGRhdGUgPSBsaW5lX21hcmtzLnRyYW5zaXRpb24oKVxyXG4gICAgICAuZGVsYXkoZnVuY3Rpb24oZCxpKXtcclxuICAgICAgICByZXR1cm4gaSAqIDEwO1xyXG4gICAgICB9KVxyXG4gICAgICAuZHVyYXRpb24oNTAwKTtcclxuXHJcbiAgICAgIGxpbmVfbWFya191cGRhdGUuc2VsZWN0QWxsKCdwYXRoLnBhdGhfbGluZScpXHJcbiAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBsaW5lcyA9PSAnb24nID8gc2NhbGVfcmVnKGRbcGFyYW1zLmNvbG9yXSkgOiAndHJhbnNwYXJlbnQnO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cihcImRcIiwgZnVuY3Rpb24oZCkgeyBcclxuICAgICAgICB2YXIgdG1wID0gZC52YWx1ZXM7ICAgXHJcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyAgIGlmICh0bXBbaV0ucGFyYW1feCA9PSBudWxsIHx8IHRtcFtpXS5wYXJhbV95ID09IG51bGwpe1xyXG4gICAgICAgIC8vICAgICB0bXAuc3BsaWNlKGksMSk7XHJcbiAgICAgICAgLy8gICB9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRtcCk7XHJcbiAgICAgICAgcmV0dXJuIGxpbmUodG1wKTsgXHJcbiAgICAgIH0pXHJcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmIChmYWNldHMgPT0gJ29uJykge1xyXG4gICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIChmYWNldF9kaW0gKiAoZFtwYXJhbXMuZmFjZXRdICUgbnVtX2ZhY2V0X2NvbHMpKSArICcsJyArIChmYWNldF9kaW0gKiBNYXRoLmZsb29yKGRbcGFyYW1zLmZhY2V0XSAvIG51bV9mYWNldF9jb2xzKSkgKyAnKSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwwKSc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTsgXHJcbiAgICAgIFxyXG4gICAgICAvKipcclxuXHJcbiAgICAgIERBVEEgRUxFTUVOVCBFWElUXHJcblxyXG4gICAgICAqKi9cclxuXHJcbiAgICAgIGNpcmNsZV9tYXJrcy5leGl0KCkgICAgICBcclxuICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgICAgbGluZV9tYXJrcy5leGl0KClcclxuICAgICAgLnJlbW92ZSgpO1xyXG5cclxuICAgICAgZmFjZXRfYm91bmRzLmV4aXQoKVxyXG4gICAgICAucmVtb3ZlKCk7XHJcbiAgICBcclxuICAgIH0pO1xyXG4gIH0gICAgXHJcblxyXG4gIC8qKlxyXG5cclxuICBHRVRURVIgLyBTRVRURVIgRlVOQ1RJT05TXHJcblxyXG4gICoqLyAgXHJcblxyXG4gIC8vZ2V0dGVyIC8gc2V0dGVyIGZvciBzaG93aW5nIGxpbmVzXHJcbiAgY2hhcnQubGluZXMgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBsaW5lcztcclxuICAgIH1cclxuICAgIGxpbmVzID0geDtcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICAvL2dldHRlciAvIHNldHRlciBmb3IgYW5pbWF0aW9uXHJcbiAgY2hhcnQuYW5pbWF0aW9uID0gZnVuY3Rpb24gKHgpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gYW5pbWF0aW9uO1xyXG4gICAgfVxyXG4gICAgYW5pbWF0aW9uID0geDtcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICAvL2dldHRlciAvIHNldHRlciBmb3IgZmFjZXRzXHJcbiAgY2hhcnQuZmFjZXRzID0gZnVuY3Rpb24gKHgpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFjZXRzO1xyXG4gICAgfVxyXG4gICAgZmFjZXRzID0geDtcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICAvL2dldHRlciAvIHNldHRlciBmb3IgY3VycmVudF95ZWFyXHJcbiAgY2hhcnQuY3VycmVudF95ZWFyID0gZnVuY3Rpb24gKHgpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gY3VycmVudF95ZWFyO1xyXG4gICAgfVxyXG4gICAgY3VycmVudF95ZWFyID0geDtcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG4gIFxyXG4gIC8vZ2V0dGVyIC8gc2V0dGVyIGZvciBzY2FsZV9wb3BcclxuICBjaGFydC5zY2FsZV9wb3AgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBzY2FsZV9wb3A7XHJcbiAgICB9XHJcbiAgICBzY2FsZV9wb3AgPSB4O1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIC8vZ2V0dGVyIC8gc2V0dGVyIGZvciBzY2FsZV94XHJcbiAgY2hhcnQuc2NhbGVfeCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHNjYWxlX3g7XHJcbiAgICB9XHJcbiAgICBzY2FsZV94ID0geDtcclxuICAgIHJldHVybiBjaGFydDtcclxuICB9O1xyXG5cclxuICAvL2dldHRlciAvIHNldHRlciBmb3Igc2NhbGVfeVxyXG4gIGNoYXJ0LnNjYWxlX3kgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBzY2FsZV95O1xyXG4gICAgfVxyXG4gICAgc2NhbGVfeSA9IHg7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgLy9nZXR0ZXIgLyBzZXR0ZXIgZm9yIHNjYWxlX3JlZ1xyXG4gIGNoYXJ0LnNjYWxlX3JlZyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHNjYWxlX3JlZztcclxuICAgIH1cclxuICAgIHNjYWxlX3JlZyA9IHg7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgLy9nZXR0ZXIgLyBzZXR0ZXIgZm9yIHNjYWxlX3RtcFxyXG4gIGNoYXJ0LnNjYWxlX3RtcCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHNjYWxlX3RtcDtcclxuICAgIH1cclxuICAgIHNjYWxlX3RtcCA9IHg7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgLy9nZXR0ZXIgLyBzZXR0ZXIgZm9yIHNjYWxlX3Njcm9sbFxyXG4gIGNoYXJ0LnNjYWxlX3Njcm9sbCA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHNjYWxlX3Njcm9sbDtcclxuICAgIH1cclxuICAgIHNjYWxlX3Njcm9sbCA9IHg7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgLy9nZXR0ZXIgLyBzZXR0ZXIgZm9yIHBhcmFtc1xyXG4gIGNoYXJ0LnBhcmFtcyA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH1cclxuICAgIHBhcmFtcyA9IHg7XHJcbiAgICByZXR1cm4gY2hhcnQ7XHJcbiAgfTtcclxuXHJcbiAgLy9nZXR0ZXIgLyBzZXR0ZXIgZm9yIHRoaXNfY2hhcnRcclxuICBjaGFydC50aGlzX2NoYXJ0ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gdGhpc19jaGFydDtcclxuICAgIH1cclxuICAgIHRoaXNfY2hhcnQgPSB4O1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcbiAgXHJcbiAgLy9nZXR0ZXIgLyBzZXR0ZXIgZm9yIGxvb3BfY291bnRcclxuICBjaGFydC5sb29wX2NvdW50ID0gZnVuY3Rpb24gKHgpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gbG9vcF9jb3VudDtcclxuICAgIH1cclxuICAgIGxvb3BfY291bnQgPSB4O1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcblxyXG4gIC8vZ2V0dGVyIC8gc2V0dGVyIGZvciBjYXB0aW9uX3RleHRcclxuICBjaGFydC5jYXB0aW9uX3RleHQgPSBmdW5jdGlvbiAoeCkge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBjYXB0aW9uX3RleHQ7XHJcbiAgICB9XHJcbiAgICBjYXB0aW9uX3RleHQgPSB4O1xyXG4gICAgcmV0dXJuIGNoYXJ0O1xyXG4gIH07XHJcbiBcclxuICByZXR1cm4gY2hhcnQ7XHJcblxyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBkMy5jaGFydDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jaGFydC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZDMgPSByZXF1aXJlKFwiZDNcIik7XHJcbnZhciBuYXRpb25EYXRhID0gcmVxdWlyZShcIi4vZGF0YS9zdHVkeURhdGFcIik7XHJcbnZhciBnbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTsgXHJcblxyXG5mdW5jdGlvbiBjb3VudHJ5U2VsZWN0b3IgKCkge1xyXG5cclxuICB2YXIgY2hlY2tFeGlzdDsgICAgXHJcbiAgZ2xvYmFscy5udW1fc2VsZWN0ZWQgPSAwO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIGdldERpbXMoKSB7XHJcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgc3ZnX2RpbSA9IGQzLm1pbihbaGVpZ2h0LHdpZHRoXSkgLSAyO1xyXG4gICAgaW5uZXJfcGFkZGluZyA9IHN2Z19kaW0gKiAwLjE7XHJcbiAgICBjaGFydF9kaW0gPSBzdmdfZGltICogMC44OyAgIFxyXG4gIH1cclxuICBcclxuICBmdW5jdGlvbiByZWRyYXcoKSB7XHJcbiAgXHJcbiAgICBnZXREaW1zKCk7ICBcclxuXHJcbiAgICBkMy5zZWxlY3QoJyNzZWxlY3Rvcl9kaXYnKS5zZWxlY3RBbGwoXCIuY291bnRyeV9idG5fZW5hYmxlZFwiKVxyXG4gICAgLmRhdGEoYWxsX2RhdGEsIGZ1bmN0aW9uKGQpIHtcclxuICAgICAgcmV0dXJuIGQuY29kZTtcclxuICAgIH0pXHJcbiAgICAuZW50ZXIoKVxyXG4gICAgLmFwcGVuZCgnaW5wdXQnKVxyXG4gICAgLmF0dHIoJ3R5cGUnLCdidXR0b24nKVxyXG4gICAgLmF0dHIoJ2NsYXNzJywgJ2NvdW50cnlfYnRuX2VuYWJsZWQnKVxyXG4gICAgLmF0dHIoJ2lkJyxmdW5jdGlvbihkKXtcclxuICAgICAgcmV0dXJuIGQuY29kZSArICdfYnR0bic7XHJcbiAgICB9KVxyXG4gICAgLmF0dHIoJ3ZhbHVlJyxmdW5jdGlvbihkKXtcclxuICAgICAgcmV0dXJuIGQuY29kZTtcclxuICAgIH0pXHJcbiAgICAuYXR0cigndGl0bGUnLGZ1bmN0aW9uKGQpe1xyXG4gICAgICByZXR1cm4gZC5jb2RlO1xyXG4gICAgfSlcclxuICAgIC5zdHlsZSgnYmFja2dyb3VuZCcsZnVuY3Rpb24oZCl7XHJcbiAgICAgIHZhciBzY2FsZV9yZWcgPSBjaGFydF9pbnN0YW5jZS5zY2FsZV9yZWcoKTtcclxuICAgICAgdmFyIGNvbG9yX3BhcmFtID0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkuY29sb3I7XHJcbiAgICAgIHZhciByZXN1bHQgPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLmV4ZWMoc2NhbGVfcmVnKGRbY29sb3JfcGFyYW1dKSk7XHJcbiAgICAgIHZhciByZ2JfcmVzdWx0ID0gcmVzdWx0ID8ge1xyXG4gICAgICAgIHI6IHBhcnNlSW50KHJlc3VsdFsxXSwgMTYpLFxyXG4gICAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLFxyXG4gICAgICAgIGI6IHBhcnNlSW50KHJlc3VsdFszXSwgMTYpXHJcbiAgICAgIH0gOiBudWxsO1xyXG4gICAgICByZXR1cm4gJ3JnYmEoJyArIHJnYl9yZXN1bHQuciArICcsJyArIHJnYl9yZXN1bHQuZyArICcsJyArIHJnYl9yZXN1bHQuYiArICcsMC41KSc7XHJcbiAgICB9KVxyXG4gICAgLnN0eWxlKCdoZWlnaHQnLCBmdW5jdGlvbigpe1xyXG4gICAgICBpZiAoaGVpZ2h0IDwgd2lkdGgpIHtcclxuICAgICAgICByZXR1cm4gKChoZWlnaHQgLyA4KSAtIDQpICsgJ3B4JztcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB2YXIgbnVtX3Jvd3MgPSBhbGxfZGF0YS5sZW5ndGggLyA4O1xyXG4gICAgICAgIHZhciBtZW51YmFyX2hlaWdodCA9ICh3aWR0aCAvIDcpO1xyXG4gICAgICAgIHZhciByZW1haW5pbmdfaGVpZ2h0ID0gaGVpZ2h0IC0gc3ZnX2RpbSAtIG1lbnViYXJfaGVpZ2h0IC0gMTA7IFxyXG4gICAgICAgIHJldHVybiAocmVtYWluaW5nX2hlaWdodCAvIG51bV9yb3dzIC0gNCkgKyAncHgnO1xyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgLnN0eWxlKCd3aWR0aCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmIChoZWlnaHQgPCB3aWR0aCkge1xyXG4gICAgICAgIHZhciBudW1fY29scyA9IGFsbF9kYXRhLmxlbmd0aCAvIDg7XHJcbiAgICAgICAgdmFyIG1lbnViYXJfd2lkdGggPSAoaGVpZ2h0IC8gNyk7XHJcbiAgICAgICAgdmFyIHJlbWFpbmluZ193aWR0aCA9IHdpZHRoIC0gc3ZnX2RpbSAtIG1lbnViYXJfd2lkdGg7IFxyXG4gICAgICAgIHJldHVybiAocmVtYWluaW5nX3dpZHRoIC8gbnVtX2NvbHMgLSA0KSArICdweCc7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7ICAgICAgICBcclxuICAgICAgICByZXR1cm4gKCh3aWR0aCAvIDgpIC0gNCkgKyAncHgnO1xyXG4gICAgICB9IFxyXG4gICAgfSlcclxuICAgIC5zdHlsZSgnbWFyZ2luJywgJzJweCcpXHJcbiAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbihkKXtcclxuICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgIGlmIChkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2JvcmRlcicpID09ICc1cHggc29saWQgZ29sZCcpIHtcclxuICAgICAgICBnbG9iYWxzLm51bV9zZWxlY3RlZC0tO1xyXG4gICAgICAgIHZhciB1bnNlbGVjdGVkID0gZ2xvYmFscy50cmlhbF9yZXNwb25zZS5pbmRleE9mKCFpbnRyb2R1Y3Rpb25fY29tcGxldGUgPyBkLmNvZGUgOiBkLm5hbWUpO1xyXG4gICAgICAgIGdsb2JhbHMudHJpYWxfcmVzcG9uc2Uuc3BsaWNlKHVuc2VsZWN0ZWQsMSk7XHJcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdib3JkZXInLCAnMXB4IHNvbGlkICNjY2MnKTtcclxuXHJcbiAgICAgICAgaWYgKGludHJvZHVjdGlvbl9jb21wbGV0ZSAmJiAoZ2xvYmFscy50cmlhbF9pbmRleCAhPSAtMSAmJiBnbG9iYWxzLm51bV9zZWxlY3RlZCA9PSBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS5udW1fcmVzcG9uc2VzICYmIChjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgPiAwIHx8IGNoYXJ0X2luc3RhbmNlLmxpbmVzKCkgPT0gJ29uJykpKSB7XHJcbiAgICAgICAgICBkMy5zZWxlY3QoJyNwcm9ncmVzc19pbmRpY2F0b3InKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JyxudWxsKVxyXG4gICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJyxudWxsKVxyXG4gICAgICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvZG9uZS5zdmcnKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjcHJvZ3Jlc3NfaW5kaWNhdG9yJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjb3V0ZXJfcHJvZ3Jlc3NfaW5kaWNhdG9yJylcclxuICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCBnbG9iYWxzLmNvbmRpdGlvbiA9PSAnbXVsdGlwbGVzJyA/ICdub25lJyA6IG51bGwpO1xyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjZG9uZV9idG4nKS5hdHRyKCdjbGFzcycsJ2ltZ19idG5fZGlzYWJsZWQnKVxyXG4gICAgICAgICAgLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpXHJcbiAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLHRydWUpXHJcbiAgICAgICAgICAuYXR0cignc3JjJywgJ2Fzc2V0cy9uYS5zdmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKCghaW50cm9kdWN0aW9uX2NvbXBsZXRlICYmIGdsb2JhbHMubnVtX3NlbGVjdGVkIDwgMykgfHwgKGludHJvZHVjdGlvbl9jb21wbGV0ZSAmJiBnbG9iYWxzLm51bV9zZWxlY3RlZCAhPSBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS5udW1fcmVzcG9uc2VzKSkge1xyXG4gICAgICAgICAgZ2xvYmFscy5udW1fc2VsZWN0ZWQrKztcclxuICAgICAgICAgIGdsb2JhbHMudHJpYWxfcmVzcG9uc2UucHVzaCghaW50cm9kdWN0aW9uX2NvbXBsZXRlID8gZC5jb2RlIDogZC5uYW1lKTtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYm9yZGVyJywgJzVweCBzb2xpZCBnb2xkJyk7ICAgIFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoaW50cm9kdWN0aW9uX2NvbXBsZXRlICYmIChnbG9iYWxzLnRyaWFsX2luZGV4ICE9IC0xICYmIGdsb2JhbHMubnVtX3NlbGVjdGVkID09IGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLm51bV9yZXNwb25zZXMgJiYgKGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA+IDAgfHwgY2hhcnRfaW5zdGFuY2UubGluZXMoKSA9PSAnb24nKSkpIHtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjcHJvZ3Jlc3NfaW5kaWNhdG9yJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLG51bGwpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsbnVsbClcclxuICAgICAgICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvZG9uZS5zdmcnKTtcclxuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjcHJvZ3Jlc3NfaW5kaWNhdG9yJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3QoJyNvdXRlcl9wcm9ncmVzc19pbmRpY2F0b3InKVxyXG4gICAgICAgICAgICAuYXR0cignZGlzcGxheScsIGdsb2JhbHMuY29uZGl0aW9uID09ICdtdWx0aXBsZXMnID8gJ25vbmUnIDogbnVsbCk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2Rpc2FibGVkJylcclxuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsdHJ1ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvbmEuc3ZnJyk7XHJcbiAgICAgICAgICB9ICAgICAgICAgIFxyXG4gICAgICAgIH0gICAgICAgIFxyXG4gICAgICB9XHJcbiAgICAgIGlmIChnbG9iYWxzLm91dGVyX3Byb2dyZXNzX2NpcmNsZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoIWludHJvZHVjdGlvbl9jb21wbGV0ZSkge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjaW5uZXJfcHJvZ3Jlc3NfdmFsdWUnKS5hdHRyKCdkJywgZ2xvYmFscy5pbm5lcl9wcm9ncmVzc19jaXJjbGUuZW5kQW5nbGUoKE1hdGguUEkgKiAyKSAqIChnbG9iYWxzLm51bV9zZWxlY3RlZCAvIDMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjaW5uZXJfcHJvZ3Jlc3NfdmFsdWUnKS5hdHRyKCdkJywgZ2xvYmFscy5pbm5lcl9wcm9ncmVzc19jaXJjbGUuZW5kQW5nbGUoKE1hdGguUEkgKiAyKSAqIChnbG9iYWxzLm51bV9zZWxlY3RlZCAvIGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLm51bV9yZXNwb25zZXMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghaW50cm9kdWN0aW9uX2NvbXBsZXRlICYmIGdsb2JhbHMubnVtX3NlbGVjdGVkID09IDMpIHsgICAgICAgIFxyXG4gICAgICAgIGlmIChnbG9iYWxzLmNvbmRpdGlvbiA9PSAnbXVsdGlwbGVzJyB8fCBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgPj0gMSkge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjcHJvZ3Jlc3NfaW5kaWNhdG9yJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgICAgICBkMy5zZWxlY3QoJyNkb25lX2J0bicpLmF0dHIoJ2NsYXNzJywnaW1nX2J0bl9lbmFibGVkJylcclxuICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsbnVsbClcclxuICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsbnVsbClcclxuICAgICAgICAgIC5hdHRyKCdzcmMnLCAnYXNzZXRzL2RvbmUuc3ZnJyk7XHJcbiAgICAgICAgfSBcclxuICAgICAgfVxyXG4gICAgfSk7ICAgIFxyXG4gICAgXHJcbiAgfSBcclxuICBcclxuICBmdW5jdGlvbiBsb2FkRGF0YSAoKSB7ICAgICBcclxuXHJcbiAgICBjaGVja0V4aXN0ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChhbGxfZGF0YSAhPSB1bmRlZmluZWQpIHsgICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIHJlZHJhdygpOyAgICBcclxuICAgICAgICBcclxuICAgICAgICBoaWRlQWRkcmVzc0JhcigpO1xyXG5cclxuICAgICAgICBjbGVhckludGVydmFsKGNoZWNrRXhpc3QpO1xyXG4gICAgICB9XHJcbiAgICB9LCAxMDApOyAvLyBjaGVjayBldmVyeSAxMDBtcyAgXHJcblxyXG4gIH0gXHJcbiAgICBcclxuICAvKiogSU5JVCAqKi9cclxuXHJcbiAgZ2V0RGltcygpO1xyXG4gIFxyXG4gIGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JylcclxuICAuYXR0cignaWQnLCdzZWxlY3Rvcl9kaXYnKVxyXG4gIC5zdHlsZSgnaGVpZ2h0JywgZnVuY3Rpb24oKXtcclxuICAgIGlmIChoZWlnaHQgPCB3aWR0aCkge1xyXG4gICAgICByZXR1cm4gKGhlaWdodCkgKyAncHgnO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIHZhciBtZW51YmFyX2hlaWdodCA9ICh3aWR0aCAvIDcpO1xyXG4gICAgICB2YXIgcmVtYWluaW5nX2hlaWdodCA9IGhlaWdodCAtIHN2Z19kaW0gLSBtZW51YmFyX2hlaWdodCAtIDEwOyBcclxuICAgICAgcmV0dXJuIChyZW1haW5pbmdfaGVpZ2h0KSArICdweCc7XHJcbiAgICB9XHJcbiAgfSlcclxuICAuc3R5bGUoJ3dpZHRoJywgZnVuY3Rpb24oKXtcclxuICAgIGlmIChoZWlnaHQgPCB3aWR0aCkge1xyXG4gICAgICB2YXIgbWVudWJhcl93aWR0aCA9IChoZWlnaHQgLyA3KTtcclxuICAgICAgdmFyIHJlbWFpbmluZ193aWR0aCA9IHdpZHRoIC0gc3ZnX2RpbSAtIG1lbnViYXJfd2lkdGg7IFxyXG4gICAgICByZXR1cm4gKHJlbWFpbmluZ193aWR0aCkgKyAncHgnO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7ICAgICAgICBcclxuICAgICAgcmV0dXJuICh3aWR0aCkgKyAncHgnO1xyXG4gICAgfSAgICAgIFxyXG4gIH0pXHJcbiAgLnN0eWxlKCdib3R0b20nLCcwcHgnKVxyXG4gIC5zdHlsZSgnZmxvYXQnLCAoaGVpZ2h0IDwgd2lkdGgpID8gJ3JpZ2h0JyA6ICd1bnNldCcpXHJcbiAgLnN0eWxlKCdsZWZ0JywgKGhlaWdodCA8IHdpZHRoKSA/IChzdmdfZGltKSArICdweCcgOiAndW5zZXQnKVxyXG4gIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gIC5hdHRyKCd0YWJpbmRleCcsMCk7XHJcbiAgXHJcbiAgYWxsX2RhdGEgPSBuYXRpb25EYXRhOyAgICAgXHJcbiAgbG9hZERhdGEoKTtcclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY291bnRyeVNlbGVjdG9yO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb3VudHJ5U2VsZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGQzID0gcmVxdWlyZShcImQzXCIpO1xyXG4vLyB2YXIgaW8gPSByZXF1aXJlKCdzb2NrZXQuaW8tY2xpZW50Jyk7XHJcbnZhciBwcmVMb2FkZXIgPSByZXF1aXJlKCdwcmUtbG9hZGVyJyk7XHJcbnZhciBnbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcclxudmFyIGluaXRUYXNrcyA9IHJlcXVpcmUoXCIuL2luaXRUYXNrc1wiKTtcclxudmFyIHNhbmRib3ggPSByZXF1aXJlKFwiLi9zYW5kYm94XCIpO1xyXG52YXIgY29uc2VudCA9IHJlcXVpcmUoXCIuL2NvbnNlbnRcIik7XHJcbnZhciBpbnRyb2R1Y3Rpb24gPSByZXF1aXJlKFwiLi9pbnRyb2R1Y3Rpb25cIik7XHJcbnZhciBxdWVzdGlvbm5haXJlID0gcmVxdWlyZShcIi4vcXVlc3Rpb25uYWlyZVwiKTtcclxudmFyIHRyaWFsID0gcmVxdWlyZShcIi4vdHJpYWxcIik7XHJcbnZhciBjb3VudHJ5U2VsZWN0b3IgPSByZXF1aXJlKFwiLi9jb3VudHJ5U2VsZWN0b3JcIik7XHJcbnZhciBtZW51ID0gcmVxdWlyZShcIi4vbWVudVwiKTsgICAgXHJcbmdsb2JhbHMudXNlcklEID0gJzEyMThfJyArIG5ldyBEYXRlKCkudmFsdWVPZigpOyAvLyBDSEFOR0UgRk9SIFBST0RVQ1RJT05cclxuXHJcbmlmICh3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCdsb2NhbGhvc3QnKSA9PSAtMSkge1xyXG4gIHZhciBzb2NrZXQgPSBpby5jb25uZWN0KHtcclxuICAgIHRyYW5zcG9ydHM6IFsnd2Vic29ja2V0J10sXHJcbiAgICByZWNvbm5lY3Q6IHRydWVcclxuICB9KTtcclxufVxyXG5lbHNlIHtcclxuICB2YXIgc29ja2V0ID0gaW8uY29ubmVjdCh7XHJcbiAgICB0cmFuc3BvcnRzOiBbJ3dlYnNvY2tldCddLFxyXG4gICAgcmVjb25uZWN0OiB0cnVlXHJcbiAgfSk7XHJcbn1cclxuXHJcbnNvY2tldC5vbignbmV3X2Nvbm5lY3Rpb24nLCBmdW5jdGlvbihtc2cpIHtcclxuICBjb25zb2xlLmxvZygnbmV3X2Nvbm5lY3Rpb24nLCBtc2cpO1xyXG59KTtcclxuXHJcbnNvY2tldC5vbignbmV3X3BhcnRpY2lwYW50JywgZnVuY3Rpb24obXNnKSB7XHJcbiAgY29uc29sZS5sb2coJ25ld19wYXJ0aWNpcGFudCcsIG1zZyk7XHJcbiAgaWYgKG1zZy51c2VyX2lkID09IGdsb2JhbHMudXNlcklEKSB7XHJcbiAgICBnbG9iYWxzLnBhcnRpY2lwYW50ID0gbXNnLnBhcnRpY2lwYW50O1xyXG4gICAgZ2xvYmFscy5jb25kaXRpb24gPSBtc2cuY29uZGl0aW9uO1xyXG4gICAgZ2xvYmFscy5vcmRlcmluZyA9IG1zZy5vcmRlcmluZztcclxuICAgIGluaXRUYXNrcygpO1xyXG4gICAgbG9hZE1lbnUoKTtcclxuICB9XHJcbn0pO1xyXG5cclxuc29ja2V0Lm9uKCdkZXBhcnR1cmUnLCBmdW5jdGlvbihtc2cpIHtcclxuICBjb25zb2xlLmxvZygnZGVwYXJ0dXJlOiAnLCBtc2cpO1xyXG59KTtcclxuXHJcbnNvY2tldC5vbignY29tcGxldGlvbicsIGZ1bmN0aW9uKG1zZykge1xyXG4gIGNvbnNvbGUubG9nKCdjb21wbGV0aW9uOiAnLCBtc2cpO1xyXG59KTtcclxuXHJcblxyXG5mdW5jdGlvbiBzZXRDb29raWUgKGNfbmFtZSwgdmFsdWUsIGV4ZGF5cylcclxue1xyXG4gIHZhciBleGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gIGV4ZGF0ZS5zZXREYXRlKGV4ZGF0ZS5nZXREYXRlKCkgKyBleGRheXMpO1xyXG4gIHZhciBjX3ZhbHVlID0gZXNjYXBlKHZhbHVlKSArICgoZXhkYXlzPT1udWxsKSA/IFwiXCIgOiBcIjsgZXhwaXJlcz1cIitleGRhdGUudG9VVENTdHJpbmcoKSk7XHJcbiAgZG9jdW1lbnQuY29va2llID0gY19uYW1lICsgXCI9XCIgKyBjX3ZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDb29raWUgKGNfbmFtZSlcclxue1xyXG4gICB2YXIgaSx4LHksQVJSY29va2llcz1kb2N1bWVudC5jb29raWUuc3BsaXQoXCI7XCIpO1xyXG4gICBmb3IgKGk9MDtpPEFSUmNvb2tpZXMubGVuZ3RoO2krKylcclxuICAgIHtcclxuICAgICAgIHg9QVJSY29va2llc1tpXS5zdWJzdHIoMCxBUlJjb29raWVzW2ldLmluZGV4T2YoXCI9XCIpKTtcclxuICAgICAgICAgIHk9QVJSY29va2llc1tpXS5zdWJzdHIoQVJSY29va2llc1tpXS5pbmRleE9mKFwiPVwiKSsxKTtcclxuICAgICAgICAgIHg9eC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpO1xyXG4gICAgICAgICAgaWYgKHg9PWNfbmFtZSlcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgICByZXR1cm4gdW5lc2NhcGUoeSk7XHJcbiAgICAgICAgICB9XHJcbiAgICB9XHJcbiB9XHJcblxyXG5cclxuLyoganNoaW50IGlnbm9yZTplbmQgKi9cclxuXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24oKSB7IFxyXG5cclxuICBpbWFnZXNBcnJheSA9IFtcclxuICAgIFwiYXNzZXRzL2JhdHRlcnkuc3ZnXCIsXHJcbiAgICBcImFzc2V0cy9icmlnaHRuZXNzLnN2Z1wiLFxyXG4gICAgXCJhc3NldHMvZG9uZS5zdmdcIixcclxuICAgIFwiYXNzZXRzL2Z1bGxzY3JlZW4ucG5nXCIsXHJcbiAgICBcImFzc2V0cy9ncmlkLnN2Z1wiLFxyXG4gICAgXCJhc3NldHMvaG9sZGluZ3Bob25lLnN2Z1wiLFxyXG4gICAgXCJhc3NldHMvbGluZS5zdmdcIixcclxuICAgIFwiYXNzZXRzL25hLnN2Z1wiLFxyXG4gICAgXCJhc3NldHMvbmV4dF9nb2xkLnN2Z1wiLFxyXG4gICAgXCJhc3NldHMvbmV4dC5zdmdcIixcclxuICAgIFwiYXNzZXRzL25vbmF2LnN2Z1wiLFxyXG4gICAgXCJhc3NldHMvcGxheS5zdmdcIixcclxuICAgIFwiYXNzZXRzL3BvcnRyYWl0LnN2Z1wiLFxyXG4gICAgXCJhc3NldHMvcHJldl9nb2xkLnN2Z1wiLFxyXG4gICAgXCJhc3NldHMvcHJldl9ncmV5LnN2Z1wiLFxyXG4gICAgXCJhc3NldHMvcHJldi5zdmdcIixcclxuICAgIFwiYXNzZXRzL3dpZmkuc3ZnXCJcclxuICBdO1xyXG5cclxuICBuZXcgcHJlTG9hZGVyKGltYWdlc0FycmF5LCB7XHJcbiAgICBvblByb2dyZXNzOiBmdW5jdGlvbihpbWcsIGltYWdlRWwsIGluZGV4KXtcclxuICAgICAgICAvLyBmaXJlcyBldmVyeSB0aW1lIGFuIGltYWdlIGlzIGRvbmUgb3IgZXJyb3JzLlxyXG4gICAgICAgIC8vIGltYWdlRWwgd2lsbCBiZSBmYWxzeSBpZiBlcnJvclxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdqdXN0ICcgKyAgKCFpbWFnZUVsID8gJ2ZhaWxlZDogJyA6ICdsb2FkZWQ6ICcpICsgaW1nKTtcclxuICAgICAgICAvLyBpbWFnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChpbWFnZUVsKTtcclxuICAgICAgICAvLyBjYW4gYWNjZXNzIGFueSBwcm9wZXJ5IG9mIHRoaXNcclxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvbXBsZXRlZC5sZW5ndGggKyB0aGlzLmVycm9ycy5sZW5ndGggKyAnIC8gJyArIHRoaXMucXVldWUubGVuZ3RoICsgJyBkb25lJyk7XHJcbiAgICB9LFxyXG4gICAgb25Db21wbGV0ZTogZnVuY3Rpb24obG9hZGVkLCBlcnJvcnMpe1xyXG4gICAgICAgIC8vIGZpcmVzIHdoZW4gd2hvbGUgbGlzdCBpcyBkb25lLiBjYWNoZSBpcyBwcmltZWQuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2Fzc2V0cyBsb2FkZWQ6JywgbG9hZGVkKTtcclxuICAgICAgICAvLyBpbWFnZUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICBpZiAoZXJyb3JzKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3RoZSBmb2xsb3dpbmcgZmFpbGVkJywgZXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmVzdW1wdGlvbnMgPSBbXTtcclxuICBnbG9iYWxzLmxhc3RfcGF1c2UgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcclxuICBcclxuXHJcbiAgXHJcbiAgaGlkZUFkZHJlc3NCYXIoKTsgICBcclxuXHJcbiAgZ2xvYmFscy5sYXN0X3BhdXNlID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XHJcblxyXG4gIHJlc3VtcHRpb25zLnB1c2goe1xyXG4gICAgJ3Jlc3VtcHRpb25fdGltZSc6IG5ldyBEYXRlKCkudmFsdWVPZigpICsgMSxcclxuICAgICdwYXVzZV90aW1lJzogZ2xvYmFscy5sYXN0X3BhdXNlLFxyXG4gICAgJ3BhdXNlX2R1cmF0aW9uJzogMVxyXG4gIH0pOyAvL2FwcCByZXN1bWVkXHJcblxyXG4gICAgXHJcbiAgZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdpbnB1dCcpXHJcbiAgLmF0dHIoJ2lkJywnbGFuZHNjYXBlX2J0bicpXHJcbiAgLmF0dHIoJ3R5cGUnLCdidXR0b24nKVxyXG4gIC5zdHlsZSgnY29sb3InLCcjMTExJylcclxuICAuc3R5bGUoJ2JhY2tncm91bmQnLCcjZWY1MzUwJylcclxuICAuc3R5bGUoJ2JvcmRlci1jb2xvcicsJyNmZmYnKVxyXG4gIC5hdHRyKCd2YWx1ZScsJ0hvbGQgeW91ciBwaG9uZSBpbiBwb3J0cmFpdCBtb2RlLicpXHJcbiAgLmF0dHIoJ3RpdGxlJywnSG9sZCB5b3VyIHBob25lIGluIHBvcnRyYWl0IG1vZGUuJylcclxuICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgIFxyXG4gICAgZDMuc2VsZWN0KCcjbGFuZHNjYXBlX2J0bicpLnJlbW92ZSgpO1xyXG4gIH0pOyBcclxuICBcclxufSk7ICBcclxuXHJcbndpbmRvdy5vbmZvY3VzID0gZnVuY3Rpb24oZSkge1xyXG4gIHZhciByX3RpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcclxuICBpZiAocmVzdW1wdGlvbnMubGVuZ3RoID09IDAgfHwgZ2xvYmFscy5sYXN0X3BhdXNlID4gcmVzdW1wdGlvbnNbcmVzdW1wdGlvbnMubGVuZ3RoIC0gMV0ucmVzdW1wdGlvbl90aW1lICYmIHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoKSB7XHJcbiAgICByZXN1bXB0aW9ucy5wdXNoKHtcclxuICAgICAgJ3Jlc3VtcHRpb25fdGltZSc6IHJfdGltZSxcclxuICAgICAgJ3BhdXNlX3RpbWUnOiBnbG9iYWxzLmxhc3RfcGF1c2UsXHJcbiAgICAgICdwYXVzZV90eXBlJzonZm9jdXMnLFxyXG4gICAgICAncGF1c2VfZHVyYXRpb24nOiByX3RpbWUgLSBnbG9iYWxzLmxhc3RfcGF1c2VcclxuICAgIH0pOyAvL2FwcCByZXN1bWVkXHJcbiAgfVxyXG4gIFxyXG4gIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySUQsIFxyXG4gICAgXCJFdmVudFwiOiBcIkluRm9jdXNcIixcclxuICAgIFwiRm9jdXNcIjogdHJ1ZSAsXHJcbiAgICAncmVzdW1wdGlvbl90aW1lJzogcl90aW1lLFxyXG4gICAgJ3BhdXNlX3RpbWUnOiBnbG9iYWxzLmxhc3RfcGF1c2UsXHJcbiAgICAncGF1c2VfdHlwZSc6ICdmb2N1cycsXHJcbiAgICAncGF1c2VfZHVyYXRpb24nOiByX3RpbWUgLSBnbG9iYWxzLmxhc3RfcGF1c2VcclxuICB9O1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKFwiSW5Gb2N1c1wiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcbn07XHJcblxyXG53aW5kb3cub25ibHVyID0gZnVuY3Rpb24oZSkge1xyXG4gIGlmIChyZXN1bXB0aW9ucy5sZW5ndGggPT0gMCB8fCByZXN1bXB0aW9uc1tyZXN1bXB0aW9ucy5sZW5ndGggLSAxXS5yZXN1bXB0aW9uX3RpbWUgPiBnbG9iYWxzLmxhc3RfcGF1c2UpIHtcclxuICAgIGdsb2JhbHMubGFzdF9wYXVzZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpOyAvL2FwcCBwYXVzZWRcclxuICB9XHJcblxyXG4gIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICBcIkV2ZW50XCI6IFwiRm9jdXNMb3NzXCIsXHJcbiAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySUQsIFxyXG4gICAgXCJGb2N1c1wiOiBmYWxzZSBcclxuICB9O1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKFwiRm9jdXNMb3NzXCIsIGdsb2JhbHMubG9nX21lc3NhZ2UpO1xyXG5cclxuXHJcbn07XHJcblxyXG53aW5kb3cub25iZWZvcmV1bmxvYWQgPSBmdW5jdGlvbigpIHsgXHJcbiAgc29ja2V0LmVtaXQoJ3VubG9hZCcsIHtcclxuICAgIHVzZXJJRDogZ2xvYmFscy51c2VySUQsXHJcbiAgICB1c2VyQWdlbnQ6IG5hdmlnYXRvci51c2VyQWdlbnRcclxuICB9KTtcclxuICByZXR1cm4gXCJZb3VyIHdvcmsgd2lsbCBiZSBsb3N0LlwiOyBcclxufTtcclxuXHJcbndpbmRvdy5vbnJlc2l6ZSA9IGZ1bmN0aW9uKGUpIHtcclxuICBcclxuICBkMy5zZWxlY3QoJyNsYW5kc2NhcGVfYnRuJykucmVtb3ZlKCk7XHJcblxyXG4gIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFuZHNjYXBlX2J0bicpKSB7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFuZHNjYXBlX2J0bicpLnJlbW92ZSgpO1xyXG4gIH1cclxuICBoaWRlQWRkcmVzc0JhcigpO1xyXG5cclxuICBpZiAod2luZG93LmlubmVySGVpZ2h0IDwgd2luZG93LmlubmVyV2lkdGgpIHtcclxuICAgIGlmIChyZXN1bXB0aW9uc1tyZXN1bXB0aW9ucy5sZW5ndGggLSAxXS5yZXN1bXB0aW9uX3RpbWUgPiBnbG9iYWxzLmxhc3RfcGF1c2UpIHtcclxuICAgICAgZ2xvYmFscy5sYXN0X3BhdXNlID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7IC8vYXBwIHBhdXNlZFxyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklELCBcclxuICAgICAgXCJFdmVudFwiOiBcIlJlc2l6ZWRcIixcclxuICAgICAgXCJXaWR0aFwiOiB3aW5kb3cuaW5uZXJXaWR0aCwgXHJcbiAgICAgIFwiSGVpZ2h0XCI6IHdpbmRvdy5pbm5lckhlaWdodCxcclxuICAgICAgXCJNb2RlXCI6ICdsYW5kc2NhcGUnIFxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coXCJSZXNpemVkXCIsIGdsb2JhbHMubG9nX21lc3NhZ2UpO1xyXG5cclxuXHJcbiAgICBkMy5zZWxlY3QoJ2JvZHknKS5hcHBlbmQoJ2lucHV0JylcclxuICAgIC5hdHRyKCdpZCcsJ2xhbmRzY2FwZV9idG4nKVxyXG4gICAgLmF0dHIoJ3R5cGUnLCdidXR0b24nKVxyXG4gICAgLnN0eWxlKCdjb2xvcicsJyMxMTEnKVxyXG4gICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywnI2VmNTM1MCcpXHJcbiAgICAuc3R5bGUoJ2JvcmRlci1jb2xvcicsJyNmZmYnKVxyXG4gICAgLmF0dHIoJ3ZhbHVlJywnSG9sZCB5b3VyIHBob25lIGluIHBvcnRyYWl0IG1vZGUuJylcclxuICAgIC5hdHRyKCd0aXRsZScsJ0hvbGQgeW91ciBwaG9uZSBpbiBwb3J0cmFpdCBtb2RlLicpXHJcbiAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgIFxyXG4gICAgICBkMy5zZWxlY3QoJyNsYW5kc2NhcGVfYnRuJykucmVtb3ZlKCk7XHJcbiAgICB9KTsgICAgICAgIFxyXG4gICAgXHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgZDMuc2VsZWN0KCcjbGFuZHNjYXBlX2J0bicpLnJlbW92ZSgpO1xyXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYW5kc2NhcGVfYnRuJykpIHtcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xhbmRzY2FwZV9idG4nKS5yZW1vdmUoKTtcclxuICAgIH1cclxuICAgIHZhciByX3RpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcclxuICAgIGlmIChnbG9iYWxzLmxhc3RfcGF1c2UgPiByZXN1bXB0aW9uc1tyZXN1bXB0aW9ucy5sZW5ndGggLSAxXS5yZXN1bXB0aW9uX3RpbWUpIHtcclxuICAgICAgcmVzdW1wdGlvbnMucHVzaCh7XHJcbiAgICAgICAgJ3Jlc3VtcHRpb25fdGltZSc6IHJfdGltZSxcclxuICAgICAgICAncGF1c2VfdGltZSc6IGdsb2JhbHMubGFzdF9wYXVzZSxcclxuICAgICAgICAncGF1c2VfdHlwZSc6ICdvcmllbnRhdGlvbicsXHJcbiAgICAgICAgJ3BhdXNlX2R1cmF0aW9uJzogcl90aW1lIC0gZ2xvYmFscy5sYXN0X3BhdXNlXHJcbiAgICAgIH0pOyAvL2FwcCByZXN1bWVkXHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICAgIFwiVGltZVN0YW1wXCI6IG5ldyBEYXRlKCkudmFsdWVPZigpLFxyXG4gICAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySUQsIFxyXG4gICAgICBcIkV2ZW50XCI6IFwiUmVzaXplZFwiLFxyXG4gICAgICBcIldpZHRoXCI6IHdpbmRvdy5pbm5lcldpZHRoLCBcclxuICAgICAgXCJIZWlnaHRcIjogd2luZG93LmlubmVySGVpZ2h0LFxyXG4gICAgICBcIk9yaWVudGF0aW9uXCI6ICdwb3J0cmFpdCcsXHJcbiAgICAgICdyZXN1bXB0aW9uX3RpbWUnOiByX3RpbWUsXHJcbiAgICAgICdwYXVzZV90aW1lJzogZ2xvYmFscy5sYXN0X3BhdXNlLFxyXG4gICAgICAncGF1c2VfdHlwZSc6ICdvcmllbnRhdGlvbicsXHJcbiAgICAgICdwYXVzZV9kdXJhdGlvbic6IHJfdGltZSAtIGdsb2JhbHMubGFzdF9wYXVzZVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coXCJSZXNpemVkXCIsIGdsb2JhbHMubG9nX21lc3NhZ2UpO1xyXG5cclxuXHJcbiAgfSAgXHJcbn07XHJcblxyXG5kMy5zZWxlY3QoXCJib2R5XCIpXHJcbi5vbihcImtleWRvd25cIiwgZnVuY3Rpb24gKCkgeyAgICBcclxuICBcclxuICBzd2l0Y2goZDMuZXZlbnQua2V5Q29kZSkgeyAgICBcclxuXHJcbiAgICBjYXNlIDI3OiAvLyB0ZXN0IG92ZXJyaWRlIG9uICdFc2MnIGFuZCBsb2FkIG1lbnVcclxuICAgICAgdGVzdF9vdmVycmlkZSA9IHRydWU7XHJcbiAgICAgIGNvbnNlbnRfY29tcGxldGUgPSB0cnVlO1xyXG4gICAgICBpbnRyb2R1Y3Rpb25fY29tcGxldGUgPSB0cnVlO1xyXG5cclxuICAgICAgZ2xvYmFscy50cmlhbF9pbmRleCA9IC0xO1xyXG5cclxuICAgICAgZ2xvYmFscy5hbmltYXRpb24gPSAnb2ZmJztcclxuICAgICAgZ2xvYmFscy5saW5lcyA9ICdvZmYnO1xyXG4gICAgICBnbG9iYWxzLmZhY2V0cyA9ICdvZmYnO1xyXG5cclxuICAgICAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgICAgXCJFdmVudFwiOiBcIkVzY2FwZVwiLFxyXG4gICAgICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRFxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coXCJFc2NhcGVcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG5cclxuICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWxlY3Rvcl9kaXYnKSAhPSB1bmRlZmluZWQpIHsgICAgICBcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VsZWN0b3JfZGl2JykucmVtb3ZlKCk7ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgfSBcclxuICAgICBcclxuICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKVswXSAhPSB1bmRlZmluZWQpIHsgICAgICAgIFxyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGl2JylbMF0ucmVtb3ZlKCk7ICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICAgICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgICAgIFwiRXZlbnRcIjogXCJUZXN0T3ZlcnJpZGVfTG9hZF9NZW51XCIsXHJcbiAgICAgICAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySURcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVGVzdE92ZXJyaWRlX0xvYWRfTWVudVwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcblxyXG4gICAgICAgIGxvYWRNZW51KCk7XHJcbiAgICAgICAgaGlkZUFkZHJlc3NCYXIoKTtcclxuICAgICAgfSAgICAgICAgICAgXHJcbiAgICBicmVhazsgICAgXHJcblxyXG4gICAgZGVmYXVsdDogICAgICBcclxuICAgIGJyZWFrO1xyXG4gIH0gICAgXHJcblxyXG59KTtcclxuXHJcbmxvYWRTYW5kYm94ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICBnbG9iYWxzLnRyaWFsX2luZGV4ID0gMDtcclxuICB0ZXN0X292ZXJyaWRlID0gdHJ1ZTsgICAgXHJcblxyXG4gIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICBcIkV2ZW50XCI6IFwiU2FuZEJveF9PcGVuXCIsXHJcbiAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySURcclxuICB9O1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKFwiU2FuZEJveF9PcGVuXCIsIGdsb2JhbHMubG9nX21lc3NhZ2UpO1xyXG5cclxuXHJcbiAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgLy8gSGlkZSB0aGUgYWRkcmVzcyBiYXIhXHJcblx0XHRzYW5kYm94KCk7ICBcclxuICB9LCAxMDApO1xyXG4gIGhpZGVBZGRyZXNzQmFyKCk7IFxyXG59O1xyXG5cclxubG9hZE1lbnUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgXHJcbiAgbWVudSgpOyBcclxuXHJcbiAgZDMuc2VsZWN0KCcjY29uc2VudF9idG4nKVxyXG4gIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyAgICBcclxuICAgIGlmICh0ZXN0X292ZXJyaWRlIHx8ICFjb25zZW50X2NvbXBsZXRlKSB7XHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51X2RpdicpLnJlbW92ZSgpO1xyXG4gICAgICBcclxuICAgICAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklELFxyXG4gICAgICAgIFwiRXZlbnRcIjogXCJDb25zZW50U3RhcnRcIixcclxuICAgICAgICBcIm9yZGVyaW5nXCI6IGdsb2JhbHMub3JkZXJpbmcsXHJcbiAgICAgICAgXCJjb25kaXRpb25cIjogZ2xvYmFscy5jb25kaXRpb24sXHJcbiAgICAgICAgXCJXaWR0aFwiOiB3aW5kb3cuaW5uZXJXaWR0aCwgXHJcbiAgICAgICAgXCJIZWlnaHRcIjogd2luZG93LmlubmVySGVpZ2h0LFxyXG4gICAgICAgIFwiU2NlbmVcIjogMFxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coXCJDb25zZW50U3RhcnRcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG4gICAgICBcclxuICAgICAgY29uc2VudCgwKTtcclxuICAgICAgaGlkZUFkZHJlc3NCYXIoKTtcclxuICAgIH0gIFxyXG4gIH0pO1xyXG5cclxuICBkMy5zZWxlY3QoJyNpbnRyb2R1Y3Rpb25fYnRuJylcclxuICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgICBcclxuICAgIGlmICh0ZXN0X292ZXJyaWRlIHx8ICghaW50cm9kdWN0aW9uX2NvbXBsZXRlICYmIGNvbnNlbnRfY29tcGxldGUpKSB7XHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZW51X2RpdicpLnJlbW92ZSgpO1xyXG4gICAgICBcclxuICAgICAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklELFxyXG4gICAgICAgIFwiRXZlbnRcIjogXCJJbnRyb1N0YXJ0XCIsXHJcbiAgICAgICAgXCJTY2VuZVwiOiAwXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhcIkludHJvU3RhcnRcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG4gICAgICBcclxuICAgICAgaW50cm9kdWN0aW9uKDApO1xyXG4gICAgICBoaWRlQWRkcmVzc0JhcigpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICBkMy5zZWxlY3QoJyN0cmlhbF9idG4nKVxyXG4gIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIGlmICh0ZXN0X292ZXJyaWRlIHx8IGludHJvZHVjdGlvbl9jb21wbGV0ZSkge1xyXG4gICAgICBnbG9iYWxzLnRyaWFsX2luZGV4ID0gLTE7ICBcclxuICAgICAgdGVzdF9vdmVycmlkZSA9IGZhbHNlOyAgXHJcbiAgICAgIFxyXG4gICAgICBzd2l0Y2ggKGdsb2JhbHMuY29uZGl0aW9uKSB7XHJcbiAgXHJcbiAgICAgICAgY2FzZSAnc3RlcHBlcic6XHJcbiAgXHJcbiAgICAgICAgICBnbG9iYWxzLmFuaW1hdGlvbiA9ICdvZmYnO1xyXG4gICAgICAgICAgZ2xvYmFscy5saW5lcyA9ICdvZmYnO1xyXG4gICAgICAgICAgZ2xvYmFscy5mYWNldHMgPSAnb2ZmJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gIFxyXG4gICAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XHJcbiAgXHJcbiAgICAgICAgICBnbG9iYWxzLmFuaW1hdGlvbiA9ICdvbic7XHJcbiAgICAgICAgICBnbG9iYWxzLmxpbmVzID0gJ29mZic7XHJcbiAgICAgICAgICBnbG9iYWxzLmZhY2V0cyA9ICdvZmYnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgXHJcbiAgICAgICAgY2FzZSAnbXVsdGlwbGVzJzpcclxuICBcclxuICAgICAgICAgIGdsb2JhbHMuYW5pbWF0aW9uID0gJ29mZic7XHJcbiAgICAgICAgICBnbG9iYWxzLmxpbmVzID0gJ29uJztcclxuICAgICAgICAgIGdsb2JhbHMuZmFjZXRzID0gJ29uJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gIFxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgXHJcbiAgICAgICAgICBnbG9iYWxzLmFuaW1hdGlvbiA9ICdvZmYnO1xyXG4gICAgICAgICAgZ2xvYmFscy5saW5lcyA9ICdvZmYnO1xyXG4gICAgICAgICAgZ2xvYmFscy5mYWNldHMgPSAnb2ZmJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9ICAgXHJcblxyXG4gICAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgICBcIkV2ZW50XCI6IFwiRXhwZXJpbWVudF9TdGFydFwiLFxyXG4gICAgICAgIFwiY29uZGl0aW9uXCI6IGdsb2JhbHMuY29uZGl0aW9uLFxyXG4gICAgICAgIFwib3JkZXJpbmdcIjogZ2xvYmFscy5vcmRlcmluZyxcclxuICAgICAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySUQsXHJcbiAgICAgICAgXCJXaWR0aFwiOiB3aW5kb3cuaW5uZXJXaWR0aCwgXHJcbiAgICAgICAgXCJIZWlnaHRcIjogd2luZG93LmlubmVySGVpZ2h0XHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhcIkV4cGVyaW1lbnRfU3RhcnRcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG4gIFxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudV9kaXYnKS5yZW1vdmUoKTsgICBcclxuICAgICAgdHJpYWwoKTsgIFxyXG4gICAgICBjb3VudHJ5U2VsZWN0b3IoKTtcclxuICAgICAgaGlkZUFkZHJlc3NCYXIoKTsgICBcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgZDMuc2VsZWN0KCcjcXVlc3Rpb25uYWlyZV9idG4nKVxyXG4gIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyAgICBcclxuICAgIGlmICh0ZXN0X292ZXJyaWRlIHx8IGV4cGVyaW1lbnRfY29tcGxldGUpIHtcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lbnVfZGl2JykucmVtb3ZlKCk7XHJcblxyXG4gICAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySUQsXHJcbiAgICAgICAgXCJFdmVudFwiOiBcIlN1cnZleVN0YXJ0XCIsXHJcbiAgICAgICAgXCJjb25kaXRpb25cIjogZ2xvYmFscy5jb25kaXRpb24sXHJcbiAgICAgICAgXCJvcmRlcmluZ1wiOiBnbG9iYWxzLm9yZGVyaW5nLFxyXG4gICAgICAgIFwiV2lkdGhcIjogd2luZG93LmlubmVyV2lkdGgsIFxyXG4gICAgICAgIFwiSGVpZ2h0XCI6IHdpbmRvdy5pbm5lckhlaWdodCxcclxuICAgICAgICBcIlNjZW5lXCI6IDBcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiU3VydmV5U3RhcnRcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG5cclxuICAgICAgc29ja2V0LmVtaXQoJ3F1ZXN0aW9ubmFpcmUnLCBnbG9iYWxzLnVzZXJJRCk7XHJcbiAgICAgIHF1ZXN0aW9ubmFpcmUoMCk7XHJcbiAgICAgIGhpZGVBZGRyZXNzQmFyKCk7XHJcbiAgICB9ICBcclxuICB9KTtcclxuXHJcbiAgZDMuc2VsZWN0KCcjc2VjcmV0X3NhbmRib3gnKVxyXG4gIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyAgXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVudV9kaXYnKS5yZW1vdmUoKTsgXHJcbiAgICBnbG9iYWxzLnRyaWFsX2luZGV4ID0gMDtcclxuICAgIHRlc3Rfb3ZlcnJpZGUgPSB0cnVlOyAgICBcclxuXHJcbiAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgIFwiRXZlbnRcIjogXCJTYW5kQm94X09wZW5cIixcclxuICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklEXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhcIlNhbmRCb3hfT3BlblwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcblxyXG4gICAgc2FuZGJveCgpO1xyXG4gICAgaGlkZUFkZHJlc3NCYXIoKTsgICBcclxuICB9KTtcclxufTtcclxuXHJcbiBpZiAoZ2V0Q29va2llKCd2aXNpdGVkJykpIHtcclxuICAvLyBhbGVydCgnWW91IGhhdmUgYWxyZWFkeSBwYXJ0aWNpcGF0ZWQgaW4gdGhpcyBzdHVkeS4nKTsgLy9DT01NRU5UIEZPUiBURVNUSU5HXHJcblxyXG4gIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICBcIkV2ZW50XCI6IFwiUmVwZWF0UGFydGljaXBhbnRcIixcclxuICAgIFwidXNlckFnZW50XCI6IG5hdmlnYXRvci51c2VyQWdlbnQsXHJcbiAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySURcclxuICB9O1xyXG4gIFxyXG4gIGNvbnNvbGUubG9nKFwiUmVwZWF0UGFydGljaXBhbnRcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG5cclxuICBzb2NrZXQuZW1pdCgndXNlcklEJywge1xyXG4gICAgdXNlcklEOiBnbG9iYWxzLnVzZXJJRCxcclxuICAgIHVzZXJBZ2VudDogbmF2aWdhdG9yLnVzZXJBZ2VudFxyXG4gIH0pOyAvL0NPTU1FTlQgRk9SIFBST0RVQ1RJT05cclxuIH1cclxuIGVsc2Uge1xyXG4gIHNldENvb2tpZSgndmlzaXRlZCcsMSwzNjUpO1xyXG5cclxuICAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgIFwiRXZlbnRcIjogXCJOZXdQYXJ0aWNpcGFudFwiLFxyXG4gICAgXCJ1c2VyQWdlbnRcIjogbmF2aWdhdG9yLnVzZXJBZ2VudCxcclxuICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRFxyXG4gIH07XHJcbiAgXHJcbiAgY29uc29sZS5sb2coXCJOZXdQYXJ0aWNpcGFudFwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcblxyXG4gIHNvY2tldC5lbWl0KCd1c2VySUQnLCB7XHJcbiAgICB1c2VySUQ6IGdsb2JhbHMudXNlcklELFxyXG4gICAgdXNlckFnZW50OiBuYXZpZ2F0b3IudXNlckFnZW50XHJcbiAgfSk7ICBcclxuIH1cclxuXHJcbmQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnc3ZnJylcclxuLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpXHJcbi5hdHRyKCd4bWxucycsJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJylcclxuLmF0dHIoJ3ZlcnNpb24nLCcxLjEnKVxyXG4uYXR0cignaGVpZ2h0JywnMCcpXHJcbi5hcHBlbmQoJ2ZpbHRlcicpXHJcbi5hdHRyKCdpZCcsJ215Ymx1cmZpbHRlcicpXHJcbi5hdHRyKCd3aWR0aCcsJzExMCUnKVxyXG4uYXR0cignaGVpZ2h0JywnMTEwJScpXHJcbi5hcHBlbmQoJ2ZlR2F1c3NpYW5CbHVyJylcclxuLmF0dHIoJ3N0ZERldmlhdGlvbicsJzMwJylcclxuLmF0dHIoJ3Jlc3VsdCcsJ2JsdXInKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCI7KGZ1bmN0aW9uKCl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvLyBjYW4gd2Ugc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyXG5cdHZhciBoYXNOYXRpdmUgPSAnYWRkRXZlbnRMaXN0ZW5lcicgaW4gKG5ldyBJbWFnZSgpKTtcblxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGltYWdlcyAtIHN0cmluZyBvZiBpbWFnZXMgdG8gbG9hZFxuXHQgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBvdmVycmlkZXMgdG8gZGVmYXVsdHNcblx0ICovXG5cdHZhciBQcmVMb2FkZXIgPSBmdW5jdGlvbihpbWFnZXMsIG9wdGlvbnMpe1xuXHRcdHRoaXMub3B0aW9ucyA9IHtcblx0XHRcdHBpcGVsaW5lOiBmYWxzZSxcblx0XHRcdGF1dG86IHRydWUsXG5cdFx0XHRwcmVmZXRjaDogZmFsc2UsXG5cdFx0XHQvKiBvblByb2dyZXNzOiBmdW5jdGlvbigpe30sICovXG5cdFx0XHQvKiBvbkVycm9yOiBmdW5jdGlvbigpe30sICovXG5cdFx0XHRvbkNvbXBsZXRlOiBmdW5jdGlvbigpe31cblx0XHR9O1xuXG5cdFx0b3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PSAnb2JqZWN0JyAmJiB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cblx0XHR0aGlzLmFkZFF1ZXVlKGltYWdlcyk7XG5cdFx0dGhpcy5xdWV1ZS5sZW5ndGggJiYgdGhpcy5vcHRpb25zLmF1dG8gJiYgdGhpcy5wcm9jZXNzUXVldWUoKTtcblx0fTtcblxuXHQvKipcblx0ICogbmFpdmUgc2hhbGxvdyBjb3B5L3JlZmVyZW5jZSBmcm9tIG9wdGlvbnMgaW50byBwcm90byBvcHRpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEByZXR1cm5zIHtQcmVMb2FkZXJ9XG5cdCAqL1xuXHRQcmVMb2FkZXIucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKXtcblx0XHQvLyBzaGFsbG93IGNvcHlcblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGtleTtcblxuXHRcdGZvciAoa2V5IGluIG9wdGlvbnMpIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAob1trZXldID0gb3B0aW9uc1trZXldKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBzdG9yZXMgYSBsb2NhbCBhcnJheSwgZGVyZWZlcmVuY2VkIGZyb20gb3JpZ2luYWxcblx0ICogQHBhcmFtIGltYWdlc1xuXHQgKiBAcmV0dXJucyB7UHJlTG9hZGVyfVxuXHQgKi9cblx0UHJlTG9hZGVyLnByb3RvdHlwZS5hZGRRdWV1ZSA9IGZ1bmN0aW9uKGltYWdlcyl7XG5cdFx0dGhpcy5xdWV1ZSA9IGltYWdlcy5zbGljZSgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIHJlc2V0IHRoZSBhcnJheXNcblx0ICogQHJldHVybnMge1ByZUxvYWRlcn1cblx0ICovXG5cdFByZUxvYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuXHRcdHRoaXMuY29tcGxldGVkID0gW107XG5cdFx0dGhpcy5lcnJvcnMgPSBbXTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdWJzY3JpYmUgdG8gZXZlbnRzIGZvciBhbiBpbWFnIG9iamVjdCBhbmQgYSBzb3VyY2Vcblx0ICogQHBhcmFtIHtPYmplY3R9IGltYWdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm5zIHtQcmVMb2FkZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRQcmVMb2FkZXIucHJvdG90eXBlLl9hZGRFdmVudHMgPSBmdW5jdGlvbihpbWFnZSwgc3JjLCBpbmRleCl7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGNsZWFudXAgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRpZiAoaGFzTmF0aXZlKXtcblx0XHRcdFx0XHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgYWJvcnQpO1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydCk7XG5cdFx0XHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5vbmVycm9yID0gdGhpcy5vbmFib3J0ID0gdGhpcy5vbmxvYWQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQgPSBmdW5jdGlvbigpe1xuXHRcdFx0XHRjbGVhbnVwLmNhbGwodGhpcyk7XG5cblx0XHRcdFx0c2VsZi5lcnJvcnMucHVzaChzcmMpO1xuXHRcdFx0XHRvLm9uRXJyb3IgJiYgby5vbkVycm9yLmNhbGwoc2VsZiwgc3JjKTtcblx0XHRcdFx0X2NoZWNrUHJvZ3Jlc3MuY2FsbChzZWxmLCBzcmMpO1xuXHRcdFx0XHRvLnBpcGVsaW5lICYmIHNlbGYuX2xvYWROZXh0KGluZGV4KTtcblx0XHRcdH0sXG5cdFx0XHRsb2FkID0gZnVuY3Rpb24oKXtcblx0XHRcdFx0Y2xlYW51cC5jYWxsKHRoaXMpO1xuXG5cdFx0XHRcdC8vIHN0b3JlIHByb2dyZXNzLiB0aGlzID09PSBpbWFnZVxuXHRcdFx0XHRzZWxmLmNvbXBsZXRlZC5wdXNoKHNyYyk7IC8vIHRoaXMuc3JjIG1heSBkaWZmZXJcblx0XHRcdFx0X2NoZWNrUHJvZ3Jlc3MuY2FsbChzZWxmLCBzcmMsIHRoaXMpO1xuXHRcdFx0XHRvLnBpcGVsaW5lICYmIHNlbGYuX2xvYWROZXh0KGluZGV4KTtcblx0XHRcdH07XG5cblx0XHRpZiAoaGFzTmF0aXZlKXtcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgYWJvcnQsIGZhbHNlKTtcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnQsIGZhbHNlKTtcblx0XHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkLCBmYWxzZSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aW1hZ2Uub25lcnJvciA9IGltYWdlLm9uYWJvcnQgPSBhYm9ydDtcblx0XHRcdGltYWdlLm9ubG9hZCA9IGxvYWQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByaXZhdGUgQVBJIHRvIGxvYWQgYW4gaW1hZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcblx0ICogQHJldHVybnMge1ByZUxvYWRlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdFByZUxvYWRlci5wcm90b3R5cGUuX2xvYWQgPSBmdW5jdGlvbihzcmMsIGluZGV4KXtcblx0XHQvKmpzaGludCAtVzA1OCAqL1xuXHRcdHZhciBpbWFnZSA9IG5ldyBJbWFnZTtcblxuXHRcdHRoaXMuX2FkZEV2ZW50cyhpbWFnZSwgc3JjLCBpbmRleCk7XG5cblx0XHQvLyBhY3R1YWxseSBsb2FkXG5cdFx0aW1hZ2Uuc3JjID0gc3JjO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1vdmUgdXAgdGhlIHF1ZXVlIGluZGV4XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJucyB7UHJlTG9hZGVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0UHJlTG9hZGVyLnByb3RvdHlwZS5fbG9hZE5leHQgPSBmdW5jdGlvbihpbmRleCl7XG5cdFx0Ly8gd2hlbiBwaXBlbGluZSBsb2FkaW5nIGlzIGVuYWJsZWQsIGNhbGxzIG5leHQgaXRlbVxuXHRcdGluZGV4Kys7XG5cdFx0dGhpcy5xdWV1ZVtpbmRleF0gJiYgdGhpcy5fbG9hZCh0aGlzLnF1ZXVlW2luZGV4XSwgaW5kZXgpO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIHF1ZXVlIG9mIGltYWdlcyB0byBsb2FkXG5cdCAqIEByZXR1cm5zIHtQcmVMb2FkZXJ9XG5cdCAqL1xuXHRQcmVMb2FkZXIucHJvdG90eXBlLnByb2Nlc3NRdWV1ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0Ly8gcnVucyB0aHJvdWdoIGFsbCBxdWV1ZWQgaXRlbXMuXG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0cXVldWUgPSB0aGlzLnF1ZXVlLFxuXHRcdFx0bGVuID0gcXVldWUubGVuZ3RoO1xuXG5cdFx0Ly8gcHJvY2VzcyBhbGwgcXVldWUgaXRlbXNcblx0XHR0aGlzLnJlc2V0KCk7XG5cblx0XHRpZiAoIXRoaXMub3B0aW9ucy5waXBlbGluZSkgZm9yICg7IGkgPCBsZW47ICsraSkgdGhpcy5fbG9hZChxdWV1ZVtpXSwgaSk7XG5cdFx0ZWxzZSB0aGlzLl9sb2FkKHF1ZXVlWzBdLCAwKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBjaGVja2VyIG9uIHRoZSBxdWV1ZSBwcm9ncmVzc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVxuXHQgKiBAcmV0dXJucyB7UHJlTG9hZGVyfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gX2NoZWNrUHJvZ3Jlc3Moc3JjLCBpbWFnZSl7XG5cdFx0Ly8gaW50ZXJtZWRpYXRlIGNoZWNrZXIgZm9yIHF1ZXVlIHJlbWFpbmluZy4gbm90IGV4cG9ydGVkLlxuXHRcdC8vIGNhbGxlZCBvbiBwcmVMb2FkZXIgaW5zdGFuY2UgYXMgc2NvcGVcblx0XHR2YXIgYXJncyA9IFtdLFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vIGNhbGwgb25Qcm9ncmVzc1xuXHRcdG8ub25Qcm9ncmVzcyAmJiBzcmMgJiYgby5vblByb2dyZXNzLmNhbGwodGhpcywgc3JjLCBpbWFnZSwgdGhpcy5jb21wbGV0ZWQubGVuZ3RoKTtcblxuXHRcdGlmICh0aGlzLmNvbXBsZXRlZC5sZW5ndGggKyB0aGlzLmVycm9ycy5sZW5ndGggPT09IHRoaXMucXVldWUubGVuZ3RoKXtcblx0XHRcdGFyZ3MucHVzaCh0aGlzLmNvbXBsZXRlZCk7XG5cdFx0XHR0aGlzLmVycm9ycy5sZW5ndGggJiYgYXJncy5wdXNoKHRoaXMuZXJyb3JzKTtcblx0XHRcdG8ub25Db21wbGV0ZS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKmpzaGludCB2YWxpZHRoaXM6ZmFsc2UgKi9cblxuXHQvKipcblx0ICogU3RhdGljIG1ldGhvZCB0aGF0IGxvYWRzIGltYWdlcyBsYXppbHkgZnJvbSBET00gYmFzZWQgdXBvbiBkYXRhLXByZWxvYWQgYXR0cmlidXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zPSBvcHRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gUHJlTG9hZGVyXG5cdCAqIEByZXR1cm5zIHtQcmVMb2FkZXJ9IGluc3RhbmNlXG5cdCAqL1xuXHRQcmVMb2FkZXIubGF6eUxvYWQgPSBmdW5jdGlvbihvcHRpb25zKXtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge307XG5cblx0XHR2YXIgbGF6eUltYWdlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwob3B0aW9ucy5zZWxlY3RvciB8fCAnaW1nW2RhdGEtcHJlbG9hZF0nKSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IGxhenlJbWFnZXMubGVuZ3RoLFxuXHRcdFx0dG9Mb2FkID0gW10sXG5cdFx0XHRvbGRQcm9ncmVzcztcblxuXHRcdGZvciAoOyBpIDwgbDsgaSsrKSB0b0xvYWQucHVzaChsYXp5SW1hZ2VzW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1wcmVsb2FkJykpO1xuXG5cdFx0b3B0aW9ucy5vblByb2dyZXNzICYmIChvbGRQcm9ncmVzcyA9IG9wdGlvbnMub25Qcm9ncmVzcyk7XG5cdFx0b3B0aW9ucy5vblByb2dyZXNzID0gZnVuY3Rpb24oaXRlbSwgaW1nRWwsIGluZGV4KXtcblx0XHRcdGxhenlJbWFnZXNbaW5kZXgtMV0uc3JjID0gaXRlbTtcblx0XHRcdGxhenlJbWFnZXNbaW5kZXgtMV0ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXByZWxvYWQnKTtcblx0XHRcdG9sZFByb2dyZXNzICYmIG9sZFByb2dyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblxuXHRcdHJldHVybiB0b0xvYWQubGVuZ3RoID8gbmV3IFByZUxvYWRlcih0b0xvYWQsIG9wdGlvbnMpIDogbnVsbDtcblx0fTtcblxuXHRpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKXtcblx0XHQvLyB3ZSBoYXZlIGFuIEFNRCBsb2FkZXIuXG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gUHJlTG9hZGVyO1xuXHRcdH0pO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHRoaXMucHJlTG9hZGVyID0gUHJlTG9hZGVyO1xuXHR9XG59KS5jYWxsKHRoaXMpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ByZS1sb2FkZXIvcHJlLWxvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XHJcbnZhciBuYXRpb25EYXRhID0gcmVxdWlyZShcIi4vZGF0YS9zdHVkeURhdGFcIik7XHJcbnZhciB0YXNrTGlzdCA9IHJlcXVpcmUoXCIuL3Rhc2tzL3Rhc2tMaXN0XCIpO1xyXG5cclxuZnVuY3Rpb24gaW5pdFRhc2tzKCkge1xyXG5cclxuICBuYXRpb25EYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpeyBcclxuICAgIGQub3JpZ19jb2RlID0gZC5jb2RlO1xyXG4gIH0pO1xyXG5cclxuICBnbG9iYWxzLnRyaWFscyA9IHRhc2tMaXN0W2dsb2JhbHMub3JkZXJpbmddOyAgICBcclxuXHJcbiAgbWF4X3RyaWFscyA9IGdsb2JhbHMudHJpYWxzLmxlbmd0aDtcclxuXHJcbiAgLy8gZ2xvYmFscy50cmlhbHMgPSB0dXRvcmlhbF90YXNrcy5jb25jYXQodGVzdF90YXNrcyk7XHJcbiAgY29uc29sZS5sb2coJ3Rhc2tfbGlzdCcsIGdsb2JhbHMudHJpYWxzKTtcclxuXHJcbiAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRCwgXHJcbiAgICBcInBhcnRpY2lwYW50XCI6IGdsb2JhbHMucGFydGljaXBhbnQsXHJcbiAgICBcIm9yZGVyaW5nXCI6IGdsb2JhbHMub3JkZXJpbmcsXHJcbiAgICBcImNvbmRpdGlvblwiOiBnbG9iYWxzLmNvbmRpdGlvbixcclxuICAgIFwiRXZlbnRcIjpcIkxvYWRcIixcclxuICAgIFwiV2lkdGhcIjogd2luZG93LmlubmVyV2lkdGgsIFxyXG4gICAgXCJIZWlnaHRcIjogd2luZG93LmlubmVySGVpZ2h0LFxyXG4gICAgXCJNb2RlXCI6ICh3aW5kb3cuaW5uZXJXaWR0aCA+IHdpbmRvdy5pbm5lckhlaWdodCkgPyAnbGFuZHNjYXBlJyA6ICdwb3J0cmFpdCdcclxuICB9O1xyXG5cclxuICBjb25zb2xlLmxvZyhcIkxvYWRcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBpbml0VGFza3M7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW5pdFRhc2tzLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciB0YXNrTGlzdCA9IFtcclxuXHQvLyBbICBcclxuXHQvLyBcdHtcclxuXHQvLyBcdFx0XCJ0YXNrX2luZGV4XCI6IC0zLFxyXG5cdC8vIFx0XHRcInhcIjogXCJFbmVyZ3kgQ29uc3VtcHRpb25cIixcclxuXHQvLyBcdFx0XCJ5XCI6IFwiR0RQIFBlciBDYXBpdGFcIixcclxuXHQvLyBcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgdGhlIGNvdW50cnkgdGhhdCBoYWQgdGhlIGxhcmdlc3QgY2hhbmdlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+R0RQIFBlciBDYXBpdGE8L3NwYW4+LlwiLFxyXG5cdC8vIFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHQvLyBcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXCJOb3J3YXlcIl0sXHJcblx0Ly8gXHRcdFwieWVhck1pblwiOiAxOTgwLFxyXG5cdC8vIFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHQvLyBcdFx0XCJ0dXRvcmlhbFwiOiB0cnVlLFxyXG5cdC8vIFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdC8vIFx0fSxcclxuXHQvLyBcdHtcclxuXHQvLyBcdFx0XCJ0YXNrX2luZGV4XCI6IC0yLFxyXG5cdC8vIFx0XHRcInhcIjogXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCIsXHJcblx0Ly8gXHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0Ly8gXHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnRocmVlPC9zcGFuPiBjb3VudHJpZXMgd2l0aCByYXBpZCBncm93dGggaW4gdGhlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyczwvc3Bhbj4gYmV0d2VlbiAxOTg1IGFuZCAyMDAwLlwiLFxyXG5cdC8vIFx0XHRcIm51bV9yZXNwb25zZXNcIjogMyxcclxuXHQvLyBcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXCJEZW5tYXJrXCIsXCJJY2VsYW5kXCIsXCJOb3J3YXlcIixcIlN3ZWRlblwiLFwiVW5pdGVkIFN0YXRlc1wiLFwiQXVzdHJhbGlhXCJdLFxyXG5cdC8vIFx0XHRcInllYXJNaW5cIjogMTk4NSxcclxuXHQvLyBcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0Ly8gXHRcdFwidHV0b3JpYWxcIjogdHJ1ZSxcclxuXHQvLyBcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHQvLyBcdH0sXHJcblx0Ly8gXHR7XHJcblx0Ly8gXHRcdFwidGFza19pbmRleFwiOiAtMSxcclxuXHQvLyBcdFx0XCJ4XCI6IFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiLFxyXG5cdC8vIFx0XHRcInlcIjogXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuXHQvLyBcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+b25lPC9zcGFuPiBmb28gY291bnRyeSB3aXRoIGxpdHRsZSBncm93dGggaW4gdGhlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyczwvc3Bhbj4uXCIsXHJcblx0Ly8gXHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdC8vIFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcIkh1bmdhcnlcIl0sXHJcblx0Ly8gXHRcdFwieWVhck1pblwiOiAxOTg1LFxyXG5cdC8vIFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHQvLyBcdFx0XCJ0dXRvcmlhbFwiOiB0cnVlLFxyXG5cdC8vIFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdC8vIFx0fSxcclxuXHQvLyBcdHtcclxuXHQvLyBcdFx0XCJ0YXNrX2luZGV4XCI6IDAsXHJcblx0Ly8gXHRcdFwieFwiOiBcIlBvcHVsYXRpb25cIixcclxuXHQvLyBcdFx0XCJ5XCI6IFwiR0RQIFBlciBDYXBpdGFcIixcclxuXHQvLyBcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgdGhlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIGhhdmluZyB0aGUgbGFyZ2VzdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPlBvcHVsYXRpb248L3NwYW4+IGluIHRoZSB5ZWFyIDIwMDAuXCIsXHJcblx0Ly8gXHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAyLFxyXG5cdC8vIFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcIkluZGlhXCIsXCJDaGluYVwiXSxcclxuXHQvLyBcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0Ly8gXHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdC8vIFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdC8vIFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiB0cnVlXHJcblx0Ly8gXHR9LFxyXG5cdC8vIFx0e1xyXG5cdC8vIFx0XHRcInRhc2tfaW5kZXhcIjogMSxcclxuXHQvLyBcdFx0XCJ4XCI6IFwiSW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb25cIixcclxuXHQvLyBcdFx0XCJ5XCI6IFwiSW5kZXhlZCBHRFBcIixcclxuXHQvLyBcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+dHdvPC9zcGFuPiBjb3VudHJpZXMgd2hvc2UgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5JbmRleGVkIEVuZXJneSBDb25zdW1wdGlvbjwvc3Bhbj4gZ3JldyBmYXN0ZXIgdGhhbiB0aGVpciA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgR0RQPC9zcGFuPi5cIixcclxuXHQvLyBcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0Ly8gXHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1wiSW5kaWFcIixcIkNoaW5hXCJdLFxyXG5cdC8vIFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHQvLyBcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0Ly8gXHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0Ly8gXHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0Ly8gXHR9LFxyXG5cdC8vIFx0e1xyXG5cdC8vIFx0XHRcInRhc2tfaW5kZXhcIjogMixcclxuXHQvLyBcdFx0XCJ4XCI6IFwiRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0Ly8gXHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0Ly8gXHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnRocmVlPC9zcGFuPiBjb3VudHJpZXMgdGhhdCBoYWQgbGl0dGxlIGNoYW5nZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkdEUCBQZXIgQ2FwaXRhPC9zcGFuPi5cIixcclxuXHQvLyBcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDMsXHJcblx0Ly8gXHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1wiR2FtYmlhXCIsXCJMaWJlcmlhXCIsXCJSd2FuZGFcIl0sXHJcblx0Ly8gXHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdC8vIFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHQvLyBcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHQvLyBcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHQvLyBcdH0sXHRcclxuXHQvLyBcdHtcclxuXHQvLyBcdFx0XCJ0YXNrX2luZGV4XCI6IDMsXHJcblx0Ly8gXHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdC8vIFx0XHRcInlcIjogXCJJbmZhbnQgTW9ydGFsaXR5XCIsXHJcblx0Ly8gXHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB3aXRoIGEgZGVjcmVhc2luZyA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUsIGJ1dCBsaXR0bGUgY2hhbmdlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TGlmZSBFeHBlY3RhbmN5PC9zcGFuPi5cIixcclxuXHQvLyBcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0Ly8gXHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1wiSHVuZ2FyeVwiXSxcclxuXHQvLyBcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0Ly8gXHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdC8vIFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdC8vIFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdC8vIFx0fSxcclxuXHQvLyBcdHtcclxuXHQvLyBcdFx0XCJ0YXNrX2luZGV4XCI6IDQsXHJcblx0Ly8gXHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdC8vIFx0XHRcInlcIjogXCJJbmZhbnQgTW9ydGFsaXR5XCIsXHJcblx0Ly8gXHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIHdob3NlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5mYW50IE1vcnRhbGl0eTwvc3Bhbj4gcmF0ZSBkZWNyZWFzZWQgZmlyc3QsIHRoZW4gaW5jcmVhc2VkIGxhdGVyLlwiLFxyXG5cdC8vIFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHQvLyBcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXCJMaWJlcmlhXCIsXCJSd2FuZGFcIl0sXHJcblx0Ly8gXHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdC8vIFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHQvLyBcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHQvLyBcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHQvLyBcdH0sXHJcblx0Ly8gXHR7XHJcblx0Ly8gXHRcdFwidGFza19pbmRleFwiOiA1LFxyXG5cdC8vIFx0XHRcInhcIjogXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuXHQvLyBcdFx0XCJ5XCI6IFwiSW5mYW50IE1vcnRhbGl0eVwiLFxyXG5cdC8vIFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUgZGVjcmVhc2VkIHRoZSBtb3N0LlwiLFxyXG5cdC8vIFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHQvLyBcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXCJHYW1iaWFcIixcIlNhdWRpIEFyYWJpYVwiXSxcclxuXHQvLyBcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0Ly8gXHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdC8vIFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdC8vIFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdC8vIFx0fSxcclxuXHQvLyBcdHtcclxuXHQvLyBcdFx0XCJ0YXNrX2luZGV4XCI6IDYsXHJcblx0Ly8gXHRcdFwieFwiOiBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0Ly8gXHRcdFwieVwiOiBcIkluZGV4ZWQgUG9wdWxhdGlvblwiLFxyXG5cdC8vIFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgUG9wdWxhdGlvbjwvc3Bhbj4gZ3JldyBmYXN0ZXIgdGhhbiB0aGVpciA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uPC9zcGFuPi5cIixcclxuXHQvLyBcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0Ly8gXHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1wiSW5kaWFcIixcIkNoaW5hXCJdLFxyXG5cdC8vIFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHQvLyBcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0Ly8gXHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0Ly8gXHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0Ly8gXHR9LFxyXG5cdC8vIFx0e1xyXG5cdC8vIFx0XHRcInRhc2tfaW5kZXhcIjogNyxcclxuXHQvLyBcdFx0XCJ4XCI6IFwiTGlmZSBFeHBlY3RhbmN5IChXb21lbilcIixcclxuXHQvLyBcdFx0XCJ5XCI6IFwiTGlmZSBFeHBlY3RhbmN5IChNZW4pXCIsXHJcblx0Ly8gXHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB3aGVyZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkxpZmUgRXhwZWN0YW5jeTwvc3Bhbj4gKDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+V29tZW48L3NwYW4+ICYgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5NZW48L3NwYW4+KSBpbmNyZWFzZWQgZmlyc3QgYW5kIGRlY3JlYXNlZCBsYXRlci5cIixcclxuXHQvLyBcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0Ly8gXHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1wiTGliZXJpYVwiLFwiUndhbmRhXCJdLFxyXG5cdC8vIFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHQvLyBcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0Ly8gXHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0Ly8gXHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0Ly8gXHR9LFxyXG5cdC8vIFx0e1xyXG5cdC8vIFx0XHRcInRhc2tfaW5kZXhcIjogOCxcclxuXHQvLyBcdFx0XCJ4XCI6IFwiQXJhYmxlIEFyZWFcIixcclxuXHQvLyBcdFx0XCJ5XCI6IFwiUG9wdWxhdGlvblwiLFxyXG5cdC8vIFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz5vbmU8L3NwYW4+IGNvdW50cnkgdGhhdCBoYWQgYSBkZWNyZWFzZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkFyYWJsZSBBcmVhPC9zcGFuPiwgZXZlbiBhcyB0aGVpciA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPlBvcHVsYXRpb248L3NwYW4+IGluY3JlYXNlZC5cIixcclxuXHQvLyBcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0Ly8gXHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1wiVW5pdGVkIFN0YXRlc1wiXSxcclxuXHQvLyBcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0Ly8gXHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdC8vIFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdC8vIFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdC8vIFx0fSxcclxuXHQvLyBcdHtcclxuXHQvLyBcdFx0XCJ0YXNrX2luZGV4XCI6IDksXHJcblx0Ly8gXHRcdFwieFwiOiBcIkFyYWJsZSBBcmVhXCIsXHJcblx0Ly8gXHRcdFwieVwiOiBcIlBvcHVsYXRpb25cIixcclxuXHQvLyBcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+b25lPC9zcGFuPiBjb3VudHJ5IHRoYXQgaGFkIGFuIGluY3JlYXNlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+QXJhYmxlIEFyZWE8L3NwYW4+LCBidXQgb25seSBhIHNsaWdodCBpbmNyZWFzZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPlBvcHVsYXRpb248L3NwYW4+LlwiLFxyXG5cdC8vIFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHQvLyBcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXCJBdXN0cmFsaWFcIl0sXHJcblx0Ly8gXHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdC8vIFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHQvLyBcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHQvLyBcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHQvLyBcdH1cclxuXHQvLyBdLFxyXG5cdFtcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IC0zLFxyXG5cdFx0XHRcInhcIjogXCJFbmVyZ3kgQ29uc3VtcHRpb25cIixcclxuXHRcdFx0XCJ5XCI6IFwiR0RQIFBlciBDYXBpdGFcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgdGhlIGNvdW50cnkgdGhhdCBoYWQgdGhlIGxhcmdlc3QgY2hhbmdlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+R0RQIFBlciBDYXBpdGE8L3NwYW4+LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJOb3J3YXlcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk4MCxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogdHJ1ZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAtMixcclxuXHRcdFx0XCJ4XCI6IFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiLFxyXG5cdFx0XHRcInlcIjogXCJHRFAgUGVyIENhcGl0YVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50aHJlZTwvc3Bhbj4gY291bnRyaWVzIHdpdGggcmFwaWQgZ3Jvd3RoIGluIHRoZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnM8L3NwYW4+IGJldHdlZW4gMTk4NSBhbmQgMjAwMC5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDMsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiRGVubWFya1wiLFxyXG5cdFx0XHRcdFwiSWNlbGFuZFwiLFxyXG5cdFx0XHRcdFwiTm9yd2F5XCIsXHJcblx0XHRcdFx0XCJTd2VkZW5cIixcclxuXHRcdFx0XHRcIlVuaXRlZCBTdGF0ZXNcIixcclxuXHRcdFx0XHRcIkF1c3RyYWxpYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTg1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiB0cnVlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IC0xLFxyXG5cdFx0XHRcInhcIjogXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCIsXHJcblx0XHRcdFwieVwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz5vbmU8L3NwYW4+IGZvbyBjb3VudHJ5IHdpdGggbGl0dGxlIGdyb3d0aCBpbiB0aGUgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5OdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSHVuZ2FyeVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTg1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiB0cnVlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDEsXHJcblx0XHRcdFwieFwiOiBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkluZGV4ZWQgR0RQXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIHdob3NlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb248L3NwYW4+IGdyZXcgZmFzdGVyIHRoYW4gdGhlaXIgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5JbmRleGVkIEdEUDwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAyLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkluZGlhXCIsXHJcblx0XHRcdFx0XCJDaGluYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAwLFxyXG5cdFx0XHRcInhcIjogXCJQb3B1bGF0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IHRoZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyBoYXZpbmcgdGhlIGxhcmdlc3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5Qb3B1bGF0aW9uPC9zcGFuPiBpbiB0aGUgeWVhciAyMDAwLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJJbmRpYVwiLFxyXG5cdFx0XHRcdFwiQ2hpbmFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IHRydWVcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAzLFxyXG5cdFx0XHRcInhcIjogXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuXHRcdFx0XCJ5XCI6IFwiSW5mYW50IE1vcnRhbGl0eVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz5vbmU8L3NwYW4+IGNvdW50cnkgd2l0aCBhIGRlY3JlYXNpbmcgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5JbmZhbnQgTW9ydGFsaXR5PC9zcGFuPiByYXRlLCBidXQgbGl0dGxlIGNoYW5nZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkxpZmUgRXhwZWN0YW5jeTwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkh1bmdhcnlcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogOSxcclxuXHRcdFx0XCJ4XCI6IFwiQXJhYmxlIEFyZWFcIixcclxuXHRcdFx0XCJ5XCI6IFwiUG9wdWxhdGlvblwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz5vbmU8L3NwYW4+IGNvdW50cnkgdGhhdCBoYWQgYW4gaW5jcmVhc2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5BcmFibGUgQXJlYTwvc3Bhbj4sIGJ1dCBvbmx5IGEgc2xpZ2h0IGluY3JlYXNlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+UG9wdWxhdGlvbjwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkF1c3RyYWxpYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA0LFxyXG5cdFx0XHRcInhcIjogXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuXHRcdFx0XCJ5XCI6IFwiSW5mYW50IE1vcnRhbGl0eVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUgZGVjcmVhc2VkIGZpcnN0LCB0aGVuIGluY3JlYXNlZCBsYXRlci5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiTGliZXJpYVwiLFxyXG5cdFx0XHRcdFwiUndhbmRhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDgsXHJcblx0XHRcdFwieFwiOiBcIkFyYWJsZSBBcmVhXCIsXHJcblx0XHRcdFwieVwiOiBcIlBvcHVsYXRpb25cIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+b25lPC9zcGFuPiBjb3VudHJ5IHRoYXQgaGFkIGEgZGVjcmVhc2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5BcmFibGUgQXJlYTwvc3Bhbj4sIGV2ZW4gYXMgdGhlaXIgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5Qb3B1bGF0aW9uPC9zcGFuPiBpbmNyZWFzZWQuXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIlVuaXRlZCBTdGF0ZXNcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogMixcclxuXHRcdFx0XCJ4XCI6IFwiRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnRocmVlPC9zcGFuPiBjb3VudHJpZXMgdGhhdCBoYWQgbGl0dGxlIGNoYW5nZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkdEUCBQZXIgQ2FwaXRhPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDMsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiR2FtYmlhXCIsXHJcblx0XHRcdFx0XCJMaWJlcmlhXCIsXHJcblx0XHRcdFx0XCJSd2FuZGFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogNyxcclxuXHRcdFx0XCJ4XCI6IFwiTGlmZSBFeHBlY3RhbmN5IChXb21lbilcIixcclxuXHRcdFx0XCJ5XCI6IFwiTGlmZSBFeHBlY3RhbmN5IChNZW4pXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB3aGVyZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkxpZmUgRXhwZWN0YW5jeTwvc3Bhbj4gKDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+V29tZW48L3NwYW4+ICYgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5NZW48L3NwYW4+KSBpbmNyZWFzZWQgZmlyc3QgYW5kIGRlY3JlYXNlZCBsYXRlci5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiTGliZXJpYVwiLFxyXG5cdFx0XHRcdFwiUndhbmRhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDUsXHJcblx0XHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdFx0XHRcInlcIjogXCJJbmZhbnQgTW9ydGFsaXR5XCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIHdob3NlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5mYW50IE1vcnRhbGl0eTwvc3Bhbj4gcmF0ZSBkZWNyZWFzZWQgdGhlIG1vc3QuXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAyLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkdhbWJpYVwiLFxyXG5cdFx0XHRcdFwiU2F1ZGkgQXJhYmlhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDYsXHJcblx0XHRcdFwieFwiOiBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkluZGV4ZWQgUG9wdWxhdGlvblwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgUG9wdWxhdGlvbjwvc3Bhbj4gZ3JldyBmYXN0ZXIgdGhhbiB0aGVpciA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSW5kaWFcIixcclxuXHRcdFx0XHRcIkNoaW5hXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fVxyXG5cdF0sXHJcblx0W1xyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogLTMsXHJcblx0XHRcdFwieFwiOiBcIkVuZXJneSBDb25zdW1wdGlvblwiLFxyXG5cdFx0XHRcInlcIjogXCJHRFAgUGVyIENhcGl0YVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCB0aGUgY291bnRyeSB0aGF0IGhhZCB0aGUgbGFyZ2VzdCBjaGFuZ2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5HRFAgUGVyIENhcGl0YTwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIk5vcndheVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTgwLFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiB0cnVlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IC0yLFxyXG5cdFx0XHRcInhcIjogXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCIsXHJcblx0XHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnRocmVlPC9zcGFuPiBjb3VudHJpZXMgd2l0aCByYXBpZCBncm93dGggaW4gdGhlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyczwvc3Bhbj4gYmV0d2VlbiAxOTg1IGFuZCAyMDAwLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMyxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJEZW5tYXJrXCIsXHJcblx0XHRcdFx0XCJJY2VsYW5kXCIsXHJcblx0XHRcdFx0XCJOb3J3YXlcIixcclxuXHRcdFx0XHRcIlN3ZWRlblwiLFxyXG5cdFx0XHRcdFwiVW5pdGVkIFN0YXRlc1wiLFxyXG5cdFx0XHRcdFwiQXVzdHJhbGlhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5ODUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IHRydWUsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogLTEsXHJcblx0XHRcdFwieFwiOiBcIk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnNcIixcclxuXHRcdFx0XCJ5XCI6IFwiTGlmZSBFeHBlY3RhbmN5XCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gZm9vIGNvdW50cnkgd2l0aCBsaXR0bGUgZ3Jvd3RoIGluIHRoZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnM8L3NwYW4+LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJIdW5nYXJ5XCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5ODUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IHRydWUsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogMyxcclxuXHRcdFx0XCJ4XCI6IFwiTGlmZSBFeHBlY3RhbmN5XCIsXHJcblx0XHRcdFwieVwiOiBcIkluZmFudCBNb3J0YWxpdHlcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+b25lPC9zcGFuPiBjb3VudHJ5IHdpdGggYSBkZWNyZWFzaW5nIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5mYW50IE1vcnRhbGl0eTwvc3Bhbj4gcmF0ZSwgYnV0IGxpdHRsZSBjaGFuZ2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5MaWZlIEV4cGVjdGFuY3k8L3NwYW4+LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJIdW5nYXJ5XCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDYsXHJcblx0XHRcdFwieFwiOiBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkluZGV4ZWQgUG9wdWxhdGlvblwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgUG9wdWxhdGlvbjwvc3Bhbj4gZ3JldyBmYXN0ZXIgdGhhbiB0aGVpciA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSW5kaWFcIixcclxuXHRcdFx0XHRcIkNoaW5hXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDQsXHJcblx0XHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdFx0XHRcInlcIjogXCJJbmZhbnQgTW9ydGFsaXR5XCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIHdob3NlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5mYW50IE1vcnRhbGl0eTwvc3Bhbj4gcmF0ZSBkZWNyZWFzZWQgZmlyc3QsIHRoZW4gaW5jcmVhc2VkIGxhdGVyLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJMaWJlcmlhXCIsXHJcblx0XHRcdFx0XCJSd2FuZGFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogOSxcclxuXHRcdFx0XCJ4XCI6IFwiQXJhYmxlIEFyZWFcIixcclxuXHRcdFx0XCJ5XCI6IFwiUG9wdWxhdGlvblwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz5vbmU8L3NwYW4+IGNvdW50cnkgdGhhdCBoYWQgYW4gaW5jcmVhc2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5BcmFibGUgQXJlYTwvc3Bhbj4sIGJ1dCBvbmx5IGEgc2xpZ2h0IGluY3JlYXNlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+UG9wdWxhdGlvbjwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkF1c3RyYWxpYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAyLFxyXG5cdFx0XHRcInhcIjogXCJFbmVyZ3kgQ29uc3VtcHRpb25cIixcclxuXHRcdFx0XCJ5XCI6IFwiR0RQIFBlciBDYXBpdGFcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+dGhyZWU8L3NwYW4+IGNvdW50cmllcyB0aGF0IGhhZCBsaXR0bGUgY2hhbmdlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+R0RQIFBlciBDYXBpdGE8L3NwYW4+LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMyxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJHYW1iaWFcIixcclxuXHRcdFx0XHRcIkxpYmVyaWFcIixcclxuXHRcdFx0XHRcIlJ3YW5kYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA4LFxyXG5cdFx0XHRcInhcIjogXCJBcmFibGUgQXJlYVwiLFxyXG5cdFx0XHRcInlcIjogXCJQb3B1bGF0aW9uXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB0aGF0IGhhZCBhIGRlY3JlYXNlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+QXJhYmxlIEFyZWE8L3NwYW4+LCBldmVuIGFzIHRoZWlyIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+UG9wdWxhdGlvbjwvc3Bhbj4gaW5jcmVhc2VkLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJVbml0ZWQgU3RhdGVzXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDcsXHJcblx0XHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeSAoV29tZW4pXCIsXHJcblx0XHRcdFwieVwiOiBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz5vbmU8L3NwYW4+IGNvdW50cnkgd2hlcmUgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5MaWZlIEV4cGVjdGFuY3k8L3NwYW4+ICg8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPldvbWVuPC9zcGFuPiAmIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TWVuPC9zcGFuPikgaW5jcmVhc2VkIGZpcnN0IGFuZCBkZWNyZWFzZWQgbGF0ZXIuXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkxpYmVyaWFcIixcclxuXHRcdFx0XHRcIlJ3YW5kYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAwLFxyXG5cdFx0XHRcInhcIjogXCJQb3B1bGF0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IHRoZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyBoYXZpbmcgdGhlIGxhcmdlc3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5Qb3B1bGF0aW9uPC9zcGFuPiBpbiB0aGUgeWVhciAyMDAwLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJJbmRpYVwiLFxyXG5cdFx0XHRcdFwiQ2hpbmFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IHRydWVcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA1LFxyXG5cdFx0XHRcInhcIjogXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuXHRcdFx0XCJ5XCI6IFwiSW5mYW50IE1vcnRhbGl0eVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUgZGVjcmVhc2VkIHRoZSBtb3N0LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJHYW1iaWFcIixcclxuXHRcdFx0XHRcIlNhdWRpIEFyYWJpYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAxLFxyXG5cdFx0XHRcInhcIjogXCJJbmRleGVkIEVuZXJneSBDb25zdW1wdGlvblwiLFxyXG5cdFx0XHRcInlcIjogXCJJbmRleGVkIEdEUFwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uPC9zcGFuPiBncmV3IGZhc3RlciB0aGFuIHRoZWlyIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5kZXhlZCBHRFA8L3NwYW4+LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJJbmRpYVwiLFxyXG5cdFx0XHRcdFwiQ2hpbmFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9XHJcblx0XSxcclxuXHRbXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAtMyxcclxuXHRcdFx0XCJ4XCI6IFwiRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IHRoZSBjb3VudHJ5IHRoYXQgaGFkIHRoZSBsYXJnZXN0IGNoYW5nZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkdEUCBQZXIgQ2FwaXRhPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiTm9yd2F5XCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5ODAsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IHRydWUsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogLTIsXHJcblx0XHRcdFwieFwiOiBcIk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnNcIixcclxuXHRcdFx0XCJ5XCI6IFwiR0RQIFBlciBDYXBpdGFcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+dGhyZWU8L3NwYW4+IGNvdW50cmllcyB3aXRoIHJhcGlkIGdyb3d0aCBpbiB0aGUgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5OdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzPC9zcGFuPiBiZXR3ZWVuIDE5ODUgYW5kIDIwMDAuXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAzLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkRlbm1hcmtcIixcclxuXHRcdFx0XHRcIkljZWxhbmRcIixcclxuXHRcdFx0XHRcIk5vcndheVwiLFxyXG5cdFx0XHRcdFwiU3dlZGVuXCIsXHJcblx0XHRcdFx0XCJVbml0ZWQgU3RhdGVzXCIsXHJcblx0XHRcdFx0XCJBdXN0cmFsaWFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk4NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogdHJ1ZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAtMSxcclxuXHRcdFx0XCJ4XCI6IFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiLFxyXG5cdFx0XHRcInlcIjogXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+b25lPC9zcGFuPiBmb28gY291bnRyeSB3aXRoIGxpdHRsZSBncm93dGggaW4gdGhlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyczwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkh1bmdhcnlcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk4NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogdHJ1ZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA0LFxyXG5cdFx0XHRcInhcIjogXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuXHRcdFx0XCJ5XCI6IFwiSW5mYW50IE1vcnRhbGl0eVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUgZGVjcmVhc2VkIGZpcnN0LCB0aGVuIGluY3JlYXNlZCBsYXRlci5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiTGliZXJpYVwiLFxyXG5cdFx0XHRcdFwiUndhbmRhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDEsXHJcblx0XHRcdFwieFwiOiBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkluZGV4ZWQgR0RQXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIHdob3NlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb248L3NwYW4+IGdyZXcgZmFzdGVyIHRoYW4gdGhlaXIgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5JbmRleGVkIEdEUDwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAyLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkluZGlhXCIsXHJcblx0XHRcdFx0XCJDaGluYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA1LFxyXG5cdFx0XHRcInhcIjogXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuXHRcdFx0XCJ5XCI6IFwiSW5mYW50IE1vcnRhbGl0eVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUgZGVjcmVhc2VkIHRoZSBtb3N0LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJHYW1iaWFcIixcclxuXHRcdFx0XHRcIlNhdWRpIEFyYWJpYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA5LFxyXG5cdFx0XHRcInhcIjogXCJBcmFibGUgQXJlYVwiLFxyXG5cdFx0XHRcInlcIjogXCJQb3B1bGF0aW9uXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB0aGF0IGhhZCBhbiBpbmNyZWFzZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkFyYWJsZSBBcmVhPC9zcGFuPiwgYnV0IG9ubHkgYSBzbGlnaHQgaW5jcmVhc2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5Qb3B1bGF0aW9uPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiQXVzdHJhbGlhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDMsXHJcblx0XHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdFx0XHRcInlcIjogXCJJbmZhbnQgTW9ydGFsaXR5XCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB3aXRoIGEgZGVjcmVhc2luZyA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUsIGJ1dCBsaXR0bGUgY2hhbmdlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TGlmZSBFeHBlY3RhbmN5PC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSHVuZ2FyeVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAwLFxyXG5cdFx0XHRcInhcIjogXCJQb3B1bGF0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IHRoZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyBoYXZpbmcgdGhlIGxhcmdlc3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5Qb3B1bGF0aW9uPC9zcGFuPiBpbiB0aGUgeWVhciAyMDAwLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJJbmRpYVwiLFxyXG5cdFx0XHRcdFwiQ2hpbmFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IHRydWVcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA3LFxyXG5cdFx0XHRcInhcIjogXCJMaWZlIEV4cGVjdGFuY3kgKFdvbWVuKVwiLFxyXG5cdFx0XHRcInlcIjogXCJMaWZlIEV4cGVjdGFuY3kgKE1lbilcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+b25lPC9zcGFuPiBjb3VudHJ5IHdoZXJlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TGlmZSBFeHBlY3RhbmN5PC9zcGFuPiAoPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5Xb21lbjwvc3Bhbj4gJiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPk1lbjwvc3Bhbj4pIGluY3JlYXNlZCBmaXJzdCBhbmQgZGVjcmVhc2VkIGxhdGVyLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJMaWJlcmlhXCIsXHJcblx0XHRcdFx0XCJSd2FuZGFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogMixcclxuXHRcdFx0XCJ4XCI6IFwiRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnRocmVlPC9zcGFuPiBjb3VudHJpZXMgdGhhdCBoYWQgbGl0dGxlIGNoYW5nZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkdEUCBQZXIgQ2FwaXRhPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDMsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiR2FtYmlhXCIsXHJcblx0XHRcdFx0XCJMaWJlcmlhXCIsXHJcblx0XHRcdFx0XCJSd2FuZGFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogOCxcclxuXHRcdFx0XCJ4XCI6IFwiQXJhYmxlIEFyZWFcIixcclxuXHRcdFx0XCJ5XCI6IFwiUG9wdWxhdGlvblwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz5vbmU8L3NwYW4+IGNvdW50cnkgdGhhdCBoYWQgYSBkZWNyZWFzZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkFyYWJsZSBBcmVhPC9zcGFuPiwgZXZlbiBhcyB0aGVpciA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPlBvcHVsYXRpb248L3NwYW4+IGluY3JlYXNlZC5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiVW5pdGVkIFN0YXRlc1wiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA2LFxyXG5cdFx0XHRcInhcIjogXCJJbmRleGVkIEVuZXJneSBDb25zdW1wdGlvblwiLFxyXG5cdFx0XHRcInlcIjogXCJJbmRleGVkIFBvcHVsYXRpb25cIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+dHdvPC9zcGFuPiBjb3VudHJpZXMgd2hvc2UgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5JbmRleGVkIFBvcHVsYXRpb248L3NwYW4+IGdyZXcgZmFzdGVyIHRoYW4gdGhlaXIgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5JbmRleGVkIEVuZXJneSBDb25zdW1wdGlvbjwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAyLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkluZGlhXCIsXHJcblx0XHRcdFx0XCJDaGluYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH1cclxuXHRdLFxyXG5cdFtcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IC0zLFxyXG5cdFx0XHRcInhcIjogXCJFbmVyZ3kgQ29uc3VtcHRpb25cIixcclxuXHRcdFx0XCJ5XCI6IFwiR0RQIFBlciBDYXBpdGFcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgdGhlIGNvdW50cnkgdGhhdCBoYWQgdGhlIGxhcmdlc3QgY2hhbmdlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+R0RQIFBlciBDYXBpdGE8L3NwYW4+LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJOb3J3YXlcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk4MCxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogdHJ1ZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAtMixcclxuXHRcdFx0XCJ4XCI6IFwiTnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyc1wiLFxyXG5cdFx0XHRcInlcIjogXCJHRFAgUGVyIENhcGl0YVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50aHJlZTwvc3Bhbj4gY291bnRyaWVzIHdpdGggcmFwaWQgZ3Jvd3RoIGluIHRoZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnM8L3NwYW4+IGJldHdlZW4gMTk4NSBhbmQgMjAwMC5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDMsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiRGVubWFya1wiLFxyXG5cdFx0XHRcdFwiSWNlbGFuZFwiLFxyXG5cdFx0XHRcdFwiTm9yd2F5XCIsXHJcblx0XHRcdFx0XCJTd2VkZW5cIixcclxuXHRcdFx0XHRcIlVuaXRlZCBTdGF0ZXNcIixcclxuXHRcdFx0XHRcIkF1c3RyYWxpYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTg1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiB0cnVlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IC0xLFxyXG5cdFx0XHRcInhcIjogXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCIsXHJcblx0XHRcdFwieVwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz5vbmU8L3NwYW4+IGZvbyBjb3VudHJ5IHdpdGggbGl0dGxlIGdyb3d0aCBpbiB0aGUgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5OdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSHVuZ2FyeVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTg1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiB0cnVlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDYsXHJcblx0XHRcdFwieFwiOiBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkluZGV4ZWQgUG9wdWxhdGlvblwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgUG9wdWxhdGlvbjwvc3Bhbj4gZ3JldyBmYXN0ZXIgdGhhbiB0aGVpciA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSW5kaWFcIixcclxuXHRcdFx0XHRcIkNoaW5hXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDgsXHJcblx0XHRcdFwieFwiOiBcIkFyYWJsZSBBcmVhXCIsXHJcblx0XHRcdFwieVwiOiBcIlBvcHVsYXRpb25cIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+b25lPC9zcGFuPiBjb3VudHJ5IHRoYXQgaGFkIGEgZGVjcmVhc2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5BcmFibGUgQXJlYTwvc3Bhbj4sIGV2ZW4gYXMgdGhlaXIgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5Qb3B1bGF0aW9uPC9zcGFuPiBpbmNyZWFzZWQuXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIlVuaXRlZCBTdGF0ZXNcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogNSxcclxuXHRcdFx0XCJ4XCI6IFwiTGlmZSBFeHBlY3RhbmN5XCIsXHJcblx0XHRcdFwieVwiOiBcIkluZmFudCBNb3J0YWxpdHlcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+dHdvPC9zcGFuPiBjb3VudHJpZXMgd2hvc2UgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5JbmZhbnQgTW9ydGFsaXR5PC9zcGFuPiByYXRlIGRlY3JlYXNlZCB0aGUgbW9zdC5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiR2FtYmlhXCIsXHJcblx0XHRcdFx0XCJTYXVkaSBBcmFiaWFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogMCxcclxuXHRcdFx0XCJ4XCI6IFwiUG9wdWxhdGlvblwiLFxyXG5cdFx0XHRcInlcIjogXCJHRFAgUGVyIENhcGl0YVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCB0aGUgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+dHdvPC9zcGFuPiBjb3VudHJpZXMgaGF2aW5nIHRoZSBsYXJnZXN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+UG9wdWxhdGlvbjwvc3Bhbj4gaW4gdGhlIHllYXIgMjAwMC5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSW5kaWFcIixcclxuXHRcdFx0XHRcIkNoaW5hXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiB0cnVlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogNyxcclxuXHRcdFx0XCJ4XCI6IFwiTGlmZSBFeHBlY3RhbmN5IChXb21lbilcIixcclxuXHRcdFx0XCJ5XCI6IFwiTGlmZSBFeHBlY3RhbmN5IChNZW4pXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB3aGVyZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkxpZmUgRXhwZWN0YW5jeTwvc3Bhbj4gKDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+V29tZW48L3NwYW4+ICYgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5NZW48L3NwYW4+KSBpbmNyZWFzZWQgZmlyc3QgYW5kIGRlY3JlYXNlZCBsYXRlci5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiTGliZXJpYVwiLFxyXG5cdFx0XHRcdFwiUndhbmRhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDMsXHJcblx0XHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdFx0XHRcInlcIjogXCJJbmZhbnQgTW9ydGFsaXR5XCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB3aXRoIGEgZGVjcmVhc2luZyA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUsIGJ1dCBsaXR0bGUgY2hhbmdlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TGlmZSBFeHBlY3RhbmN5PC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSHVuZ2FyeVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiAyLFxyXG5cdFx0XHRcInhcIjogXCJFbmVyZ3kgQ29uc3VtcHRpb25cIixcclxuXHRcdFx0XCJ5XCI6IFwiR0RQIFBlciBDYXBpdGFcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+dGhyZWU8L3NwYW4+IGNvdW50cmllcyB0aGF0IGhhZCBsaXR0bGUgY2hhbmdlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+R0RQIFBlciBDYXBpdGE8L3NwYW4+LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMyxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJHYW1iaWFcIixcclxuXHRcdFx0XHRcIkxpYmVyaWFcIixcclxuXHRcdFx0XHRcIlJ3YW5kYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA0LFxyXG5cdFx0XHRcInhcIjogXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuXHRcdFx0XCJ5XCI6IFwiSW5mYW50IE1vcnRhbGl0eVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUgZGVjcmVhc2VkIGZpcnN0LCB0aGVuIGluY3JlYXNlZCBsYXRlci5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiTGliZXJpYVwiLFxyXG5cdFx0XHRcdFwiUndhbmRhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDEsXHJcblx0XHRcdFwieFwiOiBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkluZGV4ZWQgR0RQXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIHdob3NlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb248L3NwYW4+IGdyZXcgZmFzdGVyIHRoYW4gdGhlaXIgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5JbmRleGVkIEdEUDwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAyLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkluZGlhXCIsXHJcblx0XHRcdFx0XCJDaGluYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA5LFxyXG5cdFx0XHRcInhcIjogXCJBcmFibGUgQXJlYVwiLFxyXG5cdFx0XHRcInlcIjogXCJQb3B1bGF0aW9uXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB0aGF0IGhhZCBhbiBpbmNyZWFzZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkFyYWJsZSBBcmVhPC9zcGFuPiwgYnV0IG9ubHkgYSBzbGlnaHQgaW5jcmVhc2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5Qb3B1bGF0aW9uPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiQXVzdHJhbGlhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fVxyXG5cdF0sXHJcblx0W1xyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogLTMsXHJcblx0XHRcdFwieFwiOiBcIkVuZXJneSBDb25zdW1wdGlvblwiLFxyXG5cdFx0XHRcInlcIjogXCJHRFAgUGVyIENhcGl0YVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCB0aGUgY291bnRyeSB0aGF0IGhhZCB0aGUgbGFyZ2VzdCBjaGFuZ2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5HRFAgUGVyIENhcGl0YTwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAxLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIk5vcndheVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTgwLFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiB0cnVlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IC0yLFxyXG5cdFx0XHRcInhcIjogXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCIsXHJcblx0XHRcdFwieVwiOiBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnRocmVlPC9zcGFuPiBjb3VudHJpZXMgd2l0aCByYXBpZCBncm93dGggaW4gdGhlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TnVtYmVyIG9mIFBlcnNvbmFsIENvbXB1dGVyczwvc3Bhbj4gYmV0d2VlbiAxOTg1IGFuZCAyMDAwLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMyxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJEZW5tYXJrXCIsXHJcblx0XHRcdFx0XCJJY2VsYW5kXCIsXHJcblx0XHRcdFx0XCJOb3J3YXlcIixcclxuXHRcdFx0XHRcIlN3ZWRlblwiLFxyXG5cdFx0XHRcdFwiVW5pdGVkIFN0YXRlc1wiLFxyXG5cdFx0XHRcdFwiQXVzdHJhbGlhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5ODUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IHRydWUsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogLTEsXHJcblx0XHRcdFwieFwiOiBcIk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnNcIixcclxuXHRcdFx0XCJ5XCI6IFwiTGlmZSBFeHBlY3RhbmN5XCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gZm9vIGNvdW50cnkgd2l0aCBsaXR0bGUgZ3Jvd3RoIGluIHRoZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPk51bWJlciBvZiBQZXJzb25hbCBDb21wdXRlcnM8L3NwYW4+LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJIdW5nYXJ5XCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5ODUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IHRydWUsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogNyxcclxuXHRcdFx0XCJ4XCI6IFwiTGlmZSBFeHBlY3RhbmN5IChXb21lbilcIixcclxuXHRcdFx0XCJ5XCI6IFwiTGlmZSBFeHBlY3RhbmN5IChNZW4pXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB3aGVyZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkxpZmUgRXhwZWN0YW5jeTwvc3Bhbj4gKDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+V29tZW48L3NwYW4+ICYgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5NZW48L3NwYW4+KSBpbmNyZWFzZWQgZmlyc3QgYW5kIGRlY3JlYXNlZCBsYXRlci5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiTGliZXJpYVwiLFxyXG5cdFx0XHRcdFwiUndhbmRhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDIsXHJcblx0XHRcdFwieFwiOiBcIkVuZXJneSBDb25zdW1wdGlvblwiLFxyXG5cdFx0XHRcInlcIjogXCJHRFAgUGVyIENhcGl0YVwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50aHJlZTwvc3Bhbj4gY291bnRyaWVzIHRoYXQgaGFkIGxpdHRsZSBjaGFuZ2UgaW4gPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5HRFAgUGVyIENhcGl0YTwvc3Bhbj4uXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAzLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkdhbWJpYVwiLFxyXG5cdFx0XHRcdFwiTGliZXJpYVwiLFxyXG5cdFx0XHRcdFwiUndhbmRhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDUsXHJcblx0XHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdFx0XHRcInlcIjogXCJJbmZhbnQgTW9ydGFsaXR5XCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIHdob3NlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5mYW50IE1vcnRhbGl0eTwvc3Bhbj4gcmF0ZSBkZWNyZWFzZWQgdGhlIG1vc3QuXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAyLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkdhbWJpYVwiLFxyXG5cdFx0XHRcdFwiU2F1ZGkgQXJhYmlhXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDYsXHJcblx0XHRcdFwieFwiOiBcIkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcblx0XHRcdFwieVwiOiBcIkluZGV4ZWQgUG9wdWxhdGlvblwiLFxyXG5cdFx0XHRcInByb21wdFwiOiBcIlNlbGVjdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz50d288L3NwYW4+IGNvdW50cmllcyB3aG9zZSA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgUG9wdWxhdGlvbjwvc3Bhbj4gZ3JldyBmYXN0ZXIgdGhhbiB0aGVpciA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgRW5lcmd5IENvbnN1bXB0aW9uPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSW5kaWFcIixcclxuXHRcdFx0XHRcIkNoaW5hXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDQsXHJcblx0XHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdFx0XHRcInlcIjogXCJJbmZhbnQgTW9ydGFsaXR5XCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIHdob3NlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+SW5mYW50IE1vcnRhbGl0eTwvc3Bhbj4gcmF0ZSBkZWNyZWFzZWQgZmlyc3QsIHRoZW4gaW5jcmVhc2VkIGxhdGVyLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMixcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJMaWJlcmlhXCIsXHJcblx0XHRcdFx0XCJSd2FuZGFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9LFxyXG5cdFx0e1xyXG5cdFx0XHRcInRhc2tfaW5kZXhcIjogMSxcclxuXHRcdFx0XCJ4XCI6IFwiSW5kZXhlZCBFbmVyZ3kgQ29uc3VtcHRpb25cIixcclxuXHRcdFx0XCJ5XCI6IFwiSW5kZXhlZCBHRFBcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+dHdvPC9zcGFuPiBjb3VudHJpZXMgd2hvc2UgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX2VtcGhhc2lzJz5JbmRleGVkIEVuZXJneSBDb25zdW1wdGlvbjwvc3Bhbj4gZ3JldyBmYXN0ZXIgdGhhbiB0aGVpciA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZGV4ZWQgR0RQPC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDIsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSW5kaWFcIixcclxuXHRcdFx0XHRcIkNoaW5hXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDMsXHJcblx0XHRcdFwieFwiOiBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG5cdFx0XHRcInlcIjogXCJJbmZhbnQgTW9ydGFsaXR5XCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB3aXRoIGEgZGVjcmVhc2luZyA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPkluZmFudCBNb3J0YWxpdHk8L3NwYW4+IHJhdGUsIGJ1dCBsaXR0bGUgY2hhbmdlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+TGlmZSBFeHBlY3RhbmN5PC9zcGFuPi5cIixcclxuXHRcdFx0XCJudW1fcmVzcG9uc2VzXCI6IDEsXHJcblx0XHRcdFwiY29ycmVjdF9yZXNwb25zZXNcIjogW1xyXG5cdFx0XHRcdFwiSHVuZ2FyeVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogZmFsc2VcclxuXHRcdH0sXHJcblx0XHR7XHJcblx0XHRcdFwidGFza19pbmRleFwiOiA4LFxyXG5cdFx0XHRcInhcIjogXCJBcmFibGUgQXJlYVwiLFxyXG5cdFx0XHRcInlcIjogXCJQb3B1bGF0aW9uXCIsXHJcblx0XHRcdFwicHJvbXB0XCI6IFwiU2VsZWN0IDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPm9uZTwvc3Bhbj4gY291bnRyeSB0aGF0IGhhZCBhIGRlY3JlYXNlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+QXJhYmxlIEFyZWE8L3NwYW4+LCBldmVuIGFzIHRoZWlyIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+UG9wdWxhdGlvbjwvc3Bhbj4gaW5jcmVhc2VkLlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJVbml0ZWQgU3RhdGVzXCJcclxuXHRcdFx0XSxcclxuXHRcdFx0XCJ5ZWFyTWluXCI6IDE5NzUsXHJcblx0XHRcdFwieWVhck1heFwiOiAyMDAwLFxyXG5cdFx0XHRcInR1dG9yaWFsXCI6IGZhbHNlLFxyXG5cdFx0XHRcInF1YWxpdHlfY29udHJvbFwiOiBmYWxzZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDAsXHJcblx0XHRcdFwieFwiOiBcIlBvcHVsYXRpb25cIixcclxuXHRcdFx0XCJ5XCI6IFwiR0RQIFBlciBDYXBpdGFcIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgdGhlIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9udW1iZXInPnR3bzwvc3Bhbj4gY291bnRyaWVzIGhhdmluZyB0aGUgbGFyZ2VzdCA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPlBvcHVsYXRpb248L3NwYW4+IGluIHRoZSB5ZWFyIDIwMDAuXCIsXHJcblx0XHRcdFwibnVtX3Jlc3BvbnNlc1wiOiAyLFxyXG5cdFx0XHRcImNvcnJlY3RfcmVzcG9uc2VzXCI6IFtcclxuXHRcdFx0XHRcIkluZGlhXCIsXHJcblx0XHRcdFx0XCJDaGluYVwiXHJcblx0XHRcdF0sXHJcblx0XHRcdFwieWVhck1pblwiOiAxOTc1LFxyXG5cdFx0XHRcInllYXJNYXhcIjogMjAwMCxcclxuXHRcdFx0XCJ0dXRvcmlhbFwiOiBmYWxzZSxcclxuXHRcdFx0XCJxdWFsaXR5X2NvbnRyb2xcIjogdHJ1ZVxyXG5cdFx0fSxcclxuXHRcdHtcclxuXHRcdFx0XCJ0YXNrX2luZGV4XCI6IDksXHJcblx0XHRcdFwieFwiOiBcIkFyYWJsZSBBcmVhXCIsXHJcblx0XHRcdFwieVwiOiBcIlBvcHVsYXRpb25cIixcclxuXHRcdFx0XCJwcm9tcHRcIjogXCJTZWxlY3QgPHNwYW4gY2xhc3M9J2luc3RydWN0aW9uX251bWJlcic+b25lPC9zcGFuPiBjb3VudHJ5IHRoYXQgaGFkIGFuIGluY3JlYXNlIGluIDxzcGFuIGNsYXNzPSdpbnN0cnVjdGlvbl9lbXBoYXNpcyc+QXJhYmxlIEFyZWE8L3NwYW4+LCBidXQgb25seSBhIHNsaWdodCBpbmNyZWFzZSBpbiA8c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPlBvcHVsYXRpb248L3NwYW4+LlwiLFxyXG5cdFx0XHRcIm51bV9yZXNwb25zZXNcIjogMSxcclxuXHRcdFx0XCJjb3JyZWN0X3Jlc3BvbnNlc1wiOiBbXHJcblx0XHRcdFx0XCJBdXN0cmFsaWFcIlxyXG5cdFx0XHRdLFxyXG5cdFx0XHRcInllYXJNaW5cIjogMTk3NSxcclxuXHRcdFx0XCJ5ZWFyTWF4XCI6IDIwMDAsXHJcblx0XHRcdFwidHV0b3JpYWxcIjogZmFsc2UsXHJcblx0XHRcdFwicXVhbGl0eV9jb250cm9sXCI6IGZhbHNlXHJcblx0XHR9XHJcblx0XVxyXG5dO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB0YXNrTGlzdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy90YXNrcy90YXNrTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZDMgPSByZXF1aXJlKFwiZDNcIik7XHJcbnZhciBnbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcclxudmFyIGNoYXJ0ID0gcmVxdWlyZShcIi4vY2hhcnRcIik7XHJcbnZhciBuYXRpb25EYXRhID0gcmVxdWlyZShcIi4vZGF0YS9zdHVkeURhdGFcIik7XHJcblxyXG5mdW5jdGlvbiBzYW5kYm94ICgpIHtcclxuXHJcbiAgc3VwcHJlc3NfdG91Y2hfdmFsX2ZlZWRiYWNrID0gZmFsc2U7XHJcbiAgc3VwcHJlc3NfdG91Y2hfZmVlZGJhY2sgPSBmYWxzZTtcclxuICBnbG9iYWxzLnRyaWFsX3Jlc3BvbnNlID0gW107XHJcbiAgXHJcbiAgdmFyIGNoZWNrRXhpc3Q7ICAgIFxyXG4gIHZhciBjaGVja1RvdWNoO1xyXG4gIFxyXG4gIGZ1bmN0aW9uIGdldERpbXMoKSB7XHJcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgc3ZnX2RpbSA9IGQzLm1pbihbaGVpZ2h0LHdpZHRoXSkgLSAyO1xyXG4gICAgaW5uZXJfcGFkZGluZyA9IHN2Z19kaW0gKiAwLjE7XHJcbiAgICBjaGFydF9kaW0gPSBzdmdfZGltICogMC44O1xyXG4gIH1cclxuICBcclxuICBmdW5jdGlvbiBkcmF3KCkge1xyXG4gIFxyXG4gICAgZ2V0RGltcygpO1xyXG4gICAgICAgIFxyXG4gICAgZDMuc2VsZWN0KCcjbWFpbl9zdmcnKVxyXG4gICAgLnN0eWxlKCdoZWlnaHQnLHN2Z19kaW0gKyAncHgnKVxyXG4gICAgLnN0eWxlKCd3aWR0aCcsc3ZnX2RpbSArICdweCcpO1xyXG5cclxuICAgIGQzLnNlbGVjdCgnI3NlbGVjdG9yX2RpdicpXHJcbiAgICAuc3R5bGUoJ2hlaWdodCcsIGZ1bmN0aW9uKCl7XHJcbiAgICBpZiAoaGVpZ2h0IDwgd2lkdGgpIHtcclxuICAgICAgcmV0dXJuIChoZWlnaHQpICsgJ3B4JztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICB2YXIgbWVudWJhcl9oZWlnaHQgPSB3aWR0aCAvIDc7XHJcbiAgICAgIHZhciByZW1haW5pbmdfaGVpZ2h0ID0gaGVpZ2h0IC0gc3ZnX2RpbSAtIG1lbnViYXJfaGVpZ2h0IC0gMTA7IFxyXG4gICAgICByZXR1cm4gKHJlbWFpbmluZ19oZWlnaHQpICsgJ3B4JztcclxuICAgIH1cclxuICAgIH0pXHJcbiAgICAuc3R5bGUoJ3dpZHRoJywgZnVuY3Rpb24oKXtcclxuICAgICAgaWYgKGhlaWdodCA8IHdpZHRoKSB7XHJcbiAgICAgICAgdmFyIG1lbnViYXJfd2lkdGggPSBoZWlnaHQgLyA3O1xyXG4gICAgICAgIHZhciByZW1haW5pbmdfd2lkdGggPSB3aWR0aCAtIHN2Z19kaW0gLSBtZW51YmFyX3dpZHRoOyBcclxuICAgICAgICByZXR1cm4gKHJlbWFpbmluZ193aWR0aCkgKyAncHgnO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgeyAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuICh3aWR0aCkgKyAncHgnO1xyXG4gICAgICB9ICAgICAgXHJcbiAgICB9KVxyXG4gICAgLnN0eWxlKCdmbG9hdCcsIChoZWlnaHQgPCB3aWR0aCkgPyAncmlnaHQnIDogJ3Vuc2V0JylcclxuICAgIC5zdHlsZSgnbGVmdCcsIChoZWlnaHQgPCB3aWR0aCkgPyAoc3ZnX2RpbSkgKyAncHgnIDogJ3Vuc2V0Jyk7XHJcbiAgICAgIFxyXG5cclxuICAgIGNoYXJ0X2cuYXR0cigndHJhbnNmb3JtJywndHJhbnNsYXRlKCcgKyBpbm5lcl9wYWRkaW5nICsgJywnICsgaW5uZXJfcGFkZGluZyArICcpJyk7XHJcbiAgXHJcbiAgICBkMy5zZWxlY3RBbGwoJy5ndWlkZScpLnJlbW92ZSgpO1xyXG4gICAgY2hhcnRfaW5zdGFuY2UubGluZXMoJ29mZicpOyBcclxuICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbignb2ZmJyk7XHJcbiAgICBjaGFydF9pbnN0YW5jZS5mYWNldHMoJ29mZicpO1xyXG4gICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKGdsb2JhbHMucGFyYW1feWVhck1pbik7XHJcblxyXG4gICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuICAgIGNoYXJ0X2cuY2FsbChjaGFydF9pbnN0YW5jZSk7ICAgIFxyXG4gIFxyXG4gICAgZDMuc2VsZWN0QWxsKCcudG9vbGJhcicpXHJcbiAgICAuc3R5bGUoJ3Bvc2l0aW9uJywnYWJzb2x1dGUnKVxyXG4gICAgLnN0eWxlKCd0b3AnLCBoZWlnaHQgPCB3aWR0aCA/ICcwcHgnIDogKHN2Z19kaW0pICsgJ3B4JylcclxuICAgIC5zdHlsZSgncmlnaHQnLCBoZWlnaHQgPCB3aWR0aCA/ICcwcHgnIDogJ3Vuc2V0JylcclxuICAgIC5zdHlsZSgnd2lkdGgnLCBoZWlnaHQgPCB3aWR0aCA/IChoZWlnaHQgLyA3KSArICdweCcgIDogd2lkdGggKyAncHgnKVxyXG4gICAgLnN0eWxlKCdoZWlnaHQnLCAgaGVpZ2h0IDwgd2lkdGggPyBoZWlnaHQgKyAncHgnICA6ICh3aWR0aCAvIDcpICsgJ3B4Jyk7XHJcbiAgXHJcbiAgICBkMy5zZWxlY3RBbGwoJy5pbWdfYnRuX2VuYWJsZWQnKVxyXG4gICAgLnN0eWxlKCdtYXJnaW4nLCBoZWlnaHQgPCB3aWR0aCA/ICcwcHgnIDogJzJweCcpXHJcbiAgICAuc3R5bGUoJ2hlaWdodCcsIGhlaWdodCA8IHdpZHRoID8gKGhlaWdodCAvIDcgLSA2KSArICdweCcgOiAod2lkdGggLyA3IC0gNikgKyAncHgnKVxyXG4gICAgLnN0eWxlKCd3aWR0aCcsIHdpZHRoIDwgaGVpZ2h0ID8gKHdpZHRoIC8gNyAtIDYpICsgJ3B4JyA6IChoZWlnaHQgLyA3IC0gNikgKyAncHgnKTsgXHJcblxyXG4gICAgLy8gZDMuc2VsZWN0KCcjc2FuZGJveF9kaXYnKVxyXG4gICAgLy8gLnN0eWxlKCdoZWlnaHQnLCBmdW5jdGlvbigpe1xyXG4gICAgLy8gICByZXR1cm4gc3ZnX2RpbSArIChoZWlnaHQgPCB3aWR0aCA/IChoZWlnaHQgLyA3IC0gNikgOiAod2lkdGggLyA3IC0gNikpICsgJ3B4JzsgXHJcbiAgICAvLyB9KTtcclxuXHJcbiAgfVxyXG4gIFxyXG4gIGZ1bmN0aW9uIHRvZ2dsZUxpbmVzICgpIHtcclxuICAgIGNoYXJ0X2luc3RhbmNlLnRoaXNfY2hhcnQoKS5pbnRlcnJ1cHQoKTtcclxuICAgIGlmIChjaGFydF9pbnN0YW5jZS5saW5lcygpID09IFwib25cIikge1xyXG4gICAgICBjaGFydF9pbnN0YW5jZS5saW5lcyhcIm9mZlwiKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoYXJ0X2luc3RhbmNlLmxpbmVzKCkgPT0gXCJvZmZcIikge1xyXG4gICAgICBjaGFydF9pbnN0YW5jZS5saW5lcyhcIm9uXCIpOyBcclxuICAgIH1cclxuICAgIGNoYXJ0X2cuY2FsbChjaGFydF9pbnN0YW5jZSk7XHJcbiAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRCwgXHJcbiAgICAgIFwiRXZlbnRcIjogXCJTYW5kQm94RXZlbnRcIixcclxuICAgICAgXCJFdmVudFR5cGVcIjogXCJ0b2dnbGVMaW5lc1wiLCBcclxuICAgICAgXCJTdGF0dXNcIjogY2hhcnRfaW5zdGFuY2UubGluZXMoKVxyXG4gICAgfTtcclxuICAgIGNvbnNvbGUubG9nKFwiU2FuZEJveEV2ZW50XCIsIGdsb2JhbHMubG9nX21lc3NhZ2UpO1xyXG5cclxuXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2FuZGJveF9kaXYnKS5mb2N1cygpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdG9nZ2xlQW5pbWF0ZSAoKSB7XHJcbiAgICBjaGFydF9pbnN0YW5jZS50aGlzX2NoYXJ0KCkuaW50ZXJydXB0KCk7XHJcbiAgICBpZiAoY2hhcnRfaW5zdGFuY2UuYW5pbWF0aW9uKCkgPT0gXCJvblwiKSB7XHJcbiAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihNYXRoLmZsb29yKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpKSk7XHJcbiAgICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbihcIm9mZlwiKTtcclxuICAgICAgZDMuc2VsZWN0KCcjbmV4dF9idG4nKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdpbWdfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgIC5kdXJhdGlvbigyNTApXHJcbiAgICAgIC5lYXNlKGQzLmVhc2VDdWJpYylcclxuICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvbmV4dC5zdmcnKTtcclxuICAgICAgZDMuc2VsZWN0KCcjcHJldl9idG4nKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdpbWdfYnRuX2VuYWJsZWQnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbigpID09IFwib2ZmXCIpIHtcclxuICAgICAgY2hhcnRfaW5zdGFuY2UuYW5pbWF0aW9uKFwib25cIik7IFxyXG4gICAgICBkMy5zZWxlY3QoJyNuZXh0X2J0bicpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsJ2ltZ19idG5fZGlzYWJsZWQnKVxyXG4gICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgIC5kdXJhdGlvbigyNTApXHJcbiAgICAgIC5lYXNlKGQzLmVhc2VDdWJpYylcclxuICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvbmV4dF9nb2xkLnN2ZycpO1xyXG4gICAgICBkMy5zZWxlY3QoJyNwcmV2X2J0bicpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsJ2ltZ19idG5fZGlzYWJsZWQnKTtcclxuICAgIH1cclxuICAgIGNoYXJ0X2cuY2FsbChjaGFydF9pbnN0YW5jZSk7XHJcbiAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRCwgXHJcbiAgICAgIFwiRXZlbnRcIjogXCJTYW5kQm94RXZlbnRcIixcclxuICAgICAgXCJFdmVudFR5cGVcIjogXCJ0b2dnbGVBbmltYXRlXCIsIFxyXG4gICAgICBcIlN0YXR1c1wiOiBjaGFydF9pbnN0YW5jZS5hbmltYXRpb24oKVxyXG4gICAgfTtcclxuICAgIGNvbnNvbGUubG9nKFwiU2FuZEJveEV2ZW50XCIsIGdsb2JhbHMubG9nX21lc3NhZ2UpO1xyXG5cclxuXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2FuZGJveF9kaXYnKS5mb2N1cygpO1xyXG4gIH1cclxuICBcclxuICBmdW5jdGlvbiB0b2dnbGVGYWNldHMgKCkge1xyXG4gICAgY2hhcnRfaW5zdGFuY2UudGhpc19jaGFydCgpLmludGVycnVwdCgpO1xyXG4gICAgaWYgKGNoYXJ0X2luc3RhbmNlLmZhY2V0cygpID09IFwib25cIikge1xyXG4gICAgICBjaGFydF9pbnN0YW5jZS5mYWNldHMoXCJvZmZcIik7ICAgICAgXHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjaGFydF9pbnN0YW5jZS5mYWNldHMoKSA9PSBcIm9mZlwiKSB7XHJcbiAgICAgIGNoYXJ0X2luc3RhbmNlLmZhY2V0cyhcIm9uXCIpOyAgICAgIFxyXG4gICAgfVxyXG4gICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuXHJcbiAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRCwgXHJcbiAgICAgIFwiRXZlbnRcIjogXCJTYW5kQm94RXZlbnRcIixcclxuICAgICAgXCJFdmVudFR5cGVcIjogXCJ0b2dnbGVGYWNldHNcIiwgXHJcbiAgICAgIFwiU3RhdHVzXCI6IGNoYXJ0X2luc3RhbmNlLmZhY2V0cygpXHJcbiAgICB9O1xyXG4gICAgY29uc29sZS5sb2coXCJTYW5kQm94RXZlbnRcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG5cclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzYW5kYm94X2RpdicpLmZvY3VzKCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2FkRGF0YSAoKSB7ICAgICBcclxuXHJcbiAgICBjaGVja0V4aXN0ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChhbGxfZGF0YSAhPSB1bmRlZmluZWQpIHsgICAgICAgIFxyXG4gICAgICAgIGNoYXJ0X2cuZGF0dW0oYWxsX2RhdGEpO1xyXG4gICAgICAgIGRyYXcoKTsgICAgXHJcblxyXG4gICAgICAgIGhpZGVBZGRyZXNzQmFyKCk7XHJcblxyXG4gICAgICAgIGQzLnNlbGVjdCgnI3NhbmRib3hfZGl2JylcclxuICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7XHJcblxyXG4gICAgICAgIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgICAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySUQsIFxyXG4gICAgICAgICAgXCJFdmVudFwiOiBcIlNhbmRCb3hFdmVudFwiLFxyXG4gICAgICAgICAgXCJFdmVudFR5cGVcIjogXCJsb2FkRGF0YVwiLCBcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2FuZEJveEV2ZW50XCIsIGdsb2JhbHMubG9nX21lc3NhZ2UpO1xyXG5cclxuXHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjaGVja0V4aXN0KTtcclxuICAgICAgfVxyXG4gICAgfSwgMTAwKTsgLy8gY2hlY2sgZXZlcnkgMTAwbXNcclxuXHJcbiAgICBjaGFydF9pbnN0YW5jZSA9IGNoYXJ0KCk7ICAgIFxyXG4gIFxyXG4gICAgbWFpbl9zdmcgPSBkMy5zZWxlY3QoJyNtYWluX3N2ZycpLnJlbW92ZSgpO1xyXG4gIFxyXG4gICAgbWFpbl9zdmcgPSBkMy5zZWxlY3QoJyNzYW5kYm94X2RpdicpLmFwcGVuZCgnc3ZnJylcclxuICAgIC5hdHRyKCdpZCcsJ21haW5fc3ZnJyk7ICAgICAgXHJcbiAgXHJcbiAgICBkZWZzID0gZDMuc2VsZWN0KCcjbWFpbl9zdmcnKS5hcHBlbmQoJ2RlZnMnKTtcclxuICBcclxuICAgIGNoYXJ0X2cgPSBtYWluX3N2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgLmF0dHIoJ2lkJywnY2hhcnRfZycpOyAgICAgIFxyXG5cclxuICAgIFxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NhbmRib3hfZGl2JykuZm9jdXMoKTtcclxuXHJcbiAgICAvLyB2YXIgb3JpZW50YXRpb25fZGl2ID0gZDMuc2VsZWN0KCcjc2FuZGJveF9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgICAvLyAuYXR0cignaWQnLCdvcmllbnRhdGlvbl9kaXYnKVxyXG4gICAgLy8gLmF0dHIoJ3RhYmluZGV4JywwKTtcclxuXHJcbiAgICAvLyBvcmllbnRhdGlvbl9kaXYuYXBwZW5kKCdzcGFuJylcclxuICAgIC8vIC5hdHRyKCdpZCcsJ29yaWVudGF0aW9uX3NwYW4nKVxyXG4gICAgLy8gLmh0bWwoJzxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5Ub29TbWFsbEZvck11bHRpcGxlczwvc3Bhbj4nKTtcclxuXHJcbiAgfSBcclxuICAgIFxyXG4gIC8qKiBJTklUICoqL1xyXG4gIFxyXG4gIGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JylcclxuICAuYXR0cignaWQnLCdzYW5kYm94X2RpdicpXHJcbiAgLmF0dHIoJ3RhYmluZGV4JywwKTtcclxuXHJcbiAgZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdkaXYnKVxyXG4gIC5hdHRyKCdpZCcsJ3NlbGVjdG9yX2RpdicpXHJcbiAgLnN0eWxlKCdib3R0b20nLCcwcHgnKVxyXG4gIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gIC5hdHRyKCd0YWJpbmRleCcsMCk7XHJcblxyXG4gIGFsbF9kYXRhID0gbmF0aW9uRGF0YTsgIFxyXG4gIHZhciBjb2RlcyA9IFtcIkFcIiwgXCJCXCIsIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiLCBcIkdcIiwgXCJIXCIsIFwiSVwiLCBcIkpcIiwgXCJLXCIsIFwiTFwiLCBcIk1cIiwgXCJOXCIsIFwiT1wiLCBcIlBcIl07IC8vLFxyXG4gIGNvZGVzID0gc2h1ZmZsZShjb2Rlcyk7XHJcbiAgYWxsX2RhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCxpKXsgXHJcbiAgICBkLmNvZGUgPSBjb2Rlc1tpXTsgXHJcbiAgfSk7XHJcbiAgICBcclxuICBsb2FkRGF0YSgpOyBcclxuXHJcbiAgZnVuY3Rpb24gZXhpdEhhbmRsZXIgKCkge1xyXG4gICAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICAgIFwiVGltZVN0YW1wXCI6IG5ldyBEYXRlKCkudmFsdWVPZigpLFxyXG4gICAgICBcIkV2ZW50XCI6IFwiU2FuZEJveF9DbG9zZWRcIixcclxuICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklEXHJcbiAgICB9O1xyXG4gICAgY29uc29sZS5sb2coXCJTYW5kQm94X0Nsb3NlZFwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcbiAgICBcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzYW5kYm94X2RpdicpLnJlbW92ZSgpO1xyXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWxlY3Rvcl9kaXYnKSAhPSB1bmRlZmluZWQpIHsgICAgICBcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbGVjdG9yX2RpdicpLnJlbW92ZSgpOyAgICAgICAgICAgICAgICAgICAgXHJcbiAgICB9IFxyXG4gICAgbG9hZE1lbnUoKTtcclxuICAgIGhpZGVBZGRyZXNzQmFyKCk7ICAgXHJcbiAgfVxyXG5cclxuICB2YXIgbWVudWJhciA9IGQzLnNlbGVjdCgnI3NhbmRib3hfZGl2JykuYXBwZW5kKCdkaXYnKVxyXG4gIC5hdHRyKCdjbGFzcycsJ3Rvb2xiYXInKVxyXG4gIC5hdHRyKCdpZCcsJ21lbnViYXInKTtcclxuICBcclxuICBtZW51YmFyLmFwcGVuZChcImlucHV0XCIpXHJcbiAgLmF0dHIoJ2NsYXNzJywgJ2ltZ19idG5fZW5hYmxlZCcpXHJcbiAgLmF0dHIoJ2lkJywnZnVsbHNjcmVlbl9idG4nKVxyXG4gIC5hdHRyKCdkaXNhYmxlZCcsIG51bGwpXHJcbiAgLmF0dHIoJ3R5cGUnLCdpbWFnZScpXHJcbiAgLmF0dHIoJ25hbWUnLCdFeGl0JylcclxuICAuYXR0cigndGl0bGUnLCAnRXhpdCcpXHJcbiAgLmF0dHIoJ3NyYycsICdhc3NldHMvZnVsbHNjcmVlbi5wbmcnKVxyXG4gIC5vbigndG91Y2hzdGFydCcsZnVuY3Rpb24oKXtcclxuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBleGl0SGFuZGxlcigpO1xyXG4gIH0pO1xyXG5cclxuICBtZW51YmFyLmFwcGVuZChcImlucHV0XCIpXHJcbiAgLmF0dHIoJ2NsYXNzJywgJ2ltZ19idG5fZW5hYmxlZCcpXHJcbiAgLmF0dHIoJ2lkJywnbmFfYnRuJylcclxuICAuYXR0cigndHlwZScsJ2ltYWdlJylcclxuICAuYXR0cignbmFtZScsJ01pc2NUb2dnbGUnKVxyXG4gIC5hdHRyKCd0aXRsZScsICdNaXNjVG9nZ2xlJylcclxuICAuYXR0cignc3JjJywgJ2Fzc2V0cy9uYS5zdmcnKVxyXG4gIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgfSk7ICAgIFxyXG5cclxuICBtZW51YmFyLmFwcGVuZChcImlucHV0XCIpXHJcbiAgLmF0dHIoJ2NsYXNzJywgJ2ltZ19idG5fZW5hYmxlZCcpXHJcbiAgLmF0dHIoJ3R5cGUnLCdpbWFnZScpXHJcbiAgLmF0dHIoJ25hbWUnLCdMaW5lVG9nZ2xlJylcclxuICAuYXR0cigndGl0bGUnLCAnTGluZVRvZ2dsZScpXHJcbiAgLmF0dHIoJ3NyYycsICdhc3NldHMvbGluZS5zdmcnKVxyXG4gIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIHRvZ2dsZUxpbmVzKCk7XHJcbiAgfSk7XHJcblxyXG4gIG1lbnViYXIuYXBwZW5kKFwiaW5wdXRcIilcclxuICAuYXR0cignY2xhc3MnLCAnaW1nX2J0bl9lbmFibGVkJylcclxuICAuYXR0cigndHlwZScsJ2ltYWdlJylcclxuICAuYXR0cignbmFtZScsJ0ZhY2V0VG9nZ2xlJylcclxuICAuYXR0cigndGl0bGUnLCAnRmFjZXRUb2dnbGUnKVxyXG4gIC5hdHRyKCdzcmMnLCAnYXNzZXRzL2dyaWQuc3ZnJylcclxuICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtcclxuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB0b2dnbGVGYWNldHMoKTtcclxuICB9KTsgIFxyXG5cclxuICBtZW51YmFyLmFwcGVuZChcImlucHV0XCIpXHJcbiAgLmF0dHIoJ2NsYXNzJywgJ2ltZ19idG5fZW5hYmxlZCcpXHJcbiAgLmF0dHIoJ3R5cGUnLCdpbWFnZScpXHJcbiAgLmF0dHIoJ25hbWUnLCdBbmltYXRlVG9nZ2xlJylcclxuICAuYXR0cigndGl0bGUnLCAnQW5pbWF0ZVRvZ2dsZScpXHJcbiAgLmF0dHIoJ3NyYycsICdhc3NldHMvcGxheS5zdmcnKVxyXG4gIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIHRvZ2dsZUFuaW1hdGUoKTtcclxuICB9KTsgIFxyXG5cclxuICBtZW51YmFyLmFwcGVuZChcImlucHV0XCIpXHJcbiAgLmF0dHIoJ2NsYXNzJywgJ2ltZ19idG5fZW5hYmxlZCcpXHJcbiAgLmF0dHIoJ2lkJywncHJldl9idG4nKVxyXG4gIC5hdHRyKCd0eXBlJywnaW1hZ2UnKVxyXG4gIC5hdHRyKCduYW1lJywnUHJldlRvZ2dsZScpXHJcbiAgLmF0dHIoJ3RpdGxlJywgJ1ByZXZUb2dnbGUnKVxyXG4gIC5hdHRyKCdzcmMnLCAnYXNzZXRzL3ByZXYuc3ZnJylcclxuICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKVxyXG4gICAgLmR1cmF0aW9uKDI1MClcclxuICAgIC5lYXNlKGQzLmVhc2VDdWJpYylcclxuICAgIC5hdHRyKCdzcmMnLCAnYXNzZXRzL3ByZXZfZ29sZC5zdmcnKVxyXG4gICAgLnRyYW5zaXRpb24oKVxyXG4gICAgLmR1cmF0aW9uKDI1MClcclxuICAgIC5lYXNlKGQzLmVhc2VDdWJpYylcclxuICAgIC5hdHRyKCdzcmMnLCAnYXNzZXRzL3ByZXYuc3ZnJyk7XHJcbiAgICBjaGFydF9pbnN0YW5jZS50aGlzX2NoYXJ0KCkuaW50ZXJydXB0KCk7XHJcblxyXG4gICAgaWYgKGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbigpID09ICdvZmYnKXtcclxuXHJcbiAgICAgIGlmIChjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKSB7XHJcbiAgICAgICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXgpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBwcmV2X3llYXIgPSBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSAtIDE7XHJcbiAgICAgICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKHByZXZfeWVhcik7XHJcbiAgICAgIH1cclxuICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuXHJcbiAgICAgIGNoZWNrVG91Y2ggPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbikge1xyXG4gICAgICAgICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHZhciBwcmV2X3llYXIgPSBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSAtIDE7XHJcbiAgICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIocHJldl95ZWFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuICAgICAgfSwgNTAwKTsgLy8gY2hlY2sgZXZlcnkgNTAwbXMgaWYgdG91Y2ggaXMgb25nb2luZyAgICAgICAgICBcclxuXHJcbiAgICB9XHJcbiAgfSlcclxuICAub24oJ3RvdWNoZW5kJywgZnVuY3Rpb24oKXtcclxuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBjbGVhckludGVydmFsKGNoZWNrVG91Y2gpO1xyXG4gIH0pOyAgICBcclxuXHJcbiAgbWVudWJhci5hcHBlbmQoXCJpbnB1dFwiKVxyXG4gIC5hdHRyKCdjbGFzcycsICdpbWdfYnRuX2VuYWJsZWQnKVxyXG4gIC5hdHRyKCdpZCcsJ25leHRfYnRuJylcclxuICAuYXR0cigndHlwZScsJ2ltYWdlJykgXHJcbiAgLmF0dHIoJ25hbWUnLCdOZXh0VG9nZ2xlJylcclxuICAuYXR0cigndGl0bGUnLCAnTmV4dFRvZ2dsZScpXHJcbiAgLmF0dHIoJ3NyYycsICdhc3NldHMvbmV4dC5zdmcnKVxyXG4gIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyAgICBcclxuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpXHJcbiAgICAuZHVyYXRpb24oMjUwKVxyXG4gICAgLmVhc2UoZDMuZWFzZUN1YmljKVxyXG4gICAgLmF0dHIoJ3NyYycsICdhc3NldHMvbmV4dF9nb2xkLnN2ZycpXHJcbiAgICAudHJhbnNpdGlvbigpXHJcbiAgICAuZHVyYXRpb24oMjUwKVxyXG4gICAgLmVhc2UoZDMuZWFzZUN1YmljKVxyXG4gICAgLmF0dHIoJ3NyYycsICdhc3NldHMvbmV4dC5zdmcnKTtcclxuICAgIGNoYXJ0X2luc3RhbmNlLnRoaXNfY2hhcnQoKS5pbnRlcnJ1cHQoKTtcclxuXHJcbiAgICBpZiAoY2hhcnRfaW5zdGFuY2UuYW5pbWF0aW9uKCkgPT0gJ29mZicpe1xyXG5cclxuICAgICAgaWYgKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXgpIHtcclxuICAgICAgICBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQgKyAxKTtcclxuICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIG5leHRfeWVhciA9IGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpICsgMTtcclxuICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIobmV4dF95ZWFyKTtcclxuICAgICAgfVxyXG4gICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG5cclxuICAgICAgY2hlY2tUb3VjaCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4KSB7XHJcbiAgICAgICAgICBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQgKyAxKTtcclxuICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICB2YXIgbmV4dF95ZWFyID0gY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgKyAxO1xyXG4gICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihuZXh0X3llYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gICAgICB9LCA1MDApOyAvLyBjaGVjayBldmVyeSA1MDBtcyBpZiB0b3VjaCBpcyBvbmdvaW5nICAgICAgICAgIFxyXG5cclxuICAgIH1cclxuICB9KVxyXG4gIC5vbigndG91Y2hlbmQnLCBmdW5jdGlvbigpe1xyXG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIGNsZWFySW50ZXJ2YWwoY2hlY2tUb3VjaCk7XHJcbiAgfSk7ICAgIFxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBzYW5kYm94O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9zYW5kYm94LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkMyA9IHJlcXVpcmUoXCJkM1wiKTtcclxudmFyIGdsb2JhbHMgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xyXG5cclxuZnVuY3Rpb24gY29uc2VudCAoc2NlbmUpIHsgIFxyXG4gIFxyXG4gIC8qKiBJTklUICoqL1xyXG4gIFxyXG4gIGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JylcclxuICAuYXR0cignaWQnLCdjb25zZW50X2RpdicpXHJcbiAgLmF0dHIoJ3RhYmluZGV4JywwKVxyXG4gIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyAgICBcclxuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxyXG4gIH0pOyAgXHJcblxyXG4gIHZhciBjb25zZW50X2NvbnRlbnRfZGl2ID0gZDMuc2VsZWN0KCcjY29uc2VudF9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgLmF0dHIoJ2NsYXNzJywndG9vbGJhcicpXHJcbiAgLnN0eWxlKCd3aWR0aCcsJzEwMCUnKVxyXG4gIC5zdHlsZSgnaGVpZ2h0Jywod2luZG93LmlubmVySGVpZ2h0IC0gNTApICsgJ3B4JylcclxuICAuYXR0cignaWQnLCdjb25zZW50X2NvbnRlbnRfZGl2JylcclxuICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBcclxuICB9KTsgIFxyXG5cclxuICBzd2l0Y2ggKHNjZW5lKSB7XHJcblxyXG4gICAgY2FzZSAwOlxyXG5cclxuICAgICAgY29uc2VudF9jb250ZW50X2Rpdi5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdjb25zZW50X3RleHQnKVxyXG4gICAgICAuaHRtbCgnPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPk1pY3Jvc29mdCBSZXNlYXJjaDxicj5Qcm9qZWN0IFBhcnRpY2lwYXRpb24gQ29uc2VudCBGb3JtPC9zcGFuPjxicj4nICtcclxuICAgICAgJzxzcGFuIHN0eWxlPVwidGV4dC1hbGlnbjpsZWZ0OyBmb250LXNpemU6MC43ZW07XCI+PHA+VGhhbmsgeW91IGZvciBkZWNpZGluZyB0byB2b2x1bnRlZXIgaW4gYSBNaWNyb3NvZnQgQ29ycG9yYXRpb24gcmVzZWFyY2ggcHJvamVjdC4gVGhlIHB1cnBvc2Ugb2YgdGhpcyBwcm9qZWN0IGlzIHRvIHN0dWR5IHRoZSBwZXJjZXB0aW9uIG9mIHN0YXRpc3RpY2FsIGNoYXJ0cyBvbiBtb2JpbGUgcGhvbmVzLiBZb3UgaGF2ZSBubyBvYmxpZ2F0aW9uIHRvIHBhcnRpY2lwYXRlIGFuZCB5b3UgbWF5IGRlY2lkZSB0byB0ZXJtaW5hdGUgeW91ciBwYXJ0aWNpcGF0aW9uIGF0IGFueSB0aW1lLiBZb3UgYWxzbyB1bmRlcnN0YW5kIHRoYXQgdGhlIHJlc2VhcmNoZXIgaGFzIHRoZSByaWdodCB0byB3aXRoZHJhdyB5b3UgZnJvbSBwYXJ0aWNpcGF0aW9uIGluIHRoZSBwcm9qZWN0IGF0IGFueSB0aW1lLiBCZWxvdyBpcyBhIGRlc2NyaXB0aW9uIG9mIHRoZSByZXNlYXJjaCBwcm9qZWN0LCBhbmQgeW91ciBjb25zZW50IHRvIHBhcnRpY2lwYXRlLiBSZWFkIHRoaXMgaW5mb3JtYXRpb24gY2FyZWZ1bGx5LjwvcD48L3NwYW4+JylcclxuICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7ICAgIFxyXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxyXG4gICAgICB9KTsgICAgXHJcbiAgICAgIFxyXG4gICAgICBkMy5zZWxlY3QoJyNjb25zZW50X2RpdicpXHJcbiAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsJ3Zpc2libGUnKTtcclxuXHJcbiAgICBicmVhaztcclxuICAgIFxyXG4gICAgY2FzZSAxOlxyXG5cclxuICAgICAgY29uc2VudF9jb250ZW50X2Rpdi5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdjb25zZW50X3RleHQnKVxyXG4gICAgICAuaHRtbChcclxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPlRpdGxlIG9mIEV4cGVyaW1lbnQ6PC9zcGFuPjxicj4nICtcclxuICAgICAgICAnPHNwYW4gc3R5bGU9XCJ0ZXh0LWFsaWduOmxlZnQ7IGZvbnQtc2l6ZTowLjllbTtcIj48cD48ZW0+QnViYmxlIENoYXJ0cyBvbiBNb2JpbGUgUGhvbmVzPC9lbT48L3A+PC9zcGFuPicgKyAgICAgICAgXHJcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5Qcm9jZWR1cmU6PC9zcGFuPjxicj4nICtcclxuICAgICAgICAnPHNwYW4gc3R5bGU9XCJ0ZXh0LWFsaWduOmxlZnQ7IGZvbnQtc2l6ZTowLjdlbTtcIj48cD5UaGUgZXhwZXJpbWVudCB3aWxsIHRha2UgYXBwcm94aW1hdGVseSA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+MTUgbWludXRlczwvc3Bhbj4gdG8gY29tcGxldGUuIFlvdSB3aWxsIGJlIGFza2VkIHRvIHJlc3BvbmQgdG8gYSBzZXJpZXMgb2YgcXVlc3Rpb25zIHJlbGF0aW5nIHRvICA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+YnViYmxlIGNoYXJ0czwvc3Bhbj4sIGEgdHlwZSBvZiBjaGFydCB0aGF0IHdpbGwgYmUgZXhwbGFpbmVkIHNob3J0bHkuIFNlc3Npb25zIHdpbGwgYmUgbG9nZ2VkIGFub255bW91c2x5IHRvIGNhbGN1bGF0ZSBhY2N1cmFjeSBhbmQgcmVzcG9uc2UgdGltZXMuIFRoZSBleHBlcmltZW50YWwgcHJvY2VkdXJlIGlzIGFzIGZvbGxvd3M6PC9wPicgK1xyXG4gICAgICAgICc8b2w+JyArXHJcbiAgICAgICAgJzxsaT4gQW4gaW50cm9kdWN0b3J5IHR1dG9yaWFsLicgK1xyXG4gICAgICAgICc8bGk+IDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj4xMyBwcmVzZW50YXRpb25zPC9zcGFuPiBvZiBidWJibGUgY2hhcnRzLCBlYWNoIHdpdGggYW4gYXNzb2NpYXRlZCBxdWVzdGlvbi4nICtcclxuICAgICAgICAnPGxpPiBBbiBleGl0IHN1cnZleS4nICtcclxuICAgICAgIFxyXG4gICAgICAgICc8L29sPjwvc3Bhbj4nXHJcbiAgICAgICAgXHJcbiAgICAgIClcclxuICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7ICAgIFxyXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxyXG4gICAgICB9KTsgICAgXHJcbiAgICAgIFxyXG4gICAgICBkMy5zZWxlY3QoJyNjb25zZW50X2RpdicpXHJcbiAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsJ3Zpc2libGUnKTtcclxuXHJcbiAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDI6XHJcblxyXG4gICAgICBjb25zZW50X2NvbnRlbnRfZGl2LmFwcGVuZCgnc3BhbicpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsJ2NvbnNlbnRfdGV4dCcpXHJcbiAgICAgIC5odG1sKFxyXG4gICAgICAgICc8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+UGVyc29uYWwgSW5mb3JtYXRpb246PC9zcGFuPjxicj4nICtcclxuICAgICAgICAnPHNwYW4gc3R5bGU9XCJ0ZXh0LWFsaWduOmxlZnQ7IGZvbnQtc2l6ZTowLjdlbTtcIj48cD5UaGlzIHdhaXZlciBpcyBpbnRlbmRlZCB0byBnaXZlIHlvdSBpbmZvcm1lZCBjb25zZW50IHJlZ2FyZGluZyB5b3VyIHBhcnRpY2lwYXRpb24gaW4gdGhpcyBwcm9qZWN0IGFuZCBhbHNvIHRvIHByb3RlY3QgeW91ciBwZXJzb25hbGx5IGlkZW50aWZpYWJsZSBpbmZvcm1hdGlvbiBieSBub3QgYXNraW5nIGZvciBzcGVjaWZpYyBkZXRhaWxzLCBzdWNoIGFzIHlvdXIgbmFtZS4gQnkgY2xpY2tpbmcg4oCcSSBhZ3JlZeKAnSBhdCB0aGUgZW5kIG9mIHRoaXMgZm9ybSwgeW91IGFyZSBhZ3JlZWluZyB0aGF0IHlvdeKAmXZlIGhhZCB0aW1lIHRvIHJlYWQgYW5kIGNvbnNpZGVyIHRoaXMgY29uc2VudCB3YWl2ZXIgYW5kIGFyZSBjb21mb3J0YWJsZSB3aXRoIHdoYXQgaXMgYmVpbmcgYXNrZWQgb2YgeW91IGFzIGEgcGFydGljaXBhbnQuIEFzaWRlIGZyb20geW91ciBNZWNoYW5pY2FsIFR1cmsgSUQsIG5vIHBlcnNvbmFsIGluZm9ybWF0aW9uIHdpbGwgYmUgY29sbGVjdGVkIGR1cmluZyB0aGlzIHN0dWR5LiBZb3VyIE1lY2hhbmljYWwgVHVyayBJRCB3aWxsIG5vdCBiZSBzaGFyZWQgb3V0c2lkZSBvZiBNaWNyb3NvZnQgUmVzZWFyY2ggYW5kIHRoZSBjb25maW5lcyBvZiB0aGlzIHN0dWR5IHdpdGhvdXQgeW91ciBwZXJtaXNzaW9uLCBhbmQgd2lsbCBiZSBwcm9tcHRseSBkZWxldGVkIGFmdGVyIGNvbXBlbnNhdGlvbiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgcHJvdmlkZWQgKDMwIGRheXMgb3IgbGVzcykuIERlLWlkZW50aWZpZWQgZGF0YSBtYXkgYmUgdXNlZCBmb3IgZnV0dXJlIHJlc2VhcmNoIG9yIGdpdmVuIHRvIGFub3RoZXIgaW52ZXN0aWdhdG9yIGZvciBmdXR1cmUgdXNlIHdpdGhvdXQgYWRkaXRpb25hbCBjb25zZW50IChjb250LikuPC9wPjwvc3Bhbj4nICAgICAgICBcclxuICAgICAgKVxyXG4gICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgIH0pOyAgICBcclxuICAgICAgXHJcbiAgICAgIGQzLnNlbGVjdCgnI2NvbnNlbnRfZGl2JylcclxuICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xyXG5cclxuICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMzpcclxuXHJcbiAgICAgIGNvbnNlbnRfY29udGVudF9kaXYuYXBwZW5kKCdzcGFuJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywnY29uc2VudF90ZXh0JylcclxuICAgICAgLmh0bWwoXHJcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5QZXJzb25hbCBJbmZvcm1hdGlvbiAoY29udC4pOjwvc3Bhbj48YnI+JyArXHJcbiAgICAgICAgJzxzcGFuIHN0eWxlPVwidGV4dC1hbGlnbjpsZWZ0OyBmb250LXNpemU6MC43ZW07XCI+PHA+SWYgeW91IHdpc2ggdG8gcmV2aWV3IG9yIGNvcHkgYW55IHBlcnNvbmFsIGluZm9ybWF0aW9uIHlvdSBwcm92aWRlZCBkdXJpbmcgdGhlIHN0dWR5LCBvciBpZiB5b3Ugd2FudCB1cyB0byBkZWxldGUgb3IgY29ycmVjdCBhbnkgc3VjaCBkYXRhLCBlbWFpbCB5b3VyIHJlcXVlc3QgdG8gdGhlIGxlYWQgcmVzZWFyY2hlciBNYXR0aGV3IEJyZWhtZXIgKDxhIGhyZWY9XCJtYWlsdG86bWFicmVobWVAbWljcm9zb2Z0LmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPm1hYnJlaG1lQG1pY3Jvc29mdC5jb208L2E+KS4gSWYgeW91IGhhdmUgYSBwcml2YWN5IGNvbmNlcm4sIGNvbXBsYWludCwgb3IgYSBxdWVzdGlvbiBmb3IgdGhlIENoaWVmIFByaXZhY3kgT2ZmaWNlci9EYXRhIFByb3RlY3Rpb24gT2ZmaWNlciBvZiBNaWNyb3NvZnQsIHBsZWFzZSBjb250YWN0IHVzIGJ5IHVzaW5nIG91ciA8YSBocmVmPVwiaHR0cHM6Ly9nby5taWNyb3NvZnQuY29tL2Z3bGluay8/TGlua0lkPTMyMTExNlwiIHRhcmdldD1cIl9ibGFua1wiPldlYiBmb3JtPC9hPikuIFdlIHdpbGwgcmVzcG9uZCB0byBxdWVzdGlvbnMgb3IgY29uY2VybnMgd2l0aGluIDMwIGRheXMuIEZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9uIGhvdyBNaWNyb3NvZnQgaGFuZGxlcyB5b3VyIHBlcnNvbmFsIGluZm9ybWF0aW9uLCBwbGVhc2Ugc2VlIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly9wcml2YWN5Lm1pY3Jvc29mdC5jb20vZW4tdXMvcHJpdmFjeXN0YXRlbWVudFwiIHRhcmdldD1cIl9ibGFua1wiPk1pY3Jvc29mdCBQcml2YWN5IFN0YXRlbWVudDwvYT4pLjwvcD48L3NwYW4+JyAgICBcclxuICAgICAgKVxyXG4gICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgIH0pOyAgICBcclxuICAgICAgXHJcbiAgICAgIGQzLnNlbGVjdCgnI2NvbnNlbnRfZGl2JylcclxuICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xyXG5cclxuICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgNDpcclxuXHJcbiAgICAgIGNvbnNlbnRfY29udGVudF9kaXYuYXBwZW5kKCdzcGFuJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywnY29uc2VudF90ZXh0JylcclxuICAgICAgLmh0bWwoXHJcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5SZXNlYXJjaCBSZXN1bHRzICYgRmVlZGJhY2s6PC9zcGFuPjxicj4nICtcclxuICAgICAgICAnPHNwYW4gc3R5bGU9XCJ0ZXh0LWFsaWduOmxlZnQ7IGZvbnQtc2l6ZTowLjdlbTtcIj48cD5NaWNyb3NvZnQgd2lsbCBvd24gYWxsIG9mIHRoZSByZXNlYXJjaCBkYXRhIGFuZCBhbmFseXNpcyBhbmQgb3RoZXIgcmVzdWx0cyAoY29sbGVjdGl2ZWx5IOKAnFJlc2VhcmNoIFJlc3VsdHPigJ0pIGdlbmVyYXRlZCBmcm9tIHRoZSBpbmZvcm1hdGlvbiB5b3UgcHJvdmlkZSBhbmQgeW91ciBwYXJ0aWNpcGF0aW9uIGluIHRoZSByZXNlYXJjaCBwcm9qZWN0LiBZb3UgbWF5IGFsc28gcHJvdmlkZSBzdWdnZXN0aW9ucywgY29tbWVudHMgb3Igb3RoZXIgZmVlZGJhY2sgKOKAnEZlZWRiYWNr4oCdKSB0byBNaWNyb3NvZnQgd2l0aCByZXNwZWN0IHRvIHRoZSByZXNlYXJjaCBwcm9qZWN0LiBGZWVkYmFjayBpcyBlbnRpcmVseSB2b2x1bnRhcnksIGFuZCBNaWNyb3NvZnQgc2hhbGwgYmUgZnJlZSB0byB1c2UsIGRpc2Nsb3NlLCByZXByb2R1Y2UsIGxpY2Vuc2UsIG9yIG90aGVyd2lzZSBkaXN0cmlidXRlLCBhbmQgbGV2ZXJhZ2UgdGhlIEZlZWRiYWNrIGFuZCBSZXNlYXJjaCBSZXN1bHRzLjwvcD48L3NwYW4+JyAgICBcclxuICAgICAgKVxyXG4gICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgIH0pOyAgICBcclxuICAgICAgXHJcbiAgICAgIGQzLnNlbGVjdCgnI2NvbnNlbnRfZGl2JylcclxuICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xyXG5cclxuICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgNTpcclxuXHJcbiAgICAgIGNvbnNlbnRfY29udGVudF9kaXYuYXBwZW5kKCdzcGFuJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywnY29uc2VudF90ZXh0JylcclxuICAgICAgLmh0bWwoXHJcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5CZW5lZml0cyBhbmQgUmlza3M6PC9zcGFuPjxicj4nICtcclxuICAgICAgICAnPHNwYW4gc3R5bGU9XCJ0ZXh0LWFsaWduOmxlZnQ7IGZvbnQtc2l6ZTowLjdlbTtcIj48cD48c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+QmVuZWZpdHM8L3NwYW4+OiBUaGUgcmVzZWFyY2ggdGVhbSBleHBlY3RzIHRvIGJldHRlciB1bmRlcnN0YW5kIHRoZSBwZXJjZXB0aW9uIG9mIHN0YXRpc3RpY2FsIGNoYXJ0cyBvbiBtb2JpbGUgcGhvbmVzLiBZb3Ugd2lsbCByZWNlaXZlIHRoZSBzcGVjaWZpZWQgcGF5bWVudCBhZnRlciBjb21wbGV0aW5nIHRoZSBISVQgYXMgd2VsbCBhcyBhbnkgcHVibGljIGJlbmVmaXQgdGhhdCBtYXkgY29tZSB0aGVzZSBSZXNlYXJjaCBSZXN1bHRzIGJlaW5nIHNoYXJlZCB3aXRoIHRoZSBncmVhdGVyIHNjaWVudGlmaWMgY29tbXVuaXR5LjwvcD48L3NwYW4+JyArXHJcbiAgICAgICAgJzxzcGFuIHN0eWxlPVwidGV4dC1hbGlnbjpsZWZ0OyBmb250LXNpemU6MC43ZW07XCI+PHA+PHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPlJpc2tzPC9zcGFuPjogRHVyaW5nIHlvdXIgcGFydGljaXBhdGlvbiwgeW91IG1heSBleHBlcmllbmNlIHJpc2sgdGhhdCBzaG91bGQgbm90IGJlIGFueSBtb3JlIHNpZ25pZmljYW50IHRoYW4gdGhlIHJpc2tzIHlvdSBleHBlcmllbmNlIGluIHlvdXIgcmVndWxhciBkYWlseSByb3V0aW5lLiBMb3NzIG9mIHRpbWUgYW5kIGNvbXBlbnNhdGlvbiBhcmUgYWxzbyByaXNrcywgcGFydGljdWxhcmx5IGlmIHlvdSBsb3NlIGludGVybmV0IGNvbm5lY3Rpdml0eSBhbmQgYXJlIHVuYWJsZSB0byBjb21wbGV0ZSB0aGUgSElULiAoY29udC4pPC9wPjwvc3Bhbj4nICAgICAgICBcclxuICAgICAgKVxyXG4gICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgIH0pOyAgICBcclxuICAgICAgXHJcbiAgICAgIGQzLnNlbGVjdCgnI2NvbnNlbnRfZGl2JylcclxuICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xyXG5cclxuICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgNjpcclxuXHJcbiAgICAgIGNvbnNlbnRfY29udGVudF9kaXYuYXBwZW5kKCdzcGFuJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywnY29uc2VudF90ZXh0JylcclxuICAgICAgLmh0bWwoXHJcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5CZW5lZml0cyBhbmQgUmlza3MgKGNvbnQuKTo8L3NwYW4+PGJyPicgK1xyXG4gICAgICAgICc8c3BhbiBzdHlsZT1cInRleHQtYWxpZ246bGVmdDsgZm9udC1zaXplOjAuN2VtO1wiPjxwPllvdSBhY2NlcHQgdGhlIHJpc2tzIGRlc2NyaWJlZCBvbiB0aGUgcHJldmlvdXMgcGFnZSBhbmQgd2hhdGV2ZXIgY29uc2VxdWVuY2VzIG1heSBjb21lIG9mIHRob3NlIHJpc2tzLCBob3dldmVyIHVubGlrZWx5LCB1bmxlc3MgY2F1c2VkIGJ5IG91ciBuZWdsaWdlbmNlIG9yIGludGVudGlvbmFsIG1pc2NvbmR1Y3QuIFlvdSBoZXJlYnkgcmVsZWFzZSBNaWNyb3NvZnQgYW5kIGl0cyBhZmZpbGlhdGVzIGZyb20gYW55IGNsYWltIHlvdSBtYXkgaGF2ZSBub3cgb3IgaW4gdGhlIGZ1dHVyZSBhcmlzaW5nIGZyb20gc3VjaCByaXNrcyBvciBjb25zZXF1ZW5jZXMuIEluIGFkZGl0aW9uLCB5b3UgYWdyZWUgdGhhdCBNaWNyb3NvZnQgd2lsbCBub3QgYmUgbGlhYmxlIGZvciBhbnkgbG9zcywgZGFtYWdlcyBvciBpbmp1cmllcyB0aGF0IG1heSBjb21lIG9mIGltcHJvcGVyIHVzZSBvZiB0aGUgc3R1ZHkgcHJvdG90eXBlLCBlcXVpcG1lbnQsIGZhY2lsaXRpZXMsIG9yIGFueSBvdGhlciBkZXZpYXRpb25zIGZyb20gdGhlIGluc3RydWN0aW9ucyBwcm92aWRlZCBieSB0aGUgcmVzZWFyY2ggdGVhbS4gRG9u4oCZdCBwYXJ0aWNpcGF0ZSBpbiB0aGlzIHN0dWR5IGlmIHlvdSBmZWVsIHlvdSBtYXkgbm90IGJlIGFibGUgdG8gc2FmZWx5IHBhcnRpY2lwYXRlIGluIGFueSB3YXkgaW5jbHVkaW5nIGR1ZSB0byBhbnkgcGh5c2ljYWwgb3IgbWVudGFsIGlsbG5lc3MsIGNvbmRpdGlvbiBvciBsaW1pdGF0aW9uLiBZb3UgYWdyZWUgdG8gaW1tZWRpYXRlbHkgbm90aWZ5IHRoZSByZXNlYXJjaCB0ZWFtIG9mIGFueSBpbmNpZGVudCBvciBpc3N1ZSBvciB1bmFudGljaXBhdGVkIHJpc2sgb3IgaW5jaWRlbnQuPC9wPjwvc3Bhbj4nICAgICAgICBcclxuICAgICAgKVxyXG4gICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgIH0pOyAgICBcclxuICAgICAgXHJcbiAgICAgIGQzLnNlbGVjdCgnI2NvbnNlbnRfZGl2JylcclxuICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xyXG5cclxuICAgIGJyZWFrOyAgICBcclxuXHJcbiAgICBjYXNlIDc6XHJcbiAgICBcclxuICAgICAgY29uc2VudF9jb250ZW50X2Rpdi5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdjb25zZW50X3RleHQnKVxyXG4gICAgICAuaHRtbCggICAgICAgICBcclxuICAgICAgICAnPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPllvdXIgQXV0aG9yaXR5IHRvIFBhcnRpY2lwYXRlOjwvc3Bhbj48YnI+JyArXHJcbiAgICAgICAgJzxzcGFuIHN0eWxlPVwidGV4dC1hbGlnbjpsZWZ0OyBmb250LXNpemU6MC43ZW07XCI+PHA+WW91IHJlcHJlc2VudCB0aGF0IHlvdSBoYXZlIHRoZSBmdWxsIHJpZ2h0IGFuZCBhdXRob3JpdHkgdG8gc2lnbiB0aGlzIGZvcm0sIGFuZCBpZiB5b3UgYXJlIGEgbWlub3IgdGhhdCB5b3UgaGF2ZSB0aGUgY29uc2VudCAoYXMgaW5kaWNhdGVkIGJlbG93KSBvZiB5b3VyIGxlZ2FsIGd1YXJkaWFuIHRvIHNpZ24gYW5kIGFja25vd2xlZGdlIHRoaXMgZm9ybS4gQnkgY2xpY2tpbmcg4oCcSSBhZ3JlZeKAnSBiZWxvdywgeW91IGNvbmZpcm0gdGhhdCB5b3UgdW5kZXJzdGFuZCB0aGUgcHVycG9zZSBvZiB0aGUgcHJvamVjdCBhbmQgaG93IGl0IHdpbGwgYmUgY29uZHVjdGVkIGFuZCBjb25zZW50IHRvIHBhcnRpY2lwYXRlIG9uIHRoZSB0ZXJtcyBzZXQgZm9ydGggYWJvdmUuIFNob3VsZCB5b3UgaGF2ZSBhbnkgcXVlc3Rpb25zIGNvbmNlcm5pbmcgdGhpcyBwcm9qZWN0LCBwbGVhc2UgY29udGFjdCBNYXR0aGV3IEJyZWhtZXIgKDxhIGhyZWY9XCJtYWlsdG86bWFicmVobWVAbWljcm9zb2Z0LmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPm1hYnJlaG1lQG1pY3Jvc29mdC5jb208L2E+KS4gUGxlYXNlIGNvbmZpcm0geW91ciBhY2NlcHRhbmNlIGJ5IGNsaWNraW5nIOKAnEkgYWdyZWXigJ0gYmVsb3cuIFVwb24gcmVxdWVzdCwgYSBjb3B5IG9mIHRoaXMgY29uc2VudCBmb3JtIHdpbGwgYmUgcHJvdmlkZWQgdG8geW91IGZvciB5b3VyIHJlY29yZHMuIE9uIGJlaGFsZiBvZiBNaWNyb3NvZnQsIHdlIHRoYW5rIHlvdSBmb3IgeW91ciBjb250cmlidXRpb24gYW5kIGxvb2sgZm9yd2FyZCB0byB5b3VyIHJlc2VhcmNoIHNlc3Npb24uPC9wPjwvc3Bhbj4nICsgJzxzcGFuIHN0eWxlPVwidGV4dC1hbGlnbjpsZWZ0OyBmb250LXNpemU6MC43ZW07XCI+PHA+RG8geW91IHVuZGVyc3RhbmQgYW5kIGNvbnNlbnQgdG8gdGhlc2UgdGVybXM/PC9wPjwvc3Bhbj4nICAgICAgICBcclxuICAgICAgKVxyXG4gICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgIH0pOyAgICBcclxuICAgICAgXHJcbiAgICAgIGQzLnNlbGVjdCgnI2NvbnNlbnRfZGl2JylcclxuICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xyXG5cclxuICAgIGJyZWFrO1xyXG4gICAgXHJcbiAgICBkZWZhdWx0OiAvLyByZXR1cm4gdG8gbWFpbiBtZW51XHJcblxyXG4gICAgICBkMy5zZWxlY3QoJyNjb25zZW50X2RpdicpLnJlbW92ZSgpO1xyXG4gICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnNlbnRfZGl2JykgIT0gdW5kZWZpbmVkKSB7ICAgICAgXHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnNlbnRfZGl2JykucmVtb3ZlKCk7IFxyXG4gICAgICB9XHJcblxyXG4gICAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgICBcIkV2ZW50XCI6IFwiQ29uc2VudENvbXBsZXRlXCIsXHJcbiAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklEXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIkNvbnNlbnRDb21wbGV0ZVwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcbiAgICAgIFxyXG4gICAgICBjb25zZW50X2NvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgbG9hZE1lbnUoKTtcclxuICAgICAgaGlkZUFkZHJlc3NCYXIoKTsgICBcclxuXHJcbiAgICBicmVhaztcclxuICB9XHJcbiAgXHJcbiAgZDMuc2VsZWN0KCcjY29uc2VudF9kaXYnKS5hcHBlbmQoJ2lucHV0JylcclxuICAuYXR0cignY2xhc3MnLCAnbWVudV9idG5fZW5hYmxlZCcpXHJcbiAgLmF0dHIoJ2lkJywnc3VibWl0X2J0bicpXHJcbiAgLmF0dHIoJ3R5cGUnLCdidXR0b24nKVxyXG4gIC5hdHRyKCd2YWx1ZScsIHNjZW5lID09IDcgPyAnSSBBR1JFRScgOiAnTkVYVCcpXHJcbiAgLmF0dHIoJ3RpdGxlJywgc2NlbmUgPT0gNyA/ICdJIEFHUkVFJyA6ICdORVhUJylcclxuICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcblxyXG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgIFxyXG4gICAgXHJcbiAgICBkMy5zZWxlY3QoJyNjb25zZW50X2RpdicpLnJlbW92ZSgpO1xyXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25zZW50X2RpdicpICE9IHVuZGVmaW5lZCkgeyAgICAgIFxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uc2VudF9kaXYnKS5yZW1vdmUoKTsgXHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICAgIFwiVGltZVN0YW1wXCI6IG5ldyBEYXRlKCkudmFsdWVPZigpLFxyXG4gICAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySUQsXHJcbiAgICAgIFwiRXZlbnRcIjogXCJDb25zZW50XCIsXHJcbiAgICAgIFwiU2NlbmVcIjogc2NlbmUgKyAxXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiQ29uc2VudFwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcbiAgICBjb25zZW50KHNjZW5lICsgMSk7XHJcbiAgfSk7XHJcbiBcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBjb25zZW50O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb25zZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZDMgPSByZXF1aXJlKFwiZDNcIik7XHJcbnZhciBnbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcclxudmFyIGNoYXJ0ID0gcmVxdWlyZShcIi4vY2hhcnRcIik7XHJcbnZhciBuYXRpb25EYXRhID0gcmVxdWlyZShcIi4vZGF0YS9zdHVkeURhdGFcIik7XHJcbnZhciBjb3VudHJ5U2VsZWN0b3IgPSByZXF1aXJlKFwiLi9jb3VudHJ5U2VsZWN0b3JcIik7XHJcblxyXG5mdW5jdGlvbiBpbnRyb2R1Y3Rpb24gKHNjZW5lKSB7XHJcblxyXG4gIHN1cHByZXNzX3RvdWNoX2ZlZWRiYWNrID0gdHJ1ZTtcclxuICBzdXBwcmVzc190b3VjaF92YWxfZmVlZGJhY2sgPSB0cnVlO1xyXG4gIGdsb2JhbHMudHJpYWxfcmVzcG9uc2UgPSBbXTtcclxuICBjaGFydF9zdGFnZSA9IC0xO1xyXG5cclxuICB2YXIgY2hlY2tFeGlzdDsgIFxyXG4gIHZhciBjaGVja1RvdWNoO1xyXG4gIHZhciBhdHRlbXB0cyA9IDA7XHJcblxyXG4gIGNoYXJ0X2luc3RhbmNlID0gY2hhcnQoKTtcclxuXHJcbiAgYWxsX2RhdGEgPSBuYXRpb25EYXRhOyAgXHJcbiAgdmFyIGNvZGVzID0gW1wiQVwiLCBcIkJcIiwgXCJDXCIsIFwiRFwiLCBcIkVcIiwgXCJGXCIsIFwiR1wiLCBcIkhcIiwgXCJJXCIsIFwiSlwiLCBcIktcIiwgXCJMXCIsIFwiTVwiLCBcIk5cIiwgXCJPXCIsIFwiUFwiXTsgLy8sXHJcbiAgY29kZXMgPSBzaHVmZmxlKGNvZGVzKTtcclxuICBhbGxfZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLGkpeyBcclxuICAgIGQuY29kZSA9IGNvZGVzW2ldOyBcclxuICB9KTtcclxuICAgIFxyXG4gIGZ1bmN0aW9uIGdldERpbXMoKSB7XHJcbiAgICBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgc3ZnX2RpbSA9IGQzLm1pbihbaGVpZ2h0LHdpZHRoXSkgLSAyO1xyXG4gICAgaW5uZXJfcGFkZGluZyA9IHN2Z19kaW0gKiAwLjE7XHJcbiAgICBjaGFydF9kaW0gPSBzdmdfZGltICogMC44O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZHJhdygpIHtcclxuICBcclxuICAgIGdldERpbXMoKTtcclxuICAgICAgICBcclxuICAgIGQzLnNlbGVjdCgnI21haW5fc3ZnJylcclxuICAgIC5zdHlsZSgnaGVpZ2h0JyxzdmdfZGltICsgJ3B4JylcclxuICAgIC5zdHlsZSgnd2lkdGgnLHN2Z19kaW0gKyAncHgnKTtcclxuICAgIFxyXG4gICAgY2hhcnRfZy5hdHRyKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJyArIGlubmVyX3BhZGRpbmcgKyAnLCcgKyBpbm5lcl9wYWRkaW5nICsgJyknKTtcclxuICBcclxuICAgIGQzLnNlbGVjdEFsbCgnLmd1aWRlJykucmVtb3ZlKCk7XHJcbiAgICBjaGFydF9pbnN0YW5jZS5saW5lcygnb2ZmJyk7IFxyXG4gICAgY2hhcnRfaW5zdGFuY2UuYW5pbWF0aW9uKCdvZmYnKTtcclxuICAgIGNoYXJ0X2luc3RhbmNlLmZhY2V0cygnb2ZmJyk7XHJcbiAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoZ2xvYmFscy5wYXJhbV95ZWFyTWluKTtcclxuXHJcbiAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gICAgZDMuc2VsZWN0QWxsKCcubWFyaycpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgZDMuc2VsZWN0KCcueWVhcl9pbmRpY2F0b3InKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgIGNoYXJ0X2cuY2FsbChjaGFydF9pbnN0YW5jZSk7XHJcbiAgXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb2FkRGF0YSAoKSB7ICAgICBcclxuXHJcbiAgICBjaGVja0V4aXN0ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmIChhbGxfZGF0YSAhPSB1bmRlZmluZWQpIHsgICAgICAgIFxyXG4gICAgICAgIGNoYXJ0X2cuZGF0dW0oYWxsX2RhdGEpO1xyXG4gICAgICAgIGRyYXcoKTsgICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgaGlkZUFkZHJlc3NCYXIoKTtcclxuXHJcbiAgICAgICAgZDMuc2VsZWN0KCcjaW50cm9kdWN0aW9uX2RpdicpXHJcbiAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xyXG5cclxuICAgICAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgICAgIFwiVGltZVN0YW1wXCI6IG5ldyBEYXRlKCkudmFsdWVPZigpLFxyXG4gICAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklELCBcclxuICAgICAgICAgIFwiRXZlbnRcIjogXCJJbnRyb0V2ZW50XCIsXHJcbiAgICAgICAgICBcIkV2ZW50VHlwZVwiOiBcImxvYWREYXRhXCIsIFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW50cm9FdmVudFwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjaGVja0V4aXN0KTtcclxuICAgICAgfVxyXG4gICAgfSwgMTAwKTsgLy8gY2hlY2sgZXZlcnkgMTAwbXNcclxuXHJcbiAgICBjaGFydF9pbnN0YW5jZSA9IGNoYXJ0KCk7XHJcbiAgXHJcbiAgICBtYWluX3N2ZyA9IGQzLnNlbGVjdCgnI21haW5fc3ZnJykucmVtb3ZlKCk7XHJcbiAgXHJcbiAgICBtYWluX3N2ZyA9IGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKS5hcHBlbmQoJ3N2ZycpXHJcbiAgICAuYXR0cignaWQnLCdtYWluX3N2ZycpXHJcbiAgICAuc3R5bGUoJ21hcmdpbi10b3AnLC00MCArICdweCcpOyAgXHJcbiAgXHJcbiAgICBkZWZzID0gZDMuc2VsZWN0KCcjbWFpbl9zdmcnKS5hcHBlbmQoJ2RlZnMnKTtcclxuICBcclxuICAgIGNoYXJ0X2cgPSBtYWluX3N2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgLmF0dHIoJ2lkJywnY2hhcnRfZycpOyAgICBcclxuICAgIFxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ludHJvZHVjdGlvbl9kaXYnKS5mb2N1cygpO1xyXG5cclxuICB9IFxyXG5cclxuICBmdW5jdGlvbiBidWlsZF9jaGFydChzdGFnZSkge1xyXG5cclxuICAgIHN3aXRjaCAoc3RhZ2UpIHtcclxuXHJcbiAgICAgIGNhc2UgMDpcclxuXHJcbiAgICAgICAgaW5zdHJ1Y3Rpb25fdGV4dC5odG1sKCc2LiBJbiB0aGlzIGV4cGVyaW1lbnQsIHlvdSB3aWxsIHZpZXcgY2hhcnRzIGRlcGljdGluZyBudW1lcmljYWwgdmFsdWVzLiBJbiB0aGlzIGV4YW1wbGUsIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5MaWZlIEV4cGVjdGFuY3k8L3NwYW4+IGluY3JlYXNlcyBmcm9tIGxlZnQgdG8gcmlnaHQsIGFuZCA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+R0RQIFBlciBDYXBpdGE8L3NwYW4+IChhIGNvbW1vbiBlY29ub21pYyBpbmRpY2F0b3IpIGluY3JlYXNlcyBmcm9tIGJvdHRvbSB0byB0b3AuJyk7IFxyXG4gICAgICAgIGxvYWREYXRhKCk7XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSAxOlxyXG5cclxuICAgICAgICBpbnN0cnVjdGlvbl90ZXh0Lmh0bWwoJzcuIEVhY2ggb2YgdGhlIGNpcmNsZXMgYmVsb3cgcmVwcmVzZW50cyBhIGNvdW50cnksIHdoZXJlIHRoZSA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+c2l6ZTwvc3Bhbj4gb2YgYSBjaXJjbGUgcmVwcmVzZW50cyB0aGUgY29ycmVzcG9uZGluZyBjb3VudHJ5XFwncyA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+UG9wdWxhdGlvbjwvc3Bhbj4uPGJyPjxicj4nKTsgXHJcblxyXG4gICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zZWxlY3QoJ2NpcmNsZScpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJywnIzU0YjJmYycpO1xyXG4gICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zZWxlY3QoJ3RleHQnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICBkMy5zZWxlY3RBbGwoJy5tYXJrJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbignb2ZmJyk7XHJcbiAgICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIDI6XHJcblxyXG4gICAgICAgIGluc3RydWN0aW9uX3RleHQuaHRtbCgnOC4gSW4gdGhpcyBleHBlcmltZW50LCB3ZSB3b25cXCd0IHVzZSB0aGUgcmVhbCBuYW1lcyBvZiBjb3VudHJpZXMuIEluc3RlYWQsIHdlIHdpbGwgYXNzaWduIGVhY2ggY291bnRyeSBhIGxldHRlciwgYW5kIHdlIHdpbGwgY29sb3IgdGhlIGNvdW50cmllcyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRpbmVudCBpbiB3aGljaCB0aGV5IGNhbiBiZSBmb3VuZC48YnI+Jyk7IFxyXG5cclxuICAgICAgICB2YXIgc2NhbGVfcmVnID0gY2hhcnRfaW5zdGFuY2Uuc2NhbGVfcmVnKCk7XHJcbiAgICAgICAgdmFyIGNvbG9yX3BhcmFtID0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkuY29sb3I7XHJcblxyXG4gICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zZWxlY3QoJ2NpcmNsZScpXHJcbiAgICAgICAgLnN0eWxlKCdmaWxsJyxmdW5jdGlvbihkKXtcclxuICAgICAgICAgIHJldHVybiBzY2FsZV9yZWcoZFtjb2xvcl9wYXJhbV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zZWxlY3QoJ3RleHQnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICAgICAgZDMuc2VsZWN0QWxsKCcubWFyaycpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIDM6XHJcblxyXG4gICAgICAgIGluc3RydWN0aW9uX3RleHQuaHRtbCgnOS4gVGhpcyBjaGFydCByZWZsZWN0cyB0aGUgMTk3NSA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+TGlmZSBFeHBlY3RhbmN5PC9zcGFuPiwgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPkdEUCBQZXIgQ2FwaXRhPC9zcGFuPiwgYW5kIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5Qb3B1bGF0aW9uPC9zcGFuPiB2YWx1ZXMgZm9yIHRoZXNlIGNvdW50cmllcy48YnI+PGJyPicpOyBcclxuXHJcbiAgICAgICAgZDMuc2VsZWN0KCcueWVhcl9pbmRpY2F0b3InKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSA0OlxyXG5cclxuICAgICAgICBpbnN0cnVjdGlvbl90ZXh0Lmh0bWwoJzEwLiBUaGUgYW5pbWF0aW9uIHNob3dzIGhvdyB0aGUgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPkxpZmUgRXhwZWN0YW5jeTwvc3Bhbj4sIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5HRFAgUGVyIENhcGl0YTwvc3Bhbj4sIGFuZCA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+UG9wdWxhdGlvbjwvc3Bhbj4gb2YgdGhlc2UgY291bnRyaWVzIGNoYW5nZWQgYmV0d2VlbiAxOTc1IGFuZCAyMDAwLiBUaGUgYW5pbWF0aW9uIHdpbGwgc3RhcnQgb3ZlciBhZnRlciByZWFjaGluZyB0aGUgeWVhciAyMDAwLjxicj4nKTsgXHJcblxyXG4gICAgICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbignb24nKTtcclxuICAgICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG5cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgNTpcclxuXHJcbiAgICAgICAgc3dpdGNoIChnbG9iYWxzLmNvbmRpdGlvbikge1xyXG5cclxuICAgICAgICAgIGNhc2UgJ3N0ZXBwZXInOlxyXG5cclxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25fdGV4dC5odG1sKCcxMS4gPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPlRhcCBvciBob2xkPC9zcGFuPiB0aGUgYnV0dG9ucyBiZWxvdyB0byBuYXZpZ2F0ZSBpbiB0aW1lLiBUaGUgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPnJpbmc8L3NwYW4+IChib3R0b20tcmlnaHQpIG11c3QgYmUgY29tcGxldGUgdG8gY29udGludWUuJyk7IFxyXG5cclxuICAgICAgICAgICAgYWRkbWVudSgpO1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoZ2xvYmFscy5wYXJhbV95ZWFyTWluKTtcclxuICAgICAgICAgICAgY2hhcnRfaW5zdGFuY2UuYW5pbWF0aW9uKCdvZmYnKTtcclxuICAgICAgICAgICAgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgwKTtcclxuICAgICAgICAgICAgdXBkYXRlX291dGVyX3Byb2dyZXNzKDEgLyAyNSk7XHJcbiAgICAgICAgICAgIGNoYXJ0X2cuY2FsbChjaGFydF9pbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI3N1Ym1pdF9idG4nKS5hdHRyKCdjbGFzcycsJ21lbnVfYnRuX2Rpc2FibGVkJykuYXR0cignZGlzYWJsZWQnLHRydWUpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XHJcblxyXG4gICAgICAgICAgICBpbnN0cnVjdGlvbl90ZXh0Lmh0bWwoJzExLiBUaGUgcmluZyAoYm90dG9tLXJpZ2h0KSB3aWxsIHNob3cgdGhlIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5wcm9ncmVzcyBvZiB0aGUgYW5pbWF0aW9uPC9zcGFuPi4gWW91IG1heSBwcm9jZWVkIG9uY2UgdGhlIHJpbmcgaXMgY29tcGxldGUuJyk7IFxyXG5cclxuICAgICAgICAgICAgYWRkbWVudSgpO1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoZ2xvYmFscy5wYXJhbV95ZWFyTWluKTtcclxuICAgICAgICAgICAgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgwKTtcclxuICAgICAgICAgICAgdXBkYXRlX291dGVyX3Byb2dyZXNzKDEgLyAyNSk7XHJcbiAgICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbignb24nKTtcclxuICAgICAgICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjc3VibWl0X2J0bicpLmF0dHIoJ2NsYXNzJywnbWVudV9idG5fZGlzYWJsZWQnKS5hdHRyKCdkaXNhYmxlZCcsdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlICdtdWx0aXBsZXMnOlxyXG5cclxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25fdGV4dC5odG1sKCcxMS4gSGVyZVxcJ3MgYW5vdGhlciB3YXkgdG8gc2hvdyB0aGUgc2FtZSBkYXRhLiBJbnN0ZWFkIG9mIGEgc2luZ2xlIGNoYXJ0LCBlYWNoIGNvdW50cnkgaGFzIGl0cyBvd24gY2hhcnQsIHdoZXJlIHRoZSA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+ZG90IGNvcnJlc3BvbmRzIHRvIHRoZSBmaW5hbCB2YWx1ZXM8L3NwYW4+LCBhbmQgZWFjaCBjb3VudHJ5XFwncyB0cmFqZWN0b3J5IGlzIGRyYXduIGFzIGEgbGluZS4nKTtcclxuXHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnLnllYXJfaW5kaWNhdG9yJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbignb2ZmJyk7XHJcbiAgICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihnbG9iYWxzLnBhcmFtX3llYXJNYXgpO1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5saW5lcygnb24nKTtcclxuICAgICAgICAgICAgY2hhcnRfaW5zdGFuY2UuZmFjZXRzKCdvbicpO1xyXG4gICAgICAgICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAvLyBkMy5zZWxlY3QoJyNzdWJtaXRfYnRuJykuYXR0cignY2xhc3MnLCdtZW51X2J0bl9kaXNhYmxlZCcpLmF0dHIoJ2Rpc2FibGVkJyx0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfSAgICAgICBcclxuXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIDY6XHJcbiAgICAgIFxyXG4gICAgICAgIGluc3RydWN0aW9uX3RleHQuaHRtbCgnJyk7ICAgICAgICBcclxuICAgICAgICBcclxuICAgICAgICB2YXIgaW50cm9fY29udGVudF9kaXYgPSBkMy5zZWxlY3QoJyNpbnRyb2R1Y3Rpb25fZGl2JylcclxuICAgICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsJ3Rvb2xiYXInKVxyXG4gICAgICAgIC5zdHlsZSgnd2lkdGgnLCcxMDAlJylcclxuICAgICAgICAuc3R5bGUoJ2hlaWdodCcsKHdpbmRvdy5pbm5lckhlaWdodCAtIDUwKSArICdweCcpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywnaW50cm9fY29udGVudF9kaXYnKTsgICBcclxuXHJcbiAgICAgICAgaW50cm9fY29udGVudF9kaXYuYXBwZW5kKCdzcGFuJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCdjb25zZW50X3RleHQnKVxyXG4gICAgICAgIC5odG1sKCc8c3BhbiBzdHlsZT1cInRleHQtYWxpZ246bGVmdDsgZm9udC1zaXplOjAuOGVtO1wiPjEyLiBJbiB0aGUgZXhwZXJpbWVudCwgeW91XFwnbGwgYmUgYXNrZWQgdG8gc2VsZWN0IG9uZSBvciBtb3JlIGNvdW50cmllcyBiYXNlZCBvbiB0aGVpciBjaGFyYWN0ZXJpc3RpY3MuJyArIFxyXG4gICAgICAgICc8YnI+PGJyPkluIHNvbWUgY2FzZXMsIHRoZXJlIG1heSBiZSBtb3JlIGNvcnJlY3QgcmVzcG9uc2VzIHRoYW4gcmVxdWlyZWQgcmVzcG9uc2VzLCBhbmQgdGhlIG9yZGVyIGluIHdoaWNoIHlvdSBzZWxlY3QgcmVzcG9uc2VzIGRvZXMgbm90IG1hdHRlci4nICsgXHJcbiAgICAgICAgJzxicj48YnI+SWYgeW91IGNoYW5nZSB5b3VyIG1pbmQgYWJvdXQgYSBzZWxlY3Rpb24sIHRhcCBpdCBhZ2FpbiB0byBkZS1zZWxlY3QgaXQuJyArIFxyXG4gICAgICAgICc8YnI+PGJyPlRhcCA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+TkVYVDwvc3Bhbj4gdG8gcGVyZm9ybSBhIHByYWN0aWNlIHRyaWFsLjwvc3Bhbj4nKTsgICBcclxuXHJcbiAgICAgICAgZDMuc2VsZWN0KCcjbWFpbl9zdmcnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICBkMy5zZWxlY3QoJyNtZW51YmFyJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoZ2xvYmFscy5jb25kaXRpb24pIHtcclxuXHJcbiAgICAgICAgICBjYXNlICdzdGVwcGVyJzpcclxuXHJcbiAgICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihnbG9iYWxzLnBhcmFtX3llYXJNaW4pO1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5hbmltYXRpb24oJ29mZicpO1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KDApO1xyXG4gICAgICAgICAgICB1cGRhdGVfb3V0ZXJfcHJvZ3Jlc3MoMSAvIDI1KTtcclxuICAgICAgICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XHJcblxyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoZ2xvYmFscy5wYXJhbV95ZWFyTWluKTtcclxuICAgICAgICAgICAgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgwKTtcclxuICAgICAgICAgICAgdXBkYXRlX291dGVyX3Byb2dyZXNzKDEgLyAyNSk7XHJcbiAgICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbignb24nKTtcclxuICAgICAgICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGNhc2UgJ211bHRpcGxlcyc6XHJcblxyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5hbmltYXRpb24oJ29mZicpO1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoZ2xvYmFscy5wYXJhbV95ZWFyTWF4KTtcclxuICAgICAgICAgICAgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgwKTtcclxuICAgICAgICAgICAgdXBkYXRlX291dGVyX3Byb2dyZXNzKDAgLyAyNSk7XHJcbiAgICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmxpbmVzKCdvbicpO1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5mYWNldHMoJ29uJyk7XHJcbiAgICAgICAgICAgIGFkZG1lbnUoKTtcclxuICAgICAgICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgfSAgICAgICBcclxuXHJcbiAgICAgICAgZDMuc2VsZWN0KCcjbWVudWJhcicpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgXHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBjYXNlIDc6XHJcblxyXG4gICAgICAgIGQzLnNlbGVjdCgnI2luc3RydWN0aW9uX3RleHQnKS5yZW1vdmUoKTtcclxuICAgICAgICBkMy5zZWxlY3QoJyNpbnRyb19jb250ZW50X2RpdicpLnJlbW92ZSgpO1xyXG4gICAgICAgIGQzLnNlbGVjdCgnI3N1Ym1pdF9idG4nKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICBkMy5zZWxlY3QoJyNpbnN0cnVjdGlvbl9kaXYnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICBkMy5zZWxlY3QoJy55ZWFyX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICBkMy5zZWxlY3RBbGwoJy5saW5lJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgICAgZDMuc2VsZWN0KCcjbWFpbl9zdmcnKS5zdHlsZSgnZGlzcGxheScsbnVsbCkgICAgICAgIFxyXG4gICAgICAgIC5zdHlsZSgnbWFyZ2luLXRvcCcsMCArICdweCcpOyBcclxuICAgICAgICBcclxuICAgICAgICBkMy5zZWxlY3QoJyNpbnRyb2R1Y3Rpb25fZGl2JykuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdmZWVkYmFja19idG5fZW5hYmxlZCcpXHJcbiAgICAgICAgLnN0eWxlKCdib3JkZXItY29sb3InLCd0cmFuc3BhcmVudCcpXHJcbiAgICAgICAgLnN0eWxlKCd0b3AnLChzdmdfZGltICsgNSkgKyAncHgnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsJ3N0YXJ0X2J0bicpXHJcbiAgICAgICAgLnN0eWxlKCdoZWlnaHQnLCcxMjVweCcpO1xyXG5cclxuICAgICAgICBkMy5zZWxlY3QoJyNzdGFydF9idG4nKS5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsJ2J1dHRvbl90ZXh0JylcclxuICAgICAgICAuaHRtbCgnPHNwYW4+VGFrZSBub3RlIG9mIHRoZSA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCIgc3R5bGU9XCJjb2xvcjpnb2xkO1wiPnR3byBjaGFydCBheGVzPC9zcGFuPiBhYm92ZSBhbmQgdGhpcyBpbnN0cnVjdGlvbjo8L3NwYW4+PGJyPicgKyAoZ2xvYmFscy5jb25kaXRpb24gIT0gJ211bHRpcGxlcycgPyAnIFZpZXcgPHNwYW4gY2xhc3M9XFwnaW5zdHJ1Y3Rpb25fZW1waGFzaXNcXCc+YWxsIHllYXJzPC9zcGFuPiwgcycgOiAnUycpICsgJ2VsZWN0IDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fbnVtYmVyXCI+dGhyZWU8L3NwYW4+IGNvdW50cmllcyB0aGF0IGFyZSA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+bGFiZWxlZCB3aXRoIFZPV0VMUzwvc3Bhbj4uPGJyPicgKyAnPHNwYW4gaWQ9XCJ0aW1lX3dhcm5pbmdcIj5Zb3UgbWF5IHByb2NlZWQgYWZ0ZXIgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPjUgc2Vjb25kczwvc3Bhbj4uPC9zcGFuPicgKyAnPHNwYW4gaWQ9XCJ0aW1lX2RlbGF5X21lc3NhZ2VcIiAgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCI+VGFwIG9uIHRoaXMgbWVzc2FnZSB0byBzdGFydCB0aGlzIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5QUkFDVElDRTwvc3Bhbj4gdHJpYWwuPC9zcGFuPicpOyBcclxuXHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgLy8gYWxsb3cgcGFydGljaXBhbnQgdG8gcHJvY2VlZCBhZnRlciA1c1xyXG5cclxuICAgICAgICAgIGQzLnNlbGVjdCgnI3RpbWVfd2FybmluZycpXHJcbiAgICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcblxyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjdGltZV9kZWxheV9tZXNzYWdlJylcclxuICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcblxyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjc3RhcnRfYnRuJylcclxuICAgICAgICAgIC5zdHlsZSgnYm9yZGVyLWNvbG9yJywnI2ZmZicpXHJcbiAgICAgICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICBcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjc3RhcnRfYnRuJykucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihnbG9iYWxzLmNvbmRpdGlvbiA9PSAnbXVsdGlwbGVzJyA/IGdsb2JhbHMucGFyYW1feWVhck1heCA6IGdsb2JhbHMucGFyYW1feWVhck1pbik7XHJcbiAgICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoMCk7XHJcbiAgICAgICAgICAgIHVwZGF0ZV9vdXRlcl9wcm9ncmVzcygxIC8gMjUpO1xyXG4gICAgICAgICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcubWFyaycpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcubGluZScpLnN0eWxlKCdkaXNwbGF5JyxnbG9iYWxzLmNvbmRpdGlvbiA9PSAnbXVsdGlwbGVzJyA/IG51bGwgOiAnbm9uZScpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3QoJy55ZWFyX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjbWVudWJhcicpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuXHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnLnRhc2tfaW5zdHJ1Y3Rpb25fc3BhbicpXHJcbiAgICAgICAgICAgIC5odG1sKChnbG9iYWxzLmNvbmRpdGlvbiAhPSAnbXVsdGlwbGVzJyA/ICcgVmlldyA8c3BhbiBjbGFzcz1cXCdpbnN0cnVjdGlvbl9lbXBoYXNpc1xcJz5hbGwgeWVhcnM8L3NwYW4+LCBzJyA6ICdTJykgKyAnZWxlY3QgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9udW1iZXJcIj50aHJlZTwvc3Bhbj4gY291bnRyaWVzIHRoYXQgYXJlIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5sYWJlbGVkIHdpdGggVk9XRUxTPC9zcGFuPiB1c2luZyB0aGUgYnV0dG9ucyBiZWxvdywgdGhlbiB0YXAgXFwnRE9ORVxcJy4nKTsgIFxyXG5cclxuICAgICAgICAgICAgY291bnRyeVNlbGVjdG9yKCk7ICAgICAgXHJcbiAgICAgICAgICB9KTsgXHJcbiAgICAgICAgfSwgNTAwMCk7IFxyXG5cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbignb2ZmJyk7XHJcbiAgICAgICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKGdsb2JhbHMucGFyYW1feWVhck1heCk7XHJcbiAgICAgICAgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgwKTtcclxuICAgICAgICB1cGRhdGVfb3V0ZXJfcHJvZ3Jlc3MoMCAvIDI1KTtcclxuICAgICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG5cclxuICAgICAgICBkMy5zZWxlY3QoJyNpbnRyb2R1Y3Rpb25fZGl2JykucmVtb3ZlKCk7XHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnRyb2R1Y3Rpb25fZGl2JykgIT0gdW5kZWZpbmVkKSB7ICAgICAgXHJcbiAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW50cm9kdWN0aW9uX2RpdicpLnJlbW92ZSgpOyBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgICAgICBcInVzZXJfaWRcIjogZ2xvYmFscy51c2VySUQsXHJcbiAgICAgICAgICBcIkV2ZW50XCI6IFwiSW50cm9cIixcclxuICAgICAgICAgIFwiU2NlbmVcIjogc2NlbmUgKyAxXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ0ludHJvJyxnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcblxyXG4gICAgICAgIHNjZW5lID0gNztcclxuICAgICAgICBpbnRyb2R1Y3Rpb24oc2NlbmUpO1xyXG5cclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICB9ICAgXHJcblxyXG4gIH1cclxuICAgICAgXHJcbiAgLyoqIElOSVQgKiovXHJcbiAgXHJcbiAgZDMuc2VsZWN0KCdib2R5JykuYXBwZW5kKCdkaXYnKVxyXG4gIC5hdHRyKCdpZCcsJ2ludHJvZHVjdGlvbl9kaXYnKVxyXG4gIC5hdHRyKCd0YWJpbmRleCcsMCk7ICBcclxuXHJcbiAgdmFyIGluc3RydWN0aW9uX2RpdiA9IGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgLmF0dHIoJ2NsYXNzJywndG9vbGJhcicpXHJcbiAgLmF0dHIoJ2lkJywnaW5zdHJ1Y3Rpb25fZGl2Jyk7XHJcblxyXG4gIHZhciBpbnN0cnVjdGlvbl90ZXh0ID0gaW5zdHJ1Y3Rpb25fZGl2LmFwcGVuZCgnc3BhbicpXHJcbiAgLmF0dHIoJ2lkJywnaW5zdHJ1Y3Rpb25fdGV4dCcpOyAgXHJcblxyXG4gIHN3aXRjaCAoc2NlbmUpIHtcclxuXHJcbiAgICBjYXNlIDA6XHJcblxyXG4gICAgICBpbnN0cnVjdGlvbl90ZXh0Lmh0bWwoJ1BsZWFzZSByZXZpZXcgdGhlIGZvbGxvd2luZyBwcm90b2NvbHMgYmVmb3JlIGJlZ2lubmluZyB0aGUgZXhwZXJpbWVudC4nKTsgICAgXHJcbiAgICAgIGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKVxyXG4gICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7XHJcblxyXG4gICAgICBicmVhazsgICBcclxuICAgICAgXHJcbiAgICBjYXNlIDE6XHJcblxyXG4gICAgICBpbnN0cnVjdGlvbl90ZXh0Lmh0bWwoJzEuIEZvciB0aGUgZHVyYXRpb24gb2YgdGhpcyBleHBlcmltZW50LCBob2xkIHlvdXIgcGhvbmUgaW4gPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPnBvcnRyYWl0IG1vZGU8L3NwYW4+LicpOyAgICBcclxuICAgICAgZDMuc2VsZWN0KCcjaW50cm9kdWN0aW9uX2RpdicpXHJcbiAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsJ3Zpc2libGUnKTsgXHJcblxyXG4gICAgICBnZXREaW1zKCk7XHJcblxyXG4gICAgICBtYWluX3N2ZyA9IGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKS5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgIC5hdHRyKCdpZCcsJ21haW5fc3ZnJylcclxuICAgICAgLnN0eWxlKCdoZWlnaHQnLHN2Z19kaW0gKyAncHgnKVxyXG4gICAgICAuc3R5bGUoJ3dpZHRoJyxzdmdfZGltICsgJ3B4JylcclxuICAgICAgLnN0eWxlKCdtYXJnaW4tdG9wJywtNDAgKyAncHgnKTtcclxuXHJcbiAgICAgIG1haW5fc3ZnLmFwcGVuZCgnc3ZnOmltYWdlJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywnaW5zdHJ1Y3Rpb25fc3ZnJylcclxuICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIFwiYXNzZXRzL3BvcnRyYWl0LnN2Z1wiKVxyXG4gICAgICAuYXR0cihcIndpZHRoXCIsIGNoYXJ0X2RpbSlcclxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgY2hhcnRfZGltKVxyXG4gICAgICAuYXR0cihcInhcIiwgaW5uZXJfcGFkZGluZylcclxuICAgICAgLmF0dHIoXCJ5XCIsIGlubmVyX3BhZGRpbmcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnRyb2R1Y3Rpb25fZGl2JykuZm9jdXMoKTtcclxuXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMjpcclxuICBcclxuICAgICAgaW5zdHJ1Y3Rpb25fdGV4dC5odG1sKCcyLiBIb2xkIHlvdXIgcGhvbmUgd2l0aCBvbmUgaGFuZCBhbmQgdXNlIHRoZSA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+aW5kZXggZmluZ2VyIG9uIHlvdXIgb3RoZXIgaGFuZDwvc3Bhbj4gdG8gdG91Y2ggeW91ciBwaG9uZS4gSXQgZG9lc25cXCd0IG1hdHRlciB3aGljaCBoYW5kIGhvbGRzIHRoZSBwaG9uZTsganVzdCBlbnN1cmUgdGhhdCB5b3UgYXJlIGNvbWZvcnRhYmxlLiBIb3dldmVyLCBkbyBub3Qgc3dpdGNoIHRoZSBhcnJhbmdlbWVudCBvZiB5b3VyIGhhbmRzIGR1cmluZyB0aGUgZXhwZXJpbWVudC4nKTsgICAgXHJcbiAgICAgIGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKVxyXG4gICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7IFxyXG5cclxuICAgICAgZ2V0RGltcygpO1xyXG5cclxuICAgICAgbWFpbl9zdmcgPSBkMy5zZWxlY3QoJyNpbnRyb2R1Y3Rpb25fZGl2JykuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAuYXR0cignaWQnLCdtYWluX3N2ZycpXHJcbiAgICAgIC5zdHlsZSgnaGVpZ2h0JyxzdmdfZGltICsgJ3B4JylcclxuICAgICAgLnN0eWxlKCd3aWR0aCcsc3ZnX2RpbSArICdweCcpO1xyXG5cclxuICAgICAgbWFpbl9zdmcuYXBwZW5kKCdzdmc6aW1hZ2UnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdpbnN0cnVjdGlvbl9zdmcnKVxyXG4gICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgXCJhc3NldHMvaG9sZGluZ3Bob25lLnN2Z1wiKVxyXG4gICAgICAuYXR0cihcIndpZHRoXCIsIGNoYXJ0X2RpbSlcclxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgY2hhcnRfZGltKVxyXG4gICAgICAuYXR0cihcInhcIiwgaW5uZXJfcGFkZGluZylcclxuICAgICAgLmF0dHIoXCJ5XCIsIGlubmVyX3BhZGRpbmcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnRyb2R1Y3Rpb25fZGl2JykuZm9jdXMoKTtcclxuXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMzpcclxuICAgIFxyXG4gICAgICBpbnN0cnVjdGlvbl90ZXh0Lmh0bWwoJzMuIE1ha2Ugc3VyZSB0aGF0IHlvdXIgcGhvbmVcXCdzIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5icmlnaHRuZXNzPC9zcGFuPiBsZXZlbCBpcyBzZXQgdG8gPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPm1heGltdW08L3NwYW4+LicpOyAgICBcclxuICAgICAgZDMuc2VsZWN0KCcjaW50cm9kdWN0aW9uX2RpdicpXHJcbiAgICAgIC5zdHlsZSgndmlzaWJpbGl0eScsJ3Zpc2libGUnKTsgXHJcblxyXG4gICAgICBnZXREaW1zKCk7XHJcblxyXG4gICAgICBtYWluX3N2ZyA9IGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKS5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgIC5hdHRyKCdpZCcsJ21haW5fc3ZnJylcclxuICAgICAgLnN0eWxlKCdoZWlnaHQnLHN2Z19kaW0gKyAncHgnKVxyXG4gICAgICAuc3R5bGUoJ3dpZHRoJyxzdmdfZGltICsgJ3B4Jyk7XHJcblxyXG4gICAgICBtYWluX3N2Zy5hcHBlbmQoJ3N2ZzppbWFnZScpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsJ2luc3RydWN0aW9uX3N2ZycpXHJcbiAgICAgIC5hdHRyKFwieGxpbms6aHJlZlwiLCBcImFzc2V0cy9icmlnaHRuZXNzLnN2Z1wiKVxyXG4gICAgICAuYXR0cihcIndpZHRoXCIsIGNoYXJ0X2RpbSlcclxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgY2hhcnRfZGltKVxyXG4gICAgICAuYXR0cihcInhcIiwgaW5uZXJfcGFkZGluZylcclxuICAgICAgLmF0dHIoXCJ5XCIsIGlubmVyX3BhZGRpbmcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnRyb2R1Y3Rpb25fZGl2JykuZm9jdXMoKTtcclxuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgXHJcbiAgICBjYXNlIDQ6XHJcbiAgICBcclxuICAgICAgaW5zdHJ1Y3Rpb25fdGV4dC5odG1sKCc0LiBFbnN1cmUgYSBzdGFibGUgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPldpRmk8L3NwYW4+IG5ldHdvcmsgYW5kIHN1ZmZpY2llbnQgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPmJhdHRlcnkgcG93ZXI8L3NwYW4+IGZvciBhcHByb3hpbWF0ZWx5IDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj4yMCBtaW51dGVzPC9zcGFuPi4nKTsgICAgXHJcbiAgICAgIGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKVxyXG4gICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7IFxyXG5cclxuICAgICAgZ2V0RGltcygpO1xyXG5cclxuICAgICAgbWFpbl9zdmcgPSBkMy5zZWxlY3QoJyNpbnRyb2R1Y3Rpb25fZGl2JykuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAuYXR0cignaWQnLCdtYWluX3N2ZycpXHJcbiAgICAgIC5zdHlsZSgnaGVpZ2h0JyxzdmdfZGltICsgJ3B4JylcclxuICAgICAgLnN0eWxlKCd3aWR0aCcsc3ZnX2RpbSArICdweCcpO1xyXG5cclxuICAgICAgbWFpbl9zdmcuYXBwZW5kKCdzdmc6aW1hZ2UnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdpbnN0cnVjdGlvbl9zdmcnKVxyXG4gICAgICAuYXR0cihcInhsaW5rOmhyZWZcIiwgXCJhc3NldHMvd2lmaS5zdmdcIilcclxuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBjaGFydF9kaW0pXHJcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGNoYXJ0X2RpbSlcclxuICAgICAgLmF0dHIoXCJ4XCIsIGlubmVyX3BhZGRpbmcpXHJcbiAgICAgIC5hdHRyKFwieVwiLCBpbm5lcl9wYWRkaW5nKTtcclxuICAgICAgICAgIFxyXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW50cm9kdWN0aW9uX2RpdicpLmZvY3VzKCk7XHJcblxyXG4gICAgICBicmVhazsgXHJcbiAgICAgIFxyXG4gICAgY2FzZSA1OlxyXG4gICAgXHJcbiAgICAgIGluc3RydWN0aW9uX3RleHQuaHRtbCgnNS4gPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPkRPIE5PVDwvc3Bhbj4gdGFwIHlvdXIgYnJvd3NlclxcJ3MgYmFjayBvciByZWZyZXNoIGJ1dHRvbnMgYXQgYW55IHRpbWUuJyk7ICAgIFxyXG4gICAgICBkMy5zZWxlY3QoJyNpbnRyb2R1Y3Rpb25fZGl2JylcclxuICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpOyBcclxuXHJcbiAgICAgIGdldERpbXMoKTtcclxuXHJcbiAgICAgIG1haW5fc3ZnID0gZDMuc2VsZWN0KCcjaW50cm9kdWN0aW9uX2RpdicpLmFwcGVuZCgnc3ZnJylcclxuICAgICAgLmF0dHIoJ2lkJywnbWFpbl9zdmcnKVxyXG4gICAgICAuc3R5bGUoJ2hlaWdodCcsc3ZnX2RpbSArICdweCcpXHJcbiAgICAgIC5zdHlsZSgnd2lkdGgnLHN2Z19kaW0gKyAncHgnKTtcclxuXHJcbiAgICAgIG1haW5fc3ZnLmFwcGVuZCgnc3ZnOmltYWdlJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywnaW5zdHJ1Y3Rpb25fc3ZnJylcclxuICAgICAgLmF0dHIoXCJ4bGluazpocmVmXCIsIFwiYXNzZXRzL25vbmF2LnN2Z1wiKVxyXG4gICAgICAuYXR0cihcIndpZHRoXCIsIGNoYXJ0X2RpbSlcclxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgY2hhcnRfZGltKVxyXG4gICAgICAuYXR0cihcInhcIiwgaW5uZXJfcGFkZGluZylcclxuICAgICAgLmF0dHIoXCJ5XCIsIGlubmVyX3BhZGRpbmcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnRyb2R1Y3Rpb25fZGl2JykuZm9jdXMoKTtcclxuXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgNjogXHJcblxyXG4gICAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgICBcIkV2ZW50XCI6IFwiSW50cm9DaGFydEJ1aWxkXCIsXHJcbiAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklEXHJcbiAgICAgIH07XHJcbiAgXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiSW50cm9DaGFydEJ1aWxkXCIsIGdsb2JhbHMubG9nX21lc3NhZ2UpO1xyXG5cclxuXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgXHJcbiAgICBjYXNlIDc6XHJcblxyXG4gICAgICBkMy5zZWxlY3QoJyNzZWxlY3Rvcl9kaXYnKS5yZW1vdmUoKTtcclxuICAgICAgZDMuc2VsZWN0KCcjaW5zdHJ1Y3Rpb25fZGl2JykucmVtb3ZlKCk7XHJcbiAgICAgIFxyXG4gICAgICB2YXIgaW50cm9fY29udGVudF9kaXYgPSBkMy5zZWxlY3QoJyNpbnRyb2R1Y3Rpb25fZGl2JylcclxuICAgICAgLmFwcGVuZCgnZGl2JylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywndG9vbGJhcicpXHJcbiAgICAgIC5zdHlsZSgnd2lkdGgnLCcxMDAlJylcclxuICAgICAgLnN0eWxlKCdoZWlnaHQnLCh3aW5kb3cuaW5uZXJIZWlnaHQgLSA1MCkgKyAncHgnKVxyXG4gICAgICAuYXR0cignaWQnLCdpbnRyb19jb250ZW50X2RpdicpOyAgICAgICAgXHJcblxyXG4gICAgICBpbnRyb19jb250ZW50X2Rpdi5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCdjb25zZW50X3RleHQnKVxyXG4gICAgICAuaHRtbCgnPHNwYW4gc3R5bGU9XCJ0ZXh0LWFsaWduOmxlZnQ7IGZvbnQtc2l6ZTowLjllbTtcIj48cD5Db25ncmF0dWxhdGlvbnMhPGJyPjxicj4gWW91IGFyZSBub3cgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPnJlYWR5IHRvIGJlZ2luPC9zcGFuPiB0aGUgZXhwZXJpbWVudCwgd2hlcmUgeW91IHdpbGwgYW5zd2VyIDEzIHF1ZXN0aW9ucy4gPC9wPiAnICsgXHJcbiAgICAgICc8cD5UaGUgcmVtYWluZGVyIG9mIHRoZSBleHBlcmltZW50IHdpbGwgcHJvY2VlZCBhcyBmb2xsb3dzOjwvcD4nICsgXHJcbiAgICAgICc8b2w+JyArXHJcbiAgICAgICc8bGk+IDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj4xMyBxdWVzdGlvbnM6PC9zcGFuPicgKyBcclxuICAgICAgJzx1bD4nICtcclxuICAgICAgJzxsaT5UaGVzZSBpbmNsdWRlICA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+MyBwcmFjdGljZSBxdWVzdGlvbnM8L3NwYW4+IGFuZCA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+MTAgdGVzdCBxdWVzdGlvbnM8L3NwYW4+LicgK1xyXG4gICAgICAnPGxpPlNvbWUgcXVlc3Rpb25zIG1heSBoYXZlIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5tdWx0aXBsZSBjb3JyZWN0IHJlc3BvbnNlczwvc3Bhbj4uJyArXHJcbiAgICAgICc8bGk+RWFjaCBxdWVzdGlvbiBpcyBleHBlY3RlZCB0byB0YWtlIHVuZGVyIGEgbWludXRlIHRvIGNvbXBsZXRlLicgKyBcclxuICAgICAgJzxsaT5UaGUgcXVlc3Rpb24gd2lsbCBhbHdheXMgYmUgc2hvd24gYmVsb3cgdGhlIGNoYXJ0LicgK1xyXG4gICAgICAnPC91bD48bGk+IEFuIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5leGl0IHN1cnZleTwvc3Bhbj4gY29udGFpbmluZyA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+MyBxdWVzdGlvbnM8L3NwYW4+LicgK1xyXG4gICAgIFxyXG4gICAgICAnPC9vbD48L3NwYW4+J1xyXG4gICAgICApOyAgICBcclxuXHJcbiAgICAgIGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKVxyXG4gICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7ICAgICAgICBcclxuXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGRlZmF1bHQ6IC8vIHJldHVybiB0byBtYWluIG1lbnVcclxuXHJcbiAgICAgIGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKS5yZW1vdmUoKTtcclxuICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnRyb2R1Y3Rpb25fZGl2JykgIT0gdW5kZWZpbmVkKSB7ICAgICAgXHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ludHJvZHVjdGlvbl9kaXYnKS5yZW1vdmUoKTsgXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgICAgIFwiVGltZVN0YW1wXCI6IG5ldyBEYXRlKCkudmFsdWVPZigpLFxyXG4gICAgICAgIFwiRXZlbnRcIjogXCJJbnRyb0NvbXBsZXRlXCIsXHJcbiAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklEXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIkludHJvQ29tcGxldGVcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG5cclxuICAgICAgaW50cm9kdWN0aW9uX2NvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgc3VwcHJlc3NfdG91Y2hfZmVlZGJhY2sgPSBmYWxzZTtcclxuICAgICAgc3VwcHJlc3NfdG91Y2hfdmFsX2ZlZWRiYWNrID0gZmFsc2U7XHJcbiAgICAgIGxvYWRNZW51KCk7XHJcbiAgICAgIGhpZGVBZGRyZXNzQmFyKCk7ICAgXHJcblxyXG4gICAgICBicmVhaztcclxuICB9XHJcbiAgXHJcbiAgZDMuc2VsZWN0KCcjaW50cm9kdWN0aW9uX2RpdicpLmFwcGVuZCgnaW5wdXQnKVxyXG4gIC5hdHRyKCdjbGFzcycsICdtZW51X2J0bl9lbmFibGVkJylcclxuICAuYXR0cignaWQnLCdzdWJtaXRfYnRuJylcclxuICAuYXR0cigndHlwZScsJ2J1dHRvbicpXHJcbiAgLmF0dHIoJ3ZhbHVlJywgc2NlbmUgPT0gMTYgPyAnQkVHSU4nIDogJ05FWFQnKVxyXG4gIC5hdHRyKCd0aXRsZScsIHNjZW5lID09IDE2ID8gJ0JFR0lOJyA6ICdORVhUJylcclxuICAub24oJ3RvdWNoc3RhcnQnLCBuZXh0SW50cm9TY2VuZSk7XHJcblxyXG4gIGZ1bmN0aW9uIG5leHRJbnRyb1NjZW5lICgpIHtcclxuXHJcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAgICAgICAgICBcclxuXHJcbiAgICBpZiAoZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2Rpc2FibGVkJykgPT0gbnVsbCkge1xyXG4gICAgICBpZiAoY2hhcnRfc3RhZ2UgPT0gNykge1xyXG4gICAgICAgIGF0dGVtcHRzKys7XHJcblxyXG4gICAgICAgIGQzLnNlbGVjdCgnI21haW5fc3ZnJykuYXR0cignY2xhc3MnLCdibHVybWUnKTtcclxuICAgICAgICBkMy5zZWxlY3QoJyNzZWxlY3Rvcl9kaXYnKS5yZW1vdmUoKTtcclxuICAgICAgICBkMy5zZWxlY3QoJyNtZW51YmFyJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcblxyXG4gICAgICAgIHZhciBzY29yZSA9IDA7XHJcbiAgICAgICAgaWYgKGdsb2JhbHMudHJpYWxfcmVzcG9uc2UuaW5kZXhPZignQScpICE9IC0xKSB7XHJcbiAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ2xvYmFscy50cmlhbF9yZXNwb25zZS5pbmRleE9mKCdFJykgIT0gLTEpIHtcclxuICAgICAgICAgIHNjb3JlKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnbG9iYWxzLnRyaWFsX3Jlc3BvbnNlLmluZGV4T2YoJ0knKSAhPSAtMSkge1xyXG4gICAgICAgICAgc2NvcmUrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdsb2JhbHMudHJpYWxfcmVzcG9uc2UuaW5kZXhPZignTycpICE9IC0xKSB7XHJcbiAgICAgICAgICBzY29yZSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2NvcmUgIT0gMykge1xyXG5cclxuICAgICAgICAgIHZhciBpbmNvcnJlY3RfZmVlZGJhY2tfYnRuID0gIGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZmVlZGJhY2tfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgLmF0dHIoJ2lkJywnZmVlZGJhY2tfYnRuJylcclxuICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZCcsJyNlZjUzNTAnKVxyXG4gICAgICAgICAgLnN0eWxlKCdib3JkZXItY29sb3InLCcjZmZmJykgICAgICAgIFxyXG4gICAgICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7ICBcclxuXHJcbiAgICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxyXG5cclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjcHJvZ3Jlc3NfaW5kaWNhdG9yJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3QoJyNvdXRlcl9wcm9ncmVzc19pbmRpY2F0b3InKVxyXG4gICAgICAgICAgICAuYXR0cignZGlzcGxheScsIGdsb2JhbHMuY29uZGl0aW9uID09ICdtdWx0aXBsZXMnID8gJ25vbmUnIDogbnVsbCk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2Rpc2FibGVkJylcclxuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsdHJ1ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvbmEuc3ZnJylcclxuICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4nLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPCB3aWR0aCA/ICcwcHgnIDogJzJweCc7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPCB3aWR0aCA/IChoZWlnaHQgLyA3IC0gNikgOiAod2lkdGggLyA3IC0gNik7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uICgpe1xyXG4gICAgICAgICAgICAgIHJldHVybiB3aWR0aCA8IGhlaWdodCA/ICh3aWR0aCAvIDcgLSA2KSA6IChoZWlnaHQgLyA3IC0gNik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3QoJyNmZWVkYmFja19idG4nKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjbWVudWJhcicpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjbWFpbl9zdmcnKS5hdHRyKCdjbGFzcycsbnVsbCk7XHJcbiAgICAgICAgICAgIGdsb2JhbHMubnVtX3NlbGVjdGVkID0gMDtcclxuICAgICAgICAgICAgZ2xvYmFscy50cmlhbF9yZXNwb25zZSA9IFtdOyAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb3VudHJ5U2VsZWN0b3IoKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjaW5uZXJfcHJvZ3Jlc3NfdmFsdWUnKS5hdHRyKCdkJywgZ2xvYmFscy5pbm5lcl9wcm9ncmVzc19jaXJjbGUuZW5kQW5nbGUoMCkpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy90cnkgYWdhaW5cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGluY29ycmVjdF9mZWVkYmFja19idG4uYXBwZW5kKCdzcGFuJylcclxuICAgICAgICAgIC5hdHRyKCdpZCcsJ2J1dHRvbl90ZXh0JylcclxuICAgICAgICAgIC5zdHlsZSgnY29sb3InLCcjMTExJylcclxuICAgICAgICAgIC5zdHlsZSgnZm9udC13ZWlnaHQnLCc0MDAnKVxyXG4gICAgICAgICAgLmh0bWwoZnVuY3Rpb24oKSB7ICAgIFxyXG4gICAgICAgICAgICBpZiAoYXR0ZW1wdHMgPiAxKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cImNvcnJlY3RfaW5jb3JyZWN0XCI+SU5DT1JSRUNUPC9zcGFuPjxicj5UYXAgb24gdGhpcyBtZXNzYWdlIHRvIHRyeSBhZ2Fpbi48YnI+IChIaW50OiBWb3dlbHMgaW5jbHVkZSBBLCBFLCBJLCBPLCAmIFUpLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cImNvcnJlY3RfaW5jb3JyZWN0XCI+SU5DT1JSRUNUPC9zcGFuPjxicj5UYXAgb24gdGhpcyBtZXNzYWdlIHRvIHRyeSBhZ2Fpbi4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTsgXHJcblxyXG4gICAgICAgIH0gXHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBjaGFydF9zdGFnZSsrO1xyXG4gICAgICAgICAgYnVpbGRfY2hhcnQoY2hhcnRfc3RhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChzY2VuZSAhPSA1KSB7XHJcbiAgICAgICAgZDMuc2VsZWN0KCcjaW50cm9kdWN0aW9uX2RpdicpLnJlbW92ZSgpO1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW50cm9kdWN0aW9uX2RpdicpICE9IHVuZGVmaW5lZCkgeyAgICAgIFxyXG4gICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ludHJvZHVjdGlvbl9kaXYnKS5yZW1vdmUoKTsgXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgICAgIFwiVGltZVN0YW1wXCI6IG5ldyBEYXRlKCkudmFsdWVPZigpLFxyXG4gICAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklELFxyXG4gICAgICAgICAgXCJFdmVudFwiOiBcIkludHJvXCIsXHJcbiAgICAgICAgICBcIlNjZW5lXCI6IHNjZW5lICsgMVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW50cm9cIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG4gIFxyXG4gICAgICAgIGludHJvZHVjdGlvbihzY2VuZSArIDEpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGNoYXJ0X3N0YWdlKys7XHJcbiAgICAgICAgYnVpbGRfY2hhcnQoY2hhcnRfc3RhZ2UpO1xyXG4gICAgICB9XHJcbiAgICB9IFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkbWVudSAoKSB7XHJcbiAgICB2YXIgbWVudWJhciA9IGQzLnNlbGVjdCgnI2ludHJvZHVjdGlvbl9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgICAuYXR0cignY2xhc3MnLCd0b29sYmFyJylcclxuICAgIC5hdHRyKCdpZCcsJ21lbnViYXInKVxyXG4gICAgLnN0eWxlKCdmbG9hdCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiBoZWlnaHQgPCB3aWR0aCA/ICdsZWZ0JyA6ICdpbmhlcml0JztcclxuICAgIH0pXHJcbiAgICAuc3R5bGUoJ3dpZHRoJywgZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGhlaWdodCA8IHdpZHRoID8gKGhlaWdodCAvIDcpICsgJ3B4JyAgOiB3aWR0aCArICdweCc7XHJcbiAgICB9KVxyXG4gICAgLnN0eWxlKCdoZWlnaHQnLCBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gaGVpZ2h0IDwgd2lkdGggPyBoZWlnaHQgKyAncHgnICA6ICh3aWR0aCAvIDcpICsgJ3B4JztcclxuICAgIH0pOyAgXHJcblxyXG4gICAgbWVudWJhci5hcHBlbmQoXCJpbnB1dFwiKVxyXG4gICAgLmF0dHIoJ2NsYXNzJywgJ2ltZ19idG5fZGlzYWJsZWQnKSAgXHJcbiAgICAuYXR0cignaWQnLCdwcmV2X2J0bicpXHJcbiAgICAuc3R5bGUoJ2Rpc3BsYXknLGdsb2JhbHMuY29uZGl0aW9uID09ICdzdGVwcGVyJyA/IG51bGwgOiAnbm9uZScpXHJcbiAgICAuc3R5bGUoJ21hcmdpbicsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiBoZWlnaHQgPCB3aWR0aCA/ICcwcHgnIDogJzJweCc7XHJcbiAgICB9KVxyXG4gICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiBoZWlnaHQgPCB3aWR0aCA/IChoZWlnaHQgLyA3IC0gNikgOiAod2lkdGggLyA3IC0gNik7XHJcbiAgICB9KVxyXG4gICAgLmF0dHIoJ3dpZHRoJywgZnVuY3Rpb24gKCl7XHJcbiAgICAgIHJldHVybiB3aWR0aCA8IGhlaWdodCA/ICh3aWR0aCAvIDcgLSA2KSA6IChoZWlnaHQgLyA3IC0gNik7XHJcbiAgICB9KVxyXG4gICAgLmF0dHIoJ3R5cGUnLCdpbWFnZScpXHJcbiAgICAuYXR0cignbmFtZScsJ1ByZXZUb2dnbGUnKVxyXG4gICAgLmF0dHIoJ3RpdGxlJywgJ1ByZXZUb2dnbGUnKVxyXG4gICAgLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSlcclxuICAgIC5hdHRyKCdzcmMnLCBnbG9iYWxzLmNvbmRpdGlvbiA9PSAnc3RlcHBlcicgPyAnYXNzZXRzL3ByZXZfZ3JleS5zdmcnIDogJ2Fzc2V0cy9uYS5zdmcnKVxyXG4gICAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7ICAgIFxyXG4gICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAgICAgICAgICBcclxuXHJcbiAgICAgIGlmIChnbG9iYWxzLmNvbmRpdGlvbiA9PSAnc3RlcHBlcicpe1xyXG5cclxuICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignc3JjJywgZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gKGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA8IDEgPyAnYXNzZXRzL3ByZXZfZ3JleS5zdmcnIDogJ2Fzc2V0cy9wcmV2X2dvbGQuc3ZnJykgOiAnYXNzZXRzL25hLnN2ZycpO1xyXG4gICAgICAgIGNoYXJ0X2luc3RhbmNlLnRoaXNfY2hhcnQoKS5pbnRlcnJ1cHQoKTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgaWYgKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpICE9IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pIHsgICAgICBcclxuICAgICAgICAgIHZhciBwcmV2X3llYXIgPSBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSAtIDE7XHJcbiAgICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIocHJldl95ZWFyKTtcclxuICAgICAgICAgIHZhciBvdXRlcl9wcm9ncmVzcyA9ICAoKHByZXZfeWVhciArIDEpIC0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbikgLyAoKGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXggKyAxKSAtIGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pO1xyXG4gICAgICAgICAgdXBkYXRlX291dGVyX3Byb2dyZXNzKGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSArIG91dGVyX3Byb2dyZXNzKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgPiAwICYmIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pIHtcclxuICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4KTtcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcucGF0aF9saW5lJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5tYXJrJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnBhdGhfbGluZScpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuXHJcbiAgICAgICAgY2hlY2tUb3VjaCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpICE9IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pIHtcclxuICAgICAgICAgICAgdmFyIHByZXZfeWVhciA9IGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpIC0gMTtcclxuICAgICAgICAgICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKHByZXZfeWVhcik7ICAgXHJcbiAgICAgICAgICAgIHZhciBvdXRlcl9wcm9ncmVzcyA9ICAoKHByZXZfeWVhciArIDEpIC0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbikgLyAoKGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXggKyAxKSAtIGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pO1xyXG4gICAgICAgICAgICB1cGRhdGVfb3V0ZXJfcHJvZ3Jlc3MoY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgpICsgb3V0ZXJfcHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgpID4gMCAmJiBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKSB7XHJcbiAgICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4KTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcubWFyaycpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5wYXRoX2xpbmUnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcucGF0aF9saW5lJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgIH0sIDUwMCk7IC8vIGNoZWNrIGV2ZXJ5IDUwMG1zIGlmIHRvdWNoIGlzIG9uZ29pbmcgICAgICAgICAgXHJcblxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgLm9uKCd0b3VjaGVuZCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIFxyXG4gICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBjbGVhckludGVydmFsKGNoZWNrVG91Y2gpO1xyXG5cclxuICAgICAgaWYgKGdsb2JhbHMuY29uZGl0aW9uID09ICdzdGVwcGVyJykge1xyXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4gJiYgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgpIDwgMSkgPyAnaW1nX2J0bl9kaXNhYmxlZCcgOiAnaW1nX2J0bl9lbmFibGVkJylcclxuICAgICAgICAuYXR0cignZGlzYWJsZWQnLCAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbiAmJiBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgPCAxKSA/IHRydWUgOiBudWxsKVxyXG4gICAgICAgIC5hdHRyKCdzcmMnLCAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbiAmJiBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgPCAxKSA/ICdhc3NldHMvcHJldl9ncmV5LnN2ZycgOiAnYXNzZXRzL3ByZXYuc3ZnJyk7XHJcbiAgICAgIH1cclxuICAgIH0pOyAgICBcclxuXHJcbiAgICBtZW51YmFyLmFwcGVuZChcImlucHV0XCIpXHJcbiAgICAuYXR0cignaWQnLCduZXh0X2J0bicpXHJcbiAgICAuc3R5bGUoJ2Rpc3BsYXknLGdsb2JhbHMuY29uZGl0aW9uID09ICdzdGVwcGVyJyA/IG51bGwgOiAnbm9uZScpXHJcbiAgICAuYXR0cignY2xhc3MnLCBnbG9iYWxzLmNvbmRpdGlvbiA9PSAnc3RlcHBlcicgPyAnaW1nX2J0bl9lbmFibGVkJyA6ICdpbWdfYnRuX2Rpc2FibGVkJykgIFxyXG4gICAgLnN0eWxlKCdtYXJnaW4nLCBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gaGVpZ2h0IDwgd2lkdGggPyAnMHB4JyA6ICcycHgnO1xyXG4gICAgfSlcclxuICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gaGVpZ2h0IDwgd2lkdGggPyAoaGVpZ2h0IC8gNyAtIDYpIDogKHdpZHRoIC8gNyAtIDYpO1xyXG4gICAgfSlcclxuICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uICgpe1xyXG4gICAgICByZXR1cm4gd2lkdGggPCBoZWlnaHQgPyAod2lkdGggLyA3IC0gNikgOiAoaGVpZ2h0IC8gNyAtIDYpO1xyXG4gICAgfSlcclxuICAgIC5hdHRyKCd0eXBlJywnaW1hZ2UnKSBcclxuICAgIC5hdHRyKCduYW1lJywnTmV4dFRvZ2dsZScpXHJcbiAgICAuYXR0cigndGl0bGUnLCAnTmV4dFRvZ2dsZScpXHJcbiAgICAuYXR0cignc3JjJywgZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gJ2Fzc2V0cy9uZXh0LnN2ZycgOiAnYXNzZXRzL25hLnN2ZycpXHJcbiAgICAuYXR0cignZGlzYWJsZWQnLCBnbG9iYWxzLmNvbmRpdGlvbiA9PSAnc3RlcHBlcicgPyBudWxsIDogdHJ1ZSlcclxuICAgIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyAgICBcclxuICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgICAgXHJcblxyXG4gICAgICBpZiAoZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInKXtcclxuXHJcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3NyYycsIGdsb2JhbHMuY29uZGl0aW9uID09ICdzdGVwcGVyJyA/ICdhc3NldHMvbmV4dF9nb2xkLnN2ZycgOiAnYXNzZXRzL25hLnN2ZycpO1xyXG4gICAgICAgIGNoYXJ0X2luc3RhbmNlLnRoaXNfY2hhcnQoKS5pbnRlcnJ1cHQoKTtcclxuXHJcbiAgICAgICAgaWYgKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXgpIHtcclxuICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKTtcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnBhdGhfbGluZScpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5tYXJrJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5wYXRoX2xpbmUnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHZhciBuZXh0X3llYXIgPSBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSArIDE7XHJcbiAgICAgICAgICB2YXIgb3V0ZXJfcHJvZ3Jlc3MgPSAgKChuZXh0X3llYXIgKyAxKSAtIGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pIC8gKChjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4ICsgMSkgLSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKTtcclxuICAgICAgICAgIHVwZGF0ZV9vdXRlcl9wcm9ncmVzcyhjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgKyBvdXRlcl9wcm9ncmVzcyk7XHJcbiAgICAgICAgICBpZiAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gKGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXggLSAxKSkge1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSArIDEpO1xyXG4gICAgICAgICAgICAvLyBkMy5zZWxlY3QoJyNwcm9ncmVzc19pbmRpY2F0b3InKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0X3N0YWdlID09IDcgJiYgZ2xvYmFscy5udW1fc2VsZWN0ZWQgPT0gMykge1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGQzLnNlbGVjdCgnI3Byb2dyZXNzX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgICAgICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsbnVsbClcclxuICAgICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLG51bGwpXHJcbiAgICAgICAgICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvZG9uZS5zdmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICBkMy5zZWxlY3QoJyNzdWJtaXRfYnRuJykuYXR0cignY2xhc3MnLCdtZW51X2J0bl9lbmFibGVkJylcclxuICAgICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIobmV4dF95ZWFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTsgICAgIFxyXG5cclxuICAgICAgICBjaGVja1RvdWNoID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1heCkge1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbik7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0QWxsKCcucGF0aF9saW5lJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5tYXJrJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnBhdGhfbGluZScpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbmV4dF95ZWFyID0gY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgKyAxO1xyXG4gICAgICAgICAgICB2YXIgb3V0ZXJfcHJvZ3Jlc3MgPSAgKChuZXh0X3llYXIgKyAxKSAtIGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pIC8gKChjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4ICsgMSkgLSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKTtcclxuICAgICAgICAgICAgdXBkYXRlX291dGVyX3Byb2dyZXNzKGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSArIG91dGVyX3Byb2dyZXNzKTtcclxuICAgICAgICAgICAgaWYgKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IChjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4IC0gMSkpIHtcclxuICAgICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSArIDEpO1xyXG4gICAgICAgICAgICAgIC8vIGQzLnNlbGVjdCgnI3Byb2dyZXNzX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgICAgICAgIGlmIChjaGFydF9zdGFnZSA9PSA3ICYmIGdsb2JhbHMubnVtX3NlbGVjdGVkID09IDMpIHsgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoJyNwcm9ncmVzc19pbmRpY2F0b3InKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JyxudWxsKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJyxudWxsKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvZG9uZS5zdmcnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCgnI3N1Ym1pdF9idG4nKS5hdHRyKCdjbGFzcycsJ21lbnVfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJyxudWxsKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKG5leHRfeWVhcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gICAgICAgIH0sIDUwMCk7IC8vIGNoZWNrIGV2ZXJ5IDUwMG1zIGlmIHRvdWNoIGlzIG9uZ29pbmcgICAgXHJcblxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgLm9uKCd0b3VjaGVuZCcsIGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBjbGVhckludGVydmFsKGNoZWNrVG91Y2gpO1xyXG5cclxuICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3NyYycsIGdsb2JhbHMuY29uZGl0aW9uID09ICdzdGVwcGVyJyA/ICdhc3NldHMvbmV4dC5zdmcnIDogJ2Fzc2V0cy9uYS5zdmcnKTtcclxuXHJcbiAgICAgIGlmIChnbG9iYWxzLmNvbmRpdGlvbiA9PSAnc3RlcHBlcicpIHtcclxuICAgICAgICBkMy5zZWxlY3QoJyNwcmV2X2J0bicpLmF0dHIoJ2NsYXNzJywoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbiAmJiBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgPCAxKSA/ICdpbWdfYnRuX2Rpc2FibGVkJyA6ICdpbWdfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsIChjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluICYmIGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA8IDEpID8gdHJ1ZSA6IG51bGwpXHJcbiAgICAgICAgLmF0dHIoJ3NyYycsIChjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluICYmIGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA8IDEpID8gJ2Fzc2V0cy9wcmV2X2dyZXkuc3ZnJyA6ICdhc3NldHMvcHJldi5zdmcnKTtcclxuICAgICAgfVxyXG4gICAgfSk7ICAgIFxyXG5cclxuICAgIHZhciBwcm9ncmVzc19yYWRpdXMgPSAoaGVpZ2h0IDwgd2lkdGggPyAoaGVpZ2h0IC8gNyAtIDYpIDogKHdpZHRoIC8gNyAtIDYpKSAvIDI7XHJcbiAgICB2YXIgcHJvZ3Jlc3Nfc3Ryb2tlID0gMjtcclxuICAgIHZhciBwcm9ncmVzc19kaW0gPSBwcm9ncmVzc19yYWRpdXMgKiAyO1xyXG5cclxuICAgIHZhciBwcm9tcHQgPSBtZW51YmFyLmFwcGVuZChcImRpdlwiKVxyXG4gICAgLmF0dHIoJ2lkJywncHJvbXB0JylcclxuICAgIC5zdHlsZSgnbWFyZ2luJywnMnB4JylcclxuICAgIC5zdHlsZSgnaGVpZ2h0JywgKHByb2dyZXNzX2RpbSkgKyAncHgnKVxyXG4gICAgLnN0eWxlKCd3aWR0aCcsICh3aWR0aCAtIHByb2dyZXNzX2RpbSAqIChnbG9iYWxzLmNvbmRpdGlvbiA9PSAnc3RlcHBlcicgPyAzIDogMSkgLSAoZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gMjQgOiAxMikpICsgJ3B4JylcclxuICAgIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyAgICBcclxuICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICB9KTtcclxuXHJcbiAgICBwcm9tcHQuYXBwZW5kKCdzcGFuJylcclxuICAgIC5hdHRyKCdjbGFzcycsJ3Rhc2tfaW5zdHJ1Y3Rpb25fc3BhbicpXHJcbiAgICAuaHRtbCgnJyk7ICAgICAgXHJcblxyXG4gICAgLy9wcm9ncmVzcyBpbmRpY2F0b3JzXHJcbiAgICB2YXIgcHJvZ3Jlc3NfY29sb3JzID0ge1xyXG4gICAgICBvdXRlcl9maWxsOiAnZ29sZCcsXHJcbiAgICAgIGlubmVyX2ZpbGw6ICcjZmZmJyxcclxuICAgICAgdHJhY2s6ICcjOTk5JyxcclxuICAgICAgc3Ryb2tlOiAnIzMzMycsXHJcbiAgICB9O1xyXG5cclxuICAgIG1lbnViYXIuYXBwZW5kKFwiaW5wdXRcIilcclxuICAgIC5hdHRyKCdjbGFzcycsICdpbWdfYnRuX2Rpc2FibGVkJylcclxuICAgIC5hdHRyKCdkaXNhYmxlZCcsdHJ1ZSlcclxuICAgIC5zdHlsZSgnZGlzcGxheScsJ25vbmUnKVxyXG4gICAgLnN0eWxlKCdtYXJnaW4nLCcycHgnKVxyXG4gICAgLnN0eWxlKCdoZWlnaHQnLCBwcm9ncmVzc19kaW0gKyAncHgnKVxyXG4gICAgLnN0eWxlKCd3aWR0aCcsIHByb2dyZXNzX2RpbSArICdweCcpXHJcbiAgICAuYXR0cignaWQnLCdkb25lX2J0bicpXHJcbiAgICAuYXR0cigndHlwZScsJ2ltYWdlJylcclxuICAgIC5hdHRyKCduYW1lJywnRG9uZScpXHJcbiAgICAuYXR0cigndGl0bGUnLCAnRG9uZScpXHJcbiAgICAuYXR0cignc3JjJywgJ2Fzc2V0cy9uYS5zdmcnKVxyXG4gICAgLm9uKCd0b3VjaHN0YXJ0JywgbmV4dEludHJvU2NlbmUpO1xyXG5cclxuICAgIHZhciBwcm9ncmVzc19zdmcgPSBtZW51YmFyLmFwcGVuZChcInN2Z1wiKVxyXG4gICAgLmF0dHIoJ2Rpc2FibGVkJyx0cnVlKVxyXG4gICAgLmF0dHIoJ2lkJywncHJvZ3Jlc3NfaW5kaWNhdG9yJylcclxuICAgIC5hdHRyKCdoZWlnaHQnLCBwcm9ncmVzc19kaW0pXHJcbiAgICAuYXR0cignd2lkdGgnLCBwcm9ncmVzc19kaW0pO1xyXG4gICAgXHJcbiAgICBnbG9iYWxzLm91dGVyX3Byb2dyZXNzX2NpcmNsZSA9IGQzLmFyYygpXHJcbiAgICAuc3RhcnRBbmdsZSgwKVxyXG4gICAgLmNvcm5lclJhZGl1cyg3LjUpXHJcbiAgICAuaW5uZXJSYWRpdXMocHJvZ3Jlc3NfcmFkaXVzKVxyXG4gICAgLm91dGVyUmFkaXVzKHByb2dyZXNzX3JhZGl1cyAtIDcuNSk7XHJcblxyXG4gICAgdmFyIG91dGVyX3RyYWNrX2NpcmNsZSA9IGQzLmFyYygpXHJcbiAgICAuc3RhcnRBbmdsZSgwKVxyXG4gICAgLmVuZEFuZ2xlKE1hdGguUEkgKiAyKVxyXG4gICAgLmlubmVyUmFkaXVzKHByb2dyZXNzX3JhZGl1cylcclxuICAgIC5vdXRlclJhZGl1cyhwcm9ncmVzc19yYWRpdXMgLSA3LjUpO1xyXG5cclxuICAgIGdsb2JhbHMuaW5uZXJfcHJvZ3Jlc3NfY2lyY2xlID0gZDMuYXJjKClcclxuICAgIC5zdGFydEFuZ2xlKDApXHJcbiAgICAuY29ybmVyUmFkaXVzKDcuNSlcclxuICAgIC5pbm5lclJhZGl1cyhwcm9ncmVzc19yYWRpdXMgLSA3LjUpXHJcbiAgICAub3V0ZXJSYWRpdXMocHJvZ3Jlc3NfcmFkaXVzIC0gMTUpO1xyXG5cclxuICAgIHZhciBpbm5lcl90cmFja19jaXJjbGUgPSBkMy5hcmMoKVxyXG4gICAgLnN0YXJ0QW5nbGUoMClcclxuICAgIC5lbmRBbmdsZShNYXRoLlBJICogMilcclxuICAgIC5pbm5lclJhZGl1cyhwcm9ncmVzc19yYWRpdXMgLSA3LjUpXHJcbiAgICAub3V0ZXJSYWRpdXMocHJvZ3Jlc3NfcmFkaXVzIC0gMTUpO1xyXG5cclxuICAgIHZhciBvdXRlcl9wcm9ncmVzc190cmFjayA9IHByb2dyZXNzX3N2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgLmF0dHIoJ2lkJywnb3V0ZXJfcHJvZ3Jlc3NfaW5kaWNhdG9yJylcclxuICAgIC5hdHRyKCdkaXNwbGF5JywgZ2xvYmFscy5jb25kaXRpb24gPT0gJ211bHRpcGxlcycgPyAnbm9uZScgOiBudWxsKVxyXG4gICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHByb2dyZXNzX2RpbSAvIDIgKyAnLCcgKyBwcm9ncmVzc19kaW0gLyAyICsgJyknKTtcclxuICAgIFxyXG4gICAgb3V0ZXJfcHJvZ3Jlc3NfdHJhY2suYXBwZW5kKCdwYXRoJylcclxuICAgIC5hdHRyKCdmaWxsJywgcHJvZ3Jlc3NfY29sb3JzLnRyYWNrKVxyXG4gICAgLmF0dHIoJ3N0cm9rZScsIHByb2dyZXNzX2NvbG9ycy5zdHJva2UpXHJcbiAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgcHJvZ3Jlc3Nfc3Ryb2tlICsgJ3B4JylcclxuICAgIC5hdHRyKCdkJywgb3V0ZXJfdHJhY2tfY2lyY2xlKTtcclxuXHJcbiAgICBvdXRlcl9wcm9ncmVzc190cmFjay5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgLmF0dHIoJ2lkJywgJ291dGVyX3Byb2dyZXNzX3ZhbHVlJylcclxuICAgIC5hdHRyKCdmaWxsJywgcHJvZ3Jlc3NfY29sb3JzLm91dGVyX2ZpbGwpXHJcbiAgICAuYXR0cignc3Ryb2tlJywgcHJvZ3Jlc3NfY29sb3JzLnN0cm9rZSlcclxuICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBwcm9ncmVzc19zdHJva2UgKyAncHgnKVxyXG4gICAgLmF0dHIoJ2QnLCBnbG9iYWxzLmlubmVyX3Byb2dyZXNzX2NpcmNsZS5lbmRBbmdsZSgwKSk7ICAgICBcclxuXHJcbiAgICB1cGRhdGVfb3V0ZXJfcHJvZ3Jlc3MoMSAvICgoY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1heCArIDEpIC0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbikpO1xyXG5cclxuICAgIHZhciBpbm5lcl9wcm9ncmVzc190cmFjayA9IHByb2dyZXNzX3N2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgLmF0dHIoJ2lkJywnaW5uZXJfcHJvZ3Jlc3NfaW5kaWNhdG9yJylcclxuICAgIC5hdHRyKCdkaXNwbGF5JywgbnVsbClcclxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBwcm9ncmVzc19kaW0gLyAyICsgJywnICsgcHJvZ3Jlc3NfZGltIC8gMiArICcpJyk7XHJcbiAgICBcclxuICAgIGlubmVyX3Byb2dyZXNzX3RyYWNrLmFwcGVuZCgncGF0aCcpXHJcbiAgICAuYXR0cignZmlsbCcsIHByb2dyZXNzX2NvbG9ycy50cmFjaylcclxuICAgIC5hdHRyKCdzdHJva2UnLCBwcm9ncmVzc19jb2xvcnMuc3Ryb2tlKVxyXG4gICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIHByb2dyZXNzX3N0cm9rZSArICdweCcpXHJcbiAgICAuYXR0cignZCcsIGlubmVyX3RyYWNrX2NpcmNsZSk7XHJcblxyXG4gICAgaW5uZXJfcHJvZ3Jlc3NfdHJhY2suYXBwZW5kKCdwYXRoJylcclxuICAgIC5hdHRyKCdpZCcsICdpbm5lcl9wcm9ncmVzc192YWx1ZScpXHJcbiAgICAuYXR0cignZmlsbCcsIHByb2dyZXNzX2NvbG9ycy5pbm5lcl9maWxsKVxyXG4gICAgLmF0dHIoJ3N0cm9rZScsIHByb2dyZXNzX2NvbG9ycy5zdHJva2UpXHJcbiAgICAuYXR0cignc3Ryb2tlLXdpZHRoJywgcHJvZ3Jlc3Nfc3Ryb2tlICsgJ3B4JylcclxuICAgIC5hdHRyKCdkJywgZ2xvYmFscy5pbm5lcl9wcm9ncmVzc19jaXJjbGUuZW5kQW5nbGUoMCkpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlX291dGVyX3Byb2dyZXNzKHByb2dyZXNzKSB7XHJcbiAgICBpZiAoZ2xvYmFscy5jb25kaXRpb24gIT0gJ211bHRpcGxlcycpIHtcclxuICAgICAgZDMuc2VsZWN0KCcjb3V0ZXJfcHJvZ3Jlc3NfdmFsdWUnKS5hdHRyKCdkJywgZ2xvYmFscy5vdXRlcl9wcm9ncmVzc19jaXJjbGUuZW5kQW5nbGUoKE1hdGguUEkgKiAyKSAqIHByb2dyZXNzKSk7XHJcbiAgICB9XHJcbiAgfSBcclxuIFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGludHJvZHVjdGlvbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvaW50cm9kdWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZDMgPSByZXF1aXJlKFwiZDNcIik7XHJcbnZhciBDbGlwYm9hcmQgPSByZXF1aXJlKFwiY2xpcGJvYXJkXCIpO1xyXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XHJcblxyXG5mdW5jdGlvbiBxdWVzdGlvbm5haXJlIChzY2VuZSkge1xyXG5cclxuICB2YXIgbGlrZXJ0X3JiO1xyXG5cclxuICB2YXIgY2xpcCA9IG5ldyBDbGlwYm9hcmQoJy5idG4nKTsgXHJcblxyXG4gIGNsaXAub24oXCJzdWNjZXNzXCIsIGZ1bmN0aW9uKGUpIHtcclxuXHJcbiAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgIFwiRXZlbnRcIjogXCJDb2RlQ29waWVkXCIsXHJcbiAgICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRCxcclxuICAgICAgXCJjb2RlXCI6IGUudGV4dFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zb2xlLmxvZyhcIkNvZGVDb3BpZWRcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG5cclxuICB9KTtcclxuICBjbGlwLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oZSkge1xyXG4gICAgY29uc29sZS5lcnJvcignQWN0aW9uOicsIGUuYWN0aW9uKTtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ1RyaWdnZXI6JywgZS50cmlnZ2VyKTsgIFxyXG5cclxuICB9KTtcclxuXHJcbiAgZDMuc2VsZWN0KCcjcXVlc3Rpb25uYWlyZV9kaXYnKS5yZW1vdmUoKTtcclxuICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3F1ZXN0aW9ubmFpcmVfZGl2JykgIT0gdW5kZWZpbmVkKSB7ICAgICAgXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncXVlc3Rpb25uYWlyZV9kaXYnKS5yZW1vdmUoKTsgXHJcbiAgfVxyXG4gIFxyXG4gIC8qKiBJTklUICoqL1xyXG4gIFxyXG4gIGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JylcclxuICAuYXR0cignaWQnLCdxdWVzdGlvbm5haXJlX2RpdicpXHJcbiAgLmF0dHIoJ3RhYmluZGV4JywwKTsgIFxyXG5cclxuICB2YXIgaW5zdHJ1Y3Rpb25fZGl2ID0gZDMuc2VsZWN0KCcjcXVlc3Rpb25uYWlyZV9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgLmF0dHIoJ2NsYXNzJywndG9vbGJhcicpXHJcbiAgLnN0eWxlKCdoZWlnaHQnLCcxNTBweCcpXHJcbiAgLnN0eWxlKCdwYWRkaW5nLWJvdHRvbScsJzUwJScpXHJcbiAgLmF0dHIoJ2lkJywnaW5zdHJ1Y3Rpb25fZGl2Jyk7XHJcblxyXG4gIHZhciBpbnN0cnVjdGlvbl90ZXh0ID0gaW5zdHJ1Y3Rpb25fZGl2LmFwcGVuZCgnc3BhbicpXHJcbiAgLmF0dHIoJ2lkJywnaW5zdHJ1Y3Rpb25fdGV4dCcpOyAgXHJcblxyXG4gIHN3aXRjaCAoc2NlbmUpIHtcclxuXHJcbiAgICBjYXNlIDA6XHJcblxyXG4gICAgICBpbnN0cnVjdGlvbl90ZXh0Lmh0bWwoJzxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5Db25ncmF0dWxhdGlvbnMhPC9zcGFuPjxicj5Zb3UgaGF2ZSBjb21wbGV0ZWQgdGhlIHN0dWR5IHRhc2tzLiBQbGVhc2UgdGFrZSBhIG1vbWVudCB0byByZXNwb25kIHRvIHRocmVlIHF1ZXN0aW9ucyBhYm91dCB0aGUgY2hhcnQgZGVzaWduIHVzZWQgaW4gdGhpcyBzdHVkeS4nKTsgICAgXHJcblxyXG4gICAgICBkMy5zZWxlY3QoJyNxdWVzdGlvbm5haXJlX2RpdicpLmFwcGVuZCgnaW5wdXQnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCAnbWVudV9idG5fZW5hYmxlZCcpXHJcbiAgICAgIC5hdHRyKCdpZCcsJ3N1Ym1pdF9idG4nKVxyXG4gICAgICAuYXR0cigndHlwZScsJ2J1dHRvbicpXHJcbiAgICAgIC5hdHRyKCd2YWx1ZScsJ05FWFQnKVxyXG4gICAgICAuYXR0cigndGl0bGUnLCAnTkVYVCcpXHJcbiAgICAgIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZ2xvYmFscy5sb2dfbWVzc2FnZSA9IHsgXHJcbiAgICAgICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRCxcclxuICAgICAgICAgIFwiRXZlbnRcIjogXCJTdXJ2ZXlcIixcclxuICAgICAgICAgIFwiU2NlbmVcIjogc2NlbmUgKyAxXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlN1cnZleVwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcblxyXG4gICAgICAgIHF1ZXN0aW9ubmFpcmUoc2NlbmUgKyAxKTsgICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGJyZWFrOyAgXHJcblxyXG4gICAgY2FzZSAxOlxyXG4gICAgXHJcbiAgICAgIGluc3RydWN0aW9uX3RleHQuaHRtbCgnMS4gUHJpb3IgdG8gdGhpcyBleHBlcmltZW50LCBob3cgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPmZhbWlsaWFyPC9zcGFuPiB3ZXJlIHlvdSB3aXRoIHRoZSB0eXBlIG9mIGNoYXJ0IHVzZWQgaW4gdGhpcyBleHBlcmltZW50IG9uIGEgc2NhbGUgcmFuZ2luZyBmcm9tIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj4xPC9zcGFuPiAobm90IGZhbWlsaWFyIGF0IGFsbCkgdG8gPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPjU8L3NwYW4+ICh2ZXJ5IGZhbWlsaWFyKT8nKTsgICAgXHJcblxyXG4gICAgICB2YXIgZmFtaWxpYXJpdHkgPSAwO1xyXG5cclxuICAgICAgZDMuc2VsZWN0KCcjcXVlc3Rpb25uYWlyZV9kaXYnKS5hcHBlbmQoJ2lucHV0JylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ21lbnVfYnRuX2Rpc2FibGVkJylcclxuICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSlcclxuICAgICAgLmF0dHIoJ2lkJywnc3VibWl0X2J0bicpXHJcbiAgICAgIC5hdHRyKCd0eXBlJywnYnV0dG9uJylcclxuICAgICAgLmF0dHIoJ3ZhbHVlJywnTkVYVCcpXHJcbiAgICAgIC5hdHRyKCd0aXRsZScsICdORVhUJylcclxuICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7IFxyXG5cclxuICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBcclxuICAgICAgICBcclxuICAgICAgICBpZiAoZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2Rpc2FibGVkJykgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICAgIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgICAgICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklELFxyXG4gICAgICAgICAgICBcIkV2ZW50XCI6IFwiU3VydmV5XCIsXHJcbiAgICAgICAgICAgIFwiUXVlc3Rpb25cIjogXCJGYW1pbGlhcml0eVwiLFxyXG4gICAgICAgICAgICBcIlJlc3BvbnNlXCI6IGZhbWlsaWFyaXR5XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlN1cnZleVwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcbiAgXHJcbiAgICAgICAgICBxdWVzdGlvbm5haXJlKHNjZW5lICsgMSk7ICAgICAgICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBsaWtlcnRfcmIgPSBkMy5zZWxlY3QoJyNxdWVzdGlvbm5haXJlX2RpdicpLnNlbGVjdEFsbChcIi5tZW51X2J0bl9lbmFibGVkXCIpXHJcbiAgICAgIC5kYXRhKFsxLDIsMyw0LDVdKVxyXG4gICAgICAuZW50ZXIoKTsgICAgIFxyXG5cclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgIGxpa2VydF9yYi5hcHBlbmQoJ2lucHV0JylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbWVudV9idG5fZW5hYmxlZCcpXHJcbiAgICAgICAgLnN0eWxlKCd3aWR0aCcsJzE4JScpXHJcbiAgICAgICAgLnN0eWxlKCdtYXJnaW4tbGVmdCcsJzElJykgICAgICBcclxuICAgICAgICAuc3R5bGUoJ21hcmdpbi1yaWdodCcsJzElJylcclxuICAgICAgICAuc3R5bGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgwLDApJylcclxuICAgICAgICAuYXR0cigndHlwZScsJ2J1dHRvbicpXHJcbiAgICAgICAgLmF0dHIoJ3ZhbHVlJyxmdW5jdGlvbihkKXtcclxuICAgICAgICAgIHJldHVybihkKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCd0aXRsZScsIGZ1bmN0aW9uKGQpe1xyXG4gICAgICAgICAgcmV0dXJuKGQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZCkgeyAgXHJcblxyXG4gICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1lbnVfYnRuX2VuYWJsZWQnKS5zdHlsZSgnYm9yZGVyJywgJzFweCBzb2xpZCAjY2NjJyk7ICAgICAgICAgICBcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYm9yZGVyJywgJzVweCBzb2xpZCBnb2xkJyk7XHJcblxyXG4gICAgICAgICAgZmFtaWxpYXJpdHkgPSBkOyAgXHJcblxyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjc3VibWl0X2J0bicpLmF0dHIoJ2NsYXNzJywgJ21lbnVfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgbnVsbCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0pOyAgICAgICAgICAgICAgICAgICBcclxuICAgICAgfSwgNTAwKTsgICAgXHJcblxyXG4gICAgICBicmVhaztcclxuXHJcbiAgICBjYXNlIDI6XHJcbiAgICBcclxuICAgICAgaW5zdHJ1Y3Rpb25fdGV4dC5odG1sKCcyLiBUaHJvdWdob3V0IHRoaXMgZXhwZXJpbWVudCwgaG93IDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5jb25maWRlbnQ8L3NwYW4+IHdlcmUgeW91IHdoZW4gcmVzcG9uZGluZyB0byB0aGUgcXVlc3Rpb25zIG9uIGEgc2NhbGUgcmFuZ2luZyBmcm9tIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj4xPC9zcGFuPiAobm90IGNvbmZpZGVudCBhdCBhbGwpIHRvIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj41PC9zcGFuPiAoY29tcGxldGVseSBjb25maWRlbnQpPycpOyAgICBcclxuXHJcbiAgICAgIHZhciBjb25maWRlbmNlID0gMDtcclxuXHJcbiAgICAgIGQzLnNlbGVjdCgnI3F1ZXN0aW9ubmFpcmVfZGl2JykuYXBwZW5kKCdpbnB1dCcpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdtZW51X2J0bl9kaXNhYmxlZCcpXHJcbiAgICAgIC5hdHRyKCdkaXNhYmxlZCcsIHRydWUpXHJcbiAgICAgIC5hdHRyKCdpZCcsJ3N1Ym1pdF9idG4nKVxyXG4gICAgICAuYXR0cigndHlwZScsJ2J1dHRvbicpXHJcbiAgICAgIC5hdHRyKCd2YWx1ZScsJ05FWFQnKVxyXG4gICAgICAuYXR0cigndGl0bGUnLCAnTkVYVCcpXHJcbiAgICAgIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyBcclxuXHJcbiAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdkaXNhYmxlZCcpID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgICAgICAgXCJUaW1lU3RhbXBcIjogbmV3IERhdGUoKS52YWx1ZU9mKCksXHJcbiAgICAgICAgICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRCxcclxuICAgICAgICAgICAgXCJFdmVudFwiOiBcIlN1cnZleVwiLFxyXG4gICAgICAgICAgICBcIlF1ZXN0aW9uXCI6IFwiQ29uZmlkZW5jZVwiLFxyXG4gICAgICAgICAgICBcIlJlc3BvbnNlXCI6IGNvbmZpZGVuY2VcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiU3VydmV5XCIsIGdsb2JhbHMubG9nX21lc3NhZ2UpO1xyXG5cclxuXHJcbiAgICAgICAgICBxdWVzdGlvbm5haXJlKHNjZW5lICsgMSk7ICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbGlrZXJ0X3JiID0gZDMuc2VsZWN0KCcjcXVlc3Rpb25uYWlyZV9kaXYnKS5zZWxlY3RBbGwoXCIubWVudV9idG5fZW5hYmxlZFwiKVxyXG4gICAgICAuZGF0YShbMSwyLDMsNCw1XSlcclxuICAgICAgLmVudGVyKCk7ICAgICBcclxuXHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICBsaWtlcnRfcmIuYXBwZW5kKCdpbnB1dCcpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21lbnVfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgIC5zdHlsZSgnd2lkdGgnLCcxOCUnKVxyXG4gICAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCcxJScpICAgICAgXHJcbiAgICAgICAgLnN0eWxlKCdtYXJnaW4tcmlnaHQnLCcxJScpXHJcbiAgICAgICAgLnN0eWxlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoMCwwKScpXHJcbiAgICAgICAgLmF0dHIoJ3R5cGUnLCdidXR0b24nKVxyXG4gICAgICAgIC5hdHRyKCd2YWx1ZScsZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgICByZXR1cm4oZCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigndGl0bGUnLCBmdW5jdGlvbihkKXtcclxuICAgICAgICAgIHJldHVybihkKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGQpIHsgICBcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1lbnVfYnRuX2VuYWJsZWQnKS5zdHlsZSgnYm9yZGVyJywgJzFweCBzb2xpZCAjY2NjJyk7ICAgICAgICAgICBcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnYm9yZGVyJywgJzVweCBzb2xpZCBnb2xkJyk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbmZpZGVuY2UgPSBkO1xyXG5cclxuICAgICAgICAgIGQzLnNlbGVjdCgnI3N1Ym1pdF9idG4nKS5hdHRyKCdjbGFzcycsICdtZW51X2J0bl9lbmFibGVkJylcclxuICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsIG51bGwpOyAgIFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgfSk7ICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICB9LCA1MDApO1xyXG5cclxuXHJcbiAgICAgIGJyZWFrO1xyXG5cclxuICAgIGNhc2UgMzpcclxuICAgIFxyXG4gICAgICBpbnN0cnVjdGlvbl90ZXh0Lmh0bWwoJzMuIFRocm91Z2hvdXQgdGhpcyBleHBlcmltZW50LCBob3cgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPmVhc3k8L3NwYW4+IHdhcyBpdCB0byBhbnN3ZXIgdGhlIHF1ZXN0aW9ucyB1c2luZyB0aGUgaW50ZXJmYWNlIHByb3ZpZGVkIHRvIHlvdSBvbiBhIHNjYWxlIHJhbmdpbmcgZnJvbSA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+MTwvc3Bhbj4gKHZlcnkgZGlmZmljdWx0KSB0byA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+NTwvc3Bhbj4gKHZlcnkgZWFzeSk/Jyk7ICAgIFxyXG5cclxuICAgICAgdmFyIGVhc2UgPSAwO1xyXG5cclxuICAgICAgZDMuc2VsZWN0KCcjcXVlc3Rpb25uYWlyZV9kaXYnKS5hcHBlbmQoJ2lucHV0JylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ21lbnVfYnRuX2Rpc2FibGVkJylcclxuICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSlcclxuICAgICAgLmF0dHIoJ2lkJywnc3VibWl0X2J0bicpXHJcbiAgICAgIC5hdHRyKCd0eXBlJywnYnV0dG9uJylcclxuICAgICAgLmF0dHIoJ3ZhbHVlJywnTkVYVCcpXHJcbiAgICAgIC5hdHRyKCd0aXRsZScsICdORVhUJylcclxuICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7IFxyXG4gICAgICAgIFxyXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxyXG5cclxuICAgICAgICBpZiAoZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ2Rpc2FibGVkJykgPT0gbnVsbCkge1xyXG4gICAgICAgICBcclxuICAgICAgICAgIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgICAgICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklELFxyXG4gICAgICAgICAgICBcIkV2ZW50XCI6IFwiU3VydmV5XCIsXHJcbiAgICAgICAgICAgIFwiUXVlc3Rpb25cIjogXCJFYXNlXCIsXHJcbiAgICAgICAgICAgIFwiUmVzcG9uc2VcIjogZWFzZVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJTdXJ2ZXlcIiwgZ2xvYmFscy5sb2dfbWVzc2FnZSk7XHJcblxyXG4gICAgICAgICAgIFxyXG4gICAgICAgICAgcXVlc3Rpb25uYWlyZShzY2VuZSArIDEpOyBcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGxpa2VydF9yYiA9IGQzLnNlbGVjdCgnI3F1ZXN0aW9ubmFpcmVfZGl2Jykuc2VsZWN0QWxsKFwiLm1lbnVfYnRuX2VuYWJsZWRcIilcclxuICAgICAgLmRhdGEoWzEsMiwzLDQsNV0pXHJcbiAgICAgIC5lbnRlcigpOyAgICAgXHJcblxyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgbGlrZXJ0X3JiLmFwcGVuZCgnaW5wdXQnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdtZW51X2J0bl9lbmFibGVkJylcclxuICAgICAgICAuc3R5bGUoJ3dpZHRoJywnMTglJylcclxuICAgICAgICAuc3R5bGUoJ21hcmdpbi1sZWZ0JywnMSUnKSAgICAgIFxyXG4gICAgICAgIC5zdHlsZSgnbWFyZ2luLXJpZ2h0JywnMSUnKVxyXG4gICAgICAgIC5zdHlsZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDAsMCknKVxyXG4gICAgICAgIC5hdHRyKCd0eXBlJywnYnV0dG9uJylcclxuICAgICAgICAuYXR0cigndmFsdWUnLGZ1bmN0aW9uKGQpe1xyXG4gICAgICAgICAgcmV0dXJuKGQpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3RpdGxlJywgZnVuY3Rpb24oZCl7XHJcbiAgICAgICAgICByZXR1cm4oZCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbihkKSB7ICBcclxuXHJcbiAgICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBcclxuICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5tZW51X2J0bl9lbmFibGVkJykuc3R5bGUoJ2JvcmRlcicsICcxcHggc29saWQgI2NjYycpOyAgICAgICAgICAgXHJcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2JvcmRlcicsICc1cHggc29saWQgZ29sZCcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBlYXNlID0gZDtcclxuXHJcbiAgICAgICAgICBkMy5zZWxlY3QoJyNzdWJtaXRfYnRuJykuYXR0cignY2xhc3MnLCAnbWVudV9idG5fZW5hYmxlZCcpXHJcbiAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLCBudWxsKTsgICAgICBcclxuICAgICAgICAgIFxyXG4gICAgICAgIH0pOyAgICAgICAgICBcclxuICAgICAgIFxyXG4gICAgICB9LCA1MDApO1xyXG5cclxuICAgICAgYnJlYWs7XHJcbiAgICBcclxuICAgIGRlZmF1bHQ6IC8vIHJldHVybiB0byBtYWluIG1lbnVcclxuICAgICAgICAgIFxyXG4gICAgICBkMy5zZWxlY3QoJyNpbnN0cnVjdGlvbl9kaXYnKS5yZW1vdmUoKTtcclxuICAgICAgXHJcbiAgICAgIHZhciBxdWVzdGlvbm5haXJlX2NvbnRlbnRfZGl2ID0gZDMuc2VsZWN0KCcjcXVlc3Rpb25uYWlyZV9kaXYnKVxyXG4gICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCd0b29sYmFyJylcclxuICAgICAgLnN0eWxlKCd3aWR0aCcsJzEwMCUnKVxyXG4gICAgICAuc3R5bGUoJ2hlaWdodCcsKHdpbmRvdy5pbm5lckhlaWdodCAtIDUwKSArICdweCcpXHJcbiAgICAgIC5hdHRyKCdpZCcsJ2ludHJvX2NvbnRlbnRfZGl2Jyk7ICAgICAgXHJcbiAgICAgIFxyXG4gICAgICAvL0NIQU5HRSA5OTA3NjE3Mjc0IEZPUiBQUk9EVUNUSU9OXHJcblxyXG4gICAgICBxdWVzdGlvbm5haXJlX2NvbnRlbnRfZGl2LmFwcGVuZCgnc3BhbicpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsJ2NvbnNlbnRfdGV4dCcpXHJcbiAgICAgIC5odG1sKCc8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+VGhhbmsgeW91ITwvc3Bhbj48YnI+WW91IGhhdmUgY29tcGxldGVkIHRoZSBzdXJ2ZXkgYW5kIHRoZSBzdHVkeS4gQ29weSB5b3VyIGNvbXBsZXRpb24gY29kZSBiZWxvdy4gVGhpcyBjb2RlIHdpbGwgcmVtYWluIHZhbGlkIGZvciAzMCBtaW51dGVzOjxicj48YnI+PHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiIGlkPVwiY29weV9jb2RlXCIgc3R5bGU9XCJ1c2VyLXNlbGVjdDphbGw7XCI+OTkwNzYxNzI3NDwvc3Bhbj4nXHJcbiAgICAgICk7ICAgICAgICAgIFxyXG5cclxuICAgICAgZDMuc2VsZWN0KCcjcXVlc3Rpb25uYWlyZV9kaXYnKS5hcHBlbmQoJ2lucHV0JylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2J0bicpXHJcbiAgICAgIC5hdHRyKCdpZCcsJ3N1Ym1pdF9idG4nKVxyXG4gICAgICAuYXR0cigndHlwZScsJ2J1dHRvbicpXHJcbiAgICAgIC5hdHRyKCd2YWx1ZScsJ0NvcHkgOTkwNzYxNzI3NCcpXHJcbiAgICAgIC5hdHRyKCd0aXRsZScsICdDb3B5IDk5MDc2MTcyNzQnKVxyXG4gICAgICAuYXR0cignZGF0YS1jbGlwYm9hcmQtdGFyZ2V0JywnI2NvcHlfY29kZScpXHJcbiAgICAgIC5hdHRyKCdkYXRhLWNsaXBib2FyZC10ZXh0JywgJzk5MDc2MTcyNzQnKTtcclxuXHJcbiAgICAgIGdsb2JhbHMubG9nX21lc3NhZ2UgPSB7IFxyXG4gICAgICAgIFwiVGltZVN0YW1wXCI6IG5ldyBEYXRlKCkudmFsdWVPZigpLFxyXG4gICAgICAgIFwiRXZlbnRcIjogXCJTdXJ2ZXlDb21wbGV0ZVwiLFxyXG4gICAgICAgIFwidXNlcl9pZFwiOiBnbG9iYWxzLnVzZXJJRFxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coXCJTdXJ2ZXlDb21wbGV0ZVwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcbiAgICAgIFxyXG4gICAgICBxdWVzdGlvbm5haXJlX2NvbXBsZXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuXHJcbiAgZDMuc2VsZWN0KCcjcXVlc3Rpb25uYWlyZV9kaXYnKVxyXG4gIC5zdHlsZSgndmlzaWJpbGl0eScsJ3Zpc2libGUnKTtcclxuXHJcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3F1ZXN0aW9ubmFpcmVfZGl2JykuZm9jdXMoKTsgIFxyXG4gIFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHF1ZXN0aW9ubmFpcmU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3F1ZXN0aW9ubmFpcmUuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbJ21vZHVsZScsICcuL2NsaXBib2FyZC1hY3Rpb24nLCAndGlueS1lbWl0dGVyJywgJ2dvb2QtbGlzdGVuZXInXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBmYWN0b3J5KG1vZHVsZSwgcmVxdWlyZSgnLi9jbGlwYm9hcmQtYWN0aW9uJyksIHJlcXVpcmUoJ3RpbnktZW1pdHRlcicpLCByZXF1aXJlKCdnb29kLWxpc3RlbmVyJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtb2QgPSB7XG4gICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmYWN0b3J5KG1vZCwgZ2xvYmFsLmNsaXBib2FyZEFjdGlvbiwgZ2xvYmFsLnRpbnlFbWl0dGVyLCBnbG9iYWwuZ29vZExpc3RlbmVyKTtcbiAgICAgICAgZ2xvYmFsLmNsaXBib2FyZCA9IG1vZC5leHBvcnRzO1xuICAgIH1cbn0pKHRoaXMsIGZ1bmN0aW9uIChtb2R1bGUsIF9jbGlwYm9hcmRBY3Rpb24sIF90aW55RW1pdHRlciwgX2dvb2RMaXN0ZW5lcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBfY2xpcGJvYXJkQWN0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsaXBib2FyZEFjdGlvbik7XG5cbiAgICB2YXIgX3RpbnlFbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RpbnlFbWl0dGVyKTtcblxuICAgIHZhciBfZ29vZExpc3RlbmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dvb2RMaXN0ZW5lcik7XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgICAgICB9O1xuICAgIH0oKTtcblxuICAgIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICAgICAgaWYgKCFzZWxmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICAgIH1cblxuICAgIHZhciBDbGlwYm9hcmQgPSBmdW5jdGlvbiAoX0VtaXR0ZXIpIHtcbiAgICAgICAgX2luaGVyaXRzKENsaXBib2FyZCwgX0VtaXR0ZXIpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MRWxlbWVudHxIVE1MQ29sbGVjdGlvbnxOb2RlTGlzdH0gdHJpZ2dlclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ2xpcGJvYXJkKHRyaWdnZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlwYm9hcmQpO1xuXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQ2xpcGJvYXJkLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2xpcGJvYXJkKSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgICAgIF90aGlzLnJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgX3RoaXMubGlzdGVuQ2xpY2sodHJpZ2dlcik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBpZiBhdHRyaWJ1dGVzIHdvdWxkIGJlIHJlc29sdmVkIHVzaW5nIGludGVybmFsIHNldHRlciBmdW5jdGlvbnNcbiAgICAgICAgICogb3IgY3VzdG9tIGZ1bmN0aW9ucyB0aGF0IHdlcmUgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICovXG5cblxuICAgICAgICBfY3JlYXRlQ2xhc3MoQ2xpcGJvYXJkLCBbe1xuICAgICAgICAgICAga2V5OiAncmVzb2x2ZU9wdGlvbnMnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVPcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aW9uID0gdHlwZW9mIG9wdGlvbnMuYWN0aW9uID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5hY3Rpb24gOiB0aGlzLmRlZmF1bHRBY3Rpb247XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0eXBlb2Ygb3B0aW9ucy50YXJnZXQgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnRhcmdldCA6IHRoaXMuZGVmYXVsdFRhcmdldDtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSB0eXBlb2Ygb3B0aW9ucy50ZXh0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50ZXh0IDogdGhpcy5kZWZhdWx0VGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IF90eXBlb2Yob3B0aW9ucy5jb250YWluZXIpID09PSAnb2JqZWN0JyA/IG9wdGlvbnMuY29udGFpbmVyIDogZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAnbGlzdGVuQ2xpY2snLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxpc3RlbkNsaWNrKHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIgPSAoMCwgX2dvb2RMaXN0ZW5lcjIuZGVmYXVsdCkodHJpZ2dlciwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5vbkNsaWNrKGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdvbkNsaWNrJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJpZ2dlciA9IGUuZGVsZWdhdGVUYXJnZXQgfHwgZS5jdXJyZW50VGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xpcGJvYXJkQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcGJvYXJkQWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBib2FyZEFjdGlvbiA9IG5ldyBfY2xpcGJvYXJkQWN0aW9uMi5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB0aGlzLmFjdGlvbih0cmlnZ2VyKSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCh0cmlnZ2VyKSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0KHRyaWdnZXIpLFxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiB0cmlnZ2VyLFxuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2RlZmF1bHRBY3Rpb24nLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRBY3Rpb24odHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVWYWx1ZSgnYWN0aW9uJywgdHJpZ2dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2RlZmF1bHRUYXJnZXQnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRUYXJnZXQodHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IGdldEF0dHJpYnV0ZVZhbHVlKCd0YXJnZXQnLCB0cmlnZ2VyKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdkZWZhdWx0VGV4dCcsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdFRleHQodHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVWYWx1ZSgndGV4dCcsIHRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2xpcGJvYXJkQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcGJvYXJkQWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwYm9hcmRBY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfV0sIFt7XG4gICAgICAgICAgICBrZXk6ICdpc1N1cHBvcnRlZCcsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogWydjb3B5JywgJ2N1dCddO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFjdGlvbnMgPSB0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJyA/IFthY3Rpb25dIDogYWN0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBzdXBwb3J0ID0gISFkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQ7XG5cbiAgICAgICAgICAgICAgICBhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ID0gc3VwcG9ydCAmJiAhIWRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dKTtcblxuICAgICAgICByZXR1cm4gQ2xpcGJvYXJkO1xuICAgIH0oX3RpbnlFbWl0dGVyMi5kZWZhdWx0KTtcblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byByZXRyaWV2ZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN1ZmZpeFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVZhbHVlKHN1ZmZpeCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgYXR0cmlidXRlID0gJ2RhdGEtY2xpcGJvYXJkLScgKyBzdWZmaXg7XG5cbiAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsaXBib2FyZDtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NsaXBib2FyZC9saWIvY2xpcGJvYXJkLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydtb2R1bGUnLCAnc2VsZWN0J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZmFjdG9yeShtb2R1bGUsIHJlcXVpcmUoJ3NlbGVjdCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbW9kID0ge1xuICAgICAgICAgICAgZXhwb3J0czoge31cbiAgICAgICAgfTtcbiAgICAgICAgZmFjdG9yeShtb2QsIGdsb2JhbC5zZWxlY3QpO1xuICAgICAgICBnbG9iYWwuY2xpcGJvYXJkQWN0aW9uID0gbW9kLmV4cG9ydHM7XG4gICAgfVxufSkodGhpcywgZnVuY3Rpb24gKG1vZHVsZSwgX3NlbGVjdCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBfc2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdCk7XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgICAgICB9O1xuICAgIH0oKTtcblxuICAgIHZhciBDbGlwYm9hcmRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ2xpcGJvYXJkQWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlwYm9hcmRBY3Rpb24pO1xuXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5pbml0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBiYXNlIHByb3BlcnRpZXMgcGFzc2VkIGZyb20gY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgX2NyZWF0ZUNsYXNzKENsaXBib2FyZEFjdGlvbiwgW3tcbiAgICAgICAgICAgIGtleTogJ3Jlc29sdmVPcHRpb25zJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlT3B0aW9ucygpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gb3B0aW9ucy5lbWl0dGVyO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlciA9IG9wdGlvbnMudHJpZ2dlcjtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRUZXh0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2luaXRTZWxlY3Rpb24nLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZha2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0VGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdzZWxlY3RGYWtlJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RGYWtlKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNSVEwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXInKSA9PSAncnRsJztcblxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRmFrZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVtb3ZlRmFrZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlciA9IHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrKSB8fCB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB6b29taW5nIG9uIGlPU1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUuZm9udFNpemUgPSAnMTJwdCc7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgYm94IG1vZGVsXG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS5ib3JkZXIgPSAnMCc7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUubWFyZ2luID0gJzAnO1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgZWxlbWVudCBvdXQgb2Ygc2NyZWVuIGhvcml6b250YWxseVxuICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGVbaXNSVEwgPyAncmlnaHQnIDogJ2xlZnQnXSA9ICctOTk5OXB4JztcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGVsZW1lbnQgdG8gdGhlIHNhbWUgcG9zaXRpb24gdmVydGljYWxseVxuICAgICAgICAgICAgICAgIHZhciB5UG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLmZha2VFbGVtLnN0eWxlLnRvcCA9IHlQb3NpdGlvbiArICdweCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZha2VFbGVtLnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS52YWx1ZSA9IHRoaXMudGV4dDtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZmFrZUVsZW0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRleHQgPSAoMCwgX3NlbGVjdDIuZGVmYXVsdCkodGhpcy5mYWtlRWxlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5VGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdyZW1vdmVGYWtlJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGYWtlKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZha2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFrZUhhbmRsZXJDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmFrZUVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5mYWtlRWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAnc2VsZWN0VGFyZ2V0JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RUYXJnZXQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRleHQgPSAoMCwgX3NlbGVjdDIuZGVmYXVsdCkodGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29weVRleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAnY29weVRleHQnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlUZXh0KCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWNjZWVkZWQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkZWQgPSBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmFjdGlvbik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzdWx0KHN1Y2NlZWRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2hhbmRsZVJlc3VsdCcsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUmVzdWx0KHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KHN1Y2NlZWRlZCA/ICdzdWNjZXNzJyA6ICdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB0aGlzLmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5zZWxlY3RlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IHRoaXMudHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJTZWxlY3Rpb246IHRoaXMuY2xlYXJTZWxlY3Rpb24uYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdjbGVhclNlbGVjdGlvbicsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGYWtlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2FjdGlvbicsXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnY29weSc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb24gPSBhY3Rpb247XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9uICE9PSAnY29weScgJiYgdGhpcy5fYWN0aW9uICE9PSAnY3V0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJhY3Rpb25cIiB2YWx1ZSwgdXNlIGVpdGhlciBcImNvcHlcIiBvciBcImN1dFwiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ3RhcmdldCcsXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAodHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGFyZ2V0KSkgPT09ICdvYmplY3QnICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uID09PSAnY29weScgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcInRhcmdldFwiIGF0dHJpYnV0ZS4gUGxlYXNlIHVzZSBcInJlYWRvbmx5XCIgaW5zdGVhZCBvZiBcImRpc2FibGVkXCIgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbiA9PT0gJ2N1dCcgJiYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5JykgfHwgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJ0YXJnZXRcIiBhdHRyaWJ1dGUuIFlvdSBjYW5cXCd0IGN1dCB0ZXh0IGZyb20gZWxlbWVudHMgd2l0aCBcInJlYWRvbmx5XCIgb3IgXCJkaXNhYmxlZFwiIGF0dHJpYnV0ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwidGFyZ2V0XCIgdmFsdWUsIHVzZSBhIHZhbGlkIEVsZW1lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgcmV0dXJuIENsaXBib2FyZEFjdGlvbjtcbiAgICB9KCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsaXBib2FyZEFjdGlvbjtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NsaXBib2FyZC9saWIvY2xpcGJvYXJkLWFjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gc2VsZWN0KGVsZW1lbnQpIHtcbiAgICB2YXIgc2VsZWN0ZWRUZXh0O1xuXG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgICBzZWxlY3RlZFRleHQgPSBlbGVtZW50LnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSU5QVVQnIHx8IGVsZW1lbnQubm9kZU5hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgdmFyIGlzUmVhZE9ubHkgPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmVhZG9ubHknKTtcblxuICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdyZWFkb25seScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuc2VsZWN0KCk7XG4gICAgICAgIGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgZWxlbWVudC52YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgIGlmICghaXNSZWFkT25seSkge1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JlYWRvbmx5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RlZFRleHQgPSBlbGVtZW50LnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcblxuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZWxlbWVudCk7XG4gICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcblxuICAgICAgICBzZWxlY3RlZFRleHQgPSBzZWxlY3Rpb24udG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0ZWRUZXh0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbGVjdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NlbGVjdC9zcmMvc2VsZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBFICgpIHtcbiAgLy8gS2VlcCB0aGlzIGVtcHR5IHNvIGl0J3MgZWFzaWVyIHRvIGluaGVyaXQgZnJvbVxuICAvLyAodmlhIGh0dHBzOi8vZ2l0aHViLmNvbS9saXBzbWFjayBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGNvcmdhbi90aW55LWVtaXR0ZXIvaXNzdWVzLzMpXG59XG5cbkUucHJvdG90eXBlID0ge1xuICBvbjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrLCBjdHgpIHtcbiAgICB2YXIgZSA9IHRoaXMuZSB8fCAodGhpcy5lID0ge30pO1xuXG4gICAgKGVbbmFtZV0gfHwgKGVbbmFtZV0gPSBbXSkpLnB1c2goe1xuICAgICAgZm46IGNhbGxiYWNrLFxuICAgICAgY3R4OiBjdHhcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9uY2U6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGxpc3RlbmVyICgpIHtcbiAgICAgIHNlbGYub2ZmKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIGNhbGxiYWNrLmFwcGx5KGN0eCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXIuXyA9IGNhbGxiYWNrXG4gICAgcmV0dXJuIHRoaXMub24obmFtZSwgbGlzdGVuZXIsIGN0eCk7XG4gIH0sXG5cbiAgZW1pdDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgZGF0YSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgZXZ0QXJyID0gKCh0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KSlbbmFtZV0gfHwgW10pLnNsaWNlKCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBldnRBcnIubGVuZ3RoO1xuXG4gICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGV2dEFycltpXS5mbi5hcHBseShldnRBcnJbaV0uY3R4LCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvZmY6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuICAgIHZhciBlID0gdGhpcy5lIHx8ICh0aGlzLmUgPSB7fSk7XG4gICAgdmFyIGV2dHMgPSBlW25hbWVdO1xuICAgIHZhciBsaXZlRXZlbnRzID0gW107XG5cbiAgICBpZiAoZXZ0cyAmJiBjYWxsYmFjaykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV2dHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGV2dHNbaV0uZm4gIT09IGNhbGxiYWNrICYmIGV2dHNbaV0uZm4uXyAhPT0gY2FsbGJhY2spXG4gICAgICAgICAgbGl2ZUV2ZW50cy5wdXNoKGV2dHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBldmVudCBmcm9tIHF1ZXVlIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICAvLyBTdWdnZXN0ZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2xhemRcbiAgICAvLyBSZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGNvcmdhbi90aW55LWVtaXR0ZXIvY29tbWl0L2M2ZWJmYWE5YmM5NzNiMzNkMTEwYTg0YTMwNzc0MmI3Y2Y5NGM5NTMjY29tbWl0Y29tbWVudC01MDI0OTEwXG5cbiAgICAobGl2ZUV2ZW50cy5sZW5ndGgpXG4gICAgICA/IGVbbmFtZV0gPSBsaXZlRXZlbnRzXG4gICAgICA6IGRlbGV0ZSBlW25hbWVdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RpbnktZW1pdHRlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIGRlbGVnYXRlID0gcmVxdWlyZSgnZGVsZWdhdGUnKTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYWxsIHBhcmFtcyBhbmQgY2FsbHMgdGhlIHJpZ2h0XG4gKiBsaXN0ZW5lciBmdW5jdGlvbiBiYXNlZCBvbiBpdHMgdGFyZ2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8SFRNTENvbGxlY3Rpb258Tm9kZUxpc3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0YXJnZXQgJiYgIXR5cGUgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIFN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghaXMuZm4oY2FsbGJhY2spKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChpcy5ub2RlKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Rlbk5vZGUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzLm5vZGVMaXN0KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Rlbk5vZGVMaXN0KHRhcmdldCwgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIGlmIChpcy5zdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gbGlzdGVuU2VsZWN0b3IodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgU3RyaW5nLCBIVE1MRWxlbWVudCwgSFRNTENvbGxlY3Rpb24sIG9yIE5vZGVMaXN0Jyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBIVE1MIGVsZW1lbnRcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5Ob2RlKG5vZGUsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBsaXN0IG9mIEhUTUwgZWxlbWVudHNcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R8SFRNTENvbGxlY3Rpb259IG5vZGVMaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbGlzdGVuTm9kZUxpc3Qobm9kZUxpc3QsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChub2RlTGlzdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBhIHNlbGVjdG9yXG4gKiBhbmQgcmV0dXJucyBhIHJlbW92ZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5TZWxlY3RvcihzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZGVsZWdhdGUoZG9jdW1lbnQuYm9keSwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0ZW47XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nb29kLWxpc3RlbmVyL3NyYy9saXN0ZW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYSBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLm5vZGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICYmIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnRcbiAgICAgICAgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFyZ3VtZW50IGlzIGEgbGlzdCBvZiBIVE1MIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5ub2RlTGlzdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgJiYgKHR5cGUgPT09ICdbb2JqZWN0IE5vZGVMaXN0XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJylcbiAgICAgICAgJiYgKCdsZW5ndGgnIGluIHZhbHVlKVxuICAgICAgICAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IGV4cG9ydHMubm9kZSh2YWx1ZVswXSkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuc3RyaW5nID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuZm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dvb2QtbGlzdGVuZXIvc3JjL2lzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY2xvc2VzdCA9IHJlcXVpcmUoJy4vY2xvc2VzdCcpO1xuXG4vKipcbiAqIERlbGVnYXRlcyBldmVudCB0byBhIHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlQ2FwdHVyZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfZGVsZWdhdGUoZWxlbWVudCwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgdmFyIGxpc3RlbmVyRm4gPSBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyRm4sIHVzZUNhcHR1cmUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJGbiwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogRGVsZWdhdGVzIGV2ZW50IHRvIGEgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ3xBcnJheX0gW2VsZW1lbnRzXVxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlQ2FwdHVyZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZWxlZ2F0ZShlbGVtZW50cywgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgLy8gSGFuZGxlIHRoZSByZWd1bGFyIEVsZW1lbnQgdXNhZ2VcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRzLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIF9kZWxlZ2F0ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBFbGVtZW50LWxlc3MgdXNhZ2UsIGl0IGRlZmF1bHRzIHRvIGdsb2JhbCBkZWxlZ2F0aW9uXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSBgZG9jdW1lbnRgIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIHRoZW4gYXBwbHkgYXJndW1lbnRzXG4gICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydCB3YXkgdG8gLnVuc2hpZnQgYGFyZ3VtZW50c2Agd2l0aG91dCBydW5uaW5nIGludG8gZGVvcHRpbWl6YXRpb25zXG4gICAgICAgIHJldHVybiBfZGVsZWdhdGUuYmluZChudWxsLCBkb2N1bWVudCkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgU2VsZWN0b3ItYmFzZWQgdXNhZ2VcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBBcnJheS1saWtlIGJhc2VkIHVzYWdlXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9kZWxlZ2F0ZShlbGVtZW50LCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEZpbmRzIGNsb3Nlc3QgbWF0Y2ggYW5kIGludm9rZXMgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyKGVsZW1lbnQsIHNlbGVjdG9yLCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuZGVsZWdhdGVUYXJnZXQgPSBjbG9zZXN0KGUudGFyZ2V0LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKGUuZGVsZWdhdGVUYXJnZXQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoZWxlbWVudCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVsZWdhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kZWxlZ2F0ZS9zcmMvZGVsZWdhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBET0NVTUVOVF9OT0RFX1RZUEUgPSA5O1xuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIEVsZW1lbnQubWF0Y2hlcygpXG4gKi9cbmlmICh0eXBlb2YgRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbiAgICB2YXIgcHJvdG8gPSBFbGVtZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLm1hdGNoZXMgPSBwcm90by5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCB0aGF0IG1hdGNoZXMgYSBzZWxlY3Rvci5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3QgKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gRE9DVU1FTlRfTk9ERV9UWVBFKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5tYXRjaGVzID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvc2VzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RlbGVnYXRlL3NyYy9jbG9zZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZDMgPSByZXF1aXJlKFwiZDNcIik7XHJcbnZhciBnbG9iYWxzID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcclxudmFyIGNoYXJ0ID0gcmVxdWlyZShcIi4vY2hhcnRcIik7XHJcbnZhciBuYXRpb25EYXRhID0gcmVxdWlyZShcIi4vZGF0YS9zdHVkeURhdGFcIik7XHJcbnZhciBjb3VudHJ5U2VsZWN0b3IgPSByZXF1aXJlKFwiLi9jb3VudHJ5U2VsZWN0b3JcIik7XHJcblxyXG5mdW5jdGlvbiB0cmlhbCAoKSB7XHJcblxyXG4gIHN1cHByZXNzX3RvdWNoX3ZhbF9mZWVkYmFjayA9IHRydWU7XHJcbiAgc3VwcHJlc3NfdG91Y2hfZmVlZGJhY2sgPSB0cnVlOyAgXHJcbiAgZ2xvYmFscy50cmlhbF9yZXNwb25zZSA9IFtdO1xyXG4gIGdsb2JhbHMubnVtX3NlbGVjdGVkID0gMDtcclxuICBcclxuICB2YXIgY2hlY2tFeGlzdDsgICAgXHJcbiAgdmFyIGNoZWNrVG91Y2g7XHJcbiAgdmFyIHRyaWFsO1xyXG4gIHZhciBnaXZldXA7XHJcbiAgXHJcbiAgZnVuY3Rpb24gZ2V0RGltcygpIHtcclxuICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICBzdmdfZGltID0gZDMubWluKFtoZWlnaHQsd2lkdGhdKSAtIDI7XHJcbiAgICBpbm5lcl9wYWRkaW5nID0gc3ZnX2RpbSAqIDAuMTtcclxuICAgIGNoYXJ0X2RpbSA9IHN2Z19kaW0gKiAwLjg7XHJcbiAgfVxyXG4gIFxyXG4gIGZ1bmN0aW9uIGRyYXcoKSB7XHJcbiAgICAgICAgICBcclxuICAgIGQzLnNlbGVjdCgnI21haW5fc3ZnJylcclxuICAgIC5zdHlsZSgnaGVpZ2h0JyxzdmdfZGltICsgJ3B4JylcclxuICAgIC5zdHlsZSgnd2lkdGgnLHN2Z19kaW0gKyAncHgnKTtcclxuICAgIFxyXG4gICAgY2hhcnRfZy5hdHRyKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJyArIGlubmVyX3BhZGRpbmcgKyAnLCcgKyBpbm5lcl9wYWRkaW5nICsgJyknKTtcclxuICBcclxuICAgIGQzLnNlbGVjdEFsbCgnLmd1aWRlJykucmVtb3ZlKCk7XHJcbiAgICBjaGFydF9pbnN0YW5jZS5saW5lcyhnbG9iYWxzLmxpbmVzKTsgXHJcbiAgICBjaGFydF9pbnN0YW5jZS5hbmltYXRpb24oJ29mZicpO1xyXG4gICAgY2hhcnRfaW5zdGFuY2UuZmFjZXRzKGdsb2JhbHMuZmFjZXRzKTtcclxuICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihnbG9iYWxzLmZhY2V0cyA9PSAnb24nID8gZ2xvYmFscy5wYXJhbV95ZWFyTWF4IDogZ2xvYmFscy5wYXJhbV95ZWFyTWluKTtcclxuXHJcbiAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gICAgc2NhbGVfcmVnID0gY2hhcnRfaW5zdGFuY2Uuc2NhbGVfcmVnKCk7XHJcbiAgICBkMy5zZWxlY3QoJy55ZWFyX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgZDMuc2VsZWN0QWxsKCcubWFyaycpLnN0eWxlKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XHJcbiAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gIFxyXG4gICAgZDMuc2VsZWN0QWxsKCcudG9vbGJhcicpXHJcbiAgICAuc3R5bGUoJ2Zsb2F0JywgZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGhlaWdodCA8IHdpZHRoID8gJ2xlZnQnIDogJ2luaGVyaXQnO1xyXG4gICAgfSlcclxuICAgIC5zdHlsZSgnd2lkdGgnLCBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gaGVpZ2h0IDwgd2lkdGggPyAoaGVpZ2h0IC8gNykgKyAncHgnICA6IHdpZHRoICsgJ3B4JztcclxuICAgIH0pXHJcbiAgICAuc3R5bGUoJ2hlaWdodCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiBoZWlnaHQgPCB3aWR0aCA/IGhlaWdodCArICdweCcgIDogKHdpZHRoIC8gNykgKyAncHgnO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZDMuc2VsZWN0KCcjcHJvbXB0JylcclxuICAgIC5zdHlsZSgnbWFyZ2luJywgZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGhlaWdodCA8IHdpZHRoID8gJzBweCcgOiAnMnB4JztcclxuICAgIH0pXHJcbiAgICAuc3R5bGUoJ3dpZHRoJywgZnVuY3Rpb24gKCl7XHJcbiAgICAgIHJldHVybiBoZWlnaHQgPCB3aWR0aCA/IChoZWlnaHQgLSAoaGVpZ2h0IC8gNykgKiAoZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gMyA6IDEpIC0gNikgKyAncHgnIDogKHdpZHRoIC0gKHdpZHRoIC8gNykgKiAoZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gMyA6IDEpIC0gNikgKyAncHgnO1xyXG4gICAgfSlcclxuICAgIC5zdHlsZSgnaGVpZ2h0JywgZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGhlaWdodCA8IHdpZHRoID8gKGhlaWdodCAvIDcgLSA2KSA6ICh3aWR0aCAvIDcgLSA2KSArICdweCc7XHJcbiAgICB9KTsgXHJcblxyXG4gICAgLy8gZDMuc2VsZWN0KCcjdHJpYWxfZGl2JylcclxuICAgIC8vIC5zdHlsZSgnaGVpZ2h0JywgZnVuY3Rpb24oKXtcclxuICAgIC8vICAgcmV0dXJuIHN2Z19kaW0gKyAoaGVpZ2h0IDwgd2lkdGggPyAoaGVpZ2h0IC8gNyAtIDYpIDogKHdpZHRoIC8gNyAtIDYpKSArICdweCc7IFxyXG4gICAgLy8gfSk7XHJcblxyXG4gIH1cclxuICBcclxuICBmdW5jdGlvbiBsb2FkRGF0YSAoKSB7ICAgICBcclxuXHJcbiAgICBnbG9iYWxzLnBhcmFtX3ggPSBnbG9iYWxzLnRyaWFsc1swXS54O1xyXG4gICAgZ2xvYmFscy5wYXJhbV95ID0gZ2xvYmFscy50cmlhbHNbMF0ueTtcclxuICAgIGdsb2JhbHMucGFyYW1feWVhck1pbiA9IGdsb2JhbHMudHJpYWxzWzBdLnllYXJNaW47XHJcbiAgICBnbG9iYWxzLnBhcmFtX3llYXJNYXggPSBnbG9iYWxzLnRyaWFsc1swXS55ZWFyTWF4O1xyXG5cclxuICAgIGNoZWNrRXhpc3QgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKGFsbF9kYXRhICE9IHVuZGVmaW5lZCkgeyAgICAgICAgXHJcbiAgICAgICAgY2hhcnRfZy5kYXR1bShhbGxfZGF0YSk7ICAgICAgICBcclxuICAgICAgICBkcmF3KCk7ICAgIFxyXG4gICAgICAgIFxyXG4gICAgICAgIG5leHRUcmlhbCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGhpZGVBZGRyZXNzQmFyKCk7XHJcblxyXG4gICAgICAgIGQzLnNlbGVjdCgnI3RyaWFsX2RpdicpXHJcbiAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xyXG5cclxuICAgICAgICBjbGVhckludGVydmFsKGNoZWNrRXhpc3QpO1xyXG4gICAgICB9XHJcbiAgICB9LCAxMDApOyAvLyBjaGVjayBldmVyeSAxMDBtc1xyXG5cclxuICAgIGNoYXJ0X2luc3RhbmNlID0gY2hhcnQoKTsgICAgXHJcbiAgXHJcbiAgICBtYWluX3N2ZyA9IGQzLnNlbGVjdCgnI21haW5fc3ZnJykucmVtb3ZlKCk7XHJcbiAgXHJcbiAgICBtYWluX3N2ZyA9IGQzLnNlbGVjdCgnI3RyaWFsX2RpdicpLmFwcGVuZCgnc3ZnJylcclxuICAgIC5hdHRyKCdpZCcsJ21haW5fc3ZnJyk7ICBcclxuICBcclxuICAgIGRlZnMgPSBkMy5zZWxlY3QoJyNtYWluX3N2ZycpLmFwcGVuZCgnZGVmcycpO1xyXG4gIFxyXG4gICAgY2hhcnRfZyA9IG1haW5fc3ZnLmFwcGVuZCgnZycpXHJcbiAgICAuYXR0cignaWQnLCdjaGFydF9nJyk7ICAgIFxyXG4gICAgXHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJpYWxfZGl2JykuZm9jdXMoKTtcclxuICB9IFxyXG5cclxuICBmdW5jdGlvbiBuZXh0VHJpYWwgKCkge1xyXG5cclxuICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICBkMy5zZWxlY3RBbGwoJy5wYXRoX2xpbmUnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICBkMy5zZWxlY3QoJyNtYWluX3N2ZycpLmF0dHIoJ2NsYXNzJyxudWxsKTtcclxuICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2Rpc2FibGVkJylcclxuICAgIC5zdHlsZSgnZGlzcGxheScsJ25vbmUnKVxyXG4gICAgLmF0dHIoJ2Rpc2FibGVkJyx0cnVlKVxyXG4gICAgLmF0dHIoJ3NyYycsICdhc3NldHMvbmEuc3ZnJylcclxuICAgIC5zdHlsZSgnbWFyZ2luJywgZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGhlaWdodCA8IHdpZHRoID8gJzBweCcgOiAnMnB4JztcclxuICAgIH0pXHJcbiAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGhlaWdodCA8IHdpZHRoID8gKGhlaWdodCAvIDcgLSA2KSA6ICh3aWR0aCAvIDcgLSA2KTtcclxuICAgIH0pXHJcbiAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbiAoKXtcclxuICAgICAgcmV0dXJuIHdpZHRoIDwgaGVpZ2h0ID8gKHdpZHRoIC8gNyAtIDYpIDogKGhlaWdodCAvIDcgLSA2KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGQzLnNlbGVjdCgnI3Byb2dyZXNzX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgIGQzLnNlbGVjdCgnI291dGVyX3Byb2dyZXNzX2luZGljYXRvcicpXHJcbiAgICAuYXR0cignZGlzcGxheScsIGdsb2JhbHMuZmFjZXRzID09ICdvbicgPyAnbm9uZScgOiBudWxsKTtcclxuXHJcbiAgICB1cGRhdGVfb3V0ZXJfcHJvZ3Jlc3MoMSAvIDI1KTtcclxuICAgIGQzLnNlbGVjdCgnI2lubmVyX3Byb2dyZXNzX3ZhbHVlJykuYXR0cignZCcsIGdsb2JhbHMuaW5uZXJfcHJvZ3Jlc3NfY2lyY2xlLmVuZEFuZ2xlKDApKTtcclxuXHJcbiAgICBkMy5zZWxlY3QoJyNtZW51YmFyJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICBkMy5zZWxlY3QoJy55ZWFyX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgY2hhcnRfaW5zdGFuY2UudGhpc19jaGFydCgpLmludGVycnVwdCgpO1xyXG5cclxuICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbignb2ZmJyk7XHJcbiAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gICAgXHJcbiAgICBkMy5zZWxlY3RBbGwoJy5tYXJrJykuc3R5bGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcclxuICAgIGQzLnNlbGVjdEFsbCgnLmxpbmUnKS5zdHlsZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xyXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWxlY3Rvcl9kaXYnKSAhPSBudWxsKXtcclxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NlbGVjdG9yX2RpdicpLnJlbW92ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2xvYmFscy50cmlhbF9pbmRleCsrO1xyXG4gICAgZ2xvYmFscy50cmlhbF9yZXNwb25zZSA9IFtdO1xyXG5cclxuICAgIGlmIChnbG9iYWxzLnRyaWFsX2luZGV4ICE9IG1heF90cmlhbHMpIHtcclxuXHJcbiAgICAgIHZhciB0cmlhbF9wcm9tcHQgPSBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS5wcm9tcHQ7XHJcbiAgICAgIHZhciByZWdleCA9IC88c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fbnVtYmVyJz4vZ2k7XHJcbiAgICAgIHRyaWFsX3Byb21wdCA9IHRyaWFsX3Byb21wdC5yZXBsYWNlKHJlZ2V4LFwiXCIpO1xyXG4gICAgICByZWdleCA9IC88c3BhbiBjbGFzcz0naW5zdHJ1Y3Rpb25fZW1waGFzaXMnPi9naTtcclxuICAgICAgdHJpYWxfcHJvbXB0ID0gdHJpYWxfcHJvbXB0LnJlcGxhY2UocmVnZXgsXCJcIik7XHJcbiAgICAgIHJlZ2V4ID0gLzxcXC9zcGFuPi9naTtcclxuICAgICAgdHJpYWxfcHJvbXB0ID0gdHJpYWxfcHJvbXB0LnJlcGxhY2UocmVnZXgsXCJcIik7XHJcblxyXG4gICAgICAvL2luaXQgbmV4dCB0cmlhbFxyXG4gICAgICB0cmlhbCA9IHtcclxuICAgICAgICB1c2VyX2lkOiBnbG9iYWxzLnVzZXJJRCxcclxuICAgICAgICBvcmRlcmluZzogZ2xvYmFscy5vcmRlcmluZyxcclxuICAgICAgICB0cmlhbF9pbmRleDogZ2xvYmFscy50cmlhbF9pbmRleCxcclxuICAgICAgICBjb25kaXRpb246IGdsb2JhbHMuY29uZGl0aW9uLFxyXG4gICAgICAgIHRhc2tfaW5kZXg6IGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLnRhc2tfaW5kZXgsXHJcbiAgICAgICAgeDogZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0ueCxcclxuICAgICAgICB5OiBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS55LFxyXG4gICAgICAgIHByb21wdDogdHJpYWxfcHJvbXB0LFxyXG4gICAgICAgIG51bV9yZXNwb25zZXM6IGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLm51bV9yZXNwb25zZXMsXHJcbiAgICAgICAgY29ycmVjdF9yZXNwb25zZXM6IGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLmNvcnJlY3RfcmVzcG9uc2VzLFxyXG4gICAgICAgIHllYXJNaW46IGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLnllYXJNaW4sXHJcbiAgICAgICAgeWVhck1heDogZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0ueWVhck1heCxcclxuICAgICAgICB0dXRvcmlhbDogZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0udHV0b3JpYWwsXHJcbiAgICAgICAgcXVhbGl0eV9jb250cm9sOiBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS5xdWFsaXR5X2NvbnRyb2wsXHJcbiAgICAgICAgcmVzcG9uc2VzOiBbXSxcclxuICAgICAgICBsb2FkX3RpbWU6IG5ldyBEYXRlKCkudmFsdWVPZigpLFxyXG4gICAgICAgIHJlYWRpbmdfdGltZTogMCxcclxuICAgICAgICByZWFkaW5nX2ludGVycnVwdGlvbnM6IDAsXHJcbiAgICAgICAgcmVhZGluZ19pbnRlcnJ1cHRpb25fdGltZTogMCxcclxuICAgICAgICBzdGFydF90aW1lOiAwLFxyXG4gICAgICAgIGludGVycnVwdGlvbnM6IDAsXHJcbiAgICAgICAgaW50ZXJydXB0aW9uX3RpbWU6IDAsXHJcbiAgICAgICAgZW5kX3RpbWU6IDAsXHJcbiAgICAgICAgY29tcGxldGlvbl90aW1lOiAwLFxyXG4gICAgICAgIG5leHRfc3RlcF9jb3VudDogMCxcclxuICAgICAgICBwcmV2X3N0ZXBfY291bnQ6IDAsXHJcbiAgICAgICAgbG9vcF9jb3VudDogMCxcclxuICAgICAgICBhdHRlbXB0czogMCxcclxuICAgICAgICBudW1fZXJyb3JzOiAwLFxyXG4gICAgICAgIGVycm9yOiAwLFxyXG4gICAgICAgIGdpdmVfdXA6IGZhbHNlXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBnbG9iYWxzLnBhcmFtX3ggPSBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS54O1xyXG4gICAgICBnbG9iYWxzLnBhcmFtX3kgPSBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS55O1xyXG4gICAgICBnbG9iYWxzLnBhcmFtX3llYXJNaW4gPSBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS55ZWFyTWluO1xyXG4gICAgICBnbG9iYWxzLnBhcmFtX3llYXJNYXggPSBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS55ZWFyTWF4O1xyXG5cclxuICAgICAgY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbiA9IGdsb2JhbHMucGFyYW1feWVhck1pbjtcclxuICAgICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKGdsb2JhbHMuZmFjZXRzID09ICdvbicgPyBnbG9iYWxzLnBhcmFtX3llYXJNYXggOiBnbG9iYWxzLnBhcmFtX3llYXJNaW4pO1xyXG4gICAgICBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4ID0gZ2xvYmFscy5wYXJhbV95ZWFyTWF4OyAgICAgIFxyXG4gICAgICBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS54ID0gZ2xvYmFscy5wYXJhbV94O1xyXG4gICAgICBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ID0gZ2xvYmFscy5wYXJhbV95OyAgICBcclxuICAgICAgXHJcbiAgICAgIGNoYXJ0X2cuY2FsbChjaGFydF9pbnN0YW5jZSk7XHJcblxyXG4gICAgICBkMy5zZWxlY3QoJyN0cmlhbF9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdmZWVkYmFja19idG5fZW5hYmxlZCcpXHJcbiAgICAgIC5zdHlsZSgndG9wJywoc3ZnX2RpbSArIDUpICsgJ3B4JylcclxuICAgICAgLmF0dHIoJ2lkJywnc3RhcnRfYnRuJylcclxuICAgICAgLnN0eWxlKCdib3JkZXItY29sb3InLCd0cmFuc3BhcmVudCcpXHJcbiAgICAgIC5zdHlsZSgnaGVpZ2h0JywnMTI1cHgnKTsgICAgICAgICAgIFxyXG5cclxuICAgICAgdmFyIGV1cl9oZXggPSBzY2FsZV9yZWcoJ0VVJyk7XHJcbiAgICAgIHZhciBldXJfY29sb3IgPSAnJztcclxuICAgICAgc3dpdGNoIChldXJfaGV4KSB7XHJcblxyXG4gICAgICAgIGNhc2UgJyNmYWQxMzknOlxyXG4gICAgICAgICAgZXVyX2NvbG9yID0gJ3llbGxvdyc7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAnIzU0YjJmYyc6XHJcbiAgICAgICAgICBldXJfY29sb3IgPSAnYmx1ZSc7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAnI2Y2N2FmZSc6XHJcbiAgICAgICAgICBldXJfY29sb3IgPSAncGluayc7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSAnIzhiYmEzMic6XHJcbiAgICAgICAgICBldXJfY29sb3IgPSAnZ3JlZW4nO1xyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIGNhc2UgJyNjMjlhZWInOlxyXG4gICAgICAgICAgZXVyX2NvbG9yID0gJ3B1cnBsZSc7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGV1cl9jb2xvciA9ICcnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHZhciBldXJfcmdiID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaS5leGVjKHNjYWxlX3JlZygnRVUnKSk7XHJcbiAgICAgIHZhciByZ2JfcmVzdWx0ID0gZXVyX3JnYiA/IHtcclxuICAgICAgICByOiBwYXJzZUludChldXJfcmdiWzFdLCAxNiksXHJcbiAgICAgICAgZzogcGFyc2VJbnQoZXVyX3JnYlsyXSwgMTYpLFxyXG4gICAgICAgIGI6IHBhcnNlSW50KGV1cl9yZ2JbM10sIDE2KVxyXG4gICAgICB9IDogbnVsbDtcclxuICAgICAgdmFyIGV1cl9yZ2JhID0gJ3JnYmEoJyArIHJnYl9yZXN1bHQuciArICcsJyArIHJnYl9yZXN1bHQuZyArICcsJyArIHJnYl9yZXN1bHQuYiArICcsMC41KSc7XHJcbiAgICAgIFxyXG4gICAgICB2YXIgZXVyID0gZXVyX2NvbG9yICsgXCIgLyA8c3BhbiBzdHlsZT0nZm9udC1zaXplOjFlbTsgLXdlYmtpdC10ZXh0LXN0cm9rZTogMC41cHggI2ZmZjsgY29sb3I6XCIgKyBldXJfcmdiYSArIFwiOyc+4qykPC9zcGFuPlwiO1xyXG5cclxuICAgICAgZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0ucHJvbXB0ID0gZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0ucHJvbXB0LnJlcGxhY2UoXCJmb29cIiwgZXVyKTtcclxuXHJcbiAgICAgIGQzLnNlbGVjdCgnI3N0YXJ0X2J0bicpLmFwcGVuZCgnc3BhbicpXHJcbiAgICAgIC5hdHRyKCdpZCcsJ2J1dHRvbl90ZXh0JylcclxuICAgICAgLmh0bWwoKGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLnR1dG9yaWFsID8gJzxzcGFuPlRha2Ugbm90ZSBvZiB0aGUgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiIHN0eWxlPVwiY29sb3I6Z29sZDtcIj50d28gY2hhcnQgYXhlczwvc3Bhbj4gYWJvdmUgYW5kIHRoaXMgaW5zdHJ1Y3Rpb246PC9zcGFuPjxicj4nIDogJycpICsgZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0ucHJvbXB0ICsgJzxicj4nICsgJzxzcGFuIGlkPVwidGltZV93YXJuaW5nXCI+WW91IG1heSBwcm9jZWVkIGFmdGVyIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj41IHNlY29uZHM8L3NwYW4+Ljwvc3Bhbj4nICsgJzxzcGFuICBpZD1cInRpbWVfZGVsYXlfbWVzc2FnZVwiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPlRhcCBvbiB0aGlzIG1lc3NhZ2UgdG8gc3RhcnQgJyArIChnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS50dXRvcmlhbCA/ICd0aGlzIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5QUkFDVElDRTwvc3Bhbj4gdHJpYWwnIDogKCd0cmlhbCA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+JyArICgoZ2xvYmFscy50cmlhbF9pbmRleCAtIDMpICsgMSkgKyAnPC9zcGFuPiBvZiA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCI+JyArIChnbG9iYWxzLnRyaWFscy5sZW5ndGggLSAzKSArICc8L3NwYW4+JykpICArICc8YnI+IGFuZCBUUklHR0VSIFRIRSBUSU1FUi48L3NwYW4+Jyk7ICBcclxuXHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAvLyBhbGxvdyBwYXJ0aWNpcGFudCB0byBwcm9jZWVkIGFmdGVyIDVzXHJcblxyXG4gICAgICAgIGQzLnNlbGVjdCgnI3RpbWVfZGVsYXlfbWVzc2FnZScpXHJcbiAgICAgICAgLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuXHJcbiAgICAgICAgZDMuc2VsZWN0KCcjdGltZV93YXJuaW5nJylcclxuICAgICAgICAuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcblxyXG4gICAgICAgIGQzLnNlbGVjdCgnI3N0YXJ0X2J0bicpXHJcbiAgICAgICAgLnN0eWxlKCdib3JkZXItY29sb3InLCcjZmZmJylcclxuICAgICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICBcclxuXHJcbiAgICAgICAgICBzdGFydFRyaWFsKCk7XHJcbiAgICAgICAgfSk7IFxyXG4gICAgICB9LCA1MDAwKTtcclxuXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgZ2xvYmFscy50cmlhbF9pbmRleCA9IC0xO1xyXG4gICAgICBleHBlcmltZW50X2NvbXBsZXRlID0gdHJ1ZTtcclxuXHJcbiAgICAgIGNoYXJ0X2luc3RhbmNlLmFuaW1hdGlvbignb2ZmJyk7XHJcbiAgICAgIGNoYXJ0X2luc3RhbmNlLmxpbmVzKCdvZmYnKTtcclxuICAgICAgY2hhcnRfaW5zdGFuY2UuZmFjZXRzKCdvZmYnKTtcclxuICAgICAgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgwKTtcclxuICAgICAgXHJcbiAgICAgIGdsb2JhbHMuYW5pbWF0aW9uID0gJ29mZic7XHJcbiAgICAgIGdsb2JhbHMubGluZXMgPSAnb2ZmJztcclxuICAgICAgZ2xvYmFscy5mYWNldHMgPSAnb2ZmJztcclxuXHJcbiAgICAgIGNoYXJ0X2cuY2FsbChjaGFydF9pbnN0YW5jZSk7XHJcblxyXG4gICAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgICBcIlRpbWVTdGFtcFwiOiBuZXcgRGF0ZSgpLnZhbHVlT2YoKSxcclxuICAgICAgICBcIkV2ZW50XCI6IFwiVHJpYWxzQ29tcGxldGVkXCIsXHJcbiAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklEXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIlRyaWFsc0NvbXBsZXRlZFwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmlhbF9kaXYnKS5yZW1vdmUoKTtcclxuICAgICAgXHJcbiAgICAgIGxvYWRNZW51KCk7XHJcbiAgICAgIGhpZGVBZGRyZXNzQmFyKCk7ICBcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN0YXJ0VHJpYWwgKCkge1xyXG5cclxuICAgIGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoMCk7XHJcblxyXG4gICAgZDMuc2VsZWN0KCcjbWVudWJhcicpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgIGQzLnNlbGVjdCgnLnllYXJfaW5kaWNhdG9yJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG5cclxuICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgndmlzaWJpbGl0eScsJ3Zpc2libGUnKTtcclxuICAgIGQzLnNlbGVjdEFsbCgnLmxpbmUnKS5zdHlsZSgndmlzaWJpbGl0eScsJ3Zpc2libGUnKTtcclxuXHJcbiAgICB1cGRhdGVfb3V0ZXJfcHJvZ3Jlc3MoMSAvICgoY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1heCArIDEpIC0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbikpO1xyXG5cclxuICAgIGlmIChnbG9iYWxzLmFuaW1hdGlvbiA9PSAnb24nKXtcclxuICAgICAgY2hhcnRfaW5zdGFuY2UuYW5pbWF0aW9uKCdvbicpO1xyXG4gICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGQzLnNlbGVjdEFsbCgnLmltZ19idG5fZGlzYWJsZWQnKVxyXG4gICAgLnN0eWxlKCdtYXJnaW4nLCBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gaGVpZ2h0IDwgd2lkdGggPyAnMHB4JyA6ICcycHgnO1xyXG4gICAgfSlcclxuICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gaGVpZ2h0IDwgd2lkdGggPyAoaGVpZ2h0IC8gNyAtIDYpIDogKHdpZHRoIC8gNyAtIDYpO1xyXG4gICAgfSlcclxuICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uICgpe1xyXG4gICAgICByZXR1cm4gd2lkdGggPCBoZWlnaHQgPyAod2lkdGggLyA3IC0gNikgOiAoaGVpZ2h0IC8gNyAtIDYpO1xyXG4gICAgfSk7IFxyXG5cclxuICAgIGQzLnNlbGVjdCgnI3ByZXZfYnRuJykuYXR0cignY2xhc3MnLChjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluICYmIGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA8IDEpID8gJ2ltZ19idG5fZGlzYWJsZWQnIDogKGdsb2JhbHMuY29uZGl0aW9uID09ICdzdGVwcGVyJyA/ICdpbWdfYnRuX2VuYWJsZWQnIDogJ2ltZ19idG5fZGlzYWJsZWQnKSlcclxuICAgIC5hdHRyKCdkaXNhYmxlZCcsIChjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluICYmIGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA8IDEpID8gdHJ1ZSA6IChnbG9iYWxzLmNvbmRpdGlvbiA9PSAnc3RlcHBlcicgPyBudWxsIDogdHJ1ZSkpXHJcbiAgICAuYXR0cignc3JjJywgZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gJ2Fzc2V0cy9wcmV2X2dyZXkuc3ZnJyA6ICdhc3NldHMvbmEuc3ZnJyk7XHJcblxyXG4gICAgZDMuc2VsZWN0KCcjbmV4dF9idG4nKVxyXG4gICAgLmF0dHIoJ2NsYXNzJywgZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gJ2ltZ19idG5fZW5hYmxlZCcgOiAnaW1nX2J0bl9kaXNhYmxlZCcpXHJcbiAgICAuYXR0cignZGlzYWJsZWQnLCBnbG9iYWxzLmNvbmRpdGlvbiA9PSAnc3RlcHBlcicgPyBudWxsIDogdHJ1ZSlcclxuICAgIC5hdHRyKCdzcmMnLCBnbG9iYWxzLmNvbmRpdGlvbiA9PSAnc3RlcHBlcicgPyAnYXNzZXRzL25leHQuc3ZnJyA6ICdhc3NldHMvbmEuc3ZnJyk7XHJcblxyXG4gICAgZDMuc2VsZWN0KCcjZG9uZV9idG4nKVxyXG4gICAgLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpXHJcbiAgICAuYXR0cignY2xhc3MnLCAnaW1nX2J0bl9kaXNhYmxlZCcpXHJcbiAgICAuYXR0cignZGlzYWJsZWQnLHRydWUpO1xyXG5cclxuICAgIHRyaWFsLmludGVycnVwdGlvbnMgPSAwO1xyXG4gICAgdHJpYWwuaW50ZXJydXB0aW9uX3RpbWUgPSAwO1xyXG4gICAgdHJpYWwuc3RhcnRfdGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xyXG4gICAgXHJcbiAgICBpZiAocmVzdW1wdGlvbnMubGVuZ3RoID4gMCApIHtcclxuICAgICAgdmFyIGkgPSByZXN1bXB0aW9ucy5sZW5ndGggLSAxO1xyXG4gICAgICB3aGlsZSAocmVzdW1wdGlvbnNbaV0ucmVzdW1wdGlvbl90aW1lID4gdHJpYWwubG9hZF90aW1lICYmIGkgPj0gMCkge1xyXG4gICAgICAgIHRyaWFsLnJlYWRpbmdfaW50ZXJydXB0aW9ucysrO1xyXG4gICAgICAgIHRyaWFsLnJlYWRpbmdfaW50ZXJydXB0aW9uX3RpbWUgKz0gcmVzdW1wdGlvbnNbaV0ucGF1c2VfZHVyYXRpb247XHJcbiAgICAgICAgaS0tO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdHJpYWwucmVhZGluZ190aW1lID0gdHJpYWwuc3RhcnRfdGltZSAtIHRyaWFsLmxvYWRfdGltZSAtIHRyaWFsLnJlYWRpbmdfaW50ZXJydXB0aW9uX3RpbWU7XHJcbiAgICBcclxuICAgIGQzLnNlbGVjdCgnI3N0YXJ0X2J0bicpLnJlbW92ZSgpO1xyXG4gICAgY291bnRyeVNlbGVjdG9yKCk7XHJcbiAgICBkMy5zZWxlY3QoJy50YXNrX2luc3RydWN0aW9uX3NwYW4nKS5odG1sKGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLnByb21wdCk7ICAgXHJcblxyXG4gICAgaWYgKGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLnR1dG9yaWFsICE9IHRydWUpIHtcclxuICAgICAgZ2l2ZVVwTG9vcCgpO1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdpdmVVcExvb3AgKCkge1xyXG5cclxuICAgIGdpdmV1cCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgLy8gSSBnaXZlIHVwIC8gSSBkb24ndCBrbm93IG9wdGlvbiBwcmVzZW50ZWQgYWZ0ZXIgMzBzXHJcbiAgICAgIGQzLnNlbGVjdCgnI21haW5fc3ZnJykuYXR0cignY2xhc3MnLCdibHVybWUnKTtcclxuICAgICAgZDMuc2VsZWN0KCcjc2VsZWN0b3JfZGl2Jykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgIGQzLnNlbGVjdCgnI21lbnViYXInKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuXHJcbiAgICAgIHZhciBrZWVwX2dvaW5nX2J0biA9ICBkMy5zZWxlY3QoJyN0cmlhbF9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdmZWVkYmFja19idG5fZW5hYmxlZCcpXHJcbiAgICAgIC5hdHRyKCdpZCcsJ2tlZXBfZ29pbmdfYnRuJylcclxuICAgICAgLnN0eWxlKCdiYWNrZ3JvdW5kJywnIzhiYzM0YScpXHJcbiAgICAgIC5zdHlsZSgnaGVpZ2h0JywnNTBweCcpXHJcbiAgICAgIC5zdHlsZSgnYm9yZGVyLWNvbG9yJywnI2ZmZicpXHJcbiAgICAgIC5vbigndG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkgeyAgXHJcblxyXG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxyXG4gICAgICAgIFxyXG4gICAgICAgIGQzLnNlbGVjdCgnI2tlZXBfZ29pbmdfYnRuJykucmVtb3ZlKCk7XHJcbiAgICAgICAgZDMuc2VsZWN0KCcjZ2l2ZV91cF9idG4nKS5yZW1vdmUoKTtcclxuICAgICAgICBkMy5zZWxlY3QoJyNtZW51YmFyJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgIGQzLnNlbGVjdCgnI21haW5fc3ZnJykuYXR0cignY2xhc3MnLG51bGwpO1xyXG4gICAgICAgIGQzLnNlbGVjdCgnI3NlbGVjdG9yX2RpdicpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTsgICAgICAgICAgICBcclxuICAgICAgICBnaXZlVXBMb29wKCk7XHJcbiAgICAgICAgXHJcbiAgICAgIH0pOyAgXHJcblxyXG4gICAgICBrZWVwX2dvaW5nX2J0bi5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAuYXR0cignaWQnLCdidXR0b25fdGV4dCcpICAgICAgXHJcbiAgICAgIC5zdHlsZSgnY29sb3InLCcjMTExJylcclxuICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsJzQwMCcpXHJcbiAgICAgIC5odG1sKCc8c3BhbiBjbGFzcz1cImNvcnJlY3RfaW5jb3JyZWN0XCI+TkVFRCBNT1JFIFRJTUU/PC9zcGFuPjxicj5UYXAgb24gdGhpcyBtZXNzYWdlIGlmIHlvdSBuZWVkIG1vcmUgdGltZS4nKTsgXHJcblxyXG4gICAgICB2YXIgZ2l2ZV91cF9idG4gPSAgZDMuc2VsZWN0KCcjdHJpYWxfZGl2JykuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCAnZmVlZGJhY2tfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAuYXR0cignaWQnLCdnaXZlX3VwX2J0bicpXHJcbiAgICAgIC5zdHlsZSgnaGVpZ2h0JywnNTBweCcpXHJcbiAgICAgIC5zdHlsZSgnYmFja2dyb3VuZCcsJyNlZjUzNTAnKVxyXG4gICAgICAuc3R5bGUoJ2JvcmRlci1jb2xvcicsJyNmZmYnKVxyXG4gICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgIFxyXG5cclxuICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBcclxuICAgICAgICBcclxuICAgICAgICBkMy5zZWxlY3QoJyNrZWVwX2dvaW5nX2J0bicpLnJlbW92ZSgpO1xyXG4gICAgICAgIGQzLnNlbGVjdCgnI2dpdmVfdXBfYnRuJykucmVtb3ZlKCk7ICBcclxuICAgICAgICB0cmlhbC5naXZlX3VwID0gdHJ1ZTsgICAgIFxyXG4gICAgICAgIGVuZFRyaWFsKCk7ICAgICAgICAgICAgXHJcbiAgICAgICAgXHJcbiAgICAgIH0pOyAgXHJcblxyXG4gICAgICBnaXZlX3VwX2J0bi5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAuYXR0cignaWQnLCdidXR0b25fdGV4dCcpICAgICAgXHJcbiAgICAgIC5zdHlsZSgnY29sb3InLCcjMTExJylcclxuICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsJzQwMCcpXHJcbiAgICAgIC5odG1sKCc8c3BhbiBjbGFzcz1cImNvcnJlY3RfaW5jb3JyZWN0XCI+R0lWRSBVUD88L3NwYW4+PGJyPlRhcCBvbiB0aGlzIG1lc3NhZ2UgaWYgeW91IGRvblxcJ3Qga25vdyB0aGUgYW5zd2VyLicpOyBcclxuXHJcbiAgICB9LCA2MDAwMCk7XHJcblxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZW5kVHJpYWwgKCkge1xyXG5cclxuICAgIGNsZWFyVGltZW91dChnaXZldXApO1xyXG5cclxuICAgIGlmIChkMy5zZWxlY3QoJyNkb25lX2J0bicpLmF0dHIoJ2Rpc2FibGVkJykgPT0gbnVsbCB8fCB0cmlhbC5naXZlX3VwKSB7XHJcblxyXG4gICAgICB2YXIgaSA9IDA7XHJcbiAgICAgIHRyaWFsLm51bV9lcnJvcnMgPSAwO1xyXG4gICAgICB0cmlhbC5sb29wX2NvdW50ID0gY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgpO1xyXG4gICAgICB0cmlhbC5hdHRlbXB0cysrO1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IGdsb2JhbHMudHJpYWxfcmVzcG9uc2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0uY29ycmVjdF9yZXNwb25zZXMuaW5kZXhPZihnbG9iYWxzLnRyaWFsX3Jlc3BvbnNlW2ldKSA9PSAtMSkge1xyXG4gICAgICAgICAgdHJpYWwubnVtX2Vycm9ycysrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdHJpYWwuZXJyb3IgPSB0cmlhbC5udW1fZXJyb3JzIC8gZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0ubnVtX3Jlc3BvbnNlcztcclxuXHJcbiAgICAgIGlmICh0cmlhbC5naXZlX3VwKSB7XHJcbiAgICAgICAgdHJpYWwubnVtX2Vycm9ycyA9IGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLm51bV9yZXNwb25zZXM7XHJcbiAgICAgICAgdHJpYWwuZXJyb3IgPSAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocmVzdW1wdGlvbnMubGVuZ3RoID4gMCApIHtcclxuICAgICAgICB2YXIgaiA9IHJlc3VtcHRpb25zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgd2hpbGUgKHJlc3VtcHRpb25zW2pdLnJlc3VtcHRpb25fdGltZSA+IHRyaWFsLnN0YXJ0X3RpbWUgJiYgaiA+PSAwKSB7XHJcbiAgICAgICAgICB0cmlhbC5pbnRlcnJ1cHRpb25zKys7XHJcbiAgICAgICAgICB0cmlhbC5pbnRlcnJ1cHRpb25fdGltZSArPSByZXN1bXB0aW9uc1tqXS5wYXVzZV9kdXJhdGlvbjtcclxuICAgICAgICAgIGotLTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyaWFsLmVuZF90aW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XHJcbiAgICAgIHRyaWFsLmNvbXBsZXRpb25fdGltZSA9IHRyaWFsLmVuZF90aW1lIC0gdHJpYWwuc3RhcnRfdGltZSAtIHRyaWFsLmludGVycnVwdGlvbl90aW1lO1xyXG4gICAgICB0cmlhbC5yZXNwb25zZXMgPSBnbG9iYWxzLnRyaWFsX3Jlc3BvbnNlO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coJ1RyaWFsQ29tcGxldGUnLCB0cmlhbCk7XHJcblxyXG5cclxuICAgICAgaWYgKGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLnR1dG9yaWFsID09IHRydWUpIHtcclxuXHJcbiAgICAgICAgZDMuc2VsZWN0KCcjbWFpbl9zdmcnKS5hdHRyKCdjbGFzcycsJ2JsdXJtZScpO1xyXG4gICAgICAgIGQzLnNlbGVjdCgnI3NlbGVjdG9yX2RpdicpLnJlbW92ZSgpO1xyXG4gICAgICAgIGQzLnNlbGVjdCgnI21lbnViYXInKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAvLyBnaXZlIGZlZWRiYWNrIGZvciB0dXRvcmlhbCB0cmlhbHNcclxuICAgICAgICBpZiAodHJpYWwuZXJyb3IgIT0gMCl7XHJcbiAgICAgICAgICAvL2dpdmUgbmVnYXRpdmUgZmVlZGJhY2tcclxuXHJcbiAgICAgICAgICB2YXIgaW5jb3JyZWN0X2ZlZWRiYWNrX2J0biA9ICBkMy5zZWxlY3QoJyN0cmlhbF9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAuYXR0cignY2xhc3MnLCAnZmVlZGJhY2tfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgLmF0dHIoJ2lkJywnZmVlZGJhY2tfYnRuJylcclxuICAgICAgICAgIC5zdHlsZSgnYmFja2dyb3VuZCcsJyNlZjUzNTAnKVxyXG4gICAgICAgICAgLnN0eWxlKCdib3JkZXItY29sb3InLCcjZmZmJykgICAgICAgIFxyXG4gICAgICAgICAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7ICBcclxuXHJcbiAgICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7IFxyXG5cclxuICAgICAgICAgICAgaWYgKHRyaWFsLmF0dGVtcHRzID49IDIpIHtcclxuICAgICAgICAgICAgICAvL3Nob3cgaGludCAgIFxyXG4gICAgICAgICAgICAgIGFsbF9kYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpe1xyXG4gICAgICAgICAgICAgICAgaWYgKGdsb2JhbHMudHJpYWxzW2dsb2JhbHMudHJpYWxfaW5kZXhdLmNvcnJlY3RfcmVzcG9uc2VzLmluZGV4T2YoZC5uYW1lKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICBkMy5zZWxlY3QoJyNtYXJrXycgKyBkLmNvZGUpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KCcjbGluZV8nICsgZC5jb2RlKS5zZWxlY3QoJy5wYXRoX2xpbmUnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KCcjbGluZV8nICsgZC5jb2RlKS5zZWxlY3QoJy5wYXRoX2xpbmUnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KCcjbWFya18nICsgZC5jb2RlKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHRyaWFsLmF0dGVtcHRzIDw9IDMpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgLy8gSGlkZSB0aGUgYWRkcmVzcyBiYXIhXHJcbiAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnBhdGhfbGluZScpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgICAgICAgIH0sIDE1MDApOyAgICBcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI3Byb2dyZXNzX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjb3V0ZXJfcHJvZ3Jlc3NfaW5kaWNhdG9yJylcclxuICAgICAgICAgICAgLmF0dHIoJ2Rpc3BsYXknLCBnbG9iYWxzLmZhY2V0cyA9PSAnb24nID8gJ25vbmUnIDogbnVsbCk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2Rpc2FibGVkJylcclxuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpXHJcbiAgICAgICAgICAgIC5hdHRyKCdkaXNhYmxlZCcsdHJ1ZSlcclxuICAgICAgICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvbmEuc3ZnJylcclxuICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4nLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPCB3aWR0aCA/ICcwcHgnIDogJzJweCc7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPCB3aWR0aCA/IChoZWlnaHQgLyA3IC0gNikgOiAod2lkdGggLyA3IC0gNik7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uICgpe1xyXG4gICAgICAgICAgICAgIHJldHVybiB3aWR0aCA8IGhlaWdodCA/ICh3aWR0aCAvIDcgLSA2KSA6IChoZWlnaHQgLyA3IC0gNik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3QoJyNmZWVkYmFja19idG4nKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjbWVudWJhcicpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgICAgZDMuc2VsZWN0KCcjbWFpbl9zdmcnKS5hdHRyKCdjbGFzcycsbnVsbCk7XHJcbiAgICAgICAgICAgIGdsb2JhbHMubnVtX3NlbGVjdGVkID0gMDtcclxuICAgICAgICAgICAgZ2xvYmFscy50cmlhbF9yZXNwb25zZSA9IFtdO1xyXG4gICAgICAgICAgICB0cmlhbC5yZXNwb25zZXMgPSBbXTtcclxuICAgICAgICAgICAgdHJpYWwuZXJyb3IgPSAwO1xyXG4gICAgICAgICAgICB0cmlhbC5udW1fZXJyb3JzID0gMDtcclxuICAgICAgICAgICAgY291bnRyeVNlbGVjdG9yKCk7XHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI2lubmVyX3Byb2dyZXNzX3ZhbHVlJykuYXR0cignZCcsIGdsb2JhbHMuaW5uZXJfcHJvZ3Jlc3NfY2lyY2xlLmVuZEFuZ2xlKDApKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vdHJ5IGFnYWluXHJcbiAgICAgICAgICAgIHRyaWFsLnN0YXJ0X3RpbWUgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcclxuICAgICAgICAgIH0pOyAgXHJcblxyXG4gICAgICAgICAgaW5jb3JyZWN0X2ZlZWRiYWNrX2J0bi5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAgICAgLmF0dHIoJ2lkJywnYnV0dG9uX3RleHQnKVxyXG4gICAgICAgICAgLnN0eWxlKCdjb2xvcicsJyMxMTEnKVxyXG4gICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsJzQwMCcpXHJcbiAgICAgICAgICAuaHRtbChmdW5jdGlvbigpIHsgICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKHRyaWFsLmF0dGVtcHRzID4gMykge1xyXG4gICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJjb3JyZWN0X2luY29ycmVjdFwiPklOQ09SUkVDVDwvc3Bhbj48YnI+VGFwIG9uIHRoaXMgbWVzc2FnZSB0byBzZWUgdGhlIGNvcnJlY3QgcmVzcG9uc2UuJztcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAodHJpYWwuYXR0ZW1wdHMgPiAxKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICc8c3BhbiBjbGFzcz1cImNvcnJlY3RfaW5jb3JyZWN0XCI+SU5DT1JSRUNUPC9zcGFuPjxicj5UYXAgb24gdGhpcyBtZXNzYWdlIHRvIHNlZSBhIGJyaWVmIGhpbnQuJztcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiAnPHNwYW4gY2xhc3M9XCJjb3JyZWN0X2luY29ycmVjdFwiPklOQ09SUkVDVDwvc3Bhbj48YnI+VGFwIG9uIHRoaXMgbWVzc2FnZSB0byB0cnkgYWdhaW4uJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7IFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIC8vZ2l2ZSBwb3NpdGl2ZSBmZWVkYmFja1xyXG5cclxuICAgICAgICAgIGQzLnNlbGVjdCgnI3NlbGVjdG9yX2RpdicpLnJlbW92ZSgpO1xyXG4gICAgICAgICAgZDMuc2VsZWN0KCcjbWVudWRpdicpLnJlbW92ZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgdmFyIGNvcnJlY3RfZmVlZGJhY2tfYnRuID0gZDMuc2VsZWN0KCcjdHJpYWxfZGl2JykuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2ZlZWRiYWNrX2J0bl9lbmFibGVkJylcclxuICAgICAgICAgIC5hdHRyKCdpZCcsJ2ZlZWRiYWNrX2J0bicpXHJcbiAgICAgICAgICAuc3R5bGUoJ2JhY2tncm91bmQnLCcjOGJjMzRhJylcclxuICAgICAgICAgIC5zdHlsZSgnYm9yZGVyLWNvbG9yJywnI2ZmZicpXHJcbiAgICAgICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgXHJcblxyXG4gICAgICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBcclxuXHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI2ZlZWRiYWNrX2J0bicpLnJlbW92ZSgpOyBcclxuICAgICAgICAgICAgaWYgKGdsb2JhbHMudHJpYWxfaW5kZXggPT0gMikge1xyXG5cclxuICAgICAgICAgICAgICBnbG9iYWxzLmxvZ19tZXNzYWdlID0geyBcclxuICAgICAgICAgICAgICAgIFwiVGltZVN0YW1wXCI6IG5ldyBEYXRlKCkudmFsdWVPZigpLFxyXG4gICAgICAgICAgICAgICAgXCJFdmVudFwiOiBcIlR1dG9yaWFsc0NvbXBsZXRlZFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ1c2VyX2lkXCI6IGdsb2JhbHMudXNlcklEXHJcbiAgICAgICAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlR1dG9yaWFsc0NvbXBsZXRlZFwiLCBnbG9iYWxzLmxvZ19tZXNzYWdlKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgIHZhciB0aW1lZF90cmlhbF93YXJuaW5nID0gZDMuc2VsZWN0KCcjdHJpYWxfZGl2JykuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdmZWVkYmFja19idG5fZW5hYmxlZCcpXHJcbiAgICAgICAgICAgICAgLmF0dHIoJ2lkJywndGltZWRfdHJpYWxfd2FybmluZycpXHJcbiAgICAgICAgICAgICAgLnN0eWxlKCdib3JkZXItY29sb3InLCcjZmZmJylcclxuICAgICAgICAgICAgICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICAgICAgICAgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBcclxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCgnI3RpbWVkX3RyaWFsX3dhcm5pbmcnKS5yZW1vdmUoKTsgXHJcbiAgICAgICAgICAgICAgICBuZXh0VHJpYWwoKTtcclxuICAgICAgICAgICAgICB9KTsgXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgdGltZWRfdHJpYWxfd2FybmluZy5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAgICAgICAgIC5hdHRyKCdpZCcsJ2J1dHRvbl90ZXh0JylcclxuICAgICAgICAgICAgICAuc3R5bGUoJ2ZvbnQtd2VpZ2h0JywnNDAwJylcclxuICAgICAgICAgICAgICAuaHRtbCgnWW91IGhhdmUgY29tcGxldGVkIHRoZSBwcmFjdGljZSB0cmlhbHMuIENvbXBsZXRlIHRoZSBmb2xsb3dpbmcgdHJpYWxzIGFzIDxzcGFuIGNsYXNzPVwiaW5zdHJ1Y3Rpb25fZW1waGFzaXNcIj5xdWlja2x5PC9zcGFuPiBhbmQgYXMgPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPmFjY3VyYXRlbHk8L3NwYW4+IGFzIHlvdSBjYW4uIFlvdSB3aWxsIG5vdCBiZSB0b2xkIGlmIHlvdXIgcmVzcG9uc2VzIGFyZSBjb3JyZWN0LiA8YnI+PHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPlRhcCBvbiB0aGlzIG1lc3NhZ2UgdG8gY29udGludWU8L3NwYW4+LicpOyAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgbmV4dFRyaWFsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgIFxyXG4gICAgICAgICAgfSk7ICAgICAgICBcclxuXHJcbiAgICAgICAgICBjb3JyZWN0X2ZlZWRiYWNrX2J0bi5hcHBlbmQoJ3NwYW4nKVxyXG4gICAgICAgICAgLmF0dHIoJ2lkJywnYnV0dG9uX3RleHQnKVxyXG4gICAgICAgICAgLnN0eWxlKCdjb2xvcicsJyMxMTEnKVxyXG4gICAgICAgICAgLnN0eWxlKCdmb250LXdlaWdodCcsJzQwMCcpXHJcbiAgICAgICAgICAuaHRtbCgnPHNwYW4gY2xhc3M9XCJjb3JyZWN0X2luY29ycmVjdFwiPkNPUlJFQ1Q8L3NwYW4+PGJyPlRhcCBvbiB0aGlzIG1lc3NhZ2UgdG8gY29udGludWUuPGJyPicpOyAgXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vdGVzdCB0cmlhbFxyXG4gICAgICAgIG5leHRUcmlhbCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgfVxyXG4gIH1cclxuICAgIFxyXG4gIC8qKiBJTklUICoqL1xyXG4gIFxyXG4gIGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JylcclxuICAuYXR0cignaWQnLCd0cmlhbF9kaXYnKVxyXG4gIC5hdHRyKCd0YWJpbmRleCcsMCk7XHJcblxyXG4gIGFsbF9kYXRhID0gbmF0aW9uRGF0YTsgIFxyXG4gIHZhciBjb2RlcyA9IFtcIkFcIiwgXCJCXCIsIFwiQ1wiLCBcIkRcIiwgXCJFXCIsIFwiRlwiLCBcIkdcIiwgXCJIXCIsIFwiSVwiLCBcIkpcIiwgXCJLXCIsIFwiTFwiLCBcIk1cIiwgXCJOXCIsIFwiT1wiLCBcIlBcIl07IC8vLFxyXG4gIGNvZGVzID0gc2h1ZmZsZShjb2Rlcyk7XHJcbiAgYWxsX2RhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCxpKXsgXHJcbiAgICBkLmNvZGUgPSBjb2Rlc1tpXTsgXHJcbiAgfSk7XHJcbiAgbG9hZERhdGEoKTsgXHJcblxyXG4gIGdldERpbXMoKTtcclxuXHJcbiAgdmFyIG1lbnViYXIgPSBkMy5zZWxlY3QoJyN0cmlhbF9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgLmF0dHIoJ2NsYXNzJywndG9vbGJhcicpXHJcbiAgLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpXHJcbiAgLmF0dHIoJ2lkJywnbWVudWJhcicpOyAgXHJcblxyXG4gIG1lbnViYXIuYXBwZW5kKFwiaW5wdXRcIilcclxuICAuYXR0cignY2xhc3MnLCdpbWdfYnRuX2Rpc2FibGVkJykgIFxyXG4gIC5hdHRyKCdpZCcsJ3ByZXZfYnRuJylcclxuICAuYXR0cigndHlwZScsJ2ltYWdlJylcclxuICAuYXR0cignbmFtZScsJ1ByZXZUb2dnbGUnKVxyXG4gIC5hdHRyKCd0aXRsZScsICdQcmV2VG9nZ2xlJylcclxuICAuYXR0cignZGlzYWJsZWQnLCB0cnVlKVxyXG4gIC5zdHlsZSgnZGlzcGxheScsZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gbnVsbCA6ICdub25lJylcclxuICAuYXR0cignc3JjJywgZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gJ2Fzc2V0cy9wcmV2X2dyZXkuc3ZnJyA6ICdhc3NldHMvbmEuc3ZnJylcclxuICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAgICBcclxuXHJcbiAgICBpZiAoZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInKXtcclxuXHJcbiAgICAgIGNsZWFyVGltZW91dChnaXZldXApO1xyXG4gICAgICBnaXZlVXBMb29wKCk7XHJcblxyXG4gICAgICBkMy5zZWxlY3QodGhpcykuYXR0cignc3JjJywgZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gKGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA8IDEgPyAnYXNzZXRzL3ByZXZfZ3JleS5zdmcnIDogJ2Fzc2V0cy9wcmV2X2dvbGQuc3ZnJykgOiAnYXNzZXRzL25hLnN2ZycpO1xyXG4gICAgICBjaGFydF9pbnN0YW5jZS50aGlzX2NoYXJ0KCkuaW50ZXJydXB0KCk7ICAgICAgXHJcblxyXG4gICAgICBpZiAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgIT0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbikgeyAgICAgIFxyXG4gICAgICAgIHZhciBwcmV2X3llYXIgPSBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSAtIDE7XHJcbiAgICAgICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKHByZXZfeWVhcik7XHJcbiAgICAgICAgdmFyIG91dGVyX3Byb2dyZXNzID0gICgocHJldl95ZWFyICsgMSkgLSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKSAvICgoY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1heCArIDEpIC0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbik7XHJcbiAgICAgICAgdXBkYXRlX291dGVyX3Byb2dyZXNzKGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSArIG91dGVyX3Byb2dyZXNzKTtcclxuICAgICAgICBcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgPiAwICYmIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pIHtcclxuICAgICAgICBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1heCk7XHJcbiAgICAgICAgZDMuc2VsZWN0QWxsKCcubWFyaycpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgIGQzLnNlbGVjdEFsbCgnLnBhdGhfbGluZScpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5wYXRoX2xpbmUnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICAgICAgfSwgNTAwKTtcclxuICAgICAgfVxyXG4gICAgICB0cmlhbC5wcmV2X3N0ZXBfY291bnQrKztcclxuICAgICAgY2hhcnRfZy5jYWxsKGNoYXJ0X2luc3RhbmNlKTtcclxuXHJcbiAgICAgIGNoZWNrVG91Y2ggPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcclxuICAgICAgICBpZiAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgIT0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbikge1xyXG4gICAgICAgICAgdmFyIHByZXZfeWVhciA9IGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpIC0gMTtcclxuICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihwcmV2X3llYXIpOyAgIFxyXG4gICAgICAgICAgdmFyIG91dGVyX3Byb2dyZXNzID0gICgocHJldl95ZWFyICsgMSkgLSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKSAvICgoY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1heCArIDEpIC0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbik7XHJcbiAgICAgICAgICB1cGRhdGVfb3V0ZXJfcHJvZ3Jlc3MoY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgpICsgb3V0ZXJfcHJvZ3Jlc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgPiAwICYmIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pIHtcclxuICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4KTtcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnBhdGhfbGluZScpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5tYXJrJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5wYXRoX2xpbmUnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmlhbC5wcmV2X3N0ZXBfY291bnQrKztcclxuICAgICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpO1xyXG4gICAgICAgIFxyXG4gICAgICB9LCA1MDApOyAvLyBjaGVjayBldmVyeSA1MDBtcyBpZiB0b3VjaCBpcyBvbmdvaW5nICAgICAgICAgIFxyXG5cclxuICAgIH1cclxuICB9KVxyXG4gIC5vbigndG91Y2hlbmQnLCBmdW5jdGlvbigpe1xyXG4gICAgXHJcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgY2xlYXJJbnRlcnZhbChjaGVja1RvdWNoKTtcclxuXHJcbiAgICBpZiAoZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInKSB7XHJcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCdjbGFzcycsKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4gJiYgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgpIDwgMSkgPyAnaW1nX2J0bl9kaXNhYmxlZCcgOiAnaW1nX2J0bl9lbmFibGVkJylcclxuICAgICAgLmF0dHIoJ2Rpc2FibGVkJywgKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4gJiYgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudCgpIDwgMSkgPyB0cnVlIDogbnVsbClcclxuICAgICAgLmF0dHIoJ3NyYycsIChjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluICYmIGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA8IDEpID8gJ2Fzc2V0cy9wcmV2X2dyZXkuc3ZnJyA6ICdhc3NldHMvcHJldi5zdmcnKTtcclxuICAgIH1cclxuICB9KTsgICAgXHJcblxyXG4gIG1lbnViYXIuYXBwZW5kKFwiaW5wdXRcIilcclxuICAuYXR0cignaWQnLCduZXh0X2J0bicpXHJcbiAgLmF0dHIoJ2NsYXNzJywgJ2ltZ19idG5fZGlzYWJsZWQnKSAgXHJcbiAgLmF0dHIoJ3R5cGUnLCdpbWFnZScpIFxyXG4gIC5hdHRyKCduYW1lJywnTmV4dFRvZ2dsZScpXHJcbiAgLmF0dHIoJ3RpdGxlJywgJ05leHRUb2dnbGUnKVxyXG4gIC5zdHlsZSgnZGlzcGxheScsZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gbnVsbCA6ICdub25lJylcclxuICAuYXR0cignc3JjJywgZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gJ2Fzc2V0cy9uZXh0LnN2ZycgOiAnYXNzZXRzL25hLnN2ZycpXHJcbiAgLmF0dHIoJ2Rpc2FibGVkJywgZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInID8gbnVsbCA6IHRydWUpXHJcbiAgLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7ICAgIFxyXG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTsgICAgXHJcblxyXG4gICAgaWYgKGdsb2JhbHMuY29uZGl0aW9uID09ICdzdGVwcGVyJyl7XHJcblxyXG4gICAgICBjbGVhclRpbWVvdXQoZ2l2ZXVwKTtcclxuICAgICAgZ2l2ZVVwTG9vcCgpO1xyXG5cclxuICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3NyYycsIGdsb2JhbHMuY29uZGl0aW9uID09ICdzdGVwcGVyJyA/ICdhc3NldHMvbmV4dF9nb2xkLnN2ZycgOiAnYXNzZXRzL25hLnN2ZycpO1xyXG4gICAgICBjaGFydF9pbnN0YW5jZS50aGlzX2NoYXJ0KCkuaW50ZXJydXB0KCk7XHJcblxyXG4gICAgICBpZiAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1heCkge1xyXG4gICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKTtcclxuICAgICAgICBkMy5zZWxlY3RBbGwoJy5tYXJrJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgICAgZDMuc2VsZWN0QWxsKCcucGF0aF9saW5lJykuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgZDMuc2VsZWN0QWxsKCcubWFyaycpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnBhdGhfbGluZScpLnN0eWxlKCdkaXNwbGF5JyxudWxsKTtcclxuICAgICAgICB9LCA1MDApO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBuZXh0X3llYXIgPSBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSArIDE7XHJcbiAgICAgICAgdmFyIG91dGVyX3Byb2dyZXNzID0gICgobmV4dF95ZWFyICsgMSkgLSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKSAvICgoY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1heCArIDEpIC0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbik7XHJcbiAgICAgICAgdXBkYXRlX291dGVyX3Byb2dyZXNzKGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSArIG91dGVyX3Byb2dyZXNzKTtcclxuICAgICAgICBpZiAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gKGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXggLSAxKSkge1xyXG4gICAgICAgICAgY2hhcnRfaW5zdGFuY2UubG9vcF9jb3VudChjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgKyAxKTtcclxuICAgICAgICAgIGlmIChnbG9iYWxzLm51bV9zZWxlY3RlZCA9PSBnbG9iYWxzLnRyaWFsc1tnbG9iYWxzLnRyaWFsX2luZGV4XS5udW1fcmVzcG9uc2VzKXsgICAgICAgICAgXHJcbiAgICAgICAgICAgIGQzLnNlbGVjdCgnI3Byb2dyZXNzX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3QoJyNkb25lX2J0bicpLmF0dHIoJ2NsYXNzJywnaW1nX2J0bl9lbmFibGVkJylcclxuICAgICAgICAgICAgLnN0eWxlKCdkaXNwbGF5JyxudWxsKVxyXG4gICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLG51bGwpXHJcbiAgICAgICAgICAgIC5hdHRyKCdzcmMnLCAnYXNzZXRzL2RvbmUuc3ZnJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihuZXh0X3llYXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHRyaWFsLm5leHRfc3RlcF9jb3VudCsrO1xyXG4gICAgICBjaGFydF9nLmNhbGwoY2hhcnRfaW5zdGFuY2UpOyAgICAgXHJcblxyXG4gICAgICBjaGVja1RvdWNoID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcigpID09IGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXgpIHtcclxuICAgICAgICAgIGNoYXJ0X2luc3RhbmNlLmN1cnJlbnRfeWVhcihjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKTtcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLm1hcmsnKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcclxuICAgICAgICAgIGQzLnNlbGVjdEFsbCgnLnBhdGhfbGluZScpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5tYXJrJykuc3R5bGUoJ2Rpc3BsYXknLG51bGwpO1xyXG4gICAgICAgICAgICBkMy5zZWxlY3RBbGwoJy5wYXRoX2xpbmUnKS5zdHlsZSgnZGlzcGxheScsbnVsbCk7XHJcbiAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgIHZhciBuZXh0X3llYXIgPSBjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSArIDE7XHJcbiAgICAgICAgICB2YXIgb3V0ZXJfcHJvZ3Jlc3MgPSAgKChuZXh0X3llYXIgKyAxKSAtIGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNaW4pIC8gKChjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4ICsgMSkgLSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKTtcclxuICAgICAgICAgIHVwZGF0ZV9vdXRlcl9wcm9ncmVzcyhjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgKyBvdXRlcl9wcm9ncmVzcyk7XHJcbiAgICAgICAgICBpZiAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gKGNoYXJ0X2luc3RhbmNlLnBhcmFtcygpLnllYXJNYXggLSAxKSkge1xyXG4gICAgICAgICAgICBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSArIDEpO1xyXG4gICAgICAgICAgICBpZiAoZ2xvYmFscy5udW1fc2VsZWN0ZWQgPT0gZ2xvYmFscy50cmlhbHNbZ2xvYmFscy50cmlhbF9pbmRleF0ubnVtX3Jlc3BvbnNlcyl7ICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGQzLnNlbGVjdCgnI3Byb2dyZXNzX2luZGljYXRvcicpLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpO1xyXG4gICAgICAgICAgICAgIGQzLnNlbGVjdCgnI2RvbmVfYnRuJykuYXR0cignY2xhc3MnLCdpbWdfYnRuX2VuYWJsZWQnKVxyXG4gICAgICAgICAgICAgIC5zdHlsZSgnZGlzcGxheScsbnVsbClcclxuICAgICAgICAgICAgICAuYXR0cignZGlzYWJsZWQnLG51bGwpXHJcbiAgICAgICAgICAgICAgLmF0dHIoJ3NyYycsICdhc3NldHMvZG9uZS5zdmcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKG5leHRfeWVhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyaWFsLm5leHRfc3RlcF9jb3VudCsrO1xyXG4gICAgICAgIGNoYXJ0X2cuY2FsbChjaGFydF9pbnN0YW5jZSk7XHJcbiAgICAgIH0sIDUwMCk7IC8vIGNoZWNrIGV2ZXJ5IDUwMG1zIGlmIHRvdWNoIGlzIG9uZ29pbmcgICAgXHJcblxyXG4gICAgfVxyXG4gIH0pXHJcbiAgLm9uKCd0b3VjaGVuZCcsIGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIGNsZWFySW50ZXJ2YWwoY2hlY2tUb3VjaCk7XHJcblxyXG4gICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3NyYycsIGdsb2JhbHMuY29uZGl0aW9uID09ICdzdGVwcGVyJyA/ICdhc3NldHMvbmV4dC5zdmcnIDogJ2Fzc2V0cy9uYS5zdmcnKTtcclxuXHJcbiAgICBpZiAoZ2xvYmFscy5jb25kaXRpb24gPT0gJ3N0ZXBwZXInKSB7XHJcbiAgICAgIGQzLnNlbGVjdCgnI3ByZXZfYnRuJykuYXR0cignY2xhc3MnLChjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluICYmIGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA8IDEpID8gJ2ltZ19idG5fZGlzYWJsZWQnIDogJ2ltZ19idG5fZW5hYmxlZCcpXHJcbiAgICAgIC5hdHRyKCdkaXNhYmxlZCcsIChjaGFydF9pbnN0YW5jZS5jdXJyZW50X3llYXIoKSA9PSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluICYmIGNoYXJ0X2luc3RhbmNlLmxvb3BfY291bnQoKSA8IDEpID8gdHJ1ZSA6IG51bGwpXHJcbiAgICAgIC5hdHRyKCdzcmMnLCAoY2hhcnRfaW5zdGFuY2UuY3VycmVudF95ZWFyKCkgPT0gY2hhcnRfaW5zdGFuY2UucGFyYW1zKCkueWVhck1pbiAmJiBjaGFydF9pbnN0YW5jZS5sb29wX2NvdW50KCkgPCAxKSA/ICdhc3NldHMvcHJldl9ncmV5LnN2ZycgOiAnYXNzZXRzL3ByZXYuc3ZnJyk7XHJcbiAgICB9XHJcblxyXG4gIH0pOyAgICBcclxuXHJcbiAgdmFyIHByb21wdCA9IG1lbnViYXIuYXBwZW5kKFwiZGl2XCIpXHJcbiAgLmF0dHIoJ2lkJywncHJvbXB0JylcclxuICAub24oJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHsgICAgXHJcbiAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpOyBcclxuICB9KTtcclxuXHJcbiAgcHJvbXB0LmFwcGVuZCgnc3BhbicpXHJcbiAgLmF0dHIoJ2NsYXNzJywndGFza19pbnN0cnVjdGlvbl9zcGFuJylcclxuICAuaHRtbCgnJyk7ICBcclxuXHJcbiAgbWVudWJhci5hcHBlbmQoXCJpbnB1dFwiKVxyXG4gIC5hdHRyKCdjbGFzcycsICdpbWdfYnRuX2Rpc2FibGVkJylcclxuICAuYXR0cignZGlzYWJsZWQnLHRydWUpXHJcbiAgLnN0eWxlKCdkaXNwbGF5Jywnbm9uZScpXHJcbiAgLmF0dHIoJ2lkJywnZG9uZV9idG4nKVxyXG4gIC5hdHRyKCd0eXBlJywnaW1hZ2UnKVxyXG4gIC5hdHRyKCduYW1lJywnRG9uZScpXHJcbiAgLmF0dHIoJ3RpdGxlJywgJ0RvbmUnKVxyXG4gIC5hdHRyKCdzcmMnLCAnYXNzZXRzL25hLnN2ZycpXHJcbiAgLm9uKCd0b3VjaHN0YXJ0JywgZW5kVHJpYWwpO1xyXG5cclxuICAvL3Byb2dyZXNzIGluZGljYXRvcnNcclxuICB2YXIgcHJvZ3Jlc3NfY29sb3JzID0ge1xyXG4gICAgb3V0ZXJfZmlsbDogJ2dvbGQnLFxyXG4gICAgaW5uZXJfZmlsbDogJyNmZmYnLFxyXG4gICAgdHJhY2s6ICcjOTk5JyxcclxuICAgIHN0cm9rZTogJyMzMzMnLFxyXG4gIH07XHJcblxyXG4gIHZhciBwcm9ncmVzc19yYWRpdXMgPSAoaGVpZ2h0IDwgd2lkdGggPyAoaGVpZ2h0IC8gNyAtIDYpIDogKHdpZHRoIC8gNyAtIDYpKSAvIDI7XHJcbiAgdmFyIHByb2dyZXNzX3N0cm9rZSA9IDI7XHJcbiAgdmFyIHByb2dyZXNzX2RpbSA9IHByb2dyZXNzX3JhZGl1cyAqIDI7XHJcblxyXG4gIHZhciBwcm9ncmVzc19zdmcgPSBtZW51YmFyLmFwcGVuZChcInN2Z1wiKVxyXG4gIC5hdHRyKCdkaXNhYmxlZCcsdHJ1ZSlcclxuICAuYXR0cignaWQnLCdwcm9ncmVzc19pbmRpY2F0b3InKVxyXG4gIC5hdHRyKCdoZWlnaHQnLCBwcm9ncmVzc19kaW0pXHJcbiAgLmF0dHIoJ3dpZHRoJywgcHJvZ3Jlc3NfZGltKTtcclxuICBcclxuICBnbG9iYWxzLm91dGVyX3Byb2dyZXNzX2NpcmNsZSA9IGQzLmFyYygpXHJcbiAgLnN0YXJ0QW5nbGUoMClcclxuICAuY29ybmVyUmFkaXVzKDcuNSlcclxuICAuaW5uZXJSYWRpdXMocHJvZ3Jlc3NfcmFkaXVzKVxyXG4gIC5vdXRlclJhZGl1cyhwcm9ncmVzc19yYWRpdXMgLSA3LjUpO1xyXG5cclxuICB2YXIgb3V0ZXJfdHJhY2tfY2lyY2xlID0gZDMuYXJjKClcclxuICAuc3RhcnRBbmdsZSgwKVxyXG4gIC5lbmRBbmdsZShNYXRoLlBJICogMilcclxuICAuaW5uZXJSYWRpdXMocHJvZ3Jlc3NfcmFkaXVzKVxyXG4gIC5vdXRlclJhZGl1cyhwcm9ncmVzc19yYWRpdXMgLSA3LjUpO1xyXG5cclxuICBnbG9iYWxzLmlubmVyX3Byb2dyZXNzX2NpcmNsZSA9IGQzLmFyYygpXHJcbiAgLnN0YXJ0QW5nbGUoMClcclxuICAuY29ybmVyUmFkaXVzKDcuNSlcclxuICAuaW5uZXJSYWRpdXMocHJvZ3Jlc3NfcmFkaXVzIC0gNy41KVxyXG4gIC5vdXRlclJhZGl1cyhwcm9ncmVzc19yYWRpdXMgLSAxNSk7XHJcblxyXG4gIHZhciBpbm5lcl90cmFja19jaXJjbGUgPSBkMy5hcmMoKVxyXG4gIC5zdGFydEFuZ2xlKDApXHJcbiAgLmVuZEFuZ2xlKE1hdGguUEkgKiAyKVxyXG4gIC5pbm5lclJhZGl1cyhwcm9ncmVzc19yYWRpdXMgLSA3LjUpXHJcbiAgLm91dGVyUmFkaXVzKHByb2dyZXNzX3JhZGl1cyAtIDE1KTtcclxuXHJcbiAgdmFyIG91dGVyX3Byb2dyZXNzX3RyYWNrID0gcHJvZ3Jlc3Nfc3ZnLmFwcGVuZCgnZycpXHJcbiAgLmF0dHIoJ2lkJywnb3V0ZXJfcHJvZ3Jlc3NfaW5kaWNhdG9yJylcclxuICAuYXR0cignZGlzcGxheScsIGdsb2JhbHMuZmFjZXRzID09ICdvbicgPyAnbm9uZScgOiBudWxsKVxyXG4gIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBwcm9ncmVzc19kaW0gLyAyICsgJywnICsgcHJvZ3Jlc3NfZGltIC8gMiArICcpJyk7XHJcbiAgXHJcbiAgb3V0ZXJfcHJvZ3Jlc3NfdHJhY2suYXBwZW5kKCdwYXRoJylcclxuICAuYXR0cignZmlsbCcsIHByb2dyZXNzX2NvbG9ycy50cmFjaylcclxuICAuYXR0cignc3Ryb2tlJywgcHJvZ3Jlc3NfY29sb3JzLnN0cm9rZSlcclxuICAuYXR0cignc3Ryb2tlLXdpZHRoJywgcHJvZ3Jlc3Nfc3Ryb2tlICsgJ3B4JylcclxuICAuYXR0cignZCcsIG91dGVyX3RyYWNrX2NpcmNsZSk7XHJcblxyXG4gIG91dGVyX3Byb2dyZXNzX3RyYWNrLmFwcGVuZCgncGF0aCcpXHJcbiAgLmF0dHIoJ2lkJywgJ291dGVyX3Byb2dyZXNzX3ZhbHVlJylcclxuICAuYXR0cignZmlsbCcsIHByb2dyZXNzX2NvbG9ycy5vdXRlcl9maWxsKVxyXG4gIC5hdHRyKCdzdHJva2UnLCBwcm9ncmVzc19jb2xvcnMuc3Ryb2tlKVxyXG4gIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBwcm9ncmVzc19zdHJva2UgKyAncHgnKVxyXG4gIC5hdHRyKCdkJywgZ2xvYmFscy5pbm5lcl9wcm9ncmVzc19jaXJjbGUuZW5kQW5nbGUoMCkpO1xyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVfb3V0ZXJfcHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcclxuICAgIGQzLnNlbGVjdCgnI291dGVyX3Byb2dyZXNzX3ZhbHVlJykuYXR0cignZCcsIGdsb2JhbHMub3V0ZXJfcHJvZ3Jlc3NfY2lyY2xlLmVuZEFuZ2xlKChNYXRoLlBJICogMikgKiBwcm9ncmVzcykpO1xyXG4gIH0gXHJcblxyXG4gIHVwZGF0ZV9vdXRlcl9wcm9ncmVzcygxIC8gKChjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWF4ICsgMSkgLSBjaGFydF9pbnN0YW5jZS5wYXJhbXMoKS55ZWFyTWluKSk7XHJcblxyXG4gIHZhciBpbm5lcl9wcm9ncmVzc190cmFjayA9IHByb2dyZXNzX3N2Zy5hcHBlbmQoJ2cnKVxyXG4gIC5hdHRyKCdpZCcsJ2lubmVyX3Byb2dyZXNzX2luZGljYXRvcicpXHJcbiAgLmF0dHIoJ2Rpc3BsYXknLCBudWxsKVxyXG4gIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBwcm9ncmVzc19kaW0gLyAyICsgJywnICsgcHJvZ3Jlc3NfZGltIC8gMiArICcpJyk7XHJcbiAgXHJcbiAgaW5uZXJfcHJvZ3Jlc3NfdHJhY2suYXBwZW5kKCdwYXRoJylcclxuICAuYXR0cignZmlsbCcsIHByb2dyZXNzX2NvbG9ycy50cmFjaylcclxuICAuYXR0cignc3Ryb2tlJywgcHJvZ3Jlc3NfY29sb3JzLnN0cm9rZSlcclxuICAuYXR0cignc3Ryb2tlLXdpZHRoJywgcHJvZ3Jlc3Nfc3Ryb2tlICsgJ3B4JylcclxuICAuYXR0cignZCcsIGlubmVyX3RyYWNrX2NpcmNsZSk7XHJcblxyXG4gIGlubmVyX3Byb2dyZXNzX3RyYWNrLmFwcGVuZCgncGF0aCcpXHJcbiAgLmF0dHIoJ2lkJywgJ2lubmVyX3Byb2dyZXNzX3ZhbHVlJylcclxuICAuYXR0cignZmlsbCcsIHByb2dyZXNzX2NvbG9ycy5pbm5lcl9maWxsKVxyXG4gIC5hdHRyKCdzdHJva2UnLCBwcm9ncmVzc19jb2xvcnMuc3Ryb2tlKVxyXG4gIC5hdHRyKCdzdHJva2Utd2lkdGgnLCBwcm9ncmVzc19zdHJva2UgKyAncHgnKVxyXG4gIC5hdHRyKCdkJywgZ2xvYmFscy5pbm5lcl9wcm9ncmVzc19jaXJjbGUuZW5kQW5nbGUoMCkpO1xyXG4gIFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHRyaWFsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy90cmlhbC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGQzID0gcmVxdWlyZShcImQzXCIpO1xyXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XHJcblxyXG5mdW5jdGlvbiBtZW51ICgpIHtcclxuICAgIFxyXG4gIC8qKiBJTklUICoqL1xyXG4gIFxyXG4gIGQzLnNlbGVjdCgnYm9keScpLmFwcGVuZCgnZGl2JylcclxuICAuYXR0cignaWQnLCdtZW51X2RpdicpXHJcbiAgLmF0dHIoJ3RhYmluZGV4JywwKTsgIFxyXG5cclxuICB2YXIgaW5zdHJ1Y3Rpb25fZGl2ID0gZDMuc2VsZWN0KCcjbWVudV9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgLmF0dHIoJ2NsYXNzJywndG9vbGJhcicpXHJcbiAgLmF0dHIoJ2lkJywnaW5zdHJ1Y3Rpb25fZGl2JylcclxuICAuc3R5bGUoJ2hlaWdodCcsJzUwcHgnKTsgIFxyXG5cclxuICBpbnN0cnVjdGlvbl9kaXYuYXBwZW5kKCdzcGFuJylcclxuICAuYXR0cignaWQnLCdpbnN0cnVjdGlvbl90ZXh0JylcclxuICAuaHRtbCgnPHNwYW4gY2xhc3M9XCJpbnN0cnVjdGlvbl9lbXBoYXNpc1wiPkJVQkJMRSA8c3BhbiBjbGFzcz1cImluc3RydWN0aW9uX2VtcGhhc2lzXCIgaWQ9XCJzZWNyZXRfc2FuZGJveFwiPkNIQVJUUzwvc3Bhbj4gT04gTU9CSUxFIFBIT05FUzwvc3Bhbj48YnI+VGFwIG9uIHRoZSBidXR0b25zIGJlbG93IHRvIHByb2NlZWQgd2l0aCB0aGUgZXhwZXJpbWVudC4nKTsgIFxyXG4gIFxyXG4gIHZhciBuYXZiYXIgPSBkMy5zZWxlY3QoJyNtZW51X2RpdicpLmFwcGVuZCgnZGl2JylcclxuICAuYXR0cignY2xhc3MnLCd0b29sYmFyJylcclxuICAuYXR0cignaWQnLCduYXZiYXInKTtcclxuXHJcbiAgbmF2YmFyLmFwcGVuZChcImlucHV0XCIpXHJcbiAgLmF0dHIoJ2NsYXNzJywgdGVzdF9vdmVycmlkZSB8fCAhY29uc2VudF9jb21wbGV0ZSA/ICdtZW51X2J0bl9lbmFibGVkJyA6ICdtZW51X2J0bl9kaXNhYmxlZCcpXHJcbiAgLmF0dHIoJ2Rpc2FibGVkJywgdGVzdF9vdmVycmlkZSB8fCAhY29uc2VudF9jb21wbGV0ZSA/IG51bGwgOiB0cnVlKVxyXG4gIC5hdHRyKCdpZCcsJ2NvbnNlbnRfYnRuJykgICAgXHJcbiAgLmF0dHIoJ3R5cGUnLCdidXR0b24nKVxyXG4gIC5hdHRyKCd2YWx1ZScsJzEuIENvbnNlbnQgdG8gUGFydGljaXBhdGUnKVxyXG4gIC5hdHRyKCd0aXRsZScsICcxLiBDb25zZW50IHRvIFBhcnRpY2lwYXRlJyk7XHJcblxyXG4gIG5hdmJhci5hcHBlbmQoXCJpbnB1dFwiKVxyXG4gIC5hdHRyKCdjbGFzcycsIHRlc3Rfb3ZlcnJpZGUgfHwgKCFpbnRyb2R1Y3Rpb25fY29tcGxldGUgJiYgY29uc2VudF9jb21wbGV0ZSkgPyAnbWVudV9idG5fZW5hYmxlZCcgOiAnbWVudV9idG5fZGlzYWJsZWQnKVxyXG4gIC5hdHRyKCdkaXNhYmxlZCcsIHRlc3Rfb3ZlcnJpZGUgfHwgKCFpbnRyb2R1Y3Rpb25fY29tcGxldGUgJiYgY29uc2VudF9jb21wbGV0ZSkgPyBudWxsIDogdHJ1ZSlcclxuICAuYXR0cignaWQnLCdpbnRyb2R1Y3Rpb25fYnRuJykgICAgXHJcbiAgLmF0dHIoJ3R5cGUnLCdidXR0b24nKVxyXG4gIC5hdHRyKCd2YWx1ZScsJzIuIEludHJvZHVjdGlvbiB0byB0aGUgRXhwZXJpbWVudCcpXHJcbiAgLmF0dHIoJ3RpdGxlJywgJzIuIEludHJvZHVjdGlvbiB0byB0aGUgRXhwZXJpbWVudCcpOyAgXHJcblxyXG4gIG5hdmJhci5hcHBlbmQoXCJpbnB1dFwiKVxyXG4gIC5hdHRyKCdpZCcsJ3RyaWFsX2J0bicpXHJcbiAgLmF0dHIoJ2NsYXNzJywgKHRlc3Rfb3ZlcnJpZGUgfHwgKGludHJvZHVjdGlvbl9jb21wbGV0ZSAmJiAhZXhwZXJpbWVudF9jb21wbGV0ZSkpID8gJ21lbnVfYnRuX2VuYWJsZWQnIDogJ21lbnVfYnRuX2Rpc2FibGVkJylcclxuICAuYXR0cignZGlzYWJsZWQnLCAodGVzdF9vdmVycmlkZSB8fCAoaW50cm9kdWN0aW9uX2NvbXBsZXRlICYmICFleHBlcmltZW50X2NvbXBsZXRlKSkgPyBudWxsIDogdHJ1ZSlcclxuICAuYXR0cigndHlwZScsJ2J1dHRvbicpXHJcbiAgLmF0dHIoJ3ZhbHVlJywnMy4gRXhwZXJpbWVudCcpXHJcbiAgLmF0dHIoJ3RpdGxlJywgJzMuIEV4cGVyaW1lbnQnKTtcclxuXHJcbiAgbmF2YmFyLmFwcGVuZChcImlucHV0XCIpXHJcbiAgLmF0dHIoJ2NsYXNzJywgKHRlc3Rfb3ZlcnJpZGUgfHwgZXhwZXJpbWVudF9jb21wbGV0ZSkgPyAnbWVudV9idG5fZW5hYmxlZCcgOiAnbWVudV9idG5fZGlzYWJsZWQnKVxyXG4gIC5hdHRyKCdkaXNhYmxlZCcsICh0ZXN0X292ZXJyaWRlIHx8IGV4cGVyaW1lbnRfY29tcGxldGUpID8gbnVsbCA6IHRydWUpXHJcbiAgLmF0dHIoJ2lkJywncXVlc3Rpb25uYWlyZV9idG4nKSAgICBcclxuICAuYXR0cigndHlwZScsJ2J1dHRvbicpXHJcbiAgLmF0dHIoJ3ZhbHVlJywnNC4gU3VydmV5ICYgQ29uY2x1c2lvbicpXHJcbiAgLmF0dHIoJ3RpdGxlJywgJzQuIFN1cnZleSAmIENvbmNsdXNpb24nKTtcclxuXHJcbiAgZDMuc2VsZWN0KCcjbWVudV9kaXYnKS5hcHBlbmQoJ2RpdicpXHJcbiAgLmF0dHIoJ2NsYXNzJywndG9vbGJhcicpXHJcbiAgLmF0dHIoJ2lkJywnbWVudV9mb290ZXInKVxyXG4gIC5odG1sKCc8c3Bhbj4gPGEgaHJlZj1cIm1haWx0bzptYWJyZWhtZUBtaWNyb3NvZnQuY29tXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Q29udGFjdDwvYT4gfCA8YSBocmVmPVwiaHR0cHM6Ly9nby5taWNyb3NvZnQuY29tL2Z3bGluay8/TGlua0lkPTUyMTgzOVwiIHRhcmdldD1cIl9ibGFua1wiPlByaXZhY3kgJiBDb29raWVzPC9hPiB8IDxhIGhyZWY9XCJodHRwczovL3d3dy5taWNyb3NvZnQuY29tL2VuLXVzL2xlZ2FsL2ludGVsbGVjdHVhbHByb3BlcnR5L2NvcHlyaWdodC9kZWZhdWx0LmFzcHhcIiB0YXJnZXQ9XCJfYmxhbmtcIj5UZXJtcyBvZiBVc2U8L2E+IHwgwqkgMjAxOCBNaWNyb3NvZnQ8L3NwYW4+Jyk7ICBcclxuXHJcbiAgLy8gdmFyIHBhcmFtX2xpc3QgPSBbXHJcbiAgLy8gICBcIkxpZmUgRXhwZWN0YW5jeVwiLFxyXG4gIC8vICAgXCJJbmNvbWUgUGVyIENhcGl0YSAoJClcIixcclxuICAvLyAgIFwiR0RQIFBlciBDYXBpdGEgKCQpXCIsXHJcbiAgLy8gICBcIkZlcnRpbGl0eSBSYXRlXCIsXHJcbiAgLy8gICBcIkNPMiBFbWlzc2lvbnNcIixcclxuICAvLyAgIFwiUG9wdWxhdGlvblwiLFxyXG4gIC8vICAgXCJFbGVjdHJpY2l0eSBDb25zdW1wdGlvbiAoa1doKVwiLFxyXG4gIC8vICAgXCJJbmZhbnQgTW9ydGFsaXR5IChwZXIgMWsgYmlydGhzKVwiLFxyXG4gIC8vICAgXCJNdXJkZXIgUmF0ZSAocGVyIDEwMGspXCIsXHJcbiAgLy8gICBcIlRyYWZmaWMgTW9ydGFsaXRpZXMgKHBlciAxMDBrKVwiXHJcbiAgLy8gXTtcclxuXHJcbiAgLy8gdmFyIHBhcmFtX2xpc3QgPSBbXHJcbiAgLy8gICBcIlBvcHVsYXRpb25cIixcclxuICAvLyAgIFwiQXJhYmxlIEFyZWFcIixcclxuICAvLyAgIFwiRW5lcmd5IENvbnN1bXB0aW9uXCIsXHJcbiAgLy8gICBcIkdEUCBQZXIgQ2FwaXRhXCIsXHJcbiAgLy8gICBcIkxpZmUgRXhwZWN0YW5jeSAoV29tZW4pXCIsXHJcbiAgLy8gICBcIkxpZmUgRXhwZWN0YW5jeSAoTWVuKVwiLFxyXG4gIC8vICAgXCJMaWZlIEV4cGVjdGFuY3lcIixcclxuICAvLyAgIFwiSW5mYW50IE1vcnRhbGl0eVwiLFxyXG4gIC8vICAgXCJOdW1iZXIgb2YgUGVyc29uYWwgQ29tcHV0ZXJzXCJcclxuICAvLyBdO1xyXG5cclxuICAvLyBuYXZiYXIuYXBwZW5kKFwic2VsZWN0XCIpXHJcbiAgLy8gLmF0dHIoJ2lkJywneF9waWNrZXInKVxyXG4gIC8vIC5hdHRyKCdjbGFzcycsJ21lbnVfc2VsZWN0X2VuYWJsZWQnKVxyXG4gIC8vIC5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XHJcbiAgLy8gICBpZiAoZ2xvYmFscy5wYXJhbV95ID09IGQzLnNlbGVjdCh0aGlzKS5wcm9wZXJ0eSgndmFsdWUnKSl7XHJcbiAgLy8gICAgIGQzLnNlbGVjdCh0aGlzKS5wcm9wZXJ0eSgndmFsdWUnLCBnbG9iYWxzLnBhcmFtX3gpO1xyXG4gIC8vICAgICBhbGVydCgneCAhPSB5Jyk7XHJcbiAgLy8gICB9XHJcbiAgLy8gICBlbHNle1xyXG4gIC8vICAgICBnbG9iYWxzLnBhcmFtX3ggPSBkMy5zZWxlY3QodGhpcykucHJvcGVydHkoJ3ZhbHVlJyk7XHJcbiAgLy8gICB9XHJcbiAgLy8gICBjb25zb2xlLmxvZyhnbG9iYWxzLnBhcmFtX3gpO1xyXG4gIC8vIH0pXHJcbiAgLy8gLnNlbGVjdEFsbCgnb3B0aW9uJylcclxuICAvLyAuZGF0YShwYXJhbV9saXN0KVxyXG4gIC8vIC5lbnRlcigpXHJcbiAgLy8gLmFwcGVuZCgnb3B0aW9uJylcclxuICAvLyAuYXR0cihcInZhbHVlXCIsIGZ1bmN0aW9uIChkKSB7IHJldHVybiBkOyB9KVxyXG4gIC8vIC50ZXh0KGZ1bmN0aW9uIChkKSB7IHJldHVybiAneDogJyArIGQ7IH0pXHJcbiAgLy8gLnByb3BlcnR5KFwic2VsZWN0ZWRcIiwgZnVuY3Rpb24gKGQpIHtcclxuICAvLyAgIHJldHVybiBkID09PSBnbG9iYWxzLnBhcmFtX3g7XHJcbiAgLy8gfSk7XHJcblxyXG4gIC8vIG5hdmJhci5hcHBlbmQoXCJzZWxlY3RcIilcclxuICAvLyAuYXR0cignaWQnLCd5X3BpY2tlcicpXHJcbiAgLy8gLmF0dHIoJ2NsYXNzJywnbWVudV9zZWxlY3RfZW5hYmxlZCcpICBcclxuICAvLyAub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xyXG4gIC8vICAgaWYgKGdsb2JhbHMucGFyYW1feCA9PSBkMy5zZWxlY3QodGhpcykucHJvcGVydHkoJ3ZhbHVlJykpe1xyXG4gIC8vICAgICBkMy5zZWxlY3QodGhpcykucHJvcGVydHkoJ3ZhbHVlJywgZ2xvYmFscy5wYXJhbV95KTtcclxuICAvLyAgICAgYWxlcnQoJ3kgIT0geCcpO1xyXG4gIC8vICAgfVxyXG4gIC8vICAgZWxzZSB7XHJcbiAgLy8gICAgIGdsb2JhbHMucGFyYW1feSA9IGQzLnNlbGVjdCh0aGlzKS5wcm9wZXJ0eSgndmFsdWUnKTtcclxuICAvLyAgIH1cclxuICAvLyAgIGNvbnNvbGUubG9nKGdsb2JhbHMucGFyYW1feSk7XHJcbiAgLy8gfSlcclxuICAvLyAuc2VsZWN0QWxsKCdvcHRpb24nKVxyXG4gIC8vIC5kYXRhKHBhcmFtX2xpc3QpXHJcbiAgLy8gLmVudGVyKClcclxuICAvLyAuYXBwZW5kKCdvcHRpb24nKVxyXG4gIC8vIC5hdHRyKFwidmFsdWVcIiwgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQ7IH0pXHJcbiAgLy8gLnRleHQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuICd5OiAnICsgZDsgfSlcclxuICAvLyAucHJvcGVydHkoXCJzZWxlY3RlZFwiLCBmdW5jdGlvbiAoZCkge1xyXG4gIC8vICAgcmV0dXJuIGQgPT09IGdsb2JhbHMucGFyYW1feTtcclxuICAvLyB9KTtcclxuIFxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IG1lbnU7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL21lbnUuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIiFmdW5jdGlvbih0LG4pe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP24oZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLG4pOm4odC5mbHViYmVyPXQuZmx1YmJlcnx8e30pfSh0aGlzLGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4odCl7cmV0dXJuIDEwPT09dHx8MTM9PT10fHw4MjMyPT09dHx8ODIzMz09PXR8fDMyPT09dHx8OT09PXR8fDExPT09dHx8MTI9PT10fHwxNjA9PT10fHx0Pj01NzYwJiZhbi5pbmRleE9mKHQpPj0wfWZ1bmN0aW9uIGUodCl7c3dpdGNoKDMyfHQpe2Nhc2UgMTA5OmNhc2UgMTIyOmNhc2UgMTA4OmNhc2UgMTA0OmNhc2UgMTE4OmNhc2UgOTk6Y2FzZSAxMTU6Y2FzZSAxMTM6Y2FzZSAxMTY6Y2FzZSA5NzpjYXNlIDExNDpyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiByKHQpe3JldHVybiB0Pj00OCYmdDw9NTd9ZnVuY3Rpb24gaSh0KXtyZXR1cm4gdD49NDgmJnQ8PTU3fHw0Mz09PXR8fDQ1PT09dHx8NDY9PT10fWZ1bmN0aW9uIGEodCl7dGhpcy5pbmRleD0wLHRoaXMucGF0aD10LHRoaXMubWF4PXQubGVuZ3RoLHRoaXMucmVzdWx0PVtdLHRoaXMucGFyYW09MCx0aGlzLmVycj1cIlwiLHRoaXMuc2VnbWVudFN0YXJ0PTAsdGhpcy5kYXRhPVtdfWZ1bmN0aW9uIG8odCl7Zm9yKDt0LmluZGV4PHQubWF4JiZuKHQucGF0aC5jaGFyQ29kZUF0KHQuaW5kZXgpKTspdC5pbmRleCsrfWZ1bmN0aW9uIHModCl7dmFyIG4sZT10LmluZGV4LGk9ZSxhPXQubWF4LG89ITEscz0hMSxoPSExLHU9ITE7aWYoaT49YSlyZXR1cm4gdm9pZCh0LmVycj1cIlN2Z1BhdGg6IG1pc3NlZCBwYXJhbSAoYXQgcG9zIFwiK2krXCIpXCIpO2lmKG49dC5wYXRoLmNoYXJDb2RlQXQoaSksNDMhPT1uJiY0NSE9PW58fChpKyssbj1pPGE/dC5wYXRoLmNoYXJDb2RlQXQoaSk6MCksIXIobikmJjQ2IT09bilyZXR1cm4gdm9pZCh0LmVycj1cIlN2Z1BhdGg6IHBhcmFtIHNob3VsZCBzdGFydCB3aXRoIDAuLjkgb3IgYC5gIChhdCBwb3MgXCIraStcIilcIik7aWYoNDYhPT1uKXtpZihvPTQ4PT09bixpKyssbj1pPGE/dC5wYXRoLmNoYXJDb2RlQXQoaSk6MCxvJiZpPGEmJm4mJnIobikpcmV0dXJuIHZvaWQodC5lcnI9XCJTdmdQYXRoOiBudW1iZXJzIHN0YXJ0ZWQgd2l0aCBgMGAgc3VjaCBhcyBgMDlgIGFyZSBpbGVnYWwgKGF0IHBvcyBcIitlK1wiKVwiKTtmb3IoO2k8YSYmcih0LnBhdGguY2hhckNvZGVBdChpKSk7KWkrKyxzPSEwO249aTxhP3QucGF0aC5jaGFyQ29kZUF0KGkpOjB9aWYoNDY9PT1uKXtmb3IodT0hMCxpKys7cih0LnBhdGguY2hhckNvZGVBdChpKSk7KWkrKyxoPSEwO249aTxhP3QucGF0aC5jaGFyQ29kZUF0KGkpOjB9aWYoMTAxPT09bnx8Njk9PT1uKXtpZih1JiYhcyYmIWgpcmV0dXJuIHZvaWQodC5lcnI9XCJTdmdQYXRoOiBpbnZhbGlkIGZsb2F0IGV4cG9uZW50IChhdCBwb3MgXCIraStcIilcIik7aWYoaSsrLG49aTxhP3QucGF0aC5jaGFyQ29kZUF0KGkpOjAsNDMhPT1uJiY0NSE9PW58fGkrKywhKGk8YSYmcih0LnBhdGguY2hhckNvZGVBdChpKSkpKXJldHVybiB2b2lkKHQuZXJyPVwiU3ZnUGF0aDogaW52YWxpZCBmbG9hdCBleHBvbmVudCAoYXQgcG9zIFwiK2krXCIpXCIpO2Zvcig7aTxhJiZyKHQucGF0aC5jaGFyQ29kZUF0KGkpKTspaSsrfXQuaW5kZXg9aSx0LnBhcmFtPXBhcnNlRmxvYXQodC5wYXRoLnNsaWNlKGUsaSkpKzB9ZnVuY3Rpb24gaCh0KXt2YXIgbixlO249dC5wYXRoW3Quc2VnbWVudFN0YXJ0XSxlPW4udG9Mb3dlckNhc2UoKTt2YXIgcj10LmRhdGE7aWYoXCJtXCI9PT1lJiZyLmxlbmd0aD4yJiYodC5yZXN1bHQucHVzaChbbixyWzBdLHJbMV1dKSxyPXIuc2xpY2UoMiksZT1cImxcIixuPVwibVwiPT09bj9cImxcIjpcIkxcIiksXCJyXCI9PT1lKXQucmVzdWx0LnB1c2goW25dLmNvbmNhdChyKSk7ZWxzZSBmb3IoO3IubGVuZ3RoPj1ybltlXSYmKHQucmVzdWx0LnB1c2goW25dLmNvbmNhdChyLnNwbGljZSgwLHJuW2VdKSkpLHJuW2VdKTspO31mdW5jdGlvbiB1KHQpe3ZhciBuLHIsYSx1LGM9dC5tYXg7aWYodC5zZWdtZW50U3RhcnQ9dC5pbmRleCxuPXQucGF0aC5jaGFyQ29kZUF0KHQuaW5kZXgpLCFlKG4pKXJldHVybiB2b2lkKHQuZXJyPVwiU3ZnUGF0aDogYmFkIGNvbW1hbmQgXCIrdC5wYXRoW3QuaW5kZXhdK1wiIChhdCBwb3MgXCIrdC5pbmRleCtcIilcIik7aWYoYT1yblt0LnBhdGhbdC5pbmRleF0udG9Mb3dlckNhc2UoKV0sdC5pbmRleCsrLG8odCksdC5kYXRhPVtdLCFhKXJldHVybiB2b2lkIGgodCk7Zm9yKHI9ITE7Oyl7Zm9yKHU9YTt1PjA7dS0tKXtpZihzKHQpLHQuZXJyLmxlbmd0aClyZXR1cm47dC5kYXRhLnB1c2godC5wYXJhbSksbyh0KSxyPSExLHQuaW5kZXg8YyYmNDQ9PT10LnBhdGguY2hhckNvZGVBdCh0LmluZGV4KSYmKHQuaW5kZXgrKyxvKHQpLHI9ITApfWlmKCFyKXtpZih0LmluZGV4Pj10Lm1heClicmVhaztpZighaSh0LnBhdGguY2hhckNvZGVBdCh0LmluZGV4KSkpYnJlYWt9fWgodCl9ZnVuY3Rpb24gYyh0LG4pe3JldHVyblt0WzBdKm5bMF0rdFsyXSpuWzFdLHRbMV0qblswXSt0WzNdKm5bMV0sdFswXSpuWzJdK3RbMl0qblszXSx0WzFdKm5bMl0rdFszXSpuWzNdLHRbMF0qbls0XSt0WzJdKm5bNV0rdFs0XSx0WzFdKm5bNF0rdFszXSpuWzVdK3RbNV1dfWZ1bmN0aW9uIGYoKXtpZighKHRoaXMgaW5zdGFuY2VvZiBmKSlyZXR1cm4gbmV3IGY7dGhpcy5xdWV1ZT1bXSx0aGlzLmNhY2hlPW51bGx9ZnVuY3Rpb24gbCh0LG4sZSxyKXt2YXIgaT10KnItbiplPDA/LTE6MSxhPU1hdGguc3FydCh0KnQrbipuKSxvPU1hdGguc3FydCh0KnQrbipuKSxzPXQqZStuKnIsaD1zLyhhKm8pO3JldHVybiBoPjEmJihoPTEpLGg8LTEmJihoPS0xKSxpKk1hdGguYWNvcyhoKX1mdW5jdGlvbiBwKHQsbixlLHIsaSxhLG8scyxoLHUpe3ZhciBjPXUqKHQtZSkvMitoKihuLXIpLzIsZj0taCoodC1lKS8yK3UqKG4tcikvMixwPW8qbyxnPXMqcyx2PWMqYyx4PWYqZix5PXAqZy1wKngtZyp2O3k8MCYmKHk9MCkseS89cCp4K2cqdix5PU1hdGguc3FydCh5KSooaT09PWE/LTE6MSk7dmFyIGQ9eSpvL3MqZixtPXkqLXMvbypjLE09dSpkLWgqbSsodCtlKS8yLHc9aCpkK3UqbSsobityKS8yLGI9KGMtZCkvbyxMPShmLW0pL3MsQT0oLWMtZCkvbyxxPSgtZi1tKS9zLGs9bCgxLDAsYixMKSxQPWwoYixMLEEscSk7cmV0dXJuIDA9PT1hJiZQPjAmJihQLT1sbiksMT09PWEmJlA8MCYmKFArPWxuKSxbTSx3LGssUF19ZnVuY3Rpb24gZyh0LG4pe3ZhciBlPTQvMypNYXRoLnRhbihuLzQpLHI9TWF0aC5jb3ModCksaT1NYXRoLnNpbih0KSxhPU1hdGguY29zKHQrbiksbz1NYXRoLnNpbih0K24pO3JldHVybltyLGksci1pKmUsaStyKmUsYStvKmUsby1hKmUsYSxvXX1mdW5jdGlvbiB2KHQsbixlKXtpZighKHRoaXMgaW5zdGFuY2VvZiB2KSlyZXR1cm4gbmV3IHYodCxuLGUpO3RoaXMucng9dCx0aGlzLnJ5PW4sdGhpcy5heD1lfWZ1bmN0aW9uIHgodCl7aWYoISh0aGlzIGluc3RhbmNlb2YgeCkpcmV0dXJuIG5ldyB4KHQpO3ZhciBuPW9uKHQpO3RoaXMuc2VnbWVudHM9bi5zZWdtZW50cyx0aGlzLmVycj1uLmVycix0aGlzLl9fc3RhY2s9W119ZnVuY3Rpb24geSh0KXt2YXIgbj10Lm1hdGNoKHduKTtyZXR1cm4gbj9uLm1hcChOdW1iZXIpOltdfWZ1bmN0aW9uIGQodCxuLGUscixpLGEsbyxzKXt0aGlzLmE9e3g6dCx5Om59LHRoaXMuYj17eDplLHk6cn0sdGhpcy5jPXt4OmkseTphfSx0aGlzLmQ9e3g6byx5OnN9LG51bGwhPT1vJiZ2b2lkIDAhPT1vJiZudWxsIT09cyYmdm9pZCAwIT09cz8odGhpcy5nZXRBcmNMZW5ndGg9Xyx0aGlzLmdldFBvaW50PUwsdGhpcy5nZXREZXJpdmF0aXZlPU0pOih0aGlzLmdldEFyY0xlbmd0aD1BLHRoaXMuZ2V0UG9pbnQ9Yix0aGlzLmdldERlcml2YXRpdmU9bSksdGhpcy5pbml0KCl9ZnVuY3Rpb24gbSh0LG4sZSl7cmV0dXJue3g6MiooMS1lKSoodFsxXS10WzBdKSsyKmUqKHRbMl0tdFsxXSkseToyKigxLWUpKihuWzFdLW5bMF0pKzIqZSooblsyXS1uWzFdKX19ZnVuY3Rpb24gTSh0LG4sZSl7cmV0dXJuIGIoWzMqKHRbMV0tdFswXSksMyoodFsyXS10WzFdKSwzKih0WzNdLXRbMl0pXSxbMyooblsxXS1uWzBdKSwzKihuWzJdLW5bMV0pLDMqKG5bM10tblsyXSldLGUpfWZ1bmN0aW9uIHcodCxuLGUscixpKXtmb3IodmFyIGE9MSxvPXQvbixzPSh0LWUocixpLG8pKS9uO2E+LjAwMTspe3ZhciBoPWUocixpLG8rcyksdT1lKHIsaSxvLXMpLGM9TWF0aC5hYnModC1oKS9uLGY9TWF0aC5hYnModC11KS9uO2M8YT8oYT1jLG8rPXMpOmY8YT8oYT1mLG8tPXMpOnMvPTJ9cmV0dXJuIG99ZnVuY3Rpb24gYih0LG4sZSl7cmV0dXJue3g6KDEtZSkqKDEtZSkqdFswXSsyKigxLWUpKmUqdFsxXStlKmUqdFsyXSx5OigxLWUpKigxLWUpKm5bMF0rMiooMS1lKSplKm5bMV0rZSplKm5bMl19fWZ1bmN0aW9uIEwodCxuLGUpe3JldHVybnt4OigxLWUpKigxLWUpKigxLWUpKnRbMF0rMyooMS1lKSooMS1lKSplKnRbMV0rMyooMS1lKSplKmUqdFsyXStlKmUqZSp0WzNdLHk6KDEtZSkqKDEtZSkqKDEtZSkqblswXSszKigxLWUpKigxLWUpKmUqblsxXSszKigxLWUpKmUqZSpuWzJdK2UqZSplKm5bM119fWZ1bmN0aW9uIEEodCxuLGUpe3ZvaWQgMD09PWUmJihlPTEpO3ZhciByPXRbMF0tMip0WzFdK3RbMl0saT1uWzBdLTIqblsxXStuWzJdLGE9Mip0WzFdLTIqdFswXSxvPTIqblsxXS0yKm5bMF0scz00KihyKnIraSppKSxoPTQqKHIqYStpKm8pLHU9YSphK28qbztpZigwPT09cylyZXR1cm4gZSpNYXRoLnNxcnQoTWF0aC5wb3codFsyXS10WzBdLDIpK01hdGgucG93KG5bMl0tblswXSwyKSk7dmFyIGM9aC8oMipzKSxmPXUvcyxsPWUrYyxwPWYtYypjO3JldHVybiBNYXRoLnNxcnQocykvMioobCpNYXRoLnNxcnQobCpsK3ApLWMqTWF0aC5zcXJ0KGMqYytwKStwKk1hdGgubG9nKE1hdGguYWJzKChsK01hdGguc3FydChsKmwrcCkpLyhjK01hdGguc3FydChjKmMrcCkpKSkpfWZ1bmN0aW9uIHEodCxuKXtyZXR1cm4gcW5bdF1bbl19ZnVuY3Rpb24gayh0LG4sZSl7dmFyIHIsaSxhLG89ZS5sZW5ndGgtMTtpZigwPT09bylyZXR1cm4gMDtpZigwPT09dCl7Zm9yKGk9MCxhPTA7YTw9bzthKyspaSs9cShvLGEpKk1hdGgucG93KDEtbixvLWEpKk1hdGgucG93KG4sYSkqZVthXTtyZXR1cm4gaX1mb3Iocj1uZXcgQXJyYXkobyksYT0wO2E8bzthKyspclthXT1vKihlW2ErMV0tZVthXSk7cmV0dXJuIGsodC0xLG4scil9ZnVuY3Rpb24gUCh0LG4sZSl7dmFyIHI9aygxLGUsdCksaT1rKDEsZSxuKSxhPXIqcitpKmk7cmV0dXJuIE1hdGguc3FydChhKX1mdW5jdGlvbiBfKHQsbixlKXt2YXIgcixpLGEsbzt2b2lkIDA9PT1lJiYoZT0xKTtmb3Iocj1lLzIsaT0wLGE9MDthPDIwO2ErKylvPXIqTG5bMjBdW2FdK3IsaSs9QW5bMjBdW2FdKlAodCxuLG8pO3JldHVybiByKml9ZnVuY3Rpb24gRSh0LG4sZSxyKXt2YXIgaT10KnItbiplPDA/LTE6MSxhPXQqZStuKnI7cmV0dXJuIGE+MSYmKGE9MSksYTwtMSYmKGE9LTEpLGkqTWF0aC5hY29zKGEpfWZ1bmN0aW9uIFModCxuLGUscixpLGEsbyxzLGgsdSl7dmFyIGM9dSoodC1lKS8yK2gqKG4tcikvMixmPS1oKih0LWUpLzIrdSoobi1yKS8yLGw9bypvLHA9cypzLGc9YypjLHY9ZipmLHg9bCpwLWwqdi1wKmc7eDwwJiYoeD0wKSx4Lz1sKnYrcCpnLHg9TWF0aC5zcXJ0KHgpKihpPT09YT8tMToxKTt2YXIgeT14Km8vcypmLGQ9eCotcy9vKmMsbT11KnktaCpkKyh0K2UpLzIsTT1oKnkrdSpkKyhuK3IpLzIsdz0oYy15KS9vLGI9KGYtZCkvcyxMPSgtYy15KS9vLEE9KC1mLWQpL3MscT1FKDEsMCx3LGIpLGs9RSh3LGIsTCxBKTtyZXR1cm4gMD09PWEmJms+MCYmKGstPWtuKSwxPT09YSYmazwwJiYoays9a24pLFttLE0scSxrXX1mdW5jdGlvbiBDKHQsbil7dmFyIGU9NC8zKk1hdGgudGFuKG4vNCkscj1NYXRoLmNvcyh0KSxpPU1hdGguc2luKHQpLGE9TWF0aC5jb3ModCtuKSxvPU1hdGguc2luKHQrbik7cmV0dXJuW3IsaSxyLWkqZSxpK3IqZSxhK28qZSxvLWEqZSxhLG9dfWZ1bmN0aW9uIFoodCxuLGUscixpLGEsbyxzLGgpe3ZhciB1PTAsYz1bXSxmPVtdO1BuKHQsbixlLHIsaSxhLG8scyxoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBuPW5ldyBibih0WzBdLHRbMV0sdFsyXSx0WzNdLHRbNF0sdFs1XSx0WzZdLHRbN10pLGU9bi5nZXRUb3RhbExlbmd0aCgpO3UrPWUsYy5wdXNoKGUpLGYucHVzaChuKX0pLHRoaXMubGVuZ3RoPXUsdGhpcy5wYXJ0aWFsTGVuZ3Rocz1jLHRoaXMuY3VydmVzPWZ9ZnVuY3Rpb24gVCh0LG4sZSxyKXt0aGlzLngwPXQsdGhpcy54MT1uLHRoaXMueTA9ZSx0aGlzLnkxPXJ9ZnVuY3Rpb24gRih0LG4pe3JldHVybiBNYXRoLnNxcnQoKHRbMF0tblswXSkqKHRbMF0tblswXSkrKHRbMV0tblsxXSkqKHRbMV0tblsxXSkpfWZ1bmN0aW9uIHoodCxuLGUpe3JldHVyblt0WzBdKyhuWzBdLXRbMF0pKmUsdFsxXSsoblsxXS10WzFdKSplXX1mdW5jdGlvbiBqKHQsbil7cmV0dXJuIEYodCxuKTwxZS05fWZ1bmN0aW9uIEkodCxuLGUpe3ZhciByPXQubWFwKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIFYodCxuW2VdKX0pO3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj1yLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gbih0KX0pO3JldHVybiBlP0gobik6bn19ZnVuY3Rpb24gVih0LG4pe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCxyKXtyZXR1cm4gdCtlKihuW3JdLXQpfSl9fWZ1bmN0aW9uIFgodCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJmlzRmluaXRlKHQpfWZ1bmN0aW9uIFkodCl7cmV0dXJuIEcodCk/bm4odCk6Wyh0WzBdWzBdK3RbdC5sZW5ndGgtMV1bMF0pLzIsKHRbMF1bMV0rdFt0Lmxlbmd0aC0xXVsxXSkvMl19ZnVuY3Rpb24gRyh0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoLTI7bisrKXt2YXIgZT10W25dLHI9dFtuKzFdLGk9dFtuKzJdO2lmKGVbMF0qKHJbMV0taVsxXSkrclswXSooaVsxXS1lWzFdKStpWzBdKihlWzFdLXJbMV0pKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIE8odCl7cmV0dXJuIG5ldyB5bih0KS5hYnMoKX1mdW5jdGlvbiBEKHQpe3JldHVybiB0LnRvU3RyaW5nKCkuc3BsaXQoXCJNXCIpLm1hcChmdW5jdGlvbih0LG4pe3JldHVybiB0PXQudHJpbSgpLG4mJnQ/XCJNXCIrdDp0fSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0fSl9ZnVuY3Rpb24gSCh0KXtyZXR1cm5cIk1cIit0LmpvaW4oXCJMXCIpK1wiWlwifWZ1bmN0aW9uIE4odCl7cmV0dXJuIEQoTyh0KSl9ZnVuY3Rpb24gUSh0LG4pe3ZhciBlPU8odCk7cmV0dXJuIFUoZSl8fFIoZSxuKX1mdW5jdGlvbiBVKHQpe3ZhciBuPXQuc2VnbWVudHN8fFtdLGU9W107aWYoIW4ubGVuZ3RofHxcIk1cIiE9PW5bMF1bMF0pcmV0dXJuITE7Zm9yKHZhciByPTA7cjxuLmxlbmd0aDtyKyspe3ZhciBpPW5bcl0sYT1pWzBdLG89aVsxXSxzPWlbMl07aWYoXCJNXCI9PT1hJiZyfHxcIlpcIj09PWEpYnJlYWs7aWYoXCJNXCI9PT1hfHxcIkxcIj09PWEpZS5wdXNoKFtvLHNdKTtlbHNlIGlmKFwiSFwiPT09YSllLnB1c2goW28sZVtlLmxlbmd0aC0xXVsxXV0pO2Vsc2V7aWYoXCJWXCIhPT1hKXJldHVybiExO2UucHVzaChbZVtlLmxlbmd0aC0xXVswXSxvXSl9fXJldHVybiEhZS5sZW5ndGgmJntyaW5nOmV9fWZ1bmN0aW9uIFIodCxuKXt2YXIgZSxyLGk9RCh0KVswXSxhPVtdLG89MztpZighaSl0aHJvdyBuZXcgVHlwZUVycm9yKENuKTtyPUIoaSksZT1yLmdldFRvdGFsTGVuZ3RoKCksbiYmWChuKSYmbj4wJiYobz1NYXRoLm1heChvLE1hdGguY2VpbChlL24pKSk7Zm9yKHZhciBzPTA7czxvO3MrKyl7dmFyIGg9ci5nZXRQb2ludEF0TGVuZ3RoKGUqcy9vKTthLnB1c2goW2gueCxoLnldKX1yZXR1cm57cmluZzphLHNraXBCaXNlY3Q6ITB9fWZ1bmN0aW9uIEIodCl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93JiZ3aW5kb3cuZG9jdW1lbnQpdHJ5e3ZhciBuPXdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwicGF0aFwiKTtyZXR1cm4gbi5zZXRBdHRyaWJ1dGVOUyhudWxsLFwiZFwiLHQpLG59Y2F0Y2godCl7fXJldHVybiBTbih0KX1mdW5jdGlvbiBXKHQsbil7Zm9yKHZhciBlPXQubGVuZ3RoK24scj1lbih0KS9uLGk9MCxhPTAsbz1yLzI7dC5sZW5ndGg8ZTspe3ZhciBzPXRbaV0saD10WyhpKzEpJXQubGVuZ3RoXSx1PUYocyxoKTtvPD1hK3U/KHQuc3BsaWNlKGkrMSwwLHU/eihzLGgsKG8tYSkvdSk6cy5zbGljZSgwKSksbys9cik6KGErPXUsaSsrKX19ZnVuY3Rpb24gJCh0LG4pe3ZvaWQgMD09PW4mJihuPTEvMCk7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspZm9yKHZhciByPXRbZV0saT1lPT09dC5sZW5ndGgtMT90WzBdOnRbZSsxXTtGKHIsaSk+bjspaT16KHIsaSwuNSksdC5zcGxpY2UoZSsxLDAsaSl9ZnVuY3Rpb24gSih0LG4pe3ZhciBlLHIsaTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7dmFyIGE9USh0LG4pO3Q9YS5yaW5nLGk9YS5za2lwQmlzZWN0fWVsc2UgaWYoIUFycmF5LmlzQXJyYXkodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihDbik7aWYoZT10LnNsaWNlKDApLCFLKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoQ24pO3JldHVybiBlLmxlbmd0aD4xJiZqKGVbMF0sZVtlLmxlbmd0aC0xXSkmJmUucG9wKCkscj10bihlKSxyPjAmJmUucmV2ZXJzZSgpLCFpJiZuJiZYKG4pJiZuPjAmJiQoZSxuKSxlfWZ1bmN0aW9uIEsodCl7cmV0dXJuIHQuZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmlzQXJyYXkodCkmJnQubGVuZ3RoPj0yJiZYKHRbMF0pJiZYKHRbMV0pfSl9ZnVuY3Rpb24gdHQodCxuLGUpe3ZhciByO3JldHVybiByPXQubGVuZ3RoLW4ubGVuZ3RoLFcodCxyPDA/LTEqcjowKSxXKG4scj4wP3I6MCksVG4odCxuKSxJKHQsbixlKX1mdW5jdGlvbiBudCh0LG4sZSl7ZT1lfHwyO3ZhciByPW4mJm4ubGVuZ3RoLGk9cj9uWzBdKmU6dC5sZW5ndGgsYT1ldCh0LDAsaSxlLCEwKSxvPVtdO2lmKCFhKXJldHVybiBvO3ZhciBzLGgsdSxjLGYsbCxwO2lmKHImJihhPXV0KHQsbixhLGUpKSx0Lmxlbmd0aD44MCplKXtzPXU9dFswXSxoPWM9dFsxXTtmb3IodmFyIGc9ZTtnPGk7Zys9ZSlmPXRbZ10sbD10W2crMV0sZjxzJiYocz1mKSxsPGgmJihoPWwpLGY+dSYmKHU9ZiksbD5jJiYoYz1sKTtwPU1hdGgubWF4KHUtcyxjLWgpfXJldHVybiBpdChhLG8sZSxzLGgscCksb31mdW5jdGlvbiBldCh0LG4sZSxyLGkpe3ZhciBhLG87aWYoaT09PUV0KHQsbixlLHIpPjApZm9yKGE9bjthPGU7YSs9cilvPWt0KGEsdFthXSx0W2ErMV0sbyk7ZWxzZSBmb3IoYT1lLXI7YT49bjthLT1yKW89a3QoYSx0W2FdLHRbYSsxXSxvKTtyZXR1cm4gbyYmTXQobyxvLm5leHQpJiYoUHQobyksbz1vLm5leHQpLG99ZnVuY3Rpb24gcnQodCxuKXtpZighdClyZXR1cm4gdDtufHwobj10KTt2YXIgZSxyPXQ7ZG97aWYoZT0hMSxyLnN0ZWluZXJ8fCFNdChyLHIubmV4dCkmJjAhPT1tdChyLnByZXYscixyLm5leHQpKXI9ci5uZXh0O2Vsc2V7aWYoUHQociksKHI9bj1yLnByZXYpPT09ci5uZXh0KXJldHVybiBudWxsO2U9ITB9fXdoaWxlKGV8fHIhPT1uKTtyZXR1cm4gbn1mdW5jdGlvbiBpdCh0LG4sZSxyLGksYSxvKXtpZih0KXshbyYmYSYmcHQodCxyLGksYSk7Zm9yKHZhciBzLGgsdT10O3QucHJldiE9PXQubmV4dDspaWYocz10LnByZXYsaD10Lm5leHQsYT9vdCh0LHIsaSxhKTphdCh0KSluLnB1c2gocy5pL2UpLG4ucHVzaCh0LmkvZSksbi5wdXNoKGguaS9lKSxQdCh0KSx0PWgubmV4dCx1PWgubmV4dDtlbHNlIGlmKCh0PWgpPT09dSl7bz8xPT09bz8odD1zdCh0LG4sZSksaXQodCxuLGUscixpLGEsMikpOjI9PT1vJiZodCh0LG4sZSxyLGksYSk6aXQocnQodCksbixlLHIsaSxhLDEpO2JyZWFrfX19ZnVuY3Rpb24gYXQodCl7dmFyIG49dC5wcmV2LGU9dCxyPXQubmV4dDtpZihtdChuLGUscik+PTApcmV0dXJuITE7Zm9yKHZhciBpPXQubmV4dC5uZXh0O2khPT10LnByZXY7KXtpZih5dChuLngsbi55LGUueCxlLnksci54LHIueSxpLngsaS55KSYmbXQoaS5wcmV2LGksaS5uZXh0KT49MClyZXR1cm4hMTtpPWkubmV4dH1yZXR1cm4hMH1mdW5jdGlvbiBvdCh0LG4sZSxyKXt2YXIgaT10LnByZXYsYT10LG89dC5uZXh0O2lmKG10KGksYSxvKT49MClyZXR1cm4hMTtmb3IodmFyIHM9aS54PGEueD9pLng8by54P2kueDpvLng6YS54PG8ueD9hLng6by54LGg9aS55PGEueT9pLnk8by55P2kueTpvLnk6YS55PG8ueT9hLnk6by55LHU9aS54PmEueD9pLng+by54P2kueDpvLng6YS54Pm8ueD9hLng6by54LGM9aS55PmEueT9pLnk+by55P2kueTpvLnk6YS55Pm8ueT9hLnk6by55LGY9dnQocyxoLG4sZSxyKSxsPXZ0KHUsYyxuLGUscikscD10Lm5leHRaO3AmJnAuejw9bDspe2lmKHAhPT10LnByZXYmJnAhPT10Lm5leHQmJnl0KGkueCxpLnksYS54LGEueSxvLngsby55LHAueCxwLnkpJiZtdChwLnByZXYscCxwLm5leHQpPj0wKXJldHVybiExO3A9cC5uZXh0Wn1mb3IocD10LnByZXZaO3AmJnAuej49Zjspe2lmKHAhPT10LnByZXYmJnAhPT10Lm5leHQmJnl0KGkueCxpLnksYS54LGEueSxvLngsby55LHAueCxwLnkpJiZtdChwLnByZXYscCxwLm5leHQpPj0wKXJldHVybiExO3A9cC5wcmV2Wn1yZXR1cm4hMH1mdW5jdGlvbiBzdCh0LG4sZSl7dmFyIHI9dDtkb3t2YXIgaT1yLnByZXYsYT1yLm5leHQubmV4dDshTXQoaSxhKSYmd3QoaSxyLHIubmV4dCxhKSYmTHQoaSxhKSYmTHQoYSxpKSYmKG4ucHVzaChpLmkvZSksbi5wdXNoKHIuaS9lKSxuLnB1c2goYS5pL2UpLFB0KHIpLFB0KHIubmV4dCkscj10PWEpLHI9ci5uZXh0fXdoaWxlKHIhPT10KTtyZXR1cm4gcn1mdW5jdGlvbiBodCh0LG4sZSxyLGksYSl7dmFyIG89dDtkb3tmb3IodmFyIHM9by5uZXh0Lm5leHQ7cyE9PW8ucHJldjspe2lmKG8uaSE9PXMuaSYmZHQobyxzKSl7dmFyIGg9cXQobyxzKTtyZXR1cm4gbz1ydChvLG8ubmV4dCksaD1ydChoLGgubmV4dCksaXQobyxuLGUscixpLGEpLHZvaWQgaXQoaCxuLGUscixpLGEpfXM9cy5uZXh0fW89by5uZXh0fXdoaWxlKG8hPT10KX1mdW5jdGlvbiB1dCh0LG4sZSxyKXt2YXIgaSxhLG8scyxoLHU9W107Zm9yKGk9MCxhPW4ubGVuZ3RoO2k8YTtpKyspbz1uW2ldKnIscz1pPGEtMT9uW2krMV0qcjp0Lmxlbmd0aCxoPWV0KHQsbyxzLHIsITEpLGg9PT1oLm5leHQmJihoLnN0ZWluZXI9ITApLHUucHVzaCh4dChoKSk7Zm9yKHUuc29ydChjdCksaT0wO2k8dS5sZW5ndGg7aSsrKWZ0KHVbaV0sZSksZT1ydChlLGUubmV4dCk7cmV0dXJuIGV9ZnVuY3Rpb24gY3QodCxuKXtyZXR1cm4gdC54LW4ueH1mdW5jdGlvbiBmdCh0LG4pe2lmKG49bHQodCxuKSl7dmFyIGU9cXQobix0KTtydChlLGUubmV4dCl9fWZ1bmN0aW9uIGx0KHQsbil7dmFyIGUscj1uLGk9dC54LGE9dC55LG89LTEvMDtkb3tpZihhPD1yLnkmJmE+PXIubmV4dC55KXt2YXIgcz1yLngrKGEtci55KSooci5uZXh0Lngtci54KS8oci5uZXh0Lnktci55KTtpZihzPD1pJiZzPm8pe2lmKG89cyxzPT09aSl7aWYoYT09PXIueSlyZXR1cm4gcjtpZihhPT09ci5uZXh0LnkpcmV0dXJuIHIubmV4dH1lPXIueDxyLm5leHQueD9yOnIubmV4dH19cj1yLm5leHR9d2hpbGUociE9PW4pO2lmKCFlKXJldHVybiBudWxsO2lmKGk9PT1vKXJldHVybiBlLnByZXY7dmFyIGgsdT1lLGM9ZS54LGY9ZS55LGw9MS8wO2ZvcihyPWUubmV4dDtyIT09dTspaT49ci54JiZyLng+PWMmJnl0KGE8Zj9pOm8sYSxjLGYsYTxmP286aSxhLHIueCxyLnkpJiYoKGg9TWF0aC5hYnMoYS1yLnkpLyhpLXIueCkpPGx8fGg9PT1sJiZyLng+ZS54KSYmTHQocix0KSYmKGU9cixsPWgpLHI9ci5uZXh0O3JldHVybiBlfWZ1bmN0aW9uIHB0KHQsbixlLHIpe3ZhciBpPXQ7ZG97bnVsbD09PWkueiYmKGkuej12dChpLngsaS55LG4sZSxyKSksaS5wcmV2Wj1pLnByZXYsaS5uZXh0Wj1pLm5leHQsaT1pLm5leHR9d2hpbGUoaSE9PXQpO2kucHJldloubmV4dFo9bnVsbCxpLnByZXZaPW51bGwsZ3QoaSl9ZnVuY3Rpb24gZ3QodCl7dmFyIG4sZSxyLGksYSxvLHMsaCx1PTE7ZG97Zm9yKGU9dCx0PW51bGwsYT1udWxsLG89MDtlOyl7Zm9yKG8rKyxyPWUscz0wLG49MDtuPHUmJihzKysscj1yLm5leHRaKTtuKyspO2ZvcihoPXU7cz4wfHxoPjAmJnI7KTA9PT1zPyhpPXIscj1yLm5leHRaLGgtLSk6MCE9PWgmJnI/ZS56PD1yLno/KGk9ZSxlPWUubmV4dFoscy0tKTooaT1yLHI9ci5uZXh0WixoLS0pOihpPWUsZT1lLm5leHRaLHMtLSksYT9hLm5leHRaPWk6dD1pLGkucHJldlo9YSxhPWk7ZT1yfWEubmV4dFo9bnVsbCx1Kj0yfXdoaWxlKG8+MSk7cmV0dXJuIHR9ZnVuY3Rpb24gdnQodCxuLGUscixpKXtyZXR1cm4gdD0zMjc2NyoodC1lKS9pLG49MzI3NjcqKG4tcikvaSx0PTE2NzExOTM1Jih0fHQ8PDgpLHQ9MjUyNjQ1MTM1Jih0fHQ8PDQpLHQ9ODU4OTkzNDU5Jih0fHQ8PDIpLHQ9MTQzMTY1NTc2NSYodHx0PDwxKSxuPTE2NzExOTM1JihufG48PDgpLG49MjUyNjQ1MTM1JihufG48PDQpLG49ODU4OTkzNDU5JihufG48PDIpLG49MTQzMTY1NTc2NSYobnxuPDwxKSx0fG48PDF9ZnVuY3Rpb24geHQodCl7dmFyIG49dCxlPXQ7ZG97bi54PGUueCYmKGU9biksbj1uLm5leHR9d2hpbGUobiE9PXQpO3JldHVybiBlfWZ1bmN0aW9uIHl0KHQsbixlLHIsaSxhLG8scyl7cmV0dXJuKGktbykqKG4tcyktKHQtbykqKGEtcyk+PTAmJih0LW8pKihyLXMpLShlLW8pKihuLXMpPj0wJiYoZS1vKSooYS1zKS0oaS1vKSooci1zKT49MH1mdW5jdGlvbiBkdCh0LG4pe3JldHVybiB0Lm5leHQuaSE9PW4uaSYmdC5wcmV2LmkhPT1uLmkmJiFidCh0LG4pJiZMdCh0LG4pJiZMdChuLHQpJiZBdCh0LG4pfWZ1bmN0aW9uIG10KHQsbixlKXtyZXR1cm4obi55LXQueSkqKGUueC1uLngpLShuLngtdC54KSooZS55LW4ueSl9ZnVuY3Rpb24gTXQodCxuKXtyZXR1cm4gdC54PT09bi54JiZ0Lnk9PT1uLnl9ZnVuY3Rpb24gd3QodCxuLGUscil7cmV0dXJuISEoTXQodCxuKSYmTXQoZSxyKXx8TXQodCxyKSYmTXQoZSxuKSl8fG10KHQsbixlKT4wIT1tdCh0LG4scik+MCYmbXQoZSxyLHQpPjAhPW10KGUscixuKT4wfWZ1bmN0aW9uIGJ0KHQsbil7dmFyIGU9dDtkb3tpZihlLmkhPT10LmkmJmUubmV4dC5pIT09dC5pJiZlLmkhPT1uLmkmJmUubmV4dC5pIT09bi5pJiZ3dChlLGUubmV4dCx0LG4pKXJldHVybiEwO2U9ZS5uZXh0fXdoaWxlKGUhPT10KTtyZXR1cm4hMX1mdW5jdGlvbiBMdCh0LG4pe3JldHVybiBtdCh0LnByZXYsdCx0Lm5leHQpPDA/bXQodCxuLHQubmV4dCk+PTAmJm10KHQsdC5wcmV2LG4pPj0wOm10KHQsbix0LnByZXYpPDB8fG10KHQsdC5uZXh0LG4pPDB9ZnVuY3Rpb24gQXQodCxuKXt2YXIgZT10LHI9ITEsaT0odC54K24ueCkvMixhPSh0Lnkrbi55KS8yO2Rve2UueT5hIT1lLm5leHQueT5hJiZpPChlLm5leHQueC1lLngpKihhLWUueSkvKGUubmV4dC55LWUueSkrZS54JiYocj0hciksZT1lLm5leHR9d2hpbGUoZSE9PXQpO3JldHVybiByfWZ1bmN0aW9uIHF0KHQsbil7dmFyIGU9bmV3IF90KHQuaSx0LngsdC55KSxyPW5ldyBfdChuLmksbi54LG4ueSksaT10Lm5leHQsYT1uLnByZXY7cmV0dXJuIHQubmV4dD1uLG4ucHJldj10LGUubmV4dD1pLGkucHJldj1lLHIubmV4dD1lLGUucHJldj1yLGEubmV4dD1yLHIucHJldj1hLHJ9ZnVuY3Rpb24ga3QodCxuLGUscil7dmFyIGk9bmV3IF90KHQsbixlKTtyZXR1cm4gcj8oaS5uZXh0PXIubmV4dCxpLnByZXY9cixyLm5leHQucHJldj1pLHIubmV4dD1pKTooaS5wcmV2PWksaS5uZXh0PWkpLGl9ZnVuY3Rpb24gUHQodCl7dC5uZXh0LnByZXY9dC5wcmV2LHQucHJldi5uZXh0PXQubmV4dCx0LnByZXZaJiYodC5wcmV2Wi5uZXh0Wj10Lm5leHRaKSx0Lm5leHRaJiYodC5uZXh0Wi5wcmV2Wj10LnByZXZaKX1mdW5jdGlvbiBfdCh0LG4sZSl7dGhpcy5pPXQsdGhpcy54PW4sdGhpcy55PWUsdGhpcy5wcmV2PW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy56PW51bGwsdGhpcy5wcmV2Wj1udWxsLHRoaXMubmV4dFo9bnVsbCx0aGlzLnN0ZWluZXI9ITF9ZnVuY3Rpb24gRXQodCxuLGUscil7Zm9yKHZhciBpPTAsYT1uLG89ZS1yO2E8ZTthKz1yKWkrPSh0W29dLXRbYV0pKih0W2ErMV0rdFtvKzFdKSxvPWE7cmV0dXJuIGl9ZnVuY3Rpb24gU3QodCxuKXt2YXIgZT1uLmlkLHI9bi5iYm94LGk9bnVsbD09bi5wcm9wZXJ0aWVzP3t9Om4ucHJvcGVydGllcyxhPUN0KHQsbik7cmV0dXJuIG51bGw9PWUmJm51bGw9PXI/e3R5cGU6XCJGZWF0dXJlXCIscHJvcGVydGllczppLGdlb21ldHJ5OmF9Om51bGw9PXI/e3R5cGU6XCJGZWF0dXJlXCIsaWQ6ZSxwcm9wZXJ0aWVzOmksZ2VvbWV0cnk6YX06e3R5cGU6XCJGZWF0dXJlXCIsaWQ6ZSxiYm94OnIscHJvcGVydGllczppLGdlb21ldHJ5OmF9fWZ1bmN0aW9uIEN0KHQsbil7ZnVuY3Rpb24gZSh0LG4pe24ubGVuZ3RoJiZuLnBvcCgpO2Zvcih2YXIgZT11W3Q8MD9+dDp0XSxyPTAsaT1lLmxlbmd0aDtyPGk7KytyKW4ucHVzaChoKGVbcl0scikpO3Q8MCYmVm4obixpKX1mdW5jdGlvbiByKHQpe3JldHVybiBoKHQpfWZ1bmN0aW9uIGkodCl7Zm9yKHZhciBuPVtdLHI9MCxpPXQubGVuZ3RoO3I8aTsrK3IpZSh0W3JdLG4pO3JldHVybiBuLmxlbmd0aDwyJiZuLnB1c2goblswXSksbn1mdW5jdGlvbiBhKHQpe2Zvcih2YXIgbj1pKHQpO24ubGVuZ3RoPDQ7KW4ucHVzaChuWzBdKTtyZXR1cm4gbn1mdW5jdGlvbiBvKHQpe3JldHVybiB0Lm1hcChhKX1mdW5jdGlvbiBzKHQpe3ZhciBuLGU9dC50eXBlO3N3aXRjaChlKXtjYXNlXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjpyZXR1cm57dHlwZTplLGdlb21ldHJpZXM6dC5nZW9tZXRyaWVzLm1hcChzKX07Y2FzZVwiUG9pbnRcIjpuPXIodC5jb29yZGluYXRlcyk7YnJlYWs7Y2FzZVwiTXVsdGlQb2ludFwiOm49dC5jb29yZGluYXRlcy5tYXAocik7YnJlYWs7Y2FzZVwiTGluZVN0cmluZ1wiOm49aSh0LmFyY3MpO2JyZWFrO2Nhc2VcIk11bHRpTGluZVN0cmluZ1wiOm49dC5hcmNzLm1hcChpKTticmVhaztjYXNlXCJQb2x5Z29uXCI6bj1vKHQuYXJjcyk7YnJlYWs7Y2FzZVwiTXVsdGlQb2x5Z29uXCI6bj10LmFyY3MubWFwKG8pO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIG51bGx9cmV0dXJue3R5cGU6ZSxjb29yZGluYXRlczpufX12YXIgaD1Jbih0LnRyYW5zZm9ybSksdT10LmFyY3M7cmV0dXJuIHMobil9ZnVuY3Rpb24gWnQodCl7Zm9yKHZhciBuLGU9LTEscj10Lmxlbmd0aCxpPXRbci0xXSxhPTA7KytlPHI7KW49aSxpPXRbZV0sYSs9blswXSppWzFdLW5bMV0qaVswXTtyZXR1cm4gTWF0aC5hYnMoYSl9ZnVuY3Rpb24gVHQodCxuKXtmdW5jdGlvbiBlKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIkdlb21ldHJ5Q29sbGVjdGlvblwiOnQuZ2VvbWV0cmllcy5mb3JFYWNoKGUpO2JyZWFrO2Nhc2VcIlBvbHlnb25cIjpyKHQuYXJjcyk7YnJlYWs7Y2FzZVwiTXVsdGlQb2x5Z29uXCI6dC5hcmNzLmZvckVhY2gocil9fWZ1bmN0aW9uIHIodCl7dC5mb3JFYWNoKGZ1bmN0aW9uKG4pe24uZm9yRWFjaChmdW5jdGlvbihuKXsoYVtuPW48MD9+bjpuXXx8KGFbbl09W10pKS5wdXNoKHQpfSl9KSxvLnB1c2godCl9ZnVuY3Rpb24gaShuKXtyZXR1cm4gWnQoQ3QodCx7dHlwZTpcIlBvbHlnb25cIixhcmNzOltuXX0pLmNvb3JkaW5hdGVzWzBdKX12YXIgYT17fSxvPVtdLHM9W107cmV0dXJuIG4uZm9yRWFjaChlKSxvLmZvckVhY2goZnVuY3Rpb24odCl7aWYoIXQuXyl7dmFyIG49W10sZT1bdF07Zm9yKHQuXz0xLHMucHVzaChuKTt0PWUucG9wKCk7KW4ucHVzaCh0KSx0LmZvckVhY2goZnVuY3Rpb24odCl7dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2FbdDwwP350OnRdLmZvckVhY2goZnVuY3Rpb24odCl7dC5ffHwodC5fPTEsZS5wdXNoKHQpKX0pfSl9KX19KSxvLmZvckVhY2goZnVuY3Rpb24odCl7ZGVsZXRlIHQuX30pLHt0eXBlOlwiTXVsdGlQb2x5Z29uXCIsYXJjczpzLm1hcChmdW5jdGlvbihuKXt2YXIgZSxyPVtdO2lmKG4uZm9yRWFjaChmdW5jdGlvbih0KXt0LmZvckVhY2goZnVuY3Rpb24odCl7dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2FbdDwwP350OnRdLmxlbmd0aDwyJiZyLnB1c2godCl9KX0pfSkscj1Zbih0LHIpLChlPXIubGVuZ3RoKT4xKWZvcih2YXIgbyxzLGg9MSx1PWkoclswXSk7aDxlOysraCkobz1pKHJbaF0pKT51JiYocz1yWzBdLHJbMF09cltoXSxyW2hdPXMsdT1vKTtyZXR1cm4gcn0pfX1mdW5jdGlvbiBGdCh0KXtyZXR1cm4gZnVuY3Rpb24obixlKXtyZXR1cm4gRG4odChuKSxlKX19ZnVuY3Rpb24genQodCxuKXt2YXIgZT17fSxyPXt0eXBlOlwiVG9wb2xvZ3lcIixvYmplY3RzOnt0cmlhbmdsZXM6e3R5cGU6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIixnZW9tZXRyaWVzOltdfX0sYXJjczpbXX07cmV0dXJuIHQuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgaT1bXTt0LmZvckVhY2goZnVuY3Rpb24odCxhKXt2YXIgbz10WzBdPHRbMV0/dC5qb2luKFwiLFwiKTp0WzFdK1wiLFwiK3RbMF0scz10Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gblt0XX0pO28gaW4gZT9pLnB1c2gofmVbb10pOihpLnB1c2goZVtvXT1yLmFyY3MubGVuZ3RoKSxyLmFyY3MucHVzaChzKSl9KSxyLm9iamVjdHMudHJpYW5nbGVzLmdlb21ldHJpZXMucHVzaCh7dHlwZTpcIlBvbHlnb25cIixhcmVhOk1hdGguYWJzKHRuKHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuW3RbMF1dfSkpKSxhcmNzOltpXX0pfSksci5vYmplY3RzLnRyaWFuZ2xlcy5nZW9tZXRyaWVzLnNvcnQoZnVuY3Rpb24odCxuKXtyZXR1cm4gdC5hcmVhLW4uYXJlYX0pLHJ9ZnVuY3Rpb24ganQodCxuKXtmb3IodmFyIGU9dC5vYmplY3RzLnRyaWFuZ2xlcy5nZW9tZXRyaWVzLHI9SG4oZnVuY3Rpb24odCl7cmV0dXJuIHQuYXJlYX0pLmxlZnQ7ZS5sZW5ndGg+bjspIWZ1bmN0aW9uKCl7dmFyIG49ZVswXSxpPU9uKGUpWzBdWzBdLGE9ZVtpXSxvPVR0KHQsW24sYV0pO28uYXJlYT1uLmFyZWErYS5hcmVhLG8udHlwZT1cIlBvbHlnb25cIixvLmFyY3M9by5hcmNzWzBdLGUuc3BsaWNlKGksMSksZS5zaGlmdCgpLGUuc3BsaWNlKHIoZSxvLmFyZWEpLDAsbyl9KCk7aWYobj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGNvbGxhcHNlIHRvcG9sb2d5IGludG8gXCIrbitcIiBwaWVjZXMuXCIpO3JldHVybiBYbih0LHQub2JqZWN0cy50cmlhbmdsZXMpLmZlYXR1cmVzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5wb3AoKSx0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdfSl9ZnVuY3Rpb24gSXQodCl7Zm9yKHZhciBuPXpuKHQucmVkdWNlKGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQuY29uY2F0KFtuWzBdXSxbblsxXV0pfSxbXSkpLGU9W10scj0wLGk9bi5sZW5ndGg7cjxpO3IrPTMpZS5wdXNoKFtbbltyXSxuW3IrMV1dLFtuW3IrMV0sbltyKzJdXSxbbltyKzJdLG5bcl1dXSk7cmV0dXJuIGV9ZnVuY3Rpb24gVnQodCxuLGUpe2Z1bmN0aW9uIHIodCxuLG8pe3ZvaWQgMD09PW4mJihuPVtdKSx2b2lkIDA9PT1vJiYobz0wKTtmb3IodmFyIHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIGg9dC5zcGxpY2UocywxKSx1PWVbaFswXV1bbi5sZW5ndGhdO28rdTxpJiYodC5sZW5ndGg/cih0LnNsaWNlKCksbi5jb25jYXQoaCksbyt1KTooaT1vK3UsYT1uLmNvbmNhdChoKSkpLHQubGVuZ3RoJiZ0LnNwbGljZShzLDAsaFswXSl9fXZhciBpPTEvMCxhPXQubWFwKGZ1bmN0aW9uKHQsbil7cmV0dXJuIG59KTtyZXR1cm4gcihhKSxhfWZ1bmN0aW9uIFh0KHQsbil7dmFyIGU9RihZKHQpLFkobikpO3JldHVybiBlKmV9ZnVuY3Rpb24gWXQodCxuLGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgcj1lLm1heFNlZ21lbnRMZW5ndGg7dm9pZCAwPT09ciYmKHI9MTApO3ZhciBpPWUuc3RyaW5nO3ZvaWQgMD09PWkmJihpPSEwKTt2YXIgYT1lLnNpbmdsZTt2b2lkIDA9PT1hJiYoYT0hMSk7dmFyIG89Sih0LHIpO28ubGVuZ3RoPG4ubGVuZ3RoKzImJlcobyxuLmxlbmd0aCsyLW8ubGVuZ3RoKTt2YXIgcyxoPVFuKG8sbi5sZW5ndGgpLHU9bi5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIEoodCxyKX0pLGM9XCJzdHJpbmdcIj09dHlwZW9mIHQmJnQ7cmV0dXJuIGEmJiFuLmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fSl8fChzPW4uc2xpY2UoMCkpLER0KGgsdSx7bWF0Y2g6ITAsc3RyaW5nOmksc2luZ2xlOmEsdDA6Yyx0MTpzfSl9ZnVuY3Rpb24gR3QodCxuLGUpe3ZvaWQgMD09PWUmJihlPXt9KTt2YXIgcj1lLm1heFNlZ21lbnRMZW5ndGg7dm9pZCAwPT09ciYmKHI9MTApO3ZhciBpPWUuc3RyaW5nO3ZvaWQgMD09PWkmJihpPSEwKTt2YXIgYT1lLnNpbmdsZTt2b2lkIDA9PT1hJiYoYT0hMSk7dmFyIG89WXQobix0LHttYXhTZWdtZW50TGVuZ3RoOnIsc3RyaW5nOmksc2luZ2xlOmF9KTtyZXR1cm4gYT9mdW5jdGlvbih0KXtyZXR1cm4gbygxLXQpfTpvLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIHQoMS1uKX19KX1mdW5jdGlvbiBPdCh0LG4sZSl7dm9pZCAwPT09ZSYmKGU9e30pO3ZhciByPWUubWF4U2VnbWVudExlbmd0aDt2b2lkIDA9PT1yJiYocj0xMCk7dmFyIGk9ZS5zdHJpbmc7dm9pZCAwPT09aSYmKGk9ITApO3ZhciBhPWUuc2luZ2xlO2lmKHZvaWQgMD09PWEmJihhPSExKSwhQXJyYXkuaXNBcnJheSh0KXx8IUFycmF5LmlzQXJyYXkobil8fHQubGVuZ3RoIT09bi5sZW5ndGh8fCF0Lmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFpuKTt2YXIgbyxzLGg9ZnVuY3Rpb24odCl7cmV0dXJuIEoodCxyKX0sdT10Lm1hcChoKSxjPW4ubWFwKGgpO3JldHVybiBhPyh0LmV2ZXJ5KGZ1bmN0aW9uKHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0fSkmJihvPXQuc2xpY2UoMCkpLG4uZXZlcnkoZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR9KSYmKHM9bi5zbGljZSgwKSkpOihvPXQuc2xpY2UoMCkscz1uLnNsaWNlKDApKSxEdCh1LGMse3N0cmluZzppLHNpbmdsZTphLHQwOm8sdDE6cyxtYXRjaDohMX0pfWZ1bmN0aW9uIER0KHQsbixlKXt2b2lkIDA9PT1lJiYoZT17fSk7dmFyIHI9ZS5zdHJpbmcsaT1lLnNpbmdsZSxhPWUudDAsbz1lLnQxLHM9ZS5tYXRjaCxoPXM/VW4odCxuKTp0Lm1hcChmdW5jdGlvbih0LG4pe3JldHVybiBufSksdT1oLm1hcChmdW5jdGlvbihlLGkpe3JldHVybiB0dCh0W2VdLG5baV0scil9KTtpZihzJiZBcnJheS5pc0FycmF5KGEpJiYoYT1oLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gYVt0XX0pKSxpJiZyJiYoQXJyYXkuaXNBcnJheShhKSYmKGE9YS5qb2luKFwiIFwiKSksQXJyYXkuaXNBcnJheShvKSYmKG89by5qb2luKFwiIFwiKSkpLGkpe3ZhciBjPXI/ZnVuY3Rpb24odCl7cmV0dXJuIHUubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuKHQpfSkuam9pbihcIiBcIil9OmZ1bmN0aW9uKHQpe3JldHVybiB1Lm1hcChmdW5jdGlvbihuKXtyZXR1cm4gbih0KX0pfTtyZXR1cm4gciYmKGF8fG8pP2Z1bmN0aW9uKHQpe3JldHVybiB0PDFlLTQmJmF8fDEtdDwxZS00JiZvfHxjKHQpfTpjfXJldHVybiByPyhhPUFycmF5LmlzQXJyYXkoYSk/YS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQmJnR9KTpbXSxvPUFycmF5LmlzQXJyYXkobyk/by5tYXAoZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQmJnR9KTpbXSx1Lm1hcChmdW5jdGlvbih0LG4pe3JldHVybiBhW25dfHxvW25dP2Z1bmN0aW9uKGUpe3JldHVybiBlPDFlLTQmJmFbbl18fDEtZTwxZS00JiZvW25dfHx0KGUpfTp0fSkpOnV9ZnVuY3Rpb24gSHQodCxuLGUscixpKXtyZXR1cm4gUnQoQnQodCxuLGUpLHIsSnQodCxuLGUpLDIqTWF0aC5QSSplLGkpfWZ1bmN0aW9uIE50KHQsbixlLHIsaSl7dmFyIGE9SHQobixlLHIsdCxpKTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGEoMS10KX19ZnVuY3Rpb24gUXQodCxuLGUscixpLGEpe3JldHVybiBSdChXdCh0LG4sZSxyKSxpLEt0KHQsbixlLHIpLDIqZSsyKnIsYSl9ZnVuY3Rpb24gVXQodCxuLGUscixpLGEpe3ZhciBvPVF0KG4sZSxyLGksdCxhKTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIG8oMS10KX19ZnVuY3Rpb24gUnQodCxuLGUscixpKXt2b2lkIDA9PT1pJiYoaT17fSk7dmFyIGE9aS5tYXhTZWdtZW50TGVuZ3RoO3ZvaWQgMD09PWEmJihhPTEwKTt2YXIgbz1pLnN0cmluZzt2b2lkIDA9PT1vJiYobz0hMCk7dmFyIHMsaCx1PUoobixhKTtyZXR1cm4gWChyKSYmdS5sZW5ndGg8ci9hJiZXKHUsTWF0aC5jZWlsKHIvYS11Lmxlbmd0aCkpLHM9dCh1KSxoPUkocyx1LG8pLG8/ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MWUtND9lOmgodCl9Omh9ZnVuY3Rpb24gQnQodCxuLGUpe3JldHVybiBmdW5jdGlvbihyKXt2YXIgaT1ZKHIpLGE9ZW4oci5jb25jYXQoW3JbMF1dKSksbz1NYXRoLmF0YW4yKHJbMF1bMV0taVsxXSxyWzBdWzBdLWlbMF0pLHM9MDtyZXR1cm4gci5tYXAoZnVuY3Rpb24oaSxoKXt2YXIgdTtyZXR1cm4gaCYmKHMrPUYoaSxyW2gtMV0pKSx1PW8rMipNYXRoLlBJKihhP3MvYTpoL3IubGVuZ3RoKSxbTWF0aC5jb3ModSkqZSt0LE1hdGguc2luKHUpKmUrbl19KX19ZnVuY3Rpb24gV3QodCxuLGUscil7cmV0dXJuIGZ1bmN0aW9uKGkpe3ZhciBhPVkoaSksbz1lbihpLmNvbmNhdChbaVswXV0pKSxzPU1hdGguYXRhbjIoaVswXVsxXS1hWzFdLGlbMF1bMF0tYVswXSksaD0wO3M8MCYmKHM9MipNYXRoLlBJK3MpO3ZhciB1PXMvKDIqTWF0aC5QSSk7cmV0dXJuIGkubWFwKGZ1bmN0aW9uKGEscyl7cyYmKGgrPUYoYSxpW3MtMV0pKTt2YXIgYz0kdCgodSsobz9oL286cy9pLmxlbmd0aCkpJTEpO3JldHVyblt0K2NbMF0qZSxuK2NbMV0qcl19KX19ZnVuY3Rpb24gJHQodCl7cmV0dXJuIHQ8PTEvOD9bMSwuNSs0KnRdOnQ8PTMvOD9bMS41LTQqdCwxXTp0PD01Lzg/WzAsMi41LTQqdF06dDw9Ny84P1s0KnQtMi41LDBdOlsxLDQqdC0zLjVdfWZ1bmN0aW9uIEp0KHQsbixlKXt2YXIgcj10LWUrXCIsXCIrbixpPXQrZStcIixcIituLGE9XCJBXCIrZStcIixcIitlK1wiLDAsMSwxLFwiO3JldHVyblwiTVwiK3IrYStpK2ErcitcIlpcIn1mdW5jdGlvbiBLdCh0LG4sZSxyKXt2YXIgaT10K2UsYT1uK3I7cmV0dXJuXCJNXCIrdCtcIixcIituK1wiTFwiK2krXCIsXCIrbitcIkxcIitpK1wiLFwiK2ErXCJMXCIrdCtcIixcIithK1wiWlwifXZhciB0bj1mdW5jdGlvbih0KXtmb3IodmFyIG4sZT0tMSxyPXQubGVuZ3RoLGk9dFtyLTFdLGE9MDsrK2U8cjspbj1pLGk9dFtlXSxhKz1uWzFdKmlbMF0tblswXSppWzFdO3JldHVybiBhLzJ9LG5uPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbixlLHI9LTEsaT10Lmxlbmd0aCxhPTAsbz0wLHM9dFtpLTFdLGg9MDsrK3I8aTspbj1zLHM9dFtyXSxoKz1lPW5bMF0qc1sxXS1zWzBdKm5bMV0sYSs9KG5bMF0rc1swXSkqZSxvKz0oblsxXStzWzFdKSplO3JldHVybiBoKj0zLFthL2gsby9oXX0sZW49ZnVuY3Rpb24odCl7Zm9yKHZhciBuLGUscj0tMSxpPXQubGVuZ3RoLGE9dFtpLTFdLG89YVswXSxzPWFbMV0saD0wOysrcjxpOyluPW8sZT1zLGE9dFtyXSxvPWFbMF0scz1hWzFdLG4tPW8sZS09cyxoKz1NYXRoLnNxcnQobipuK2UqZSk7cmV0dXJuIGh9LHJuPXthOjcsYzo2LGg6MSxsOjIsbToyLHI6NCxxOjQsczo0LHQ6Mix2OjEsejowfSxhbj1bNTc2MCw2MTU4LDgxOTIsODE5Myw4MTk0LDgxOTUsODE5Niw4MTk3LDgxOTgsODE5OSw4MjAwLDgyMDEsODIwMiw4MjM5LDgyODcsMTIyODgsNjUyNzldLG9uPWZ1bmN0aW9uKHQpe3ZhciBuPW5ldyBhKHQpLGU9bi5tYXg7Zm9yKG8obik7bi5pbmRleDxlJiYhbi5lcnIubGVuZ3RoOyl1KG4pO3JldHVybiBuLmVyci5sZW5ndGg/bi5yZXN1bHQ9W106bi5yZXN1bHQubGVuZ3RoJiYoXCJtTVwiLmluZGV4T2Yobi5yZXN1bHRbMF1bMF0pPDA/KG4uZXJyPVwiU3ZnUGF0aDogc3RyaW5nIHNob3VsZCBzdGFydCB3aXRoIGBNYCBvciBgbWBcIixuLnJlc3VsdD1bXSk6bi5yZXN1bHRbMF1bMF09XCJNXCIpLHtlcnI6bi5lcnIsc2VnbWVudHM6bi5yZXN1bHR9fTtmLnByb3RvdHlwZS5tYXRyaXg9ZnVuY3Rpb24odCl7cmV0dXJuIDE9PT10WzBdJiYwPT09dFsxXSYmMD09PXRbMl0mJjE9PT10WzNdJiYwPT09dFs0XSYmMD09PXRbNV0/dGhpczoodGhpcy5jYWNoZT1udWxsLHRoaXMucXVldWUucHVzaCh0KSx0aGlzKX0sZi5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIDA9PT10JiYwPT09bnx8KHRoaXMuY2FjaGU9bnVsbCx0aGlzLnF1ZXVlLnB1c2goWzEsMCwwLDEsdCxuXSkpLHRoaXN9LGYucHJvdG90eXBlLnNjYWxlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIDE9PT10JiYxPT09bnx8KHRoaXMuY2FjaGU9bnVsbCx0aGlzLnF1ZXVlLnB1c2goW3QsMCwwLG4sMCwwXSkpLHRoaXN9LGYucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbih0LG4sZSl7dmFyIHIsaSxhO3JldHVybiAwIT09dCYmKHRoaXMudHJhbnNsYXRlKG4sZSkscj10Kk1hdGguUEkvMTgwLGk9TWF0aC5jb3MociksYT1NYXRoLnNpbihyKSx0aGlzLnF1ZXVlLnB1c2goW2ksYSwtYSxpLDAsMF0pLHRoaXMuY2FjaGU9bnVsbCx0aGlzLnRyYW5zbGF0ZSgtbiwtZSkpLHRoaXN9LGYucHJvdG90eXBlLnNrZXdYPWZ1bmN0aW9uKHQpe3JldHVybiAwIT09dCYmKHRoaXMuY2FjaGU9bnVsbCx0aGlzLnF1ZXVlLnB1c2goWzEsMCxNYXRoLnRhbih0Kk1hdGguUEkvMTgwKSwxLDAsMF0pKSx0aGlzfSxmLnByb3RvdHlwZS5za2V3WT1mdW5jdGlvbih0KXtyZXR1cm4gMCE9PXQmJih0aGlzLmNhY2hlPW51bGwsdGhpcy5xdWV1ZS5wdXNoKFsxLE1hdGgudGFuKHQqTWF0aC5QSS8xODApLDAsMSwwLDBdKSksdGhpc30sZi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe3ZhciB0PXRoaXM7aWYodGhpcy5jYWNoZSlyZXR1cm4gdGhpcy5jYWNoZTtpZighdGhpcy5xdWV1ZS5sZW5ndGgpcmV0dXJuIHRoaXMuY2FjaGU9WzEsMCwwLDEsMCwwXSx0aGlzLmNhY2hlO2lmKHRoaXMuY2FjaGU9dGhpcy5xdWV1ZVswXSwxPT09dGhpcy5xdWV1ZS5sZW5ndGgpcmV0dXJuIHRoaXMuY2FjaGU7Zm9yKHZhciBuPTE7bjx0aGlzLnF1ZXVlLmxlbmd0aDtuKyspdC5jYWNoZT1jKHQuY2FjaGUsdC5xdWV1ZVtuXSk7cmV0dXJuIHRoaXMuY2FjaGV9LGYucHJvdG90eXBlLmNhbGM9ZnVuY3Rpb24odCxuLGUpe3ZhciByO3JldHVybiB0aGlzLnF1ZXVlLmxlbmd0aD8odGhpcy5jYWNoZXx8KHRoaXMuY2FjaGU9dGhpcy50b0FycmF5KCkpLHI9dGhpcy5jYWNoZSxbdCpyWzBdK24qclsyXSsoZT8wOnJbNF0pLHQqclsxXStuKnJbM10rKGU/MDpyWzVdKV0pOlt0LG5dfTt2YXIgc249Zixobj17bWF0cml4OiEwLHNjYWxlOiEwLHJvdGF0ZTohMCx0cmFuc2xhdGU6ITAsc2tld1g6ITAsc2tld1k6ITB9LHVuPS9cXHMqKG1hdHJpeHx0cmFuc2xhdGV8c2NhbGV8cm90YXRlfHNrZXdYfHNrZXdZKVxccypcXChcXHMqKC4rPylcXHMqXFwpW1xccyxdKi8sY249L1tcXHMsXSsvLGZuPWZ1bmN0aW9uKHQpe3ZhciBuLGUscj1uZXcgc247cmV0dXJuIHQuc3BsaXQodW4pLmZvckVhY2goZnVuY3Rpb24odCl7aWYodC5sZW5ndGgpe2lmKHZvaWQgMCE9PWhuW3RdKXJldHVybiB2b2lkKG49dCk7c3dpdGNoKGU9dC5zcGxpdChjbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybit0fHwwfSksbil7Y2FzZVwibWF0cml4XCI6cmV0dXJuIHZvaWQoNj09PWUubGVuZ3RoJiZyLm1hdHJpeChlKSk7Y2FzZVwic2NhbGVcIjpyZXR1cm4gdm9pZCgxPT09ZS5sZW5ndGg/ci5zY2FsZShlWzBdLGVbMF0pOjI9PT1lLmxlbmd0aCYmci5zY2FsZShlWzBdLGVbMV0pKTtjYXNlXCJyb3RhdGVcIjpyZXR1cm4gdm9pZCgxPT09ZS5sZW5ndGg/ci5yb3RhdGUoZVswXSwwLDApOjM9PT1lLmxlbmd0aCYmci5yb3RhdGUoZVswXSxlWzFdLGVbMl0pKTtjYXNlXCJ0cmFuc2xhdGVcIjpyZXR1cm4gdm9pZCgxPT09ZS5sZW5ndGg/ci50cmFuc2xhdGUoZVswXSwwKToyPT09ZS5sZW5ndGgmJnIudHJhbnNsYXRlKGVbMF0sZVsxXSkpO2Nhc2VcInNrZXdYXCI6cmV0dXJuIHZvaWQoMT09PWUubGVuZ3RoJiZyLnNrZXdYKGVbMF0pKTtjYXNlXCJza2V3WVwiOnJldHVybiB2b2lkKDE9PT1lLmxlbmd0aCYmci5za2V3WShlWzBdKSl9fX0pLHJ9LGxuPTIqTWF0aC5QSSxwbj1mdW5jdGlvbih0LG4sZSxyLGksYSxvLHMsaCl7dmFyIHU9TWF0aC5zaW4oaCpsbi8zNjApLGM9TWF0aC5jb3MoaCpsbi8zNjApLGY9YyoodC1lKS8yK3UqKG4tcikvMixsPS11Kih0LWUpLzIrYyoobi1yKS8yO2lmKDA9PT1mJiYwPT09bClyZXR1cm5bXTtpZigwPT09b3x8MD09PXMpcmV0dXJuW107bz1NYXRoLmFicyhvKSxzPU1hdGguYWJzKHMpO3ZhciB2PWYqZi8obypvKStsKmwvKHMqcyk7dj4xJiYobyo9TWF0aC5zcXJ0KHYpLHMqPU1hdGguc3FydCh2KSk7dmFyIHg9cCh0LG4sZSxyLGksYSxvLHMsdSxjKSx5PVtdLGQ9eFsyXSxtPXhbM10sTT1NYXRoLm1heChNYXRoLmNlaWwoTWF0aC5hYnMobSkvKGxuLzQpKSwxKTttLz1NO2Zvcih2YXIgdz0wO3c8TTt3KyspeS5wdXNoKGcoZCxtKSksZCs9bTtyZXR1cm4geS5tYXAoZnVuY3Rpb24odCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKz0yKXt2YXIgZT10W24rMF0scj10W24rMV07ZSo9byxyKj1zO3ZhciBpPWMqZS11KnIsYT11KmUrYypyO3RbbiswXT1pK3hbMF0sdFtuKzFdPWEreFsxXX1yZXR1cm4gdH0pfSxnbj1NYXRoLlBJLzE4MDt2LnByb3RvdHlwZS50cmFuc2Zvcm09ZnVuY3Rpb24odCl7dmFyIG49TWF0aC5jb3ModGhpcy5heCpnbiksZT1NYXRoLnNpbih0aGlzLmF4KmduKSxyPVt0aGlzLnJ4Kih0WzBdKm4rdFsyXSplKSx0aGlzLnJ4Kih0WzFdKm4rdFszXSplKSx0aGlzLnJ5KigtdFswXSplK3RbMl0qbiksdGhpcy5yeSooLXRbMV0qZSt0WzNdKm4pXSxpPXJbMF0qclswXStyWzJdKnJbMl0sYT1yWzFdKnJbMV0rclszXSpyWzNdLG89KChyWzBdLXJbM10pKihyWzBdLXJbM10pKyhyWzJdK3JbMV0pKihyWzJdK3JbMV0pKSooKHJbMF0rclszXSkqKHJbMF0rclszXSkrKHJbMl0tclsxXSkqKHJbMl0tclsxXSkpLHM9KGkrYSkvMjtpZihvPDFlLTEwKnMpcmV0dXJuIHRoaXMucng9dGhpcy5yeT1NYXRoLnNxcnQocyksdGhpcy5heD0wLHRoaXM7dmFyIGg9clswXSpyWzFdK3JbMl0qclszXTtvPU1hdGguc3FydChvKTt2YXIgdT1zK28vMixjPXMtby8yO3JldHVybiB0aGlzLmF4PU1hdGguYWJzKGgpPDFlLTEwJiZNYXRoLmFicyh1LWEpPDFlLTEwPzkwOjE4MCpNYXRoLmF0YW4oTWF0aC5hYnMoaCk+TWF0aC5hYnModS1hKT8odS1pKS9oOmgvKHUtYSkpL01hdGguUEksdGhpcy5heD49MD8odGhpcy5yeD1NYXRoLnNxcnQodSksdGhpcy5yeT1NYXRoLnNxcnQoYykpOih0aGlzLmF4Kz05MCx0aGlzLnJ4PU1hdGguc3FydChjKSx0aGlzLnJ5PU1hdGguc3FydCh1KSksdGhpc30sdi5wcm90b3R5cGUuaXNEZWdlbmVyYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucng8MWUtMTAqdGhpcy5yeXx8dGhpcy5yeTwxZS0xMCp0aGlzLnJ4fTt2YXIgdm49djt4LnByb3RvdHlwZS5fX21hdHJpeD1mdW5jdGlvbih0KXt2YXIgbixlPXRoaXM7dC5xdWV1ZS5sZW5ndGgmJnRoaXMuaXRlcmF0ZShmdW5jdGlvbihyLGksYSxvKXt2YXIgcyxoLHUsYztzd2l0Y2goclswXSl7Y2FzZVwidlwiOnM9dC5jYWxjKDAsclsxXSwhMCksaD0wPT09c1swXT9bXCJ2XCIsc1sxXV06W1wibFwiLHNbMF0sc1sxXV07YnJlYWs7Y2FzZVwiVlwiOnM9dC5jYWxjKGEsclsxXSwhMSksaD1zWzBdPT09dC5jYWxjKGEsbywhMSlbMF0/W1wiVlwiLHNbMV1dOltcIkxcIixzWzBdLHNbMV1dO2JyZWFrO2Nhc2VcImhcIjpzPXQuY2FsYyhyWzFdLDAsITApLGg9MD09PXNbMV0/W1wiaFwiLHNbMF1dOltcImxcIixzWzBdLHNbMV1dO2JyZWFrO2Nhc2VcIkhcIjpzPXQuY2FsYyhyWzFdLG8sITEpLGg9c1sxXT09PXQuY2FsYyhhLG8sITEpWzFdP1tcIkhcIixzWzBdXTpbXCJMXCIsc1swXSxzWzFdXTticmVhaztjYXNlXCJhXCI6Y2FzZVwiQVwiOnZhciBmPXQudG9BcnJheSgpLGw9dm4oclsxXSxyWzJdLHJbM10pLnRyYW5zZm9ybShmKTtpZihmWzBdKmZbM10tZlsxXSpmWzJdPDAmJihyWzVdPXJbNV0/XCIwXCI6XCIxXCIpLHM9dC5jYWxjKHJbNl0scls3XSxcImFcIj09PXJbMF0pLFwiQVwiPT09clswXSYmcls2XT09PWEmJnJbN109PT1vfHxcImFcIj09PXJbMF0mJjA9PT1yWzZdJiYwPT09cls3XSl7aD1bXCJhXCI9PT1yWzBdP1wibFwiOlwiTFwiLHNbMF0sc1sxXV07YnJlYWt9aD1sLmlzRGVnZW5lcmF0ZSgpP1tcImFcIj09PXJbMF0/XCJsXCI6XCJMXCIsc1swXSxzWzFdXTpbclswXSxsLnJ4LGwucnksbC5heCxyWzRdLHJbNV0sc1swXSxzWzFdXTticmVhaztjYXNlXCJtXCI6Yz1pPjAscz10LmNhbGMoclsxXSxyWzJdLGMpLGg9W1wibVwiLHNbMF0sc1sxXV07YnJlYWs7ZGVmYXVsdDpmb3IodT1yWzBdLGg9W3VdLGM9dS50b0xvd2VyQ2FzZSgpPT09dSxuPTE7bjxyLmxlbmd0aDtuKz0yKXM9dC5jYWxjKHJbbl0scltuKzFdLGMpLGgucHVzaChzWzBdLHNbMV0pfWUuc2VnbWVudHNbaV09aH0sITApfSx4LnByb3RvdHlwZS5fX2V2YWx1YXRlU3RhY2s9ZnVuY3Rpb24oKXt2YXIgdCxuLGU9dGhpcztpZih0aGlzLl9fc3RhY2subGVuZ3RoKXtpZigxPT09dGhpcy5fX3N0YWNrLmxlbmd0aClyZXR1cm4gdGhpcy5fX21hdHJpeCh0aGlzLl9fc3RhY2tbMF0pLHZvaWQodGhpcy5fX3N0YWNrPVtdKTtmb3IodD1zbigpLG49dGhpcy5fX3N0YWNrLmxlbmd0aDstLW4+PTA7KXQubWF0cml4KGUuX19zdGFja1tuXS50b0FycmF5KCkpO3RoaXMuX19tYXRyaXgodCksdGhpcy5fX3N0YWNrPVtdfX0seC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgdCxuLGU9dGhpcyxyPVtdO3RoaXMuX19ldmFsdWF0ZVN0YWNrKCk7Zm9yKHZhciBpPTA7aTx0aGlzLnNlZ21lbnRzLmxlbmd0aDtpKyspbj1lLnNlZ21lbnRzW2ldWzBdLHQ9aT4wJiZcIm1cIiE9PW4mJlwiTVwiIT09biYmbj09PWUuc2VnbWVudHNbaS0xXVswXSxyPXIuY29uY2F0KHQ/ZS5zZWdtZW50c1tpXS5zbGljZSgxKTplLnNlZ21lbnRzW2ldKTtyZXR1cm4gci5qb2luKFwiIFwiKS5yZXBsYWNlKC8gPyhbYWNobG1xcnN0dnpdKSA/L2dpLFwiJDFcIikucmVwbGFjZSgvIFxcLS9nLFwiLVwiKS5yZXBsYWNlKC96bS9nLFwieiBtXCIpfSx4LnByb3RvdHlwZS50cmFuc2xhdGU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdGhpcy5fX3N0YWNrLnB1c2goc24oKS50cmFuc2xhdGUodCxufHwwKSksdGhpc30seC5wcm90b3R5cGUuc2NhbGU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdGhpcy5fX3N0YWNrLnB1c2goc24oKS5zY2FsZSh0LG58fDA9PT1uP246dCkpLHRoaXN9LHgucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbih0LG4sZSl7cmV0dXJuIHRoaXMuX19zdGFjay5wdXNoKHNuKCkucm90YXRlKHQsbnx8MCxlfHwwKSksdGhpc30seC5wcm90b3R5cGUuc2tld1g9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX19zdGFjay5wdXNoKHNuKCkuc2tld1godCkpLHRoaXN9LHgucHJvdG90eXBlLnNrZXdZPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9fc3RhY2sucHVzaChzbigpLnNrZXdZKHQpKSx0aGlzfSx4LnByb3RvdHlwZS5tYXRyaXg9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX19zdGFjay5wdXNoKHNuKCkubWF0cml4KHQpKSx0aGlzfSx4LnByb3RvdHlwZS50cmFuc2Zvcm09ZnVuY3Rpb24odCl7cmV0dXJuIHQudHJpbSgpPyh0aGlzLl9fc3RhY2sucHVzaChmbih0KSksdGhpcyk6dGhpc30seC5wcm90b3R5cGUucm91bmQ9ZnVuY3Rpb24odCl7dmFyIG4sZT0wLHI9MCxpPTAsYT0wO3JldHVybiB0PXR8fDAsdGhpcy5fX2V2YWx1YXRlU3RhY2soKSx0aGlzLnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24obyl7dmFyIHM9b1swXS50b0xvd2VyQ2FzZSgpPT09b1swXTtzd2l0Y2gob1swXSl7Y2FzZVwiSFwiOmNhc2VcImhcIjpyZXR1cm4gcyYmKG9bMV0rPWkpLGk9b1sxXS1vWzFdLnRvRml4ZWQodCksdm9pZChvWzFdPStvWzFdLnRvRml4ZWQodCkpO2Nhc2VcIlZcIjpjYXNlXCJ2XCI6cmV0dXJuIHMmJihvWzFdKz1hKSxhPW9bMV0tb1sxXS50b0ZpeGVkKHQpLHZvaWQob1sxXT0rb1sxXS50b0ZpeGVkKHQpKTtjYXNlXCJaXCI6Y2FzZVwielwiOnJldHVybiBpPWUsdm9pZChhPXIpO2Nhc2VcIk1cIjpjYXNlXCJtXCI6cmV0dXJuIHMmJihvWzFdKz1pLG9bMl0rPWEpLGk9b1sxXS1vWzFdLnRvRml4ZWQodCksYT1vWzJdLW9bMl0udG9GaXhlZCh0KSxlPWkscj1hLG9bMV09K29bMV0udG9GaXhlZCh0KSx2b2lkKG9bMl09K29bMl0udG9GaXhlZCh0KSk7Y2FzZVwiQVwiOmNhc2VcImFcIjpyZXR1cm4gcyYmKG9bNl0rPWksb1s3XSs9YSksaT1vWzZdLW9bNl0udG9GaXhlZCh0KSxhPW9bN10tb1s3XS50b0ZpeGVkKHQpLG9bMV09K29bMV0udG9GaXhlZCh0KSxvWzJdPStvWzJdLnRvRml4ZWQodCksb1szXT0rb1szXS50b0ZpeGVkKHQrMiksb1s2XT0rb1s2XS50b0ZpeGVkKHQpLHZvaWQob1s3XT0rb1s3XS50b0ZpeGVkKHQpKTtkZWZhdWx0OnJldHVybiBuPW8ubGVuZ3RoLHMmJihvW24tMl0rPWksb1tuLTFdKz1hKSxpPW9bbi0yXS1vW24tMl0udG9GaXhlZCh0KSxhPW9bbi0xXS1vW24tMV0udG9GaXhlZCh0KSx2b2lkIG8uZm9yRWFjaChmdW5jdGlvbihuLGUpe2UmJihvW2VdPStvW2VdLnRvRml4ZWQodCkpfSl9fSksdGhpc30seC5wcm90b3R5cGUuaXRlcmF0ZT1mdW5jdGlvbih0LG4pe3ZhciBlLHIsaSxhPXRoaXMuc2VnbWVudHMsbz17fSxzPSExLGg9MCx1PTAsYz0wLGY9MDtpZihufHx0aGlzLl9fZXZhbHVhdGVTdGFjaygpLGEuZm9yRWFjaChmdW5jdGlvbihuLGUpe3ZhciByPXQobixlLGgsdSk7QXJyYXkuaXNBcnJheShyKSYmKG9bZV09cixzPSEwKTt2YXIgaT1uWzBdPT09blswXS50b0xvd2VyQ2FzZSgpO3N3aXRjaChuWzBdKXtjYXNlXCJtXCI6Y2FzZVwiTVwiOnJldHVybiBoPW5bMV0rKGk/aDowKSx1PW5bMl0rKGk/dTowKSxjPWgsdm9pZChmPXUpO2Nhc2VcImhcIjpjYXNlXCJIXCI6cmV0dXJuIHZvaWQoaD1uWzFdKyhpP2g6MCkpO2Nhc2VcInZcIjpjYXNlXCJWXCI6cmV0dXJuIHZvaWQodT1uWzFdKyhpP3U6MCkpO2Nhc2VcInpcIjpjYXNlXCJaXCI6cmV0dXJuIGg9Yyx2b2lkKHU9Zik7ZGVmYXVsdDpoPW5bbi5sZW5ndGgtMl0rKGk/aDowKSx1PW5bbi5sZW5ndGgtMV0rKGk/dTowKX19KSwhcylyZXR1cm4gdGhpcztmb3IoaT1bXSxlPTA7ZTxhLmxlbmd0aDtlKyspaWYodm9pZCAwIT09b1tlXSlmb3Iocj0wO3I8b1tlXS5sZW5ndGg7cisrKWkucHVzaChvW2VdW3JdKTtlbHNlIGkucHVzaChhW2VdKTtyZXR1cm4gdGhpcy5zZWdtZW50cz1pLHRoaXN9LHgucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZXJhdGUoZnVuY3Rpb24odCxuLGUscil7dmFyIGksYT10WzBdLG89YS50b1VwcGVyQ2FzZSgpO2lmKGEhPT1vKXN3aXRjaCh0WzBdPW8sYSl7Y2FzZVwidlwiOnJldHVybiB2b2lkKHRbMV0rPXIpO2Nhc2VcImFcIjpyZXR1cm4gdFs2XSs9ZSx2b2lkKHRbN10rPXIpO2RlZmF1bHQ6Zm9yKGk9MTtpPHQubGVuZ3RoO2krKyl0W2ldKz1pJTI/ZTpyfX0sITApLHRoaXN9LHgucHJvdG90eXBlLnJlbD1mdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZXJhdGUoZnVuY3Rpb24odCxuLGUscil7dmFyIGksYT10WzBdLG89YS50b0xvd2VyQ2FzZSgpO2lmKGEhPT1vJiYoMCE9PW58fFwiTVwiIT09YSkpc3dpdGNoKHRbMF09byxhKXtjYXNlXCJWXCI6cmV0dXJuIHZvaWQodFsxXS09cik7Y2FzZVwiQVwiOnJldHVybiB0WzZdLT1lLHZvaWQodFs3XS09cik7ZGVmYXVsdDpmb3IoaT0xO2k8dC5sZW5ndGg7aSsrKXRbaV0tPWklMj9lOnJ9fSwhMCksdGhpc30seC5wcm90b3R5cGUudW5hcmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVyYXRlKGZ1bmN0aW9uKHQsbixlLHIpe3ZhciBpLGEsbyxzPVtdLGg9dFswXTtyZXR1cm5cIkFcIiE9PWgmJlwiYVwiIT09aD9udWxsOihcImFcIj09PWg/KGE9ZSt0WzZdLG89cit0WzddKTooYT10WzZdLG89dFs3XSksaT1wbihlLHIsYSxvLHRbNF0sdFs1XSx0WzFdLHRbMl0sdFszXSksMD09PWkubGVuZ3RoP1tbXCJhXCI9PT10WzBdP1wibFwiOlwiTFwiLHRbNl0sdFs3XV1dOihpLmZvckVhY2goZnVuY3Rpb24odCl7cy5wdXNoKFtcIkNcIix0WzJdLHRbM10sdFs0XSx0WzVdLHRbNl0sdFs3XV0pfSkscykpfSksdGhpc30seC5wcm90b3R5cGUudW5zaG9ydD1mdW5jdGlvbigpe3ZhciB0LG4sZSxyLGksYT10aGlzLnNlZ21lbnRzO3JldHVybiB0aGlzLml0ZXJhdGUoZnVuY3Rpb24obyxzLGgsdSl7dmFyIGMsZj1vWzBdLGw9Zi50b1VwcGVyQ2FzZSgpO3MmJihcIlRcIj09PWw/KGM9XCJ0XCI9PT1mLGU9YVtzLTFdLFwiUVwiPT09ZVswXT8odD1lWzFdLWgsbj1lWzJdLXUpOlwicVwiPT09ZVswXT8odD1lWzFdLWVbM10sbj1lWzJdLWVbNF0pOih0PTAsbj0wKSxyPS10LGk9LW4sY3x8KHIrPWgsaSs9dSksYVtzXT1bYz9cInFcIjpcIlFcIixyLGksb1sxXSxvWzJdXSk6XCJTXCI9PT1sJiYoYz1cInNcIj09PWYsZT1hW3MtMV0sXCJDXCI9PT1lWzBdPyh0PWVbM10taCxuPWVbNF0tdSk6XCJjXCI9PT1lWzBdPyh0PWVbM10tZVs1XSxuPWVbNF0tZVs2XSk6KHQ9MCxuPTApLHI9LXQsaT0tbixjfHwocis9aCxpKz11KSxhW3NdPVtjP1wiY1wiOlwiQ1wiLHIsaSxvWzFdLG9bMl0sb1szXSxvWzRdXSkpfSksdGhpc307dmFyIHhuPXgseW49eG4sZG49e2E6NyxjOjYsaDoxLGw6MixtOjIscTo0LHM6NCx0OjIsdjoxLHo6MH0sbW49LyhbYXN0dnpxbWhsY10pKFteYXN0dnpxbWhsY10qKS9naSxNbj1mdW5jdGlvbih0KXt2YXIgbj1bXTtyZXR1cm4gdC5yZXBsYWNlKG1uLGZ1bmN0aW9uKHQsZSxyKXt2YXIgaT1lLnRvTG93ZXJDYXNlKCk7Zm9yKHI9eShyKSxcIm1cIj09PWkmJnIubGVuZ3RoPjImJihuLnB1c2goW2VdLmNvbmNhdChyLnNwbGljZSgwLDIpKSksaT1cImxcIixlPVwibVwiPT09ZT9cImxcIjpcIkxcIik7ci5sZW5ndGg+PTA7KXtpZihyLmxlbmd0aD09PWRuW2ldKXJldHVybiByLnVuc2hpZnQoZSksbi5wdXNoKHIpO2lmKHIubGVuZ3RoPGRuW2ldKXRocm93IG5ldyBFcnJvcihcIm1hbGZvcm1lZCBwYXRoIGRhdGFcIik7bi5wdXNoKFtlXS5jb25jYXQoci5zcGxpY2UoMCxkbltpXSkpKX19KSxufSx3bj0vLT9bMC05XSpcXC4/WzAtOV0rKD86ZVstK10/XFxkKyk/L2dpLGJuPWZ1bmN0aW9uKHQsbixlLHIsaSxhLG8scyl7cmV0dXJuIG5ldyBkKHQsbixlLHIsaSxhLG8scyl9O2QucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpkLGluaXQ6ZnVuY3Rpb24oKXt0aGlzLmxlbmd0aD10aGlzLmdldEFyY0xlbmd0aChbdGhpcy5hLngsdGhpcy5iLngsdGhpcy5jLngsdGhpcy5kLnhdLFt0aGlzLmEueSx0aGlzLmIueSx0aGlzLmMueSx0aGlzLmQueV0pfSxnZXRUb3RhbExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlbmd0aH0sZ2V0UG9pbnRBdExlbmd0aDpmdW5jdGlvbih0KXt2YXIgbj13KHQsdGhpcy5sZW5ndGgsdGhpcy5nZXRBcmNMZW5ndGgsW3RoaXMuYS54LHRoaXMuYi54LHRoaXMuYy54LHRoaXMuZC54XSxbdGhpcy5hLnksdGhpcy5iLnksdGhpcy5jLnksdGhpcy5kLnldKTtyZXR1cm4gdGhpcy5nZXRQb2ludChbdGhpcy5hLngsdGhpcy5iLngsdGhpcy5jLngsdGhpcy5kLnhdLFt0aGlzLmEueSx0aGlzLmIueSx0aGlzLmMueSx0aGlzLmQueV0sbil9LGdldFRhbmdlbnRBdExlbmd0aDpmdW5jdGlvbih0KXt2YXIgbj13KHQsdGhpcy5sZW5ndGgsdGhpcy5nZXRBcmNMZW5ndGgsW3RoaXMuYS54LHRoaXMuYi54LHRoaXMuYy54LHRoaXMuZC54XSxbdGhpcy5hLnksdGhpcy5iLnksdGhpcy5jLnksdGhpcy5kLnldKSxlPXRoaXMuZ2V0RGVyaXZhdGl2ZShbdGhpcy5hLngsdGhpcy5iLngsdGhpcy5jLngsdGhpcy5kLnhdLFt0aGlzLmEueSx0aGlzLmIueSx0aGlzLmMueSx0aGlzLmQueV0sbikscj1NYXRoLnNxcnQoZS54KmUueCtlLnkqZS55KTtyZXR1cm4gcj4wP3t4OmUueC9yLHk6ZS55L3J9Ont4OjAseTowfX0sZ2V0UHJvcGVydGllc0F0TGVuZ3RoOmZ1bmN0aW9uKHQpe3ZhciBuLGU9dyh0LHRoaXMubGVuZ3RoLHRoaXMuZ2V0QXJjTGVuZ3RoLFt0aGlzLmEueCx0aGlzLmIueCx0aGlzLmMueCx0aGlzLmQueF0sW3RoaXMuYS55LHRoaXMuYi55LHRoaXMuYy55LHRoaXMuZC55XSkscj10aGlzLmdldERlcml2YXRpdmUoW3RoaXMuYS54LHRoaXMuYi54LHRoaXMuYy54LHRoaXMuZC54XSxbdGhpcy5hLnksdGhpcy5iLnksdGhpcy5jLnksdGhpcy5kLnldLGUpLGk9TWF0aC5zcXJ0KHIueCpyLngrci55KnIueSk7bj1pPjA/e3g6ci54L2kseTpyLnkvaX06e1xueDowLHk6MH07dmFyIGE9dGhpcy5nZXRQb2ludChbdGhpcy5hLngsdGhpcy5iLngsdGhpcy5jLngsdGhpcy5kLnhdLFt0aGlzLmEueSx0aGlzLmIueSx0aGlzLmMueSx0aGlzLmQueV0sZSk7cmV0dXJue3g6YS54LHk6YS55LHRhbmdlbnRYOm4ueCx0YW5nZW50WTpuLnl9fX07dmFyIExuPVtbXSxbXSxbLS41NzczNTAyNjkxODk2MjU3LC41NzczNTAyNjkxODk2MjU3XSxbMCwtLjc3NDU5NjY2OTI0MTQ4MzQsLjc3NDU5NjY2OTI0MTQ4MzRdLFstLjMzOTk4MTA0MzU4NDg1NjI2LC4zMzk5ODEwNDM1ODQ4NTYyNiwtLjg2MTEzNjMxMTU5NDA1MjYsLjg2MTEzNjMxMTU5NDA1MjZdLFswLC0uNTM4NDY5MzEwMTA1NjgzMSwuNTM4NDY5MzEwMTA1NjgzMSwtLjkwNjE3OTg0NTkzODY2NCwuOTA2MTc5ODQ1OTM4NjY0XSxbLjY2MTIwOTM4NjQ2NjI2NDUsLS42NjEyMDkzODY0NjYyNjQ1LC0uMjM4NjE5MTg2MDgzMTk2OSwuMjM4NjE5MTg2MDgzMTk2OSwtLjkzMjQ2OTUxNDIwMzE1MiwuOTMyNDY5NTE0MjAzMTUyXSxbMCwuNDA1ODQ1MTUxMzc3Mzk3MiwtLjQwNTg0NTE1MTM3NzM5NzIsLS43NDE1MzExODU1OTkzOTQ1LC43NDE1MzExODU1OTkzOTQ1LC0uOTQ5MTA3OTEyMzQyNzU4NSwuOTQ5MTA3OTEyMzQyNzU4NV0sWy0uMTgzNDM0NjQyNDk1NjQ5OCwuMTgzNDM0NjQyNDk1NjQ5OCwtLjUyNTUzMjQwOTkxNjMyOSwuNTI1NTMyNDA5OTE2MzI5LC0uNzk2NjY2NDc3NDEzNjI2NywuNzk2NjY2NDc3NDEzNjI2NywtLjk2MDI4OTg1NjQ5NzUzNjMsLjk2MDI4OTg1NjQ5NzUzNjNdLFswLC0uODM2MDMxMTA3MzI2NjM1OCwuODM2MDMxMTA3MzI2NjM1OCwtLjk2ODE2MDIzOTUwNzYyNjEsLjk2ODE2MDIzOTUwNzYyNjEsLS4zMjQyNTM0MjM0MDM4MDg5LC4zMjQyNTM0MjM0MDM4MDg5LC0uNjEzMzcxNDMyNzAwNTkwNCwuNjEzMzcxNDMyNzAwNTkwNF0sWy0uMTQ4ODc0MzM4OTgxNjMxMjIsLjE0ODg3NDMzODk4MTYzMTIyLC0uNDMzMzk1Mzk0MTI5MjQ3MiwuNDMzMzk1Mzk0MTI5MjQ3MiwtLjY3OTQwOTU2ODI5OTAyNDQsLjY3OTQwOTU2ODI5OTAyNDQsLS44NjUwNjMzNjY2ODg5ODQ1LC44NjUwNjMzNjY2ODg5ODQ1LC0uOTczOTA2NTI4NTE3MTcxNywuOTczOTA2NTI4NTE3MTcxN10sWzAsLS4yNjk1NDMxNTU5NTIzNDQ5NiwuMjY5NTQzMTU1OTUyMzQ0OTYsLS41MTkwOTYxMjkyMDY4MTE4LC41MTkwOTYxMjkyMDY4MTE4LC0uNzMwMTUyMDA1NTc0MDQ5NCwuNzMwMTUyMDA1NTc0MDQ5NCwtLjg4NzA2MjU5OTc2ODA5NTMsLjg4NzA2MjU5OTc2ODA5NTMsLS45NzgyMjg2NTgxNDYwNTcsLjk3ODIyODY1ODE0NjA1N10sWy0uMTI1MjMzNDA4NTExNDY4OSwuMTI1MjMzNDA4NTExNDY4OSwtLjM2NzgzMTQ5ODk5ODE4MDIsLjM2NzgzMTQ5ODk5ODE4MDIsLS41ODczMTc5NTQyODY2MTc1LC41ODczMTc5NTQyODY2MTc1LC0uNzY5OTAyNjc0MTk0MzA0NywuNzY5OTAyNjc0MTk0MzA0NywtLjkwNDExNzI1NjM3MDQ3NDksLjkwNDExNzI1NjM3MDQ3NDksLS45ODE1NjA2MzQyNDY3MTkyLC45ODE1NjA2MzQyNDY3MTkyXSxbMCwtLjIzMDQ1ODMxNTk1NTEzNDgsLjIzMDQ1ODMxNTk1NTEzNDgsLS40NDg0OTI3NTEwMzY0NDY4NywuNDQ4NDkyNzUxMDM2NDQ2ODcsLS42NDIzNDkzMzk0NDAzNDAyLC42NDIzNDkzMzk0NDAzNDAyLC0uODAxNTc4MDkwNzMzMzA5OSwuODAxNTc4MDkwNzMzMzA5OSwtLjkxNzU5ODM5OTIyMjk3NzksLjkxNzU5ODM5OTIyMjk3NzksLS45ODQxODMwNTQ3MTg1ODgxLC45ODQxODMwNTQ3MTg1ODgxXSxbLS4xMDgwNTQ5NDg3MDczNDM2NywuMTA4MDU0OTQ4NzA3MzQzNjcsLS4zMTkxMTIzNjg5Mjc4ODk3NCwuMzE5MTEyMzY4OTI3ODg5NzQsLS41MTUyNDg2MzYzNTgxNTQxLC41MTUyNDg2MzYzNTgxNTQxLC0uNjg3MjkyOTA0ODExNjg1NSwuNjg3MjkyOTA0ODExNjg1NSwtLjgyNzIwMTMxNTA2OTc2NSwuODI3MjAxMzE1MDY5NzY1LC0uOTI4NDM0ODgzNjYzNTczNSwuOTI4NDM0ODgzNjYzNTczNSwtLjk4NjI4MzgwODY5NjgxMjMsLjk4NjI4MzgwODY5NjgxMjNdLFswLC0uMjAxMTk0MDkzOTk3NDM0NTEsLjIwMTE5NDA5Mzk5NzQzNDUxLC0uMzk0MTUxMzQ3MDc3NTYzNCwuMzk0MTUxMzQ3MDc3NTYzNCwtLjU3MDk3MjE3MjYwODUzODgsLjU3MDk3MjE3MjYwODUzODgsLS43MjQ0MTc3MzEzNjAxNzAxLC43MjQ0MTc3MzEzNjAxNzAxLC0uODQ4MjA2NTgzNDEwNDI3MiwuODQ4MjA2NTgzNDEwNDI3MiwtLjkzNzI3MzM5MjQwMDcwNiwuOTM3MjczMzkyNDAwNzA2LC0uOTg3OTkyNTE4MDIwNDg1NCwuOTg3OTkyNTE4MDIwNDg1NF0sWy0uMDk1MDEyNTA5ODM3NjM3NDQsLjA5NTAxMjUwOTgzNzYzNzQ0LC0uMjgxNjAzNTUwNzc5MjU4OSwuMjgxNjAzNTUwNzc5MjU4OSwtLjQ1ODAxNjc3NzY1NzIyNzM3LC40NTgwMTY3Nzc2NTcyMjczNywtLjYxNzg3NjI0NDQwMjY0MzgsLjYxNzg3NjI0NDQwMjY0MzgsLS43NTU0MDQ0MDgzNTUwMDMsLjc1NTQwNDQwODM1NTAwMywtLjg2NTYzMTIwMjM4NzgzMTgsLjg2NTYzMTIwMjM4NzgzMTgsLS45NDQ1NzUwMjMwNzMyMzI2LC45NDQ1NzUwMjMwNzMyMzI2LC0uOTg5NDAwOTM0OTkxNjQ5OSwuOTg5NDAwOTM0OTkxNjQ5OV0sWzAsLS4xNzg0ODQxODE0OTU4NDc4NSwuMTc4NDg0MTgxNDk1ODQ3ODUsLS4zNTEyMzE3NjM0NTM4NzYzLC4zNTEyMzE3NjM0NTM4NzYzLC0uNTEyNjkwNTM3MDg2NDc2OSwuNTEyNjkwNTM3MDg2NDc2OSwtLjY1NzY3MTE1OTIxNjY5MDcsLjY1NzY3MTE1OTIxNjY5MDcsLS43ODE1MTQwMDM4OTY4MDE0LC43ODE1MTQwMDM4OTY4MDE0LC0uODgwMjM5MTUzNzI2OTg1OSwuODgwMjM5MTUzNzI2OTg1OSwtLjk1MDY3NTUyMTc2ODc2NzgsLjk1MDY3NTUyMTc2ODc2NzgsLS45OTA1NzU0NzUzMTQ0MTc0LC45OTA1NzU0NzUzMTQ0MTc0XSxbLS4wODQ3NzUwMTMwNDE3MzUzLC4wODQ3NzUwMTMwNDE3MzUzLC0uMjUxODg2MjI1NjkxNTA1NSwuMjUxODg2MjI1NjkxNTA1NSwtLjQxMTc1MTE2MTQ2Mjg0MjYzLC40MTE3NTExNjE0NjI4NDI2MywtLjU1OTc3MDgzMTA3Mzk0NzUsLjU1OTc3MDgzMTA3Mzk0NzUsLS42OTE2ODcwNDMwNjAzNTMyLC42OTE2ODcwNDMwNjAzNTMyLC0uODAzNzA0OTU4OTcyNTIzMSwuODAzNzA0OTU4OTcyNTIzMSwtLjg5MjYwMjQ2NjQ5NzU1NTcsLjg5MjYwMjQ2NjQ5NzU1NTcsLS45NTU4MjM5NDk1NzEzOTc3LC45NTU4MjM5NDk1NzEzOTc3LC0uOTkxNTY1MTY4NDIwOTMwOSwuOTkxNTY1MTY4NDIwOTMwOV0sWzAsLS4xNjAzNTg2NDU2NDAyMjUzNywuMTYwMzU4NjQ1NjQwMjI1MzcsLS4zMTY1NjQwOTk5NjM2Mjk4MywuMzE2NTY0MDk5OTYzNjI5ODMsLS40NjQ1NzA3NDEzNzU5NjA5NCwuNDY0NTcwNzQxMzc1OTYwOTQsLS42MDA1NDUzMDQ2NjE2ODEsLjYwMDU0NTMwNDY2MTY4MSwtLjcyMDk2NjE3NzMzNTIyOTQsLjcyMDk2NjE3NzMzNTIyOTQsLS44MjI3MTQ2NTY1MzcxNDI4LC44MjI3MTQ2NTY1MzcxNDI4LC0uOTAzMTU1OTAzNjE0ODE3OSwuOTAzMTU1OTAzNjE0ODE3OSwtLjk2MDIwODE1MjEzNDgzLC45NjAyMDgxNTIxMzQ4MywtLjk5MjQwNjg0Mzg0MzU4NDQsLjk5MjQwNjg0Mzg0MzU4NDRdLFstLjA3NjUyNjUyMTEzMzQ5NzM0LC4wNzY1MjY1MjExMzM0OTczNCwtLjIyNzc4NTg1MTE0MTY0NTA3LC4yMjc3ODU4NTExNDE2NDUwNywtLjM3MzcwNjA4ODcxNTQxOTU1LC4zNzM3MDYwODg3MTU0MTk1NSwtLjUxMDg2NzAwMTk1MDgyNzEsLjUxMDg2NzAwMTk1MDgyNzEsLS42MzYwNTM2ODA3MjY1MTUsLjYzNjA1MzY4MDcyNjUxNSwtLjc0NjMzMTkwNjQ2MDE1MDgsLjc0NjMzMTkwNjQ2MDE1MDgsLS44MzkxMTY5NzE4MjIyMTg4LC44MzkxMTY5NzE4MjIyMTg4LC0uOTEyMjM0NDI4MjUxMzI2LC45MTIyMzQ0MjgyNTEzMjYsLS45NjM5NzE5MjcyNzc5MTM4LC45NjM5NzE5MjcyNzc5MTM4LC0uOTkzMTI4NTk5MTg1MDk0OSwuOTkzMTI4NTk5MTg1MDk0OV0sWzAsLS4xNDU1NjE4NTQxNjA4OTUxLC4xNDU1NjE4NTQxNjA4OTUxLC0uMjg4MDIxMzE2ODAyNDAxMSwuMjg4MDIxMzE2ODAyNDAxMSwtLjQyNDM0MjEyMDIwNzQzODgsLjQyNDM0MjEyMDIwNzQzODgsLS41NTE2MTg4MzU4ODcyMTk4LC41NTE2MTg4MzU4ODcyMTk4LC0uNjY3MTM4ODA0MTk3NDEyMywuNjY3MTM4ODA0MTk3NDEyMywtLjc2ODQzOTk2MzQ3NTY3NzksLjc2ODQzOTk2MzQ3NTY3NzksLS44NTMzNjMzNjQ1ODMzMTczLC44NTMzNjMzNjQ1ODMzMTczLC0uOTIwMDk5MzM0MTUwNDAwOCwuOTIwMDk5MzM0MTUwNDAwOCwtLjk2NzIyNjgzODU2NjMwNjMsLjk2NzIyNjgzODU2NjMwNjMsLS45OTM3NTIxNzA2MjAzODk1LC45OTM3NTIxNzA2MjAzODk1XSxbLS4wNjk3MzkyNzMzMTk3MjIyMywuMDY5NzM5MjczMzE5NzIyMjMsLS4yMDc4NjA0MjY2ODgyMjEyNywuMjA3ODYwNDI2Njg4MjIxMjcsLS4zNDE5MzU4MjA4OTIwODQyNCwuMzQxOTM1ODIwODkyMDg0MjQsLS40NjkzNTU4Mzc5ODY3NTcsLjQ2OTM1NTgzNzk4Njc1NywtLjU4NzY0MDQwMzUwNjkxMTYsLjU4NzY0MDQwMzUwNjkxMTYsLS42OTQ0ODcyNjMxODY2ODI3LC42OTQ0ODcyNjMxODY2ODI3LC0uNzg3ODE2ODA1OTc5MjA4MSwuNzg3ODE2ODA1OTc5MjA4MSwtLjg2NTgxMjU3NzcyMDMwMDIsLjg2NTgxMjU3NzcyMDMwMDIsLS45MjY5NTY3NzIxODcxNzQsLjkyNjk1Njc3MjE4NzE3NCwtLjk3MDA2MDQ5NzgzNTQyODcsLjk3MDA2MDQ5NzgzNTQyODcsLS45OTQyOTQ1ODU0ODIzOTkyLC45OTQyOTQ1ODU0ODIzOTkyXSxbMCwtLjEzMzI1NjgyNDI5ODQ2NjEsLjEzMzI1NjgyNDI5ODQ2NjEsLS4yNjQxMzU2ODA5NzAzNDQ5NSwuMjY0MTM1NjgwOTcwMzQ0OTUsLS4zOTAzMDEwMzgwMzAyOTA4LC4zOTAzMDEwMzgwMzAyOTA4LC0uNTA5NTAxNDc3ODQ2MDA3NSwuNTA5NTAxNDc3ODQ2MDA3NSwtLjYxOTYwOTg3NTc2MzY0NjEsLjYxOTYwOTg3NTc2MzY0NjEsLS43MTg2NjEzNjMxMzE5NTAyLC43MTg2NjEzNjMxMzE5NTAyLC0uODA0ODg4NDAxNjE4ODM5OSwuODA0ODg4NDAxNjE4ODM5OSwtLjg3Njc1MjM1ODI3MDQ0MTYsLjg3Njc1MjM1ODI3MDQ0MTYsLS45MzI5NzEwODY4MjYwMTYxLC45MzI5NzEwODY4MjYwMTYxLC0uOTcyNTQyNDcxMjE4MTE1MiwuOTcyNTQyNDcxMjE4MTE1MiwtLjk5NDc2OTMzNDk5NzU1MjIsLjk5NDc2OTMzNDk5NzU1MjJdLFstLjA2NDA1Njg5Mjg2MjYwNTYzLC4wNjQwNTY4OTI4NjI2MDU2MywtLjE5MTExODg2NzQ3MzYxNjMsLjE5MTExODg2NzQ3MzYxNjMsLS4zMTUwNDI2Nzk2OTYxNjM0LC4zMTUwNDI2Nzk2OTYxNjM0LC0uNDMzNzkzNTA3NjI2MDQ1MSwuNDMzNzkzNTA3NjI2MDQ1MSwtLjU0NTQyMTQ3MTM4ODgzOTYsLjU0NTQyMTQ3MTM4ODgzOTYsLS42NDgwOTM2NTE5MzY5NzU1LC42NDgwOTM2NTE5MzY5NzU1LC0uNzQwMTI0MTkxNTc4NTU0NCwuNzQwMTI0MTkxNTc4NTU0NCwtLjgyMDAwMTk4NTk3MzkwMywuODIwMDAxOTg1OTczOTAzLC0uODg2NDE1NTI3MDA0NDAxMSwuODg2NDE1NTI3MDA0NDAxMSwtLjkzODI3NDU1MjAwMjczMjgsLjkzODI3NDU1MjAwMjczMjgsLS45NzQ3Mjg1NTU5NzEzMDk1LC45NzQ3Mjg1NTU5NzEzMDk1LC0uOTk1MTg3MjE5OTk3MDIxMywuOTk1MTg3MjE5OTk3MDIxM11dLEFuPVtbXSxbXSxbMSwxXSxbLjg4ODg4ODg4ODg4ODg4ODgsLjU1NTU1NTU1NTU1NTU1NTYsLjU1NTU1NTU1NTU1NTU1NTZdLFsuNjUyMTQ1MTU0ODYyNTQ2MSwuNjUyMTQ1MTU0ODYyNTQ2MSwuMzQ3ODU0ODQ1MTM3NDUzODUsLjM0Nzg1NDg0NTEzNzQ1Mzg1XSxbLjU2ODg4ODg4ODg4ODg4ODksLjQ3ODYyODY3MDQ5OTM2NjQ3LC40Nzg2Mjg2NzA0OTkzNjY0NywuMjM2OTI2ODg1MDU2MTg5MDgsLjIzNjkyNjg4NTA1NjE4OTA4XSxbLjM2MDc2MTU3MzA0ODEzODYsLjM2MDc2MTU3MzA0ODEzODYsLjQ2NzkxMzkzNDU3MjY5MTA0LC40Njc5MTM5MzQ1NzI2OTEwNCwuMTcxMzI0NDkyMzc5MTcwMzYsLjE3MTMyNDQ5MjM3OTE3MDM2XSxbLjQxNzk1OTE4MzY3MzQ2OTQsLjM4MTgzMDA1MDUwNTExODksLjM4MTgzMDA1MDUwNTExODksLjI3OTcwNTM5MTQ4OTI3NjY0LC4yNzk3MDUzOTE0ODkyNzY2NCwuMTI5NDg0OTY2MTY4ODY5NywuMTI5NDg0OTY2MTY4ODY5N10sWy4zNjI2ODM3ODMzNzgzNjIsLjM2MjY4Mzc4MzM3ODM2MiwuMzEzNzA2NjQ1ODc3ODg3MjcsLjMxMzcwNjY0NTg3Nzg4NzI3LC4yMjIzODEwMzQ0NTMzNzQ0OCwuMjIyMzgxMDM0NDUzMzc0NDgsLjEwMTIyODUzNjI5MDM3NjI2LC4xMDEyMjg1MzYyOTAzNzYyNl0sWy4zMzAyMzkzNTUwMDEyNTk4LC4xODA2NDgxNjA2OTQ4NTc0LC4xODA2NDgxNjA2OTQ4NTc0LC4wODEyNzQzODgzNjE1NzQ0MSwuMDgxMjc0Mzg4MzYxNTc0NDEsLjMxMjM0NzA3NzA0MDAwMjg2LC4zMTIzNDcwNzcwNDAwMDI4NiwuMjYwNjEwNjk2NDAyOTM1NDQsLjI2MDYxMDY5NjQwMjkzNTQ0XSxbLjI5NTUyNDIyNDcxNDc1Mjg3LC4yOTU1MjQyMjQ3MTQ3NTI4NywuMjY5MjY2NzE5MzA5OTk2MzUsLjI2OTI2NjcxOTMwOTk5NjM1LC4yMTkwODYzNjI1MTU5ODIwNCwuMjE5MDg2MzYyNTE1OTgyMDQsLjE0OTQ1MTM0OTE1MDU4MDYsLjE0OTQ1MTM0OTE1MDU4MDYsLjA2NjY3MTM0NDMwODY4ODE0LC4wNjY2NzEzNDQzMDg2ODgxNF0sWy4yNzI5MjUwODY3Nzc5MDA2LC4yNjI4MDQ1NDQ1MTAyNDY2NSwuMjYyODA0NTQ0NTEwMjQ2NjUsLjIzMzE5Mzc2NDU5MTk5MDQ4LC4yMzMxOTM3NjQ1OTE5OTA0OCwuMTg2MjkwMjEwOTI3NzM0MjYsLjE4NjI5MDIxMDkyNzczNDI2LC4xMjU1ODAzNjk0NjQ5MDQ2LC4xMjU1ODAzNjk0NjQ5MDQ2LC4wNTU2Njg1NjcxMTYxNzM2NiwuMDU1NjY4NTY3MTE2MTczNjZdLFsuMjQ5MTQ3MDQ1ODEzNDAyNzcsLjI0OTE0NzA0NTgxMzQwMjc3LC4yMzM0OTI1MzY1MzgzNTQ4LC4yMzM0OTI1MzY1MzgzNTQ4LC4yMDMxNjc0MjY3MjMwNjU5MiwuMjAzMTY3NDI2NzIzMDY1OTIsLjE2MDA3ODMyODU0MzM0NjIyLC4xNjAwNzgzMjg1NDMzNDYyMiwuMTA2OTM5MzI1OTk1MzE4NDMsLjEwNjkzOTMyNTk5NTMxODQzLC4wNDcxNzUzMzYzODY1MTE4MywuMDQ3MTc1MzM2Mzg2NTExODNdLFsuMjMyNTUxNTUzMjMwODczOSwuMjI2MjgzMTgwMjYyODk3MjMsLjIyNjI4MzE4MDI2Mjg5NzIzLC4yMDc4MTYwNDc1MzY4ODg1LC4yMDc4MTYwNDc1MzY4ODg1LC4xNzgxNDU5ODA3NjE5NDU3NCwuMTc4MTQ1OTgwNzYxOTQ1NzQsLjEzODg3MzUxMDIxOTc4NzI1LC4xMzg4NzM1MTAyMTk3ODcyNSwuMDkyMTIxNDk5ODM3NzI4NDUsLjA5MjEyMTQ5OTgzNzcyODQ1LC4wNDA0ODQwMDQ3NjUzMTU4OCwuMDQwNDg0MDA0NzY1MzE1ODhdLFsuMjE1MjYzODUzNDYzMTU3OCwuMjE1MjYzODUzNDYzMTU3OCwuMjA1MTk4NDYzNzIxMjk1NiwuMjA1MTk4NDYzNzIxMjk1NiwuMTg1NTM4Mzk3NDc3OTM3ODIsLjE4NTUzODM5NzQ3NzkzNzgyLC4xNTcyMDMxNjcxNTgxOTM1NSwuMTU3MjAzMTY3MTU4MTkzNTUsLjEyMTUxODU3MDY4NzkwMzE5LC4xMjE1MTg1NzA2ODc5MDMxOSwuMDgwMTU4MDg3MTU5NzYwMjEsLjA4MDE1ODA4NzE1OTc2MDIxLC4wMzUxMTk0NjAzMzE3NTE4NiwuMDM1MTE5NDYwMzMxNzUxODZdLFsuMjAyNTc4MjQxOTI1NTYxMywuMTk4NDMxNDg1MzI3MTExNTgsLjE5ODQzMTQ4NTMyNzExMTU4LC4xODYxNjEwMDAwMTU1NjIyLC4xODYxNjEwMDAwMTU1NjIyLC4xNjYyNjkyMDU4MTY5OTM5MiwuMTY2MjY5MjA1ODE2OTkzOTIsLjEzOTU3MDY3NzkyNjE1NDMyLC4xMzk1NzA2Nzc5MjYxNTQzMiwuMTA3MTU5MjIwNDY3MTcxOTQsLjEwNzE1OTIyMDQ2NzE3MTk0LC4wNzAzNjYwNDc0ODgxMDgxMiwuMDcwMzY2MDQ3NDg4MTA4MTIsLjAzMDc1MzI0MTk5NjExNzI3LC4wMzA3NTMyNDE5OTYxMTcyN10sWy4xODk0NTA2MTA0NTUwNjg1LC4xODk0NTA2MTA0NTUwNjg1LC4xODI2MDM0MTUwNDQ5MjM1OCwuMTgyNjAzNDE1MDQ0OTIzNTgsLjE2OTE1NjUxOTM5NTAwMjU0LC4xNjkxNTY1MTkzOTUwMDI1NCwuMTQ5NTk1OTg4ODE2NTc2NzQsLjE0OTU5NTk4ODgxNjU3Njc0LC4xMjQ2Mjg5NzEyNTU1MzM4OCwuMTI0NjI4OTcxMjU1NTMzODgsLjA5NTE1ODUxMTY4MjQ5Mjc5LC4wOTUxNTg1MTE2ODI0OTI3OSwuMDYyMjUzNTIzOTM4NjQ3ODk0LC4wNjIyNTM1MjM5Mzg2NDc4OTQsLjAyNzE1MjQ1OTQxMTc1NDA5NiwuMDI3MTUyNDU5NDExNzU0MDk2XSxbLjE3OTQ0NjQ3MDM1NjIwNjUzLC4xNzY1NjI3MDUzNjY5OTI2NCwuMTc2NTYyNzA1MzY2OTkyNjQsLjE2ODAwNDEwMjE1NjQ1MDA0LC4xNjgwMDQxMDIxNTY0NTAwNCwuMTU0MDQ1NzYxMDc2ODEwMjgsLjE1NDA0NTc2MTA3NjgxMDI4LC4xMzUxMzYzNjg0Njg1MjU0OCwuMTM1MTM2MzY4NDY4NTI1NDgsLjExMTg4Mzg0NzE5MzQwMzk3LC4xMTE4ODM4NDcxOTM0MDM5NywuMDg1MDM2MTQ4MzE3MTc5MTgsLjA4NTAzNjE0ODMxNzE3OTE4LC4wNTU0NTk1MjkzNzM5ODcyLC4wNTU0NTk1MjkzNzM5ODcyLC4wMjQxNDgzMDI4Njg1NDc5MywuMDI0MTQ4MzAyODY4NTQ3OTNdLFsuMTY5MTQyMzgyOTYzMTQzNiwuMTY5MTQyMzgyOTYzMTQzNiwuMTY0Mjc2NDgzNzQ1ODMyNzMsLjE2NDI3NjQ4Mzc0NTgzMjczLC4xNTQ2ODQ2NzUxMjYyNjUyNCwuMTU0Njg0Njc1MTI2MjY1MjQsLjE0MDY0MjkxNDY3MDY1MDY1LC4xNDA2NDI5MTQ2NzA2NTA2NSwuMTIyNTU1MjA2NzExNDc4NDYsLjEyMjU1NTIwNjcxMTQ3ODQ2LC4xMDA5NDIwNDQxMDYyODcxNywuMTAwOTQyMDQ0MTA2Mjg3MTcsLjA3NjQyNTczMDI1NDg4OTA1LC4wNzY0MjU3MzAyNTQ4ODkwNSwuMDQ5NzE0NTQ4ODk0OTY5OCwuMDQ5NzE0NTQ4ODk0OTY5OCwuMDIxNjE2MDEzNTI2NDgzMzEsLjAyMTYxNjAxMzUyNjQ4MzMxXSxbLjE2MTA1NDQ0OTg0ODc4MzcsLjE1ODk2ODg0MzM5Mzk1NDM0LC4xNTg5Njg4NDMzOTM5NTQzNCwuMTUyNzY2MDQyMDY1ODU5NjcsLjE1Mjc2NjA0MjA2NTg1OTY3LC4xNDI2MDY3MDIxNzM2MDY2LC4xNDI2MDY3MDIxNzM2MDY2LC4xMjg3NTM5NjI1MzkzMzYyMSwuMTI4NzUzOTYyNTM5MzM2MjEsLjExMTU2NjY0NTU0NzMzMzk5LC4xMTE1NjY2NDU1NDczMzM5OSwuMDkxNDkwMDIxNjIyNDUsLjA5MTQ5MDAyMTYyMjQ1LC4wNjkwNDQ1NDI3Mzc2NDEyMywuMDY5MDQ0NTQyNzM3NjQxMjMsLjA0NDgxNDIyNjc2NTY5OTYsLjA0NDgxNDIyNjc2NTY5OTYsLjAxOTQ2MTc4ODIyOTcyNjQ3OCwuMDE5NDYxNzg4MjI5NzI2NDc4XSxbLjE1Mjc1MzM4NzEzMDcyNTg0LC4xNTI3NTMzODcxMzA3MjU4NCwuMTQ5MTcyOTg2NDcyNjAzNzQsLjE0OTE3Mjk4NjQ3MjYwMzc0LC4xNDIwOTYxMDkzMTgzODIwNCwuMTQyMDk2MTA5MzE4MzgyMDQsLjEzMTY4ODYzODQ0OTE3NjY0LC4xMzE2ODg2Mzg0NDkxNzY2NCwuMTE4MTk0NTMxOTYxNTE4NDEsLjExODE5NDUzMTk2MTUxODQxLC4xMDE5MzAxMTk4MTcyNDA0NCwuMTAxOTMwMTE5ODE3MjQwNDQsLjA4MzI3Njc0MTU3NjcwNDc1LC4wODMyNzY3NDE1NzY3MDQ3NSwuMDYyNjcyMDQ4MzM0MTA5MDcsLjA2MjY3MjA0ODMzNDEwOTA3LC4wNDA2MDE0Mjk4MDAzODY5NCwuMDQwNjAxNDI5ODAwMzg2OTQsLjAxNzYxNDAwNzEzOTE1MjExOCwuMDE3NjE0MDA3MTM5MTUyMTE4XSxbLjE0NjA4MTEzMzY0OTY5MDQxLC4xNDQ1MjQ0MDM5ODk5NzAwNSwuMTQ0NTI0NDAzOTg5OTcwMDUsLjEzOTg4NzM5NDc5MTA3MzE1LC4xMzk4ODczOTQ3OTEwNzMxNSwuMTMyMjY4OTM4NjMzMzM3NDcsLjEzMjI2ODkzODYzMzMzNzQ3LC4xMjE4MzE0MTYwNTM3Mjg1MywuMTIxODMxNDE2MDUzNzI4NTMsLjEwODc5NzI5OTE2NzE0ODM4LC4xMDg3OTcyOTkxNjcxNDgzOCwuMDkzNDQ0NDIzNDU2MDMzODYsLjA5MzQ0NDQyMzQ1NjAzMzg2LC4wNzYxMDAxMTM2MjgzNzkzLC4wNzYxMDAxMTM2MjgzNzkzLC4wNTcxMzQ0MjU0MjY4NTcyMDUsLjA1NzEzNDQyNTQyNjg1NzIwNSwuMDM2OTUzNzg5NzcwODUyNDk0LC4wMzY5NTM3ODk3NzA4NTI0OTQsLjAxNjAxNzIyODI1Nzc3NDMzNSwuMDE2MDE3MjI4MjU3Nzc0MzM1XSxbLjEzOTI1MTg3Mjg1NTYzMTk4LC4xMzkyNTE4NzI4NTU2MzE5OCwuMTM2NTQxNDk4MzQ2MDE1MTcsLjEzNjU0MTQ5ODM0NjAxNTE3LC4xMzExNzM1MDQ3ODcwNjIzOCwuMTMxMTczNTA0Nzg3MDYyMzgsLjEyMzI1MjM3NjgxMDUxMjQyLC4xMjMyNTIzNzY4MTA1MTI0MiwuMTEyOTMyMjk2MDgwNTM5MjIsLjExMjkzMjI5NjA4MDUzOTIyLC4xMDA0MTQxNDQ0NDI4ODA5NiwuMTAwNDE0MTQ0NDQyODgwOTYsLjA4NTk0MTYwNjIxNzA2NzczLC4wODU5NDE2MDYyMTcwNjc3MywuMDY5Nzk2NDY4NDI0NTIwNDksLjA2OTc5NjQ2ODQyNDUyMDQ5LC4wNTIyOTMzMzUxNTI2ODMyODYsLjA1MjI5MzMzNTE1MjY4MzI4NiwuMDMzNzc0OTAxNTg0ODE0MTUsLjAzMzc3NDkwMTU4NDgxNDE1LC4wMTQ2Mjc5OTUyOTgyNzIyLC4wMTQ2Mjc5OTUyOTgyNzIyXSxbLjEzMzY1NDU3MjE4NjEwNjE5LC4xMzI0NjIwMzk0MDQ2OTY2LC4xMzI0NjIwMzk0MDQ2OTY2LC4xMjg5MDU3MjIxODgwODIxNiwuMTI4OTA1NzIyMTg4MDgyMTYsLjEyMzA0OTA4NDMwNjcyOTUzLC4xMjMwNDkwODQzMDY3Mjk1MywuMTE0OTk2NjQwMjIyNDExMzYsLjExNDk5NjY0MDIyMjQxMTM2LC4xMDQ4OTIwOTE0NjQ1NDE0MSwuMTA0ODkyMDkxNDY0NTQxNDEsLjA5MjkxNTc2NjA2MDAzNTE1LC4wOTI5MTU3NjYwNjAwMzUxNSwuMDc5MjgxNDExNzc2NzE4OTUsLjA3OTI4MTQxMTc3NjcxODk1LC4wNjQyMzI0MjE0MDg1MjU4NSwuMDY0MjMyNDIxNDA4NTI1ODUsLjA0ODAzNzY3MTczMTA4NDY3LC4wNDgwMzc2NzE3MzEwODQ2NywuMDMwOTg4MDA1ODU2OTc5NDQ1LC4wMzA5ODgwMDU4NTY5Nzk0NDUsLjAxMzQxMTg1OTQ4NzE0MTc3MSwuMDEzNDExODU5NDg3MTQxNzcxXSxbLjEyNzkzODE5NTM0Njc1MjE2LC4xMjc5MzgxOTUzNDY3NTIxNiwuMTI1ODM3NDU2MzQ2ODI4MywuMTI1ODM3NDU2MzQ2ODI4MywuMTIxNjcwNDcyOTI3ODAzMzksLjEyMTY3MDQ3MjkyNzgwMzM5LC4xMTU1MDU2NjgwNTM3MjU2LC4xMTU1MDU2NjgwNTM3MjU2LC4xMDc0NDQyNzAxMTU5NjU2MywuMTA3NDQ0MjcwMTE1OTY1NjMsLjA5NzYxODY1MjEwNDExMzg4LC4wOTc2MTg2NTIxMDQxMTM4OCwuMDg2MTkwMTYxNTMxOTUzMjcsLjA4NjE5MDE2MTUzMTk1MzI3LC4wNzMzNDY0ODE0MTEwODAzLC4wNzMzNDY0ODE0MTEwODAzLC4wNTkyOTg1ODQ5MTU0MzY3OCwuMDU5Mjk4NTg0OTE1NDM2NzgsLjA0NDI3NzQzODgxNzQxOTgxLC4wNDQyNzc0Mzg4MTc0MTk4MSwuMDI4NTMxMzg4NjI4OTMzNjYzLC4wMjg1MzEzODg2Mjg5MzM2NjMsLjAxMjM0MTIyOTc5OTk4NzIsLjAxMjM0MTIyOTc5OTk4NzJdXSxxbj1bWzFdLFsxLDFdLFsxLDIsMV0sWzEsMywzLDFdXSxrbj0yKk1hdGguUEksUG49ZnVuY3Rpb24odCxuLGUscixpLGEsbyxzLGgpe3ZhciB1PU1hdGguc2luKGkqa24vMzYwKSxjPU1hdGguY29zKGkqa24vMzYwKSxmPWMqKHQtcykvMit1KihuLWgpLzIsbD0tdSoodC1zKS8yK2MqKG4taCkvMjtpZigwPT09ZiYmMD09PWwpcmV0dXJuW107aWYoMD09PWV8fDA9PT1yKXJldHVybltdO2U9TWF0aC5hYnMoZSkscj1NYXRoLmFicyhyKTt2YXIgcD1mKmYvKGUqZSkrbCpsLyhyKnIpO3A+MSYmKGUqPU1hdGguc3FydChwKSxyKj1NYXRoLnNxcnQocCkpO3ZhciBnPVModCxuLHMsaCxhLG8sZSxyLHUsYyksdj1bXSx4PWdbMl0seT1nWzNdLGQ9TWF0aC5tYXgoTWF0aC5jZWlsKE1hdGguYWJzKHkpLyhrbi80KSksMSk7eS89ZDtmb3IodmFyIG09MDttPGQ7bSsrKXYucHVzaChDKHgseSkpLHgrPXk7cmV0dXJuIHYubWFwKGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bis9Mil7dmFyIGk9dFtuKzBdLGE9dFtuKzFdO2kqPWUsYSo9cjt2YXIgbz1jKmktdSphLHM9dSppK2MqYTt0W24rMF09bytnWzBdLHRbbisxXT1zK2dbMV19cmV0dXJuIHR9KX0sX249ZnVuY3Rpb24odCxuLGUscixpLGEsbyxzLGgpe3JldHVybiBuZXcgWih0LG4sZSxyLGksYSxvLHMsaCl9O1oucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpaLGluaXQ6ZnVuY3Rpb24oKXt9LGdldFRvdGFsTGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVuZ3RofSxnZXRQb2ludEF0TGVuZ3RoOmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7dDwwP3Q9MDp0PnRoaXMubGVuZ3RoJiYodD10aGlzLmxlbmd0aCk7Zm9yKHZhciBlPXRoaXMucGFydGlhbExlbmd0aHMubGVuZ3RoLTE7dGhpcy5wYXJ0aWFsTGVuZ3Roc1tlXT49dCYmdGhpcy5wYXJ0aWFsTGVuZ3Roc1tlXT4wOyllLS07ZTx0aGlzLnBhcnRpYWxMZW5ndGhzLmxlbmd0aC0xJiZlKys7Zm9yKHZhciByPTAsaT0wO2k8ZTtpKyspcis9bi5wYXJ0aWFsTGVuZ3Roc1tpXTtyZXR1cm4gdGhpcy5jdXJ2ZXNbZV0uZ2V0UG9pbnRBdExlbmd0aCh0LXIpfSxnZXRUYW5nZW50QXRMZW5ndGg6ZnVuY3Rpb24odCl7dmFyIG49dGhpczt0PDA/dD0wOnQ+dGhpcy5sZW5ndGgmJih0PXRoaXMubGVuZ3RoKTtmb3IodmFyIGU9dGhpcy5wYXJ0aWFsTGVuZ3Rocy5sZW5ndGgtMTt0aGlzLnBhcnRpYWxMZW5ndGhzW2VdPj10JiZ0aGlzLnBhcnRpYWxMZW5ndGhzW2VdPjA7KWUtLTtlPHRoaXMucGFydGlhbExlbmd0aHMubGVuZ3RoLTEmJmUrKztmb3IodmFyIHI9MCxpPTA7aTxlO2krKylyKz1uLnBhcnRpYWxMZW5ndGhzW2ldO3JldHVybiB0aGlzLmN1cnZlc1tlXS5nZXRUYW5nZW50QXRMZW5ndGgodC1yKX0sZ2V0UHJvcGVydGllc0F0TGVuZ3RoOmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMuZ2V0VGFuZ2VudEF0TGVuZ3RoKHQpLGU9dGhpcy5nZXRQb2ludEF0TGVuZ3RoKHQpO3JldHVybnt4OmUueCx5OmUueSx0YW5nZW50WDpuLngsdGFuZ2VudFk6bi55fX19O3ZhciBFbj1mdW5jdGlvbih0LG4sZSxyKXtyZXR1cm4gbmV3IFQodCxuLGUscil9O1QucHJvdG90eXBlLmdldFRvdGFsTGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLngwLXRoaXMueDEsMikrTWF0aC5wb3codGhpcy55MC10aGlzLnkxLDIpKX0sVC5wcm90b3R5cGUuZ2V0UG9pbnRBdExlbmd0aD1mdW5jdGlvbih0KXt2YXIgbj10L01hdGguc3FydChNYXRoLnBvdyh0aGlzLngwLXRoaXMueDEsMikrTWF0aC5wb3codGhpcy55MC10aGlzLnkxLDIpKSxlPSh0aGlzLngxLXRoaXMueDApKm4scj0odGhpcy55MS10aGlzLnkwKSpuO3JldHVybnt4OnRoaXMueDArZSx5OnRoaXMueTArcn19LFQucHJvdG90eXBlLmdldFRhbmdlbnRBdExlbmd0aD1mdW5jdGlvbigpe3ZhciB0PU1hdGguc3FydCgodGhpcy54MS10aGlzLngwKSoodGhpcy54MS10aGlzLngwKSsodGhpcy55MS10aGlzLnkwKSoodGhpcy55MS10aGlzLnkwKSk7cmV0dXJue3g6KHRoaXMueDEtdGhpcy54MCkvdCx5Oih0aGlzLnkxLXRoaXMueTApL3R9fSxULnByb3RvdHlwZS5nZXRQcm9wZXJ0aWVzQXRMZW5ndGg9ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5nZXRQb2ludEF0TGVuZ3RoKHQpLGU9dGhpcy5nZXRUYW5nZW50QXRMZW5ndGgoKTtyZXR1cm57eDpuLngseTpuLnksdGFuZ2VudFg6ZS54LHRhbmdlbnRZOmUueX19O3ZhciBTbj1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKHQpe2lmKCF0KXJldHVybiBudWxsO2Zvcih2YXIgYSxvPU1uKHQpLHM9WzAsMF0saD1bMCwwXSx1PTA7dTxvLmxlbmd0aDt1KyspXCJNXCI9PT1vW3VdWzBdPyhzPVtvW3VdWzFdLG9bdV1bMl1dLGkucHVzaChudWxsKSk6XCJtXCI9PT1vW3VdWzBdPyhzPVtvW3VdWzFdK3NbMF0sb1t1XVsyXStzWzFdXSxpLnB1c2gobnVsbCkpOlwiTFwiPT09b1t1XVswXT8oZSs9TWF0aC5zcXJ0KE1hdGgucG93KHNbMF0tb1t1XVsxXSwyKStNYXRoLnBvdyhzWzFdLW9bdV1bMl0sMikpLGkucHVzaChuZXcgRW4oc1swXSxvW3VdWzFdLHNbMV0sb1t1XVsyXSkpLHM9W29bdV1bMV0sb1t1XVsyXV0pOlwibFwiPT09b1t1XVswXT8oZSs9TWF0aC5zcXJ0KE1hdGgucG93KG9bdV1bMV0sMikrTWF0aC5wb3cob1t1XVsyXSwyKSksaS5wdXNoKG5ldyBFbihzWzBdLG9bdV1bMV0rc1swXSxzWzFdLG9bdV1bMl0rc1sxXSkpLHM9W29bdV1bMV0rc1swXSxvW3VdWzJdK3NbMV1dKTpcIkhcIj09PW9bdV1bMF0/KGUrPU1hdGguYWJzKHNbMF0tb1t1XVsxXSksaS5wdXNoKG5ldyBFbihzWzBdLG9bdV1bMV0sc1sxXSxzWzFdKSksc1swXT1vW3VdWzFdKTpcImhcIj09PW9bdV1bMF0/KGUrPU1hdGguYWJzKG9bdV1bMV0pLGkucHVzaChuZXcgRW4oc1swXSxzWzBdK29bdV1bMV0sc1sxXSxzWzFdKSksc1swXT1vW3VdWzFdK3NbMF0pOlwiVlwiPT09b1t1XVswXT8oZSs9TWF0aC5hYnMoc1sxXS1vW3VdWzFdKSxpLnB1c2gobmV3IEVuKHNbMF0sc1swXSxzWzFdLG9bdV1bMV0pKSxzWzFdPW9bdV1bMV0pOlwidlwiPT09b1t1XVswXT8oZSs9TWF0aC5hYnMob1t1XVsxXSksaS5wdXNoKG5ldyBFbihzWzBdLHNbMF0sc1sxXSxzWzFdK29bdV1bMV0pKSxzWzFdPW9bdV1bMV0rc1sxXSk6XCJ6XCI9PT1vW3VdWzBdfHxcIlpcIj09PW9bdV1bMF0/KGUrPU1hdGguc3FydChNYXRoLnBvdyhvWzBdWzFdLXNbMF0sMikrTWF0aC5wb3cob1swXVsyXS1zWzFdLDIpKSxpLnB1c2gobmV3IEVuKHNbMF0sb1swXVsxXSxzWzFdLG9bMF1bMl0pKSxzPVtvWzBdWzFdLG9bMF1bMl1dKTpcIkNcIj09PW9bdV1bMF0/KGE9bmV3IGJuKHNbMF0sc1sxXSxvW3VdWzFdLG9bdV1bMl0sb1t1XVszXSxvW3VdWzRdLG9bdV1bNV0sb1t1XVs2XSksZSs9YS5nZXRUb3RhbExlbmd0aCgpLHM9W29bdV1bNV0sb1t1XVs2XV0saS5wdXNoKGEpKTpcImNcIj09PW9bdV1bMF0/KGE9bmV3IGJuKHNbMF0sc1sxXSxzWzBdK29bdV1bMV0sc1sxXStvW3VdWzJdLHNbMF0rb1t1XVszXSxzWzFdK29bdV1bNF0sc1swXStvW3VdWzVdLHNbMV0rb1t1XVs2XSksZSs9YS5nZXRUb3RhbExlbmd0aCgpLHM9W29bdV1bNV0rc1swXSxvW3VdWzZdK3NbMV1dLGkucHVzaChhKSk6XCJTXCI9PT1vW3VdWzBdPyhhPXU+MCYmW1wiQ1wiLFwiY1wiLFwiU1wiLFwic1wiXS5pbmRleE9mKG9bdS0xXVswXSk+LTE/bmV3IGJuKHNbMF0sc1sxXSwyKnNbMF0tb1t1LTFdW29bdS0xXS5sZW5ndGgtNF0sMipzWzFdLW9bdS0xXVtvW3UtMV0ubGVuZ3RoLTNdLG9bdV1bMV0sb1t1XVsyXSxvW3VdWzNdLG9bdV1bNF0pOm5ldyBibihzWzBdLHNbMV0sc1swXSxzWzFdLG9bdV1bMV0sb1t1XVsyXSxvW3VdWzNdLG9bdV1bNF0pLGUrPWEuZ2V0VG90YWxMZW5ndGgoKSxzPVtvW3VdWzNdLG9bdV1bNF1dLGkucHVzaChhKSk6XCJzXCI9PT1vW3VdWzBdPyhhPXU+MCYmW1wiQ1wiLFwiY1wiLFwiU1wiLFwic1wiXS5pbmRleE9mKG9bdS0xXVswXSk+LTE/bmV3IGJuKHNbMF0sc1sxXSxzWzBdK2EuZC54LWEuYy54LHNbMV0rYS5kLnktYS5jLnksc1swXStvW3VdWzFdLHNbMV0rb1t1XVsyXSxzWzBdK29bdV1bM10sc1sxXStvW3VdWzRdKTpuZXcgYm4oc1swXSxzWzFdLHNbMF0sc1sxXSxzWzBdK29bdV1bMV0sc1sxXStvW3VdWzJdLHNbMF0rb1t1XVszXSxzWzFdK29bdV1bNF0pLGUrPWEuZ2V0VG90YWxMZW5ndGgoKSxzPVtvW3VdWzNdK3NbMF0sb1t1XVs0XStzWzFdXSxpLnB1c2goYSkpOlwiUVwiPT09b1t1XVswXT8oYT1uZXcgYm4oc1swXSxzWzFdLG9bdV1bMV0sb1t1XVsyXSxvW3VdWzNdLG9bdV1bNF0pLGUrPWEuZ2V0VG90YWxMZW5ndGgoKSxpLnB1c2goYSkscz1bb1t1XVszXSxvW3VdWzRdXSxoPVtvW3VdWzFdLG9bdV1bMl1dKTpcInFcIj09PW9bdV1bMF0/KGE9bmV3IGJuKHNbMF0sc1sxXSxzWzBdK29bdV1bMV0sc1sxXStvW3VdWzJdLHNbMF0rb1t1XVszXSxzWzFdK29bdV1bNF0pLGUrPWEuZ2V0VG90YWxMZW5ndGgoKSxoPVtzWzBdK29bdV1bMV0sc1sxXStvW3VdWzJdXSxzPVtvW3VdWzNdK3NbMF0sb1t1XVs0XStzWzFdXSxpLnB1c2goYSkpOlwiVFwiPT09b1t1XVswXT8oYT11PjAmJltcIlFcIixcInFcIixcIlRcIixcInRcIl0uaW5kZXhPZihvW3UtMV1bMF0pPi0xP25ldyBibihzWzBdLHNbMV0sMipzWzBdLWhbMF0sMipzWzFdLWhbMV0sb1t1XVsxXSxvW3VdWzJdKTpuZXcgRW4oc1swXSxvW3VdWzFdLHNbMV0sb1t1XVsyXSksaS5wdXNoKGEpLGUrPWEuZ2V0VG90YWxMZW5ndGgoKSxoPVsyKnNbMF0taFswXSwyKnNbMV0taFsxXV0scz1bb1t1XVsxXSxvW3VdWzJdXSk6XCJ0XCI9PT1vW3VdWzBdPyhhPXU+MCYmW1wiUVwiLFwicVwiLFwiVFwiLFwidFwiXS5pbmRleE9mKG9bdS0xXVswXSk+LTE/bmV3IGJuKHNbMF0sc1sxXSwyKnNbMF0taFswXSwyKnNbMV0taFsxXSxzWzBdK29bdV1bMV0sc1sxXStvW3VdWzJdKTpuZXcgRW4oc1swXSxzWzBdK29bdV1bMV0sc1sxXSxzWzFdK29bdV1bMl0pLGUrPWEuZ2V0VG90YWxMZW5ndGgoKSxoPVsyKnNbMF0taFswXSwyKnNbMV0taFsxXV0scz1bb1t1XVsxXStzWzBdLG9bdV1bMl0rc1swXV0saS5wdXNoKGEpKTpcIkFcIj09PW9bdV1bMF0/KGE9bmV3IF9uKHNbMF0sc1sxXSxvW3VdWzFdLG9bdV1bMl0sb1t1XVszXSxvW3VdWzRdLG9bdV1bNV0sb1t1XVs2XSxvW3VdWzddKSxlKz1hLmdldFRvdGFsTGVuZ3RoKCkscz1bb1t1XVs2XSxvW3VdWzddXSxpLnB1c2goYSkpOlwiYVwiPT09b1t1XVswXSYmKGE9bmV3IF9uKHNbMF0sc1sxXSxvW3VdWzFdLG9bdV1bMl0sb1t1XVszXSxvW3VdWzRdLG9bdV1bNV0sc1swXStvW3VdWzZdLHNbMV0rb1t1XVs3XSksZSs9YS5nZXRUb3RhbExlbmd0aCgpLHM9W3NbMF0rb1t1XVs2XSxzWzFdK29bdV1bN11dLGkucHVzaChhKSksci5wdXNoKGUpO3JldHVybiBufXZhciBlPTAscj1bXSxpPVtdO24uZ2V0VG90YWxMZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gZX0sbi5nZXRQb2ludEF0TGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBuPWEodCk7cmV0dXJuIGlbbi5pXS5nZXRQb2ludEF0TGVuZ3RoKG4uZnJhY3Rpb24pfSxuLmdldFRhbmdlbnRBdExlbmd0aD1mdW5jdGlvbih0KXt2YXIgbj1hKHQpO3JldHVybiBpW24uaV0uZ2V0VGFuZ2VudEF0TGVuZ3RoKG4uZnJhY3Rpb24pfSxuLmdldFByb3BlcnRpZXNBdExlbmd0aD1mdW5jdGlvbih0KXt2YXIgbj1hKHQpO3JldHVybiBpW24uaV0uZ2V0UHJvcGVydGllc0F0TGVuZ3RoKG4uZnJhY3Rpb24pfTt2YXIgYT1mdW5jdGlvbih0KXt0PDA/dD0wOnQ+ZSYmKHQ9ZSk7Zm9yKHZhciBuPXIubGVuZ3RoLTE7cltuXT49dCYmcltuXT4wOyluLS07cmV0dXJuIG4rKyx7ZnJhY3Rpb246dC1yW24tMV0saTpufX07cmV0dXJuIG4odCl9LENuPSdBbGwgc2hhcGVzIG11c3QgYmUgc3VwcGxpZWQgYXMgYXJyYXlzIG9mIFt4LCB5XSBwb2ludHMgb3IgYW4gU1ZHIHBhdGggc3RyaW5nIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2QpLlxcbkV4YW1wbGUgdmFsaWQgd2F5cyBvZiBzdXBwbHlpbmcgYSBzaGFwZSB3b3VsZCBiZTpcXG5bWzAsIDBdLCBbMTAsIDBdLCBbMTAsIDEwXV1cXG5cIk0wLDAgTDEwLDAgTDEwLDEwWlwiXFxuJyxabj1cImZsdWJiZXIuYWxsKCkgZXhwZWN0cyB0d28gYXJyYXlzIG9mIGVxdWFsIGxlbmd0aCBhcyBhcmd1bWVudHMuIEVhY2ggZWxlbWVudCBpbiBib3RoIGFycmF5cyBzaG91bGQgYmUgYW4gYXJyYXkgb2YgW3gsIHldIHBvaW50cyBvciBhbiBTVkcgcGF0aCBzdHJpbmcgKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZCkuXCIsVG49ZnVuY3Rpb24odCxuKXtmb3IodmFyIGUscixpLGE9dC5sZW5ndGgsbz0xLzAscz0wO3M8YTtzKyspIWZ1bmN0aW9uKGkpe3I9MCxuLmZvckVhY2goZnVuY3Rpb24obixlKXt2YXIgbz1GKHRbKGkrZSklYV0sbik7cis9bypvfSkscjxvJiYobz1yLGU9aSl9KHMpO2UmJihpPXQuc3BsaWNlKDAsZSksdC5zcGxpY2UuYXBwbHkodCxbdC5sZW5ndGgsMF0uY29uY2F0KGkpKSl9LEZuPWZ1bmN0aW9uKHQsbixlKXt2b2lkIDA9PT1lJiYoZT17fSk7dmFyIHI9ZS5tYXhTZWdtZW50TGVuZ3RoO3ZvaWQgMD09PXImJihyPTEwKTt2YXIgaT1lLnN0cmluZzt2b2lkIDA9PT1pJiYoaT0hMCk7dmFyIGE9Sih0LHIpLG89SihuLHIpLHM9dHQoYSxvLGkpO3JldHVybiFpfHxcInN0cmluZ1wiIT10eXBlb2YgdCYmXCJzdHJpbmdcIiE9dHlwZW9mIG4/czpmdW5jdGlvbihlKXtyZXR1cm4gZTwxZS00JiZcInN0cmluZ1wiPT10eXBlb2YgdD90OjEtZTwxZS00JiZcInN0cmluZ1wiPT10eXBlb2Ygbj9uOnMoZSl9fSx6bj1udDtudC5kZXZpYXRpb249ZnVuY3Rpb24odCxuLGUscil7dmFyIGk9biYmbi5sZW5ndGgsYT1pP25bMF0qZTp0Lmxlbmd0aCxvPU1hdGguYWJzKEV0KHQsMCxhLGUpKTtpZihpKWZvcih2YXIgcz0wLGg9bi5sZW5ndGg7czxoO3MrKyl7dmFyIHU9bltzXSplLGM9czxoLTE/bltzKzFdKmU6dC5sZW5ndGg7by09TWF0aC5hYnMoRXQodCx1LGMsZSkpfXZhciBmPTA7Zm9yKHM9MDtzPHIubGVuZ3RoO3MrPTMpe3ZhciBsPXJbc10qZSxwPXJbcysxXSplLGc9cltzKzJdKmU7Zis9TWF0aC5hYnMoKHRbbF0tdFtnXSkqKHRbcCsxXS10W2wrMV0pLSh0W2xdLXRbcF0pKih0W2crMV0tdFtsKzFdKSl9cmV0dXJuIDA9PT1vJiYwPT09Zj8wOk1hdGguYWJzKChmLW8pL28pfSxudC5mbGF0dGVuPWZ1bmN0aW9uKHQpe2Zvcih2YXIgbj10WzBdWzBdLmxlbmd0aCxlPXt2ZXJ0aWNlczpbXSxob2xlczpbXSxkaW1lbnNpb25zOm59LHI9MCxpPTA7aTx0Lmxlbmd0aDtpKyspe2Zvcih2YXIgYT0wO2E8dFtpXS5sZW5ndGg7YSsrKWZvcih2YXIgbz0wO288bjtvKyspZS52ZXJ0aWNlcy5wdXNoKHRbaV1bYV1bb10pO2k+MCYmKHIrPXRbaS0xXS5sZW5ndGgsZS5ob2xlcy5wdXNoKHIpKX1yZXR1cm4gZX07dmFyIGpuPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxJbj1mdW5jdGlvbih0KXtpZihudWxsPT10KXJldHVybiBqbjt2YXIgbixlLHI9dC5zY2FsZVswXSxpPXQuc2NhbGVbMV0sYT10LnRyYW5zbGF0ZVswXSxvPXQudHJhbnNsYXRlWzFdO3JldHVybiBmdW5jdGlvbih0LHMpe3N8fChuPWU9MCk7dmFyIGg9Mix1PXQubGVuZ3RoLGM9bmV3IEFycmF5KHUpO2ZvcihjWzBdPShuKz10WzBdKSpyK2EsY1sxXT0oZSs9dFsxXSkqaStvO2g8dTspY1toXT10W2hdLCsraDtyZXR1cm4gY319LFZuPWZ1bmN0aW9uKHQsbil7Zm9yKHZhciBlLHI9dC5sZW5ndGgsaT1yLW47aTwtLXI7KWU9dFtpXSx0W2krK109dFtyXSx0W3JdPWV9LFhuPWZ1bmN0aW9uKHQsbil7cmV0dXJuXCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PW4udHlwZT97dHlwZTpcIkZlYXR1cmVDb2xsZWN0aW9uXCIsZmVhdHVyZXM6bi5nZW9tZXRyaWVzLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gU3QodCxuKX0pfTpTdCh0LG4pfSxZbj1mdW5jdGlvbih0LG4pe2Z1bmN0aW9uIGUobil7dmFyIGUscj10LmFyY3NbbjwwP35uOm5dLGk9clswXTtyZXR1cm4gdC50cmFuc2Zvcm0/KGU9WzAsMF0sci5mb3JFYWNoKGZ1bmN0aW9uKHQpe2VbMF0rPXRbMF0sZVsxXSs9dFsxXX0pKTplPXJbci5sZW5ndGgtMV0sbjwwP1tlLGldOltpLGVdfWZ1bmN0aW9uIHIodCxuKXtmb3IodmFyIGUgaW4gdCl7dmFyIHI9dFtlXTtkZWxldGUgbltyLnN0YXJ0XSxkZWxldGUgci5zdGFydCxkZWxldGUgci5lbmQsci5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lbdDwwP350OnRdPTF9KSxzLnB1c2gocil9fXZhciBpPXt9LGE9e30sbz17fSxzPVtdLGg9LTE7cmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbihlLHIpe3ZhciBpLGE9dC5hcmNzW2U8MD9+ZTplXTthLmxlbmd0aDwzJiYhYVsxXVswXSYmIWFbMV1bMV0mJihpPW5bKytoXSxuW2hdPWUsbltyXT1pKX0pLG4uZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgbixyLGk9ZSh0KSxzPWlbMF0saD1pWzFdO2lmKG49b1tzXSlpZihkZWxldGUgb1tuLmVuZF0sbi5wdXNoKHQpLG4uZW5kPWgscj1hW2hdKXtkZWxldGUgYVtyLnN0YXJ0XTt2YXIgdT1yPT09bj9uOm4uY29uY2F0KHIpO2FbdS5zdGFydD1uLnN0YXJ0XT1vW3UuZW5kPXIuZW5kXT11fWVsc2UgYVtuLnN0YXJ0XT1vW24uZW5kXT1uO2Vsc2UgaWYobj1hW2hdKWlmKGRlbGV0ZSBhW24uc3RhcnRdLG4udW5zaGlmdCh0KSxuLnN0YXJ0PXMscj1vW3NdKXtkZWxldGUgb1tyLmVuZF07dmFyIGM9cj09PW4/bjpyLmNvbmNhdChuKTthW2Muc3RhcnQ9ci5zdGFydF09b1tjLmVuZD1uLmVuZF09Y31lbHNlIGFbbi5zdGFydF09b1tuLmVuZF09bjtlbHNlIG49W3RdLGFbbi5zdGFydD1zXT1vW24uZW5kPWhdPW59KSxyKG8sYSkscihhLG8pLG4uZm9yRWFjaChmdW5jdGlvbih0KXtpW3Q8MD9+dDp0XXx8cy5wdXNoKFt0XSl9KSxzfSxHbj1mdW5jdGlvbih0LG4pe2Zvcih2YXIgZT0wLHI9dC5sZW5ndGg7ZTxyOyl7dmFyIGk9ZStyPj4+MTt0W2ldPG4/ZT1pKzE6cj1pfXJldHVybiBlfSxPbj1mdW5jdGlvbih0KXtmdW5jdGlvbiBuKHQsbil7dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3Q8MCYmKHQ9fnQpO3ZhciBlPWlbdF07ZT9lLnB1c2gobik6aVt0XT1bbl19KX1mdW5jdGlvbiBlKHQsZSl7dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe24odCxlKX0pfWZ1bmN0aW9uIHIodCxuKXtcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09dC50eXBlP3QuZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3IodCxuKX0pOnQudHlwZSBpbiBvJiZvW3QudHlwZV0odC5hcmNzLG4pfXZhciBpPXt9LGE9dC5tYXAoZnVuY3Rpb24oKXtyZXR1cm5bXX0pLG89e0xpbmVTdHJpbmc6bixNdWx0aUxpbmVTdHJpbmc6ZSxQb2x5Z29uOmUsTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQsbil7dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UodCxuKX0pfX07dC5mb3JFYWNoKHIpO2Zvcih2YXIgcyBpbiBpKWZvcih2YXIgaD1pW3NdLHU9aC5sZW5ndGgsYz0wO2M8dTsrK2MpZm9yKHZhciBmPWMrMTtmPHU7KytmKXt2YXIgbCxwPWhbY10sZz1oW2ZdOyhsPWFbcF0pW3M9R24obCxnKV0hPT1nJiZsLnNwbGljZShzLDAsZyksKGw9YVtnXSlbcz1HbihsLHApXSE9PXAmJmwuc3BsaWNlKHMsMCxwKX1yZXR1cm4gYX0sRG49ZnVuY3Rpb24odCxuKXtyZXR1cm4gdDxuPy0xOnQ+bj8xOnQ+PW4/MDpOYU59LEhuPWZ1bmN0aW9uKHQpe3JldHVybiAxPT09dC5sZW5ndGgmJih0PUZ0KHQpKSx7bGVmdDpmdW5jdGlvbihuLGUscixpKXtmb3IobnVsbD09ciYmKHI9MCksbnVsbD09aSYmKGk9bi5sZW5ndGgpO3I8aTspe3ZhciBhPXIraT4+PjE7dChuW2FdLGUpPDA/cj1hKzE6aT1hfXJldHVybiByfSxyaWdodDpmdW5jdGlvbihuLGUscixpKXtmb3IobnVsbD09ciYmKHI9MCksbnVsbD09aSYmKGk9bi5sZW5ndGgpO3I8aTspe3ZhciBhPXIraT4+PjE7dChuW2FdLGUpPjA/aT1hOnI9YSsxfXJldHVybiByfX19LE5uPUhuKERuKSxRbj0oTm4ucmlnaHQsTWF0aC5zcXJ0KDUwKSxNYXRoLnNxcnQoMTApLE1hdGguc3FydCgyKSxmdW5jdGlvbih0LG4pe3JldHVybiBqdCh6dChJdCh0KSx0KSxuKX0pLFVuPWZ1bmN0aW9uKHQsbil7aWYodC5sZW5ndGg+OClyZXR1cm4gdC5tYXAoZnVuY3Rpb24odCxuKXtyZXR1cm4gbn0pO3ZhciBlPXQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gWHQodCxuKX0pfSk7cmV0dXJuIFZ0KHQsbixlKX07dC5pbnRlcnBvbGF0ZT1Gbix0LnNlcGFyYXRlPVl0LHQuY29tYmluZT1HdCx0LmludGVycG9sYXRlQWxsPU90LHQuc3BsaXRQYXRoU3RyaW5nPU4sdC50b1BhdGhTdHJpbmc9SCx0LmZyb21DaXJjbGU9SHQsdC50b0NpcmNsZT1OdCx0LmZyb21SZWN0PVF0LHQudG9SZWN0PVV0LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mbHViYmVyL2J1aWxkL2ZsdWJiZXIubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9